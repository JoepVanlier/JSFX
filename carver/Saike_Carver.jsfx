desc:Carver

slider1:frequency=0.35<0,1,0.00001>-Frequency
slider2:q=3<0.1, 8, 0.00001>-Q
slider3:gain=12<0, 60, 0.001>-Gain
slider4:effect_mod1=0<0, 1, 0.00001>-Effect Mod 1
slider5:effect_mod2=0<0, 1, 0.00001>-Effect Mod 2
slider6:effect_choice=2<0,8,1{None,Tanh,Frequency Shift,Samplerate Reduction,Comb,Crush,Pitch Shift}>-Effect choice

slider7:frequency_2=0.5<0,1,0.00001>-Frequency (2)
slider8:q_2=3<0.1, 8, 0.00001>-Q (2)
slider9:gain_2=12<0, 60, 0.001>-Gain (2)
slider10:effect_mod1_2=0<0, 1, 0.00001>-Effect Mod 1 (2)
slider11:effect_mod2_2=0<0, 1, 0.00001>-Effect Mod 2 (2)
slider12:effect_choice_2=0<0,8,1{None,Tanh,Frequency Shift,Samplerate Reduction,Comb,Crush,Pitch Shift}>-Effect choice

slider13:frequency_3=0.5<0,1,0.00001>-Frequency (3)
slider14:q_3=3<0.1, 8, 0.00001>-Q (3)
slider15:gain_3=12<0, 60, 0.001>-Gain (3)
slider16:effect_mod1_3=0<0, 1, 0.00001>-Effect Mod 1 (3)
slider17:effect_mod2_3=0<0, 1, 0.00001>-Effect Mod 2 (3)
slider18:effect_choice_3=0<0,8,1{None,Tanh,Frequency Shift,Samplerate Reduction,Comb,Crush,Pitch Shift}>-Effect choice (3)

slider19:frequency_4=0.5<0,1,0.00001>-Frequency (4)
slider20:q_4=3<0.1, 8, 0.00001>-Q (4)
slider21:gain_4=12<0, 60, 0.001>-Gain (4)
slider22:effect_mod1_4=0<0, 1, 0.00001>-Effect Mod 1 (4)
slider23:effect_mod2_4=0<0, 1, 0.00001>-Effect Mod 2 (4)
slider24:effect_choice_4=0<0,8,1{None,Tanh,Frequency Shift,Samplerate Reduction,Comb,Crush,Pitch Shift}>-Effect choice (4)


in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import saike_carver_effects.jsfx-inc
import saike_carver_fft_view.jsfx-inc

@init
inertia_factor = 0.001;

function init_effect(freq, q, gain, mod1, mod2, choice, force)
local()
global()
instance(
  freq_idx, q_idx, gain_idx, mod1_idx, mod2_idx, choice_idx,
  c_freq, c_q, c_gain, c_mod1, c_mod2,
  coeff, init,
)
(
  coeff = 0.001;

  freq_idx = freq;
  q_idx = q;
  gain_idx = gain;
  mod1_idx = mod1;
  mod2_idx = mod2;
  choice_idx = choice;

  force ? (
    c_freq = slider(freq_idx);
    c_q = slider(q_idx);
    c_gain = slider(gain_idx);
    c_mod1 = slider(mod1_idx);
    c_mod2 = slider(mod2_idx);
    init = 0;
  );
);

effect1.init_effect(1, 2, 3, 4, 5, 6, 1);
effect2.init_effect(7, 8, 9, 10, 11, 12, 1);
effect3.init_effect(13, 14, 15, 16, 17, 18, 1);
effect4.init_effect(19, 20, 21, 22, 23, 24, 1);

function init_buffer(mem, size)
local()
instance(mem_start, mem_end, mem_ptr)
global()
(
  mem_start = mem;
  mem_end = mem_start + size;
  !mem_ptr ? mem_ptr = mem_start;
  
  mem_end
);

function init_effect(freemem)
local(BUF_SIZE)
instance()
global()
(
  // 1 second of buffer at 96 kHz should be plenty.
  BUF_SIZE = 96000;
  freemem = this.l.init_buffer(freemem, BUF_SIZE);
  freemem = this.r.init_buffer(freemem, BUF_SIZE);
  
  freemem
);

freemem = 0;
freemem = in_gfx_fft.init_fft_scope_mem(freemem, 5);
freemem = out_gfx_fft.init_fft_scope_mem(freemem, 5);
freemem = effect1.init_effect(freemem);
freemem = effect2.init_effect(freemem);
freemem = effect3.init_effect(freemem);
freemem = effect4.init_effect(freemem);

function tanh(x)
local()
global()
instance()
(
  (2/(1+exp(-2*x)) - 1)
);

function calc_freq(log_f)
global()
(
  0.5 * exp((1.0 - log_f) * log(20/22050)) * 44100
);

function invert_freq(f)
global()
(
  1.0 - log((2.0 * f) / 44100) / log(20/22050)
);

function set_bell(log_frequency, q, gain)
local(A, frequency)
instance(g, k, a1, a2, a3, m1)
global(srate)
(
  a = pow(10, gain / 40);
  frequency = calc_freq(log_frequency) / srate;
  g = tan($pi * frequency);
//  q = q / (1 + 60 * frequency/srate); /* Fudgy decramp */
  k = 1.0 / (q * a);
  
  a1 = 1.0 / (1.0 + g * (g + k));
  a2 = g * a1;
  a3 = g * a2;
  m1 = k * (a * a - 1.0);
);

function bell_tick(v0)
local(v1, v2, v3)
instance(ic1eq, ic2eq, a1, a2, a3, m1)
global()
(
  v3 = v0 - ic2eq;
  v1 = a1 * ic1eq + a2 * v3;
  v2 = ic2eq + a2 * ic1eq + a3 * v3;
  ic1eq = 2.0 * v1 - ic1eq;
  ic2eq = 2.0 * v2 - ic2eq;
  
  m1 * v1 /* Bell */
);

function update_effect(choice, cur_mod1, cur_mod2)
instance(current_effect, delay, c_delay, dt, crush_step_size, icrush_step_size)
local()
global(srate)
(
  current_effect = choice;
  (choice == 2) ? (
    // Frequency shifter
    this.freq_shifter.init_cheapest_freq_shifter(
     0.5 * exp((1.0 - cur_mod1) * log(1/22050)) * srate
    );
  ) : (choice == 3) ? (
    this.srate_reduction.init_srate_reduction(cur_mod1, cur_mod2);
  ) : (choice == 4) ? (
    delay = exp((1.0 - cur_mod1) * log(1/22050)) * srate;
  ) : (choice == 5) ? (
    crush_step_size = 0.5 * exp(- 5 * (1.0 - cur_mod1));
    icrush_step_size = 1 / crush_step_size;
  ) : (choice == 201) ? (
    // Vibrato kinda lame for this
    delay = exp((1.0 - cur_mod1) * log(1/22050)) * srate;
    dt = 2 * $pi * exp((1.0 - cur_mod2) * log(1/440)) * 440 / srate;
  ) : (choice == 200) ? (
    // Ring modulation (sucks)
    this.rm.init_cheap_rm_am(
      0.5 * exp((1.0 - cur_mod1) * log(20/22050)) * srate,
      cur_mod2
    );
  );
);

function mem_interp(offset)
local(ptr, frac, 
      x0, x1, x2, x3, id0, id1, id2, id3)
global()
instance(mem_ptr, mem_end, mem_start)
(
  ptr = mem_ptr - offset - 1;
  frac = ptr - floor(ptr);
  
  ptr < mem_start ? ptr += (mem_end - mem_start);
  x3 = ptr[]; ptr += 1;
  (ptr == mem_end) ? ptr = mem_start;
  x2 = ptr[];
  (ptr == mem_end) ? ptr = mem_start;
  x1 = ptr[];
  (ptr == mem_end) ? ptr = mem_start;
  x0 = ptr[];
  
  id0 = x2;
  id1 = 0.5*(x1 - x3);
  id2 = x3 - 2.5*x2 + 2*x1 - 0.5*x0;
  id3 = 0.5 * (x0 - x3) + 1.5 * (x2 - x1);
  
  ((id3*frac+id2)*frac+id1)*frac+id0
);

function do_effect(v0)
local(in)
instance(current_effect, h1, h2, h3,
         mem_ptr, mem_end, mem_start,
         c_delay, delay, t, dt,
         crush_step_size, icrush_step_size)
global(inertia_factor, tmp, tmp2)
(
  in = v0;
  v0 = this.bell_tick(v0);

  mem_ptr[] = v0;
  mem_ptr += 1; (mem_ptr == mem_end) ? mem_ptr = mem_start;

  (current_effect == 1) ? (
    tanh(v0) - v0
  ) : (current_effect == 2) ? (
    this.freq_shifter.eval_cheapest_freq_shifter(v0);
  ) : (current_effect == 3) ? (
    h3 = h2; h2 = h1; h1 = v0; /* Delay compensation */
    this.srate_reduction.eval_srate_reduction(v0) - h3;
  ) : (current_effect == 4) ? (
    c_delay += inertia_factor * (delay - c_delay);
    0.5 * (this.mem_interp(c_delay) - v0);
  ) : (current_effect == 5) ? (
    v0 /= this.m1;
    tmp = icrush_step_size * v0 - 0.5;
    tmp2 = (tmp - floor(tmp)) / crush_step_size;  // Probability
    ((floor(tmp) + (rand() < tmp2)) * crush_step_size - v0) * this.m1
  ) : (current_effect = 6) ? (
    - v0
  ) : (current_effect == 201) ? (
    // Vibrato is kinda lame for this
    t += dt;
    c_delay += inertia_factor * (delay - c_delay);
    this.mem_interp(c_delay * (0.6 + 0.5 * sin(t))) - v0;
  ) : (current_effect == 200) ? (
    this.rm.eval_cheap_rm_am(v0)
  );
);

function set_effect_stereo()
instance(
  l, r,
  freq_idx, q_idx, gain_idx, mod1_idx, mod2_idx, choice_idx,
  c_freq, c_q, c_gain, c_mod1, c_mod2, c_choice, l_choice,
  coeff,
  init,
)
local(choice, df, dq, dg, dm1, dm2)
global(cbell)
(
  df = (slider(freq_idx) - c_freq);
  dq = (slider(q_idx) - c_q);
  dg = (slider(gain_idx) - c_gain);
  dm1 = (slider(mod1_idx) - c_mod1);
  dm2 = (slider(mod2_idx) - c_mod2);
  c_freq += coeff * df;
  c_q += coeff * dq;
  c_gain += coeff * dg;
  c_mod1 += coeff * dm1;
  c_mod2 += coeff * dm2;
  choice = slider(choice_idx);

  !init || (abs(df) + abs(dq) + abs(dg)) > 0.000001 ? (
    l.set_bell(c_freq, c_q, c_gain);
    r.a1 = l.a1; r.a2 = l.a2; r.a3 = l.a3; r.m1 = l.m1;
  );
  !init || (abs(choice - l_choice) + abs(dm1) + abs(dm2)) > 0.00001 ? (
    l_choice = choice;
    l.update_effect(choice, c_mod1, c_mod2);
    r.update_effect(choice, c_mod1, c_mod2);
    cbell += 1;
  );
  
  init = 1;
);

function bell_response(w, g, k)
local(gsq, ksq, wsq, gsqwsq)
(
  gsq = g * g;
  ksq = k * k;
  wsq = w * w;
  gsqwsq = gsq * wsq;
  
  gsqwsq / (gsq * gsq + ksq * gsqwsq - 2 * gsqwsq + wsq * wsq)
);

function draw_bell(x, y, w, h, floor_db, ceil_db, min_freq, max_freq, color)
local(f, scaling, f_to_bin, offset, cx, mag, i_db_range, last_mag, iradian_rate)
global(srate, gfx_a)
instance(g, k, m1)
(
//  to_dB = 10 / log(10);
//  to_fig_y_scale = h * to_dB / (ceil_db - floor_db);
//  to_fig_y_origin = h * to_dB * ceil_db / (ceil_db - floor_db);
  colormodel(color);

  scaling = (log(max_freq) - log(min_freq)) / w;
//  f_to_bin = 0.5 * $pi * (srate / (max_freq - min_freq)) / srate;
//  f_to_bin = 0.5 * $pi / (max_freq - min_freq);
//  f_to_bin = $pi / srate;
//  offset = log(min_freq) + log(f_to_bin);

  iradian_rate = $pi / srate;
  offset = log(min_freq * iradian_rate);
  scaling = (log(max_freq * iradian_rate) - offset) / w;
  i_db_range = h / (ceil_db - floor_db);
  
  cx = 0;
  f = tan(exp(scaling * 0 + offset));
  last_mag = y + h - (20 * log10(m1 * m1 * bell_response(f, g, k)) - floor_db) * i_db_range;
  loop(w,
    f = tan(exp(scaling * cx + offset));
    mag = y + h - (20 * log10(m1 * m1 * bell_response(f, g, k)) - floor_db) * i_db_range;
    mag < (y + h) ? (
      gfx_line(x + cx - 1, last_mag, x + cx, mag);
      gfx_line(x + cx - 1, last_mag + 1, x + cx, mag + 1);
    );
    last_mag = mag;
    
    cx += 1;
  );
);

function to_f(position, xp, w, min_freq, max_freq)
global()
(
  invert_freq(exp(((position - xp) / w) * (log(max_freq) - log(min_freq)) + log(min_freq)))
);

function to_g(position, y, h)
global()
(
  - 60 * (position - y - h) / h
);

function effect_ui(x, y, w, h, floor_db, ceil_db, min_freq, max_freq, color, slider_idx)
local(radius, over, dx, dy, menu_selection)
instance(l, r, c_freq, c_gain, xp, yp, not_moved)
global(srate, gfx_x, gfx_y, mouse_x, mouse_y, mouse_cap, mouse_wheel, last_cap, last_x, last_y, tt, grabbed)
(
  this.l.draw_bell(x, y, w, h, floor_db, ceil_db, min_freq, max_freq, color);
  this.r.draw_bell(x, y, w, h, floor_db, ceil_db, min_freq, max_freq, color);
  
  //xp = c_freq;//exp(f + log(min_freq));
  xp = calc_freq(slider(slider_idx));
  xp = (log(xp) - log(min_freq)) / (log(max_freq) - log(min_freq));
  xp = x + w * xp;
  
  yp = c_gain / 60;
  yp = y + h - h * yp;
  
  radius = 12;
  dx = (mouse_x - xp);
  dy = (mouse_y - yp);
  over = (dx * dx + dy * dy) < radius * radius;
  
  gfx_set(0.6, 0.5, 1.0, 1.0);
  dx = 0;
  xp = floor(xp);
  yp = floor(yp);
  loop(10,
    gfx_arc(xp, yp, radius + dx, -0.75 * $pi, -0.75 * $pi + 1.5 * $pi * slider(slider_idx + 3), 1);
    dx += 0.6;
  );
  
  gfx_set(0, 0, 0, 1);
  gfx_circle(xp, yp, radius, 1);
  
  over ? (
    gfx_set(0.7, 0.5, 1, 0.7 + 0.3 * sin(5 * time_precise()));
    gfx_circle(xp, yp, 0.8 * radius, 1);
  );
  
  gfx_set(1, 1, 1, 1);
  gfx_circle(xp, yp, radius, 0, 1);
  gfx_circle(xp, yp, radius + 0.5, 0, 1);
  
  (mouse_cap == 0) ? (
    (grabbed == slider_idx) ? grabbed = 0;
    
    (not_moved == 1) ? (
      not_moved = 0;
      gfx_x = mouse_x;
      gfx_y = mouse_y;
      menu_selection = gfx_showmenu("Tanh|Frequency Shift|Samplerate Reduction|Comb|Crush|Pitch Shift");
      
      (menu_selection > 0) ? (
        slider(slider_idx + 5) = menu_selection;
      );
    );
  );
  
  (grabbed == slider_idx) ? (
    (mouse_cap & 2 == 0) ? (
      tt = to_f(mouse_x, x, w, min_freq, max_freq) - to_f(mouse_x, x, w, min_freq, max_freq);
      slider(slider_idx) = min(1.0, max(0.0, slider(slider_idx) + to_f(mouse_x, x, w, min_freq, max_freq) - to_f(last_x, x, w, min_freq, max_freq)));
      slider_automate(slider_idx);
      slider(slider_idx + 2) = min(60, max(0, slider(slider_idx + 2) + to_g(mouse_y, y, h) - to_g(last_y, y, h)));
    ) : (
      slider(slider_idx + 3) = min(1, max(0, slider(slider_idx + 3) - (mouse_y - last_y) / h ));
    );
  );
  
  over ? (
    ((grabbed == 0) && (mouse_cap & 2)) ? (
      not_moved = 1;
    );
    
    ((last_cap == 0) && (grabbed == 0) && ((mouse_cap & 1 == 1) || (mouse_cap & 2 == 2))) ? (
      grabbed = slider_idx;
    );
    
    (abs(mouse_wheel) > 0) ? (
      slider(slider_idx + 1) = min(8.0, max(0.0, slider(slider_idx + 1) + 0.001 * mouse_wheel));
      mouse_wheel = 0;
    );
  );
  
  ((abs(mouse_x - last_x) + abs(mouse_y - last_y)) > 5) ? not_moved = 0;
);

@slider
next_gain = 10^(gain_db/20);

@block
d_gain = (next_gain - last_gain)/samplesblock;

@sample
in_gfx_fft.process_fft_view(spl0, spl1);

// There are two modes of operation
// 1 -> For every bell, carve out the the bell by reducing the volume with the
//      bell and then subtracting the modified signal from the raw one.
effect1.set_effect_stereo();
effect2.set_effect_stereo();
effect3.set_effect_stereo();
effect4.set_effect_stereo();

add0 = 0;
add1 = 0;

effect_choice > 0 ? (
  add0 += effect1.l.do_effect(spl0);
  add1 += effect1.r.do_effect(spl1);
);

effect_choice2 > 0 ? (
  add0 += effect2.l.do_effect(spl0);
  add1 += effect2.r.do_effect(spl1);
);

effect_choice3 > 0 ? (
  add0 += effect3.l.do_effect(spl0);
  add1 += effect3.r.do_effect(spl1);
);

effect_choice4 > 0 ? (
  add0 += effect4.l.do_effect(spl0);
  add1 += effect4.r.do_effect(spl1);
);

spl0 += add0;
spl1 += add1;

out_gfx_fft.process_fft_view(spl0, spl1);

@gfx
gfx_set(0, 0, 0, 0);
gfx_rect(0, 0, gfx_w, gfx_h);



floor_db = -84 + 12;
ceil_db = 0;
db_step_size = 6;
x_wnd = 0.1 * gfx_w;
y_wnd = 0.1 * gfx_h;
w_wnd = 0.8 * gfx_w;
h_wnd = 0.8 * gfx_h;

in_gfx_fft.block_fft_view();
in_gfx_fft.render_fft(x_wnd, y_wnd, w_wnd, h_wnd, floor_db, ceil_db, db_step_size, 20, srate / 2, 0.8, 0.8);

out_gfx_fft.block_fft_view();
out_gfx_fft.render_fft(x_wnd, y_wnd, w_wnd, h_wnd, floor_db, ceil_db, db_step_size, 20, srate / 2, 0.2, 0.2);

ceil_db = 120;
floor_db = -60;
effect_choice > 0 ? effect1.effect_ui(x_wnd, y_wnd, w_wnd, h_wnd, floor_db, ceil_db, 20, srate / 2, 0.8, 1);
effect_choice2 > 0 ? effect2.effect_ui(x_wnd, y_wnd, w_wnd, h_wnd, floor_db, ceil_db, 20, srate / 2, 0.8, 7);
effect_choice3 > 0 ? effect3.effect_ui(x_wnd, y_wnd, w_wnd, h_wnd, floor_db, ceil_db, 20, srate / 2, 0.8, 13);
effect_choice4 > 0 ? effect4.effect_ui(x_wnd, y_wnd, w_wnd, h_wnd, floor_db, ceil_db, 20, srate / 2, 0.8, 19);

last_cap = mouse_cap;
last_x = mouse_x;
last_y = mouse_y;

