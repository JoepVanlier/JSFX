@init
function quick_ellip(x)
local()
instance(y, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12)
global()
(
  // Elliptical filter at 0.25
  y = 0.007395822247552258 * x + s1;
  s1 = 0.028029587556478226 * x - -2.4746173827703033 * y + s2;
  s2 = 0.08001006991705603 * x - 6.846257931064017 * y + s3;
  s3 = 0.15914168882810034 * x - -11.139935267094023 * y + s4;
  s4 = 0.25798663134993277 * x - 16.912304774812497 * y + s5;
  s5 = 0.33774345939233036 * x - -19.512531460749045 * y + s6;
  s6 = 0.3707618321631671 * x - 19.922414889136803 * y + s7;
  s7 = 0.33774345939233036 * x - -16.53398086736409 * y + s8;
  s8 = 0.25798663134993255 * x - 11.73416604468883 * y + s9;
  s9 = 0.1591416888281004 * x - -6.7144018048689516 * y + s10;
  s10 = 0.08001006991705606 * x - 3.11737949235283 * y + s11;
  s11 = 0.028029587556478237 * x - -1.0276481022383934 * y + s12;
  s12 = 0.007395822247552263 * x - 0.2395949825436374 * y;
);

function init_cheap_rm_am(shift, offset)
instance(t, dt, sin_1, sin_2, osc_coeff, half_offset)
global(srate)
local(piblock, w)
(
  half_offset = 0.5 * offset;
  piblock = 200 * $pi;
  dt = 2.0 * $pi * shift / srate;
  (t > piblock) ? t -= piblock;
  
  w = dt;
  osc_coeff = 2.0 * cos(w);
  t += dt;
  sin_1 = - cos(- w + t);
  sin_2 = - cos(- 2.0 * w + t);
  t -= dt;
);

function eval_cheap_rm_am(x)
instance(st, t, dt, osc_coeff, sin_1, sin_2, half_offset)
global()
local(mul)
(
  t += dt;
  
  st = osc_coeff * sin_1 - sin_2;
  sin_2 = sin_1;
  sin_1 = st;

  mul = 1.0 - half_offset;
  0.25 * x * (st * (1.0 - half_offset) + half_offset);
);


function init_cheapest_freq_shifter(shift)
instance(osc_coeff_t1, osc_coeff_t2,
         cos_t1_1, cos_t1_2, sin_t1_1, sin_t1_2,
         cos_t2_1, cos_t2_2, sin_t2_1, sin_t2_2,
         t1,  t2, dt1, dt2)
local(ip, piblock, w)
global(srate)
(
  piblock = 200 * $pi;
  dt1 = 2.0 * $pi * 0.251;  // oscillating at srate / 4
  dt2 = dt1 + 2.0 * $pi * shift / srate;
  (t1 > piblock) ? t1 -= piblock;
  (t2 > piblock) ? t2 -= piblock;
  
  w = dt1;
  osc_coeff_t1 = 2.0 * cos(w);
  t1 += dt1;
  cos_t1_1 = sin(- w + t1);
  cos_t1_2 = sin(- 2.0*w + t1);
  sin_t1_1 = - cos(- w + t1);
  sin_t1_2 = - cos(- 2.0*w + t1);
  t1 -= dt1;
  
  w = dt2;
  osc_coeff_t2 = 2.0 * cos(w);
  t2 += dt2;
  cos_t2_1 = sin(- w + t2);
  cos_t2_2 = sin(- 2.0 * w + t2);
  sin_t2_1 = - cos(- w + t2);
  sin_t2_2 = - cos(- 2.0 * w + t2);
  t2 -= dt2;
);


function eval_cheapest_freq_shifter(v0)
instance(
  osc_coeff_t1, osc_coeff_t2,
  l1, l2,
  dt1, dt2,
  t1, t2,
  cos_t1_1, cos_t1_2, sin_t1_1, sin_t1_2,
  cos_t2_1, cos_t2_2, sin_t2_1, sin_t2_2,
)
local(ct1, st1, ct2, st2)
global(ssl, ssr)
(
  t1 += dt1;
  t2 += dt2;
  
  ct1 = osc_coeff_t1 * cos_t1_1 - cos_t1_2;
  cos_t1_2 = cos_t1_1;
  cos_t1_1 = ct1;
  
  ct2 = osc_coeff_t2 * cos_t2_1 - cos_t2_2;
  cos_t2_2 = cos_t2_1;
  cos_t2_1 = ct2;
  
  st1 = osc_coeff_t1 * sin_t1_1 - sin_t1_2;
  sin_t1_2 = sin_t1_1;
  sin_t1_1 = st1;
  
  st2 = osc_coeff_t2 * sin_t2_1 - sin_t2_2;
  sin_t2_2 = sin_t2_1;
  sin_t2_1 = st2;
  
  l1.quick_ellip(v0 * ct1) * ct2 + l2.quick_ellip(v0 * st1) * st2;
);

function init_srate_reduction(mod1, mod2)
instance(factor)
global(srate)
local(target)
(
  target = srate * exp((mod1) * log(1000/22050));
  factor = srate / target;
);

function interp(x0, frac)
instance(x1, x2, x3)
local(id0, id1, id2, id3)
global()
(
  // We interpolate in the range 0 - 1
  //   y[-1]  y[0]  y[1]  y[2]
  //     x3    x2    x1    x0
  // Note that when using this interpolator
  // we need to stagger the non-interpolated
  // signal by three samples.
  
  id0 = x2;
  id1 = 0.5*(x1 - x3);
  id2 = x3 - 2.5*x2 + 2*x1 - 0.5*x0;
  id3 = 0.5 * (x0 - x3) + 1.5 * (x2 - x1);
  
  ((id3*frac+id2)*frac+id1)*frac+id0
);

function hist(x0)
instance(x1, x2, x3)
local()
global()
(
  x3 = x2;
  x2 = x1;
  x1 = x0;
);

function eval_srate_reduction(v0)
instance(factor, hist, degrade_pos, current)
local()
global()
(
  degrade_pos += 1;
  
  degrade_pos > (factor - 2) ? (
    while(
      degrade_pos -= factor;
      degrade_pos > (factor - 2)
    );
    
    current = hist.interp(v0, degrade_pos - floor(degrade_pos));
  );
  
  hist.hist(v0);
  
  current
);



