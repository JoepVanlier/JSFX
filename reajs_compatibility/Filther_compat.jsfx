import reajs_compatibility.jsfx-inc
noindex: true//import reajs_compatibility.jsfx-inc.txt
desc:Filther [ReaJS-Compatibility]
tags: Filther
version: 3.08
author: Joep Vanlier
changelog: Workarounds for SSE branch's issues with tan(pi/2).
about:
  # Filther
  Filther is a waveshaping / filterbank plugin that allows for some dynamic processing as well.
  [Screenshot](https://imgur.com/GPk7WmN.png)
  ### Manual
  A manual can be found here: [manual](https://joepvanlier.github.io/FiltherManual/)
  ### Demos
  You can find demos of the plugin [soundcloud](https://soundcloud.com/saike/ohnoesitsaboss2/s-zYCOt) and [youtube](https://www.youtube.com/watch?v=-VUckbkJ3EY).
  Small tutorial here: [here](https://www.youtube.com/watch?v=jtc8kp57xpI).
  ### Features:
  - Spline waveshaping curve based on placing nodes. Can draw asymmetric curves as well.
  - Two non-linear filter modules which can be automated by dynamics from the input signal or a side chain, LFO or envelopes.
  - Waveshaping amount can be modulated by input dynamics, LFOs or envelopes.
  - Modulators can optionally be triggered by MIDI notes.
  - Huge array of filter types (linear filters, analog models, FM, AM filters, reverbs, distortions).
  - Feedback section.
  - Automatic Gain Control to protect your ears somewhat
Copyright (C) 2019 Joep Vanlier
License: MIT

Filter attribution:
LP Diode Ladder (MIT Licensed)
Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
Karlsen Fast Ladder III
Copyright (c) Ove Hy Karlsen
Weeping Demon emulation by Chet Gnegy (https://ccrma.stanford.edu/~chet/)

Theme attribution:
FoxAsteria made some of the better lookin' color schemes.

Special thanks goes out to everyone who has reported bugs and provided ideas to me:
Eliseat, Bri1, FoxAsteria, EpicSounds, TonE, daxliniere, JamesPeters, kneipp123, 
jrengmusic, mawi, vdubreeze, Sju, nitsuj, GonZ.
And of course Cockos Inc for developing JSFX.

slider1:2<2,9,1>-Nodes negative
slider2:2<2,9,1>-Nodes positive

slider3:0.15<0,1,.01>-Pos1x
slider4:1.0<0,1,.01>-Pos1y
slider5:0.25<0,1,.01>-Pos2x
slider6:0.25<0,1,.01>-Pos2y
slider7:0.35<0,1,.01>-Pos3x
slider8:0.35<0,1,.01>-Pos3y
slider9:0.5<0,1,.01> -Pos4x
slider10:0.5<0,1,.01>-Pos4y
slider11:0.6<0,1,.01>-Pos5x
slider12:0.6<0,1,.01>-Pos5y
slider13:0.7<0,1,.01>-Pos6x
slider14:0.7<0,1,.01>-Pos6y
slider15:0.0<0,1,.01>-Pos7x or FB amnt
slider16:0.8<0,1,.01>-Pos7y or FB time
slider17:0<-1,1,.01>-Post-Gain Mod %
slider18:0.9<0,1,.01>-Pos8y or Morph value

slider19:0.15<0,1,.01>-Neg1x
slider20:1.0<0,1,.01>-Neg1y
slider21:0.25<0,1,.01>-Neg2x
slider22:0.25<0,1,.01>-Neg2y
slider23:0.35<0,1,.01>-Neg3x
slider24:0.35<0,1,.01>-Neg3y
slider25:0.5<0,1,.01>-Neg4x
slider26:0.5<0,1,.01>-Neg4y
slider27:0.6<0,1,.01>-Neg5x
slider28:0.6<0,1,.01>-Neg5y
slider29:0.7<0,1,.01>-Neg6x
slider30:0.7<0,1,.01>-Neg6y
slider31:0.8<-1,1,.01>-Neg7x or FB amnt mod
slider32:0.8<-1,1,.01>-Neg7y or FB time mod
slider33:1.0<0,2,.01>-Key follow amount
slider34:0.9<-1,1,.01>-Neg8y or Morph mod %
// This one secretly has the information folded in whether pre-gain modulation is being used.
// Mask: 1 = lookahead, 2 = MGM, 3 = BYPASS 1, 4 = BYPASS 2, 5 = LFO SMOOTHING, 6 = FB Active, 7 = DYN FB, 8 = LFO FB, 9 = feedback X16, 10 = feedback X8, 11 = Dyn Morph, 12 = LFO Morph, 13 = Dynamic LFO, 11 = feedback X16, 12 = Modern sliders
slider35:16384<0,32767,1>-Toggles (DO NOT AUTOMATE)
slider36:0<0,26,1{OFF,Cosine,Sine,Cos^2,Sin^2,Ramp up,Ramp down,Exponential,Exp + Atk,1-Exponential,Random,Random Exps,Rand Exps + Atk,Single Exp,Single Exp + Atk,Sixteenth pulse,Eighth pulse,Quarter pulse,Half pulse,Triplet,Sine Pulse,Polyrhythm,Polyrhythm ][,Polyrhythm ]|[,Triangle,Two harmonics,Three harmonics}>-LFO type

slider37:0<0,1,0.001>-LFO freq
slider38:0<0,7,1{No reset,Reset,No reset + temposync,Reset + temposync,No reset + centered,Reset + centered,No reset + temposync + centered,Reset + temposync + centered}>-Reset LFO
slider39:1<0,4,.00001>-Modulation range

slider40:<0,90,1{OFF,LP RC-C,Diode Ladder,Vowel,Karlsen,Karlsen S,WS LP,WS HP,WS BP,Moog (ZDF),Ch. Moog (unstable),Notch,Narsty,Modulator,Phaser (OTA),Phaser (FET),Delay Feedbok,Phase Mangler,MS20 LP lin (ZDF),MS20 BP lin(ZDF),MS20 HP lin (ZDF),MS20 LP NL (ZDF),MS20 BP NL (ZDF),MS20 HP NL (ZDF),Experimental,Rezzy (ZDF),SSM LP NL (ZDF),ch. SSM LP NL (Approx),CEM LP NL (ZDF),SSM LP lin (ZDF),CEM LP lin (ZDF),Sine,FM FB,FM-ish,Broken conn,Broken FB (ZDF),Waspey Lin (ZDF),Waspey LP NL(ZDF),Waspey BP NL (ZDF),SVF LP (ZDF),SVF BP (ZDF),SVF HP (ZDF),SVF Notch (ZDF),SVF Peak (ZDF),Saw (ZDF),SVF w/WS Res (ZDF),Voodoo,Junk (ZDF),Comb,Combres (LP),Combedres (BP),MS20x LP,MS20x BP,MS20x HP,WahDemon,PWM LP,PWM BP,Bitred,Muck,WahDemon2,Crybaby,CrybabyH,CrybabyL,VowelSVF,Monstro,KingOfTone,Modulon,OctaverDown,OctaverUp,Metallic,Frazzle,Phone,T.Modulon,Modulatrix,Vibrato,Spin,Wavefold,Multi-WF,Serge WF,Metallic diff,Sproing,Worp,Crunch,Athena,Resonant 1,Resonant 2,Resonant 3,Resonant 4,Harmonizer x2,Harmonizer x4,Harmonizer x1.5}>-Filter2 Type
slider41:1<0,1,.001>-Filter2 Cutoff
slider42:0<0,1,.001>-Filter2 Reso
slider43:0<-1,1,.01>-Filter2 Cutoff Mod %
slider44:0<-1,1,.01>-Filter2 Reso Mod %

slider45:0<0,11,1{Dynamic RMS Post Drive,Direct RMS Post Drive,MIDI poly,MIDI legato,MIDI poly vel,MIDI legato vel,Dynamic RMS Pre Drive,Direct RMS Pre Drive,Dynamic RMS Sidechain,Direct RMS Sidechain,ModWheel>-Dynamics mode
slider46:<0,9,1{Stereo,Mono2dangerous,M1S2dangerous,M2S1dangerous,Side,Mid,Stereo Boost,Stereoize,Subtle Stereo,Inverted}>-Filter Operation Mode
#slider47:<0,54,1{OFF,LP RC-C,Diode Ladder,Vowel,Karlsen,Karlsen S,WS LP,WS HP,WS BP,Moog (ZDF),Ch. Moog (unstable),Notch,Narsty,Modulator,Phaser (OTA),Phaser (FET),Delay Feedbok,Phase Mangler,MS20 LP lin (ZDF),MS20 BP lin(ZDF),MS20 HP lin (ZDF),MS20 LP NL (ZDF),MS20 BP NL (ZDF),MS20 HP NL (ZDF),Experimental,Rezzy (ZDF),SSM LP NL (ZDF),ch. SSM LP NL (Approx),CEM LP NL (ZDF),SSM LP lin (ZDF),CEM LP lin (ZDF),Sine,FM FB,FM-ish,Broken conn,Broken FB (ZDF),Waspey Lin (ZDF),Waspey LP NL(ZDF),Waspey BP NL (ZDF),SVF LP (ZDF),SVF BP (ZDF),SVF HP (ZDF),SVF Notch (ZDF),SVF Peak (ZDF),Saw (ZDF),SVF w/WS Res (ZDF),Voodoo,Junk (ZDF),Comb,Combres (LP),Combedres (BP),MS-20 LP2,MS-20 BP2,MS-20 HP2}>-Filter Type
slider47:<0,90,1{OFF,LP RC-C,Diode Ladder,Vowel,Karlsen,Karlsen S,WS LP,WS HP,WS BP,Moog (ZDF),Ch. Moog (unstable),Notch,Narsty,Modulator,Phaser (OTA),Phaser (FET),Delay Feedbok,Phase Mangler,MS20 LP lin (ZDF),MS20 BP lin(ZDF),MS20 HP lin (ZDF),MS20 LP NL (ZDF),MS20 BP NL (ZDF),MS20 HP NL (ZDF),Experimental,Rezzy (ZDF),SSM LP NL (ZDF),ch. SSM LP NL (Approx),CEM LP NL (ZDF),SSM LP lin (ZDF),CEM LP lin (ZDF),Sine,FM FB,FM-ish,Broken conn,Broken FB (ZDF),Waspey Lin (ZDF),Waspey LP NL(ZDF),Waspey BP NL (ZDF),SVF LP (ZDF),SVF BP (ZDF),SVF HP (ZDF),SVF Notch (ZDF),SVF Peak (ZDF),Saw (ZDF),SVF w/WS Res (ZDF),Voodoo,Junk (ZDF),Comb,Combres (LP),Combedres (BP),MS20x LP,MS20x BP,MS20x HP,WahDemon,PWM LP,PWM BP,Bitred,Muck,WahDemon2,Crybaby,CrybabyH,CrybabyL,VowelSVF,Monstro,KingOfTone,Modulon,OctaverDown,OctaverUp,Metallic,Frazzle,Phone,T.Modulon,Modulatrix,Vibrato,Spin,Wavefold,Multi-WF,Serge WF,Metallic diff,Sproing,Worp,Crunch,Athena,Resonant 1,Resonant 2,Resonant 3,Resonant 4,Harmonizer x2,Harmonizer x4,Harmonizer x1.5}>-Filter Type
slider48:1<0,1,.001>-Cutoff
slider49:0<0,1,.001>-Reso
slider50:0<0,16,1{Serial DualDist,Serial DualDist (FIR),Serial,Serial (FIR),Parallel DualDist,Parallel DualDist (FIR),Parallel,Parallel (FIR),Morph DualDist,Morph DualDist (FIR),Morph,Morph (FIR)}>-FIR resampling and linking mode

slider51:0<-1,1,.01>-Pre-Gain/Drive Mod %
slider52:0<-40,40,.01>-PreGain
slider53:0<-40,40,.01>-PostGain
slider54:1<1,8,1>-Oversampling
slider55:0<0,7,1{No clipping,Input clipping,Output clipping,Input/output clipping,No clipping + Inertia,Input clipping + Inertia,Output clipping + Inertia,Input/output clipping + Inertia}>-Clipping and Inertia
slider56:0<0,5,1{Spline,Tanh,Fast Tanh,None,Sine,Tanh}>-Waveshaping Mode
slider57:0<0,63,1{Attack x1 Decay x1 RMS x1,Attack x8 Decay x1 RMS x1,Attack x4 Decay x1 RMS x1,Attack x32 Decay x1 RMS x1,Attack x1 Decay x8 RMS x1,Attack x8 Decay x8 RMS x1,Attack x4 Decay x8 RMS x1,Attack x32 Decay x8 RMS x1,Attack x1 Decay x4 RMS x1,Attack x8 Decay x4 RMS x1,Attack x4 Decay x4 RMS x1,Attack x32 Decay x4 RMS x1,Attack x1 Decay x32 RMS x1,Attack x8 Decay x32 RMS x1,Attack x4 Decay x32 RMS x1,Attack x32 Decay x32 RMS x1,Attack x1 Decay x1 RMS x8,Attack x8 Decay x1 RMS x8,Attack x4 Decay x1 RMS x8,Attack x32 Decay x1 RMS x8,Attack x1 Decay x8 RMS x8,Attack x8 Decay x8 RMS x8,Attack x4 Decay x8 RMS x8,Attackx32 Decay x8 RMS x8,Attack x1 Decay x4 RMS x8,Attack x8 Decay x4 RMS x8,Attack x4 Decay x4 RMS x8,Attack x32 Decay x4 RMS x8,Attack x1 Decay x32 RMS x8,Attack x8 Decay x32 RMS x8,Attack x4 Decay x32 RMS x8,Attack x32 Decay x32 RMS x8,Attack x1 Decay x1 RMS x4,Attack x8 Decay x1 RMS x4,Attack x4 Decay x1 RMS x4,Attack x32 Decay x1 RMS x4,Attack x1 Decay x8 RMS x4,Attack x8 Decay x8 RMS x4,Attack x4 Decay x8 RMS x4,Attack x32 Decay x8 RMS x4,Attack x1 Decay x4 RMS x4,Attack x8 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x32 Decay x4 RMS x4,Attack x1 Decay x32 RMS x4,Attack x8 Decay x32 RMS x4,Attack x4 Decay x32 RMS x4,Attack x32 Decay x32 RMS x4,Attack x1 Decay x1 RMS x32,Attack x8 Decay x1 RMS x32,Attack x4 Decay x1 RMS x32,Attack x32 Decay x1 RMS x32,Attack x1 Decay x8 RMS x32,Attack x8 Decay x8 RMS x32,Attack x4 Decay x8 RMS x32,Attack x32 Decay x8 RMS x32,Attack x1 Decay x4 RMS x32,Attack x8 Decay x4 RMS x32,Attack x4 Decay x4 RMS x32,Attack x32 Decay x4 RMS x32,Attack x1 Decay x32 RMS x32,Attack x8 Decay x32 RMS x32,Attack x4 Decay x32 RMS x32,Attack x32 Decay x32 RMS x3}>-Multipliers

// {OFF,F1F2DYN-LFO,SHAPER,F1F2DYN-LFO-SHAPER,F1DYN-LFO,F1F2DYN-LFO,F1DYN-LFO-SHAPER,F1F2DYN-LFO-SHAPER,F1LFO,F1F2DYN-F1LFO,F1LFO-SHAPER,F1F2DYN-F1LFO-SHAPER,F1DYN-F1LFO,F1F2DYN-F1LFO,F1DYN-F1LFO-SHAPER,F1F2DYN-F1LFO-SHAPER,F2DYN-LFO,F1F2DYN-LFO,F2DYN-LFO-SHAPER,F1F2DYN-LFO-SHAPER,F1F2DYN-LFO,F1F2DYN-LFO,F1F2DYN-LFO-SHAPER,F1F2DYN-LFO-SHAPER,F2DYN-F1LFO,F1F2DYN-F1LFO,F2DYN-F1LFO-SHAPER,F1F2DYN-F1LFO-SHAPER,F1F2DYN-F1LFO,F1F2DYN-F1LFO,F1F2DYN-F1LFO-SHAPER,F1F2DYN-F1LFO-SHAPER,F2LFO,F1F2DYN-F2LFO,F2LFO-SHAPER,F1F2DYN-F2LFO-SHAPER,F1DYN-F2LFO,F1F2DYN-F2LFO,F1DYN-F2LFO-SHAPER,F1F2DYN-F2LFO-SHAPER,F1F2LFO,F1F2DYN-F1F2LFO,F1F2LFO-SHAPER,F1F2DYN-F1F2LFO-SHAPER,F1DYN-F1F2LFO,F1F2DYN-F1F2LFO,F1DYN-F1F2LFO-SHAPER,F1F2DYN-F1F2LFO-SHAPER,F2DYN-F2LFO,F1F2DYN-F2LFO,F2DYN-F2LFO-SHAPER,F1F2DYN-F2LFO-SHAPER,F1F2DYN-F2LFO,F1F2DYN-F2LFO,F1F2DYN-F2LFO-SHAPER,F1F2DYN-F2LFO-SHAPER,F2DYN-F1F2LFO,F1F2DYN-F1F2LFO,F2DYN-F1F2LFO-SHAPER,F1F2DYN-F1F2LFO-SHAPER,F1F2DYN-F1F2LFO,F1F2DYN-F1F2LFO,F1F2DYN-F1F2LFO-SHAPER,F1F2DYN-F1F2LFO-SHAPER}
slider58:0<0,4095,1>-Dynamics

slider59:1<0,1,.001>-Thresh
slider60:5<0,50,.1>-Attack
slider61:5<0.1,50,.1>-Decay
slider62:0<-1,1,.01>-Filt Cutoff Mod %
slider63:0<-1,1,.01>-Filt Reso Mod %
slider64:.34<0.02,40,0.001>-RMS Integration time

in_pin:left input
in_pin:right input
in_pin:left sidechain
in_pin:right sidechain
out_pin:left output
out_pin:right output
options:no_meter 

@serialize
danger_list     = 960000-500; // List of dangerous filters
danger_list2    = 960000-100; // List of dangerous modes

(file_avail(0)>=0) ? (
  envelopesPresent = 0;
  newCutoffMapping = 1;
  
  dynamicFilterButton.mode = 0;
  dynamicFilterButton2.mode = 0;
  lfoFilterButton.mode = 0;
  lfoFilterButton2.mode = 0;
  env1FilterButton.mode = 0;
  env2FilterButton.mode = 0;
  env1Filter2Button.mode = 0;
  env2Filter2Button.mode = 0;
  
  memset(danger_list,0,255);
  memset(danger_list2,0,99);
);

env_buf1        = 66*65536;
env_buf_shapes1 = 67*65536;
env_buf2        = 68*65536;
env_buf_shapes2 = 69*65536;
//env_buf1 = 66*65536;
//env_buf2 = 68*65536;

file_var(0,extraScale);
file_var(0,hideToolTips);
file_var(0,linuxMode);
file_var(0,dnoisefloor_freq);
file_var(0,dsteps_fft);
file_var(0,dgonio_zoom);
file_var(0,agcControl);
file_var(0,agc_corr);
file_var(0,block_analyzers);
file_var(0,mod_LFO_rate);
file_var(0,mod_LFO_amount);
file_var(0,force_mono_output);
file_var(0,rescale_factor);
file_var(0,global_bypass);
file_var(0,hideSpectrumIn);
file_var(0,hideSpectrumOut);
file_var(0,hideSpectrumFilters);

file_var(0,env1GainButton.active);
file_var(0,env2GainButton.active);
file_var(0,env1FilterButton.active);
file_var(0,env2FilterButton.active);
file_var(0,env1Filter2Button.active);
file_var(0,env2Filter2Button.active);
file_var(0,env1Morph.active);
file_var(0,env2Morph.active);
file_var(0,env1LFO.active);
file_var(0,env2LFO.active);
file_var(0,env1FB.active);
file_var(0,env2FB.active);

file_var(0,envWindow1.nodes);
file_var(0,envWindow2.nodes);
file_mem(0,env_buf1,256);
file_mem(0,env_buf2,256);
file_var(0,envWindow1.loopStart);
file_var(0,envWindow1.loopEnd);
file_var(0,envWindow1.loopType);
file_var(0,envWindow1.division);
file_var(0,envWindow1.speedSlider.value);

file_var(0,envWindow2.loopStart);
file_var(0,envWindow2.loopEnd);
file_var(0,envWindow2.loopType);
file_var(0,envWindow2.division);
file_var(0,envWindow2.speedSlider.value);

file_var(0,envWindow1.zoom);
file_var(0,envWindow2.zoom);
file_var(0,envWindow1.offset);
file_var(0,envWindow2.offset);

file_var(0,envWindow1.softening);
file_var(0,envWindow2.softening);
file_var(0,envWindow1.triggering);
file_var(0,envWindow2.triggering);
file_var(0,envWindow1.useVelocities);
file_var(0,envWindow2.useVelocities);

file_var(0,envWindow1.snapping);
file_var(0,envWindow2.snapping);

file_mem(0,env_buf_shapes1,256);
file_mem(0,env_buf_shapes2,256);

file_var(0,envelopesPresent);
file_var(0,newCutoffMapping);

file_var(0,dynvalSmoothing);
dynvalSmoothing == 0 ? dynvalSmoothing = 0.9;

file_var(0,dynamicFilterButton.mode);
file_var(0,dynamicFilterButton2.mode);
file_var(0,lfoFilterButton.mode);
file_var(0,lfoFilterButton2.mode);
file_var(0,env1FilterButton.mode);
file_var(0,env2FilterButton.mode);
file_var(0,env1Filter2Button.mode);
file_var(0,env2Filter2Button.mode);

file_mem(0,danger_list,256);
file_mem(0,danger_list2,100);

danger_list[16] = 1;
danger_list[24] = 1;
danger_list[10] = 1;
danger_list[6] = 1;
danger_list[7] = 1;
danger_list[8] = 1;
danger_list2[1] = 1;
danger_list2[2] = 1;
danger_list2[3] = 1;

file_var(0,envWindow1.autoloop);
file_var(0,envWindow2.autoloop);
file_var(0,polarityButton.active);

file_var(0,currentTheme);

file_var(0,envWindow1.bidi);
file_var(0,envWindow2.bidi);

envWindow1.updateTogglesAfterLoad();
envWindow2.updateTogglesAfterLoad();

@init
activeTheme = -1;

function updateTogglesAfterLoad()
  local()
  global()
  instance(bidi, softening, triggering, useVelocities, snapping, autoloop,
           bidiLoop, soften, midiTrigger, midiVel, snap, aLoop)
  (
    bidiLoop.active     = bidi == 1 ? 1 : 0;
    soften.active       = softening == 1 ? 1 : 0;
    midiTrigger.active  = triggering == 1 ? 1 : 0;
    midiVel.active      = useVelocities == 1 ? 1 : 0;
    snap.active         = snapping == 1 ? 1 : 0;
    aLoop.active        = autoloop == 1 ? 1 : 0;
  );

function resetEnvelope(vel, hard)
  global()
  instance(curTime, memory, curveMemory, cpos, cpos2, tn, tnm1, yn, ynm1, dy, invdx, cnode, triggering, curvel, curCurve, autoloop)
  local(go)
  (
    // If we do not respond to MIDI triggers, only go on a full reset
    ( ( triggering == 2 ) && ( hard == 1 ) ) ? (
      go = 1;
    // If we _do_ respond to MIDI triggers, respond only when it is *not* a hard reset
    ) : ( ( triggering == 1 ) && ( hard == 0 ) ) ? ( 
      go = 1 
    ) : (go = 0);
    
    ( go == 1 ) ? (
      curTime   = 0;
      cpos      = memory;
      cpos2     = curveMemory;
      tnm1      = 0;
      ynm1      = 0;
      tn        = cpos[];
      yn        = cpos[1];
      cnode     = 0;
      curvel    = vel;
      dy        = (yn - ynm1);
      invdx     =  1 / ( tn - tnm1 );
      curCurve  = cpos2[];
      curCurve == 0 ? dy *= invdx;
      cpos2     += 1;
    );
  );

skipFactor = 4;
globalTime = 0;

maxTheme = 5;
function initTheme(theme)
(
  ( theme == 1 ) ? (
    // Boring default
    boldGroups = 0;
    voltage_opacity = 1;
    bg_color_r = 0;
    bg_color_g = 0;
    bg_color_b = 0;
    bg_color_a = .6;
    fft_out_r = .8;
    fft_out_g = .8;
    fft_out_b = .8;
    fft_out_a = 1.0;
    fft_in_r = .13;
    fft_in_g = .13;
    fft_in_b = .23;
    fft_in_a = .6;
    fft_filt_r = .2;
    fft_filt_g = .2;
    fft_filt_b = .7;
    fft_filt_a = .15;
    fft_filt2_r = .5;
    fft_filt2_g = .1;
    fft_filt2_b = .1;
    fft_filt2_a = .15;
    spline_r = .7;
    spline_g = .7;
    spline_b = .7;
    spline_a = .7;
    dyn_color_r = .8;
    dyn_color_g = .8;
    dyn_color_b = .2;
    dyn_color_a = .3;
    filter_description_r = 0.6;
    filter_description_g = 0.6;
    filter_description_b = 1.0;
    filter_description_a = 1.0;
    font_color_r = .8;
    font_color_g = .8;
    font_color_b = .8;
    font_color_a = .8;
    disabled_color_r = .4;
    disabled_color_g = .4;
    disabled_color_b = .4;
    disabled_color_a = .8;
    highlight_color_r = .9;
    highlight_color_g = .7;
    highlight_color_b = .7;
    highlight_color_a = .7;
    slider_marker_r = .9;
    slider_marker_g = .9;
    slider_marker_b = .7;
    slider_marker_a = .7;
    grid_color_r = .3;
    grid_color_g = .3;
    grid_color_b = .6;
    grid_color_a = .2;
    backface_color_r = .2;
    backface_color_g = .2;
    backface_color_b = .3;
    backface_color_a = .1;
    thresh_color_r = 0.9;
    thresh_color_g = 0.3;
    thresh_color_b = 0.3;
    thresh_color_a = 1.0;
    gonio_out_r = .8;
    gonio_out_g = .8;
    gonio_out_b = .8;
    gonio_out_a = .24;  
    gonio_in_r = .23;
    gonio_in_g = .23;
    gonio_in_b = .23;
    gonio_in_a = .36;
    logo_color_r = .8;
    logo_color_g = .9;
    logo_color_b = 1.5;
    rms_in_r = 1;
    rms_in_g = .3;
    rms_in_b = .3;
    rms_in_a = .3;
    rms_out_r = .6;
    rms_out_g = .3;
    rms_out_b = 1;
    rms_out_a = .9;
    widgetcolor_r = .7;
    widgetcolor_g = .7;
    widgetcolor_b = .9;
    widgetcolor_a = .7;
    group_color_r = .7;
    group_color_g = .7;
    group_color_b = .9;
    group_color_a = 0.05;
    selectionbutton_color_r = .3; 
    selectionbutton_color_g = .4;
    selectionbutton_color_b = .8;
    selectionbutton_color_a = .3;
    selectionbutton_color_r = .3; 
    selectionbutton_color_g = .3;
    selectionbutton_color_b = .7;
    selectionbutton_color_a = .3;
    filter_description_bg_r = 0.1;
    filter_description_bg_g = 0.1;
    filter_description_bg_b = 0.2;
    filter_description_bg_a = 0.05;
    highlight_r = .6;
    highlight_g = .6;
    highlight_b = .8;
    highlight_a = .08;
    combo_bg_r = .1;
    combo_bg_g = .1;
    combo_bg_b = .11;
    modrange_r = widgetcolor_r;
    modrange_g = widgetcolor_g;
    modrange_b = widgetcolor_b;
    modrange_a = .4;
    boldEdges = 0;
    
    colorize = 0.1;
    env1button_color_r = selectionbutton_color_r+colorize;
    env1button_color_g = selectionbutton_color_g;
    env1button_color_b = selectionbutton_color_b-colorize;
    env1button_color_a = selectionbutton_color_a;
      
    env2button_color_r = selectionbutton_color_r+colorize;
    env2button_color_g = selectionbutton_color_g;
    env2button_color_b = selectionbutton_color_b-colorize;
    env2button_color_a = selectionbutton_color_a;
      
    dynbutton_color_r = selectionbutton_color_r;
    dynbutton_color_g = selectionbutton_color_g+colorize;
    dynbutton_color_b = selectionbutton_color_b;
    dynbutton_color_a = selectionbutton_color_a;
      
    lfobutton_color_r = selectionbutton_color_r+colorize;
    lfobutton_color_g = selectionbutton_color_g;
    lfobutton_color_b = selectionbutton_color_b;
    lfobutton_color_a = selectionbutton_color_a;
    
    env1_widget_r = widgetcolor_r + colorize;
    env1_widget_g = widgetcolor_g;
    env1_widget_b = widgetcolor_b - colorize;
    env1_widget_a = widgetcolor_a;
    
    env2_widget_r = widgetcolor_r + colorize;
    env2_widget_g = widgetcolor_g;
    env2_widget_b = widgetcolor_b - colorize;
    env2_widget_a = widgetcolor_a;
    
    dynamics_widget_r = widgetcolor_r;
    dynamics_widget_g = widgetcolor_g + colorize;
    dynamics_widget_b = widgetcolor_b;
    dynamics_widget_a = widgetcolor_a;
    
    lfo_widget_r = widgetcolor_r+colorize;
    lfo_widget_g = widgetcolor_g;
    lfo_widget_b = widgetcolor_b;
    lfo_widget_a = widgetcolor_a;
    
    gonio_axis_r = fft_out_r;
    gonio_axis_g = fft_out_g;
    gonio_axis_b = fft_out_b;
    gonio_axis_a = fft_out_a;
    
    label_color_r = fft_out_r;
    label_color_g = fft_out_g;
    label_color_b = fft_out_b;
    label_color_a = fft_out_a;
    
    spline_knot_r = spline_r;
    spline_knot_g = spline_g;
    spline_knot_b = spline_b;
    spline_knot_a = 1.0;
    
    hint_bg_r = 0.05;
    hint_bg_g = 0.05;
    hint_bg_b = 0.1;
    hint_bg_a = 0.8;
    
    filled_input = 0;
    
  ) : ( theme == 0 ) ? (
    // Purple haze (modded)
    boldGroups = 1;
    voltage_opacity = .9;
    bg_color_r = .07;
    bg_color_g = .05;
    bg_color_b = .12;
    bg_color_a = .9;
    fft_out_r = .8;
    fft_out_g = .8;
    fft_out_b = .8;
    fft_out_a = 1.0;
    fft_in_r = .23;
    fft_in_g = .23;
    fft_in_b = .23;
    fft_in_a = .6;
    fft_filt_r = .25;
    fft_filt_g = .25;
    fft_filt_b = .4;
    fft_filt_a = .35;
    fft_filt2_r = .5;
    fft_filt2_g = .025;
    fft_filt2_b = .25;
    fft_filt2_a = .35;
    spline_r = .37;
    spline_g = .3;
    spline_b = .97;
    spline_a = .3;
    dyn_color_r = 1;
    dyn_color_g = .1;
    dyn_color_b = .1;
    dyn_color_a = .1;
    filter_description_r = 0.6;
    filter_description_g = 0.6;
    filter_description_b = 1.0;
    filter_description_a = 1.0;
    font_color_r = 1;
    font_color_g = 1;
    font_color_b = 1;
    font_color_a = .6;
    disabled_color_r = .4;
    disabled_color_g = .4;
    disabled_color_b = .4;
    disabled_color_a = .8;
    highlight_color_r = .7;
    highlight_color_g = 1;
    highlight_color_b = .5;
    highlight_color_a = 1;
    slider_marker_r = .9;
    slider_marker_g = .9;
    slider_marker_b = .7;
    slider_marker_a = .7;
    grid_color_r = .4;
    grid_color_g = .3;
    grid_color_b = .7;
    grid_color_a = .07;
    backface_color_r = .2;
    backface_color_g = .2;
    backface_color_b = .3;
    backface_color_a = .15;
    thresh_color_r = 1;
    thresh_color_g = 1;
    thresh_color_b = 1;
    thresh_color_a = .7;
    gonio_out_r = .93;
    gonio_out_g = .9;
    gonio_out_b = .9;
    gonio_out_a = .37;  
    gonio_in_r = .27;
    gonio_in_g = .27;
    gonio_in_b = .27;
    gonio_in_a = .37;
    logo_color_r = .8;
    logo_color_g = .9;
    logo_color_b = 1.5;
    rms_in_r = .27;
    rms_in_g = .27;
    rms_in_b = .27;
    rms_in_a = .37;
    rms_out_r = .9;
    rms_out_g = .9;
    rms_out_b = .9;
    rms_out_a = .3;
    widgetcolor_r = .7;
    widgetcolor_g = .7;
    widgetcolor_b = .9;
    widgetcolor_a = .5;
    group_color_r = .7;
    group_color_g = .7;
    group_color_b = .9;
    group_color_a = 0.05;
    selectionbutton_color_r = .3; 
    selectionbutton_color_g = .4;
    selectionbutton_color_b = .8;
    selectionbutton_color_a = .3;
    selectionbutton_color_r = .3; 
    selectionbutton_color_g = .3;
    selectionbutton_color_b = .7;
    selectionbutton_color_a = .3;
    filter_description_bg_r = 0.1;
    filter_description_bg_g = 0.1;
    filter_description_bg_b = 0.2;
    filter_description_bg_a = 0.05;
    highlight_r = .1;
    highlight_g = .2;
    highlight_b = 1.0;
    highlight_a = .3;
    combo_bg_r = .07;
    combo_bg_g = .05;
    combo_bg_b = .12;
    modrange_r = widgetcolor_r;
    modrange_g = widgetcolor_g;
    modrange_b = widgetcolor_b;
    modrange_a = .5;
    boldEdges = 1;
    
    colorize = 0.97;
    env1button_color_r = 1/colorize;
    env1button_color_g = 1/colorize;
    env1button_color_b = .1/colorize;
    env1button_color_a = .9;
      
    env2button_color_r = 1/colorize;
    env2button_color_g = .7/colorize;
    env2button_color_b = .1/colorize;
    env2button_color_a = 1;
      
    dynbutton_color_r = 1/colorize;
    dynbutton_color_g = .1/colorize;
    dynbutton_color_b = .1/colorize;;
    dynbutton_color_a = .1;
      
    lfobutton_color_r = .37/colorize;
    lfobutton_color_g = .1/colorize;
    lfobutton_color_b = .89/colorize;
    lfobutton_color_a = .3;
    
    env1_widget_r = env1button_color_r;
    env1_widget_g = env1button_color_g;
    env1_widget_b = env1button_color_b;
    env1_widget_a = env1button_color_a;
    
    env2_widget_r = env2button_color_r;
    env2_widget_g = env2button_color_g;
    env2_widget_b = env2button_color_b;
    env2_widget_a = env2button_color_a;
    
    dynamics_widget_r = dynbutton_color_r;
    dynamics_widget_g = dynbutton_color_g;
    dynamics_widget_b = dynbutton_color_b;
    dynamics_widget_a = dynbutton_color_a;
    
    lfo_widget_r = lfobutton_color_r*colorize;
    lfo_widget_g = lfobutton_color_g*colorize;
    lfo_widget_b = lfobutton_color_b*colorize;
    lfo_widget_a = lfobutton_color_a;
    
    gonio_axis_r = filter_description_r;
    gonio_axis_g = filter_description_g;
    gonio_axis_b = filter_description_b;
    gonio_axis_a = filter_description_a;
    
    label_color_r = fft_out_r;
    label_color_g = fft_out_g;
    label_color_b = fft_out_b;
    label_color_a = fft_out_a;
    
    filled_input = 1;
    spline_knot_r = spline_r;
    spline_knot_g = spline_g;
    spline_knot_b = spline_b;
    spline_knot_a = 1.0;
    
    hint_bg_r = combo_bg_r;
    hint_bg_g = combo_bg_g;
    hint_bg_b = combo_bg_b;
    hint_bg_a = 0.8;
    
  ) : ( theme == 2 ) ? (
    // Filthy Brown (FoxAsteria)
    boldGroups = 1;
    voltage_opacity = .5;
    bg_color_r = .73;
    bg_color_g = .69;
    bg_color_b = .6;
    bg_color_a = .93;
    fft_out_r = .9;
    fft_out_g = .9;
    fft_out_b = .9;
    fft_out_a = 1.0;
    fft_in_r = .23;
    fft_in_g = .23;
    fft_in_b = .23;
    fft_in_a = .6;
    fft_filt_r = .2;
    fft_filt_g = .2;
    fft_filt_b = .2;
    fft_filt_a = .15;
    fft_filt2_r = .1;
    fft_filt2_g = .1;
    fft_filt2_b = .1;
    fft_filt2_a = .15;
    spline_r = 1;
    spline_g = 1;
    spline_b = 1;
    spline_a = .3;
    dyn_color_r = 1;
    dyn_color_g = .1;
    dyn_color_b = .1;
    dyn_color_a = .1;
    filter_description_r = .2;
    filter_description_g = .2;
    filter_description_b = .1;
    filter_description_a = .9;
    font_color_r = .07;
    font_color_g = .07;
    font_color_b = 0.03;
    font_color_a = .8;
    disabled_color_r = .5;
    disabled_color_g = .4;
    disabled_color_b = .2;
    disabled_color_a = .3;
    highlight_color_r = .7;
    highlight_color_g = 1;
    highlight_color_b = .5;
    highlight_color_a = 1;
    slider_marker_r = .71;
    slider_marker_g = .723;
    slider_marker_b = .72;
    slider_marker_a = .7;
    grid_color_r = .9;
    grid_color_g = .9;
    grid_color_b = .9;
    grid_color_a = .1;
    backface_color_r = .4;
    backface_color_g = .3;
    backface_color_b = .2;
    backface_color_a = .4;
    thresh_color_r = 1;
    thresh_color_g = 1;
    thresh_color_b = 1;
    thresh_color_a = .7;
    gonio_out_r = .8;
    gonio_out_g = .8;
    gonio_out_b = .8;
    gonio_out_a = .24;  
    gonio_in_r = .23;
    gonio_in_g = .23;
    gonio_in_b = .23;
    gonio_in_a = .36;
    logo_color_r = .4;
    logo_color_g = .3;
    logo_color_b = .2;
    rms_in_r = .23;
    rms_in_g = .23;
    rms_in_b = .23;
    rms_in_a = .6;
    rms_out_r = .9;
    rms_out_g = .9;
    rms_out_b = .9;
    rms_out_a = 1;
    widgetcolor_r = .5;
    widgetcolor_g = .4;
    widgetcolor_b = .2;
    widgetcolor_a = .1;
    group_color_r = .5;
    group_color_g = .4;
    group_color_b = .2;
    group_color_a = 0.3;
    selectionbutton_color_r = .5; 
    selectionbutton_color_g = .4;
    selectionbutton_color_b = .2;
    selectionbutton_color_a = .1;
    filter_description_bg_r = 0.5;
    filter_description_bg_g = 0.4;
    filter_description_bg_b = 0.2;
    filter_description_bg_a = 0.1;
    highlight_r = .1;
    highlight_g = .2;
    highlight_b = 1.0;
    highlight_a = .7;
    
    colorize = 0.77;
    env1button_color_r = .3*colorize;
    env1button_color_g = 1*colorize;
    env1button_color_b = 1*colorize;
    env1button_color_a = .5;
      
    env2button_color_r = .3*colorize;
    env2button_color_g = 1*colorize;
    env2button_color_b = 1*colorize;
    env2button_color_a = .5;
      
    dynbutton_color_r = .89*colorize;
    dynbutton_color_g = .7*colorize;
    dynbutton_color_b = .73*colorize;
    dynbutton_color_a = .3;
      
    lfobutton_color_r = .73*colorize;
    lfobutton_color_g = .7*colorize;
    lfobutton_color_b = .89*colorize;
    lfobutton_color_a = .3;
    
    env1_widget_r = env1button_color_r;
    env1_widget_g = env1button_color_g;
    env1_widget_b = env1button_color_b;
    env1_widget_a = env1button_color_a;
    
    env2_widget_r = env1button_color_r;
    env2_widget_g = env1button_color_g;
    env2_widget_b = env1button_color_b;
    env2_widget_a = env1button_color_a;
    
    dynamics_widget_r = dynbutton_color_r;
    dynamics_widget_g = dynbutton_color_g;
    dynamics_widget_b = dynbutton_color_b;
    dynamics_widget_a = dynbutton_color_a;
    
    lfo_widget_r = lfobutton_color_r*colorize;
    lfo_widget_g = lfobutton_color_g*colorize;
    lfo_widget_b = lfobutton_color_b*colorize;
    lfo_widget_a = lfobutton_color_a;
    
    combo_bg_r = .63;
    combo_bg_g = .59;
    combo_bg_b = .5;
    modrange_r = widgetcolor_r;
    modrange_g = widgetcolor_g;
    modrange_b = widgetcolor_b;
    modrange_a = .7;
    boldEdges = 1;
    
    colorize = 0.97;
    env1button_color_r = 1/colorize;
    env1button_color_g = 1/colorize;
    env1button_color_b = .1/colorize;
    env1button_color_a = .9;
      
    env2button_color_r = 1/colorize;
    env2button_color_g = .7/colorize;
    env2button_color_b = .1/colorize;
    env2button_color_a = 1;
      
    dynbutton_color_r = 1/colorize;
    dynbutton_color_g = .1/colorize;
    dynbutton_color_b = .1/colorize;;
    dynbutton_color_a = .1;
      
    lfobutton_color_r = .37/colorize;
    lfobutton_color_g = .1/colorize;
    lfobutton_color_b = .89/colorize;
    lfobutton_color_a = .3;
    
    env1_widget_r = env1button_color_r;
    env1_widget_g = env1button_color_g;
    env1_widget_b = env1button_color_b;
    env1_widget_a = env1button_color_a;
    
    env2_widget_r = env2button_color_r;
    env2_widget_g = env2button_color_g;
    env2_widget_b = env2button_color_b;
    env2_widget_a = env2button_color_a;
    
    dynamics_widget_r = dynbutton_color_r;
    dynamics_widget_g = dynbutton_color_g;
    dynamics_widget_b = dynbutton_color_b;
    dynamics_widget_a = dynbutton_color_a;
    
    lfo_widget_r = lfobutton_color_r*colorize;
    lfo_widget_g = lfobutton_color_g*colorize;
    lfo_widget_b = lfobutton_color_b*colorize;
    lfo_widget_a = lfobutton_color_a;
    
    gonio_axis_r = filter_description_r;
    gonio_axis_g = filter_description_g;
    gonio_axis_b = filter_description_b;
    gonio_axis_a = filter_description_a;
    
    label_color_r = fft_out_r;
    label_color_g = fft_out_g;
    label_color_b = fft_out_b;
    label_color_a = fft_out_a;
    
    filled_input = 1;
    spline_knot_r = spline_r;
    spline_knot_g = spline_g;
    spline_knot_b = spline_b;
    spline_knot_a = 1.0;
    
    hint_bg_r = combo_bg_r;
    hint_bg_g = combo_bg_g;
    hint_bg_b = combo_bg_b;
    hint_bg_a = 0.8;
    
  ) : ( theme == 3 ) ? (
    // Clean Colors (FoxAsteria)
    boldGroups = 1;
    voltage_opacity = .5;
    bg_color_r = .92;
    bg_color_g = .9;
    bg_color_b = .89;
    bg_color_a = .9;
    fft_out_r = .9;
    fft_out_g = .9;
    fft_out_b = .9;
    fft_out_a = 1.0;
    fft_in_r = .13;
    fft_in_g = .13;
    fft_in_b = .23;
    fft_in_a = .3;
    fft_filt_r = .2;
    fft_filt_g = .2;
    fft_filt_b = .2;
    fft_filt_a = .15;
    fft_filt2_r = .1;
    fft_filt2_g = .1;
    fft_filt2_b = .1;
    fft_filt2_a = .15;
    spline_r = .9;
    spline_g = .9;
    spline_b = .9;
    spline_a = .9;
    dyn_color_r = .9;
    dyn_color_g = .12;
    dyn_color_b = .23;
    dyn_color_a = .3;
    filter_description_r = 0.1;
    filter_description_g = 0.1;
    filter_description_b = .1;
    filter_description_a = .5;
    font_color_r = .01;
    font_color_g = .01;
    font_color_b = .3;
    font_color_a = .6;
    disabled_color_r = .7;
    disabled_color_g = .7;
    disabled_color_b = .7;
    disabled_color_a = .7;
    highlight_color_r = .6;
    highlight_color_g = 1;
    highlight_color_b = .7;
    highlight_color_a = .9;
    slider_marker_r = .9;
    slider_marker_g = .9;
    slider_marker_b = .9;
    slider_marker_a = .9;
    grid_color_r = .9;
    grid_color_g = .9;
    grid_color_b = .9;
    grid_color_a = .2;
    backface_color_r = .23;
    backface_color_g = .2;
    backface_color_b = .32;
    backface_color_a = .1;
    thresh_color_r = 1.0;
    thresh_color_g = 1.0;
    thresh_color_b = 1.0;
    thresh_color_a = 1.0;
    gonio_out_r = 1;
    gonio_out_g = 1;
    gonio_out_b = 1;
    gonio_out_a = .84;  
    gonio_in_r = .53;
    gonio_in_g = .53;
    gonio_in_b = .53;
    gonio_in_a = .01;
    logo_color_r = .4;
    logo_color_g = .4;
    logo_color_b = 1;
    rms_in_r = .6;
    rms_in_g = .6;
    rms_in_b = .6;
    rms_in_a = .9;
    rms_out_r = 1;
    rms_out_g = 1;
    rms_out_b = 1;
    rms_out_a = .9;
    widgetcolor_r = .7;
    widgetcolor_g = .7;
    widgetcolor_b = .9;
    widgetcolor_a = .3;
    group_color_r = .7;
    group_color_g = .7;
    group_color_b = .7;
    group_color_a = 0.3;
    selectionbutton_color_r = .5; 
    selectionbutton_color_g = .5;
    selectionbutton_color_b = .5;
    selectionbutton_color_a = 1;
    filter_description_bg_r = 0.9;
    filter_description_bg_g = 0.9;
    filter_description_bg_b = 0.97;
    filter_description_bg_a = 0.7;
    highlight_r = 1;
    highlight_g = .2;
    highlight_b = 1.0;
    highlight_a = .7;
    combo_bg_r = .9;
    combo_bg_g = .9;
    combo_bg_b = .91;
    modrange_r = widgetcolor_r;
    modrange_g = widgetcolor_g;
    modrange_b = widgetcolor_b;
    modrange_a = 1;
    boldEdges = 1;
    colorize = 0.97;
    env1button_color_r = 1/colorize;
    env1button_color_g = 1/colorize;
    env1button_color_b = .1/colorize;
    env1button_color_a = .9;
      
    env2button_color_r = 1/colorize;
    env2button_color_g = .7/colorize;
    env2button_color_b = .1/colorize;
    env2button_color_a = 1;
      
    dynbutton_color_r = 1/colorize;
    dynbutton_color_g = .1/colorize;
    dynbutton_color_b = .1/colorize;;
    dynbutton_color_a = .3;
      
    lfobutton_color_r = .37/colorize;
    lfobutton_color_g = .1/colorize;
    lfobutton_color_b = .89/colorize;
    lfobutton_color_a = .3;
    
    env1_widget_r = env1button_color_r;
    env1_widget_g = env1button_color_g;
    env1_widget_b = env1button_color_b;
    env1_widget_a = env1button_color_a;
    
    env2_widget_r = env2button_color_r;
    env2_widget_g = env2button_color_g;
    env2_widget_b = env2button_color_b;
    env2_widget_a = env2button_color_a;
    
    dynamics_widget_r = dynbutton_color_r;
    dynamics_widget_g = dynbutton_color_g;
    dynamics_widget_b = dynbutton_color_b;
    dynamics_widget_a = dynbutton_color_a;
    
    lfo_widget_r = lfobutton_color_r*colorize;
    lfo_widget_g = lfobutton_color_g*colorize;
    lfo_widget_b = lfobutton_color_b*colorize;
    lfo_widget_a = lfobutton_color_a;
    
    gonio_axis_r = filter_description_r;
    gonio_axis_g = filter_description_g;
    gonio_axis_b = filter_description_b;
    gonio_axis_a = filter_description_a;
    
    label_color_r = fft_out_r;
    label_color_g = fft_out_g;
    label_color_b = fft_out_b;
    label_color_a = fft_out_a;
    
    filled_input = 1;
    spline_knot_r = spline_r;
    spline_knot_g = spline_g;
    spline_knot_b = spline_b;
    spline_knot_a = 1.0;
    
    hint_bg_r = combo_bg_r;
    hint_bg_g = combo_bg_g;
    hint_bg_b = combo_bg_b;
    hint_bg_a = 0.8;
    
  ) : ( theme == 4 ) ? (
    // Ice Cold (FoxAsteria)
    boldGroups = 1;
    voltage_opacity = .5;
    bg_color_r = .7;
    bg_color_g = .8;
    bg_color_b = .86;
    bg_color_a = .3;
    fft_out_r = .9;
    fft_out_g = .9;
    fft_out_b = 1;
    fft_out_a = 1.0;
    fft_in_r = .18;
    fft_in_g = .13;
    fft_in_b = .13;
    fft_in_a = .6;
    fft_filt_r = .78;
    fft_filt_g = .73;
    fft_filt_b = .73;
    fft_filt_a = .35;
    fft_filt2_r = .78;
    fft_filt2_g = .73;
    fft_filt2_b = .73;
    fft_filt2_a = .35;
    spline_r = .9;
    spline_g = .9;
    spline_b = 1;
    spline_a = .7;
    dyn_color_r = 1;
    dyn_color_g = .1;
    dyn_color_b = .1;
    dyn_color_a = .1;
    filter_description_r = 0.1;
    filter_description_g = 0.58;
    filter_description_b = 1;
    filter_description_a = .9;
    font_color_r = .1;
    font_color_g = .1;
    font_color_b = .1;
    font_color_a = .67;
    disabled_color_r = .4;
    disabled_color_g = .4;
    disabled_color_b = .4;
    disabled_color_a = .3;
    highlight_color_r = .7;
    highlight_color_g = 1;
    highlight_color_b = .5;
    highlight_color_a = 1;
    slider_marker_r = .89;
    slider_marker_g = .89;
    slider_marker_b = .89;
    slider_marker_a = .7;
    grid_color_r = .4;
    grid_color_g = .3;
    grid_color_b = .7;
    grid_color_a = .07;
    backface_color_r = .81;
    backface_color_g = .89;
    backface_color_b = .93;
    backface_color_a = .23;
    thresh_color_r = 1;
    thresh_color_g = 1;
    thresh_color_b = 1;
    thresh_color_a = .7;
    gonio_out_r = 1;
    gonio_out_g = 1;
    gonio_out_b = 1;
    gonio_out_a = 1;  
    gonio_in_r = .53;
    gonio_in_g = .53;
    gonio_in_b = .58;
    gonio_in_a = .01;
    logo_color_r = .8;
    logo_color_g = .9;
    logo_color_b = 1;
    rms_in_r = .38;
    rms_in_g = .33;
    rms_in_b = .33;
    rms_in_a = .37;
    rms_out_r = 1;
    rms_out_g = 1;
    rms_out_b = 1;
    rms_out_a = 1;
    widgetcolor_r = .6;
    widgetcolor_g = .7;
    widgetcolor_b = 1;
    widgetcolor_a = 1;
    group_color_r = .81;
    group_color_g = .89;
    group_color_b = .93;
    group_color_a = 1;
    selectionbutton_color_r = .1; 
    selectionbutton_color_g = .78;
    selectionbutton_color_b = 1;
    selectionbutton_color_a = .9;
    filter_description_bg_r = 0.81;
    filter_description_bg_g = 0.89;
    filter_description_bg_b = 0.93;
    filter_description_bg_a = 0.3;
    highlight_r = .1;
    highlight_g = .2;
    highlight_b = 1.0;
    highlight_a = .3;
    combo_bg_r = .8;
    combo_bg_g = .9;
    combo_bg_b = .93;
    modrange_r = .1;
    modrange_g = .78;
    modrange_b = 1;
    modrange_a = .3;
    boldEdges = 1;
    
    gonio_axis_r = filter_description_r;
    gonio_axis_g = filter_description_g;
    gonio_axis_b = filter_description_b;
    gonio_axis_a = filter_description_a;
    
    colorize = 0.97;
    env1button_color_r = 1/colorize;
    env1button_color_g = 1/colorize;
    env1button_color_b = .1/colorize;
    env1button_color_a = .9;
      
    env2button_color_r = 1/colorize;
    env2button_color_g = .7/colorize;
    env2button_color_b = .1/colorize;
    env2button_color_a = 1;
      
    dynbutton_color_r = 1/colorize;
    dynbutton_color_g = .1/colorize;
    dynbutton_color_b = .1/colorize;;
    dynbutton_color_a = .1;
      
    lfobutton_color_r = .37/colorize;
    lfobutton_color_g = .1/colorize;
    lfobutton_color_b = .89/colorize;
    lfobutton_color_a = .3;
    
    env1_widget_r = env1button_color_r;
    env1_widget_g = env1button_color_g;
    env1_widget_b = env1button_color_b;
    env1_widget_a = env1button_color_a;
    
    env2_widget_r = env2button_color_r;
    env2_widget_g = env2button_color_g;
    env2_widget_b = env2button_color_b;
    env2_widget_a = env2button_color_a;
    
    dynamics_widget_r = dynbutton_color_r;
    dynamics_widget_g = dynbutton_color_g;
    dynamics_widget_b = dynbutton_color_b;
    dynamics_widget_a = dynbutton_color_a;
    
    lfo_widget_r = lfobutton_color_r*colorize;
    lfo_widget_g = lfobutton_color_g*colorize;
    lfo_widget_b = lfobutton_color_b*colorize;
    lfo_widget_a = lfobutton_color_a;
    
    label_color_r = fft_out_r;
    label_color_g = fft_out_g;
    label_color_b = fft_out_b;
    label_color_a = fft_out_a;
    
    spline_knot_r = spline_r;
    spline_knot_g = spline_g;
    spline_knot_b = spline_b;
    spline_knot_a = 1.0;
    filled_input = 1;
    
    hint_bg_r = combo_bg_r;
    hint_bg_g = combo_bg_g;
    hint_bg_b = combo_bg_b;
    hint_bg_a = 0.8;
  ) : ( theme == 5 ) ? (
    // Purple haze
    boldGroups = 1;
    voltage_opacity = .5;
    bg_color_r = .07;
    bg_color_g = .05;
    bg_color_b = .12;
    bg_color_a = .9;
    fft_out_r = .8;
    fft_out_g = .8;
    fft_out_b = .8;
    fft_out_a = 1.0;
    fft_in_r = .23;
    fft_in_g = .23;
    fft_in_b = .23;
    fft_in_a = .6;
    fft_filt_r = .4;
    fft_filt_g = .4;
    fft_filt_b = .4;
    fft_filt_a = .35;
    fft_filt2_r = .5;
    fft_filt2_g = .5;
    fft_filt2_b = .5;
    fft_filt2_a = .35;
    spline_r = .37;
    spline_g = .3;
    spline_b = .97;
    spline_a = .3;
    dyn_color_r = 1;
    dyn_color_g = .1;
    dyn_color_b = .1;
    dyn_color_a = .1;
    filter_description_r = 0.6;
    filter_description_g = 0.6;
    filter_description_b = 1.0;
    filter_description_a = 1.0;
    font_color_r = 1;
    font_color_g = 1;
    font_color_b = 1;
    font_color_a = .6;
    disabled_color_r = .4;
    disabled_color_g = .4;
    disabled_color_b = .4;
    disabled_color_a = .8;
    highlight_color_r = .7;
    highlight_color_g = 1;
    highlight_color_b = .5;
    highlight_color_a = 1;
    slider_marker_r = .9;
    slider_marker_g = .9;
    slider_marker_b = .7;
    slider_marker_a = .7;
    grid_color_r = .4;
    grid_color_g = .3;
    grid_color_b = .7;
    grid_color_a = .07;
    backface_color_r = .2;
    backface_color_g = .2;
    backface_color_b = .3;
    backface_color_a = .15;
    thresh_color_r = 1;
    thresh_color_g = 1;
    thresh_color_b = 1;
    thresh_color_a = .7;
    gonio_out_r = .93;
    gonio_out_g = .9;
    gonio_out_b = .9;
    gonio_out_a = .37;  
    gonio_in_r = .27;
    gonio_in_g = .27;
    gonio_in_b = .27;
    gonio_in_a = .37;
    logo_color_r = .8;
    logo_color_g = .9;
    logo_color_b = 1.5;
    rms_in_r = .27;
    rms_in_g = .27;
    rms_in_b = .27;
    rms_in_a = .37;
    rms_out_r = .9;
    rms_out_g = .9;
    rms_out_b = .9;
    rms_out_a = .3;
    widgetcolor_r = .7;
    widgetcolor_g = .7;
    widgetcolor_b = .9;
    widgetcolor_a = .5;
    group_color_r = .7;
    group_color_g = .7;
    group_color_b = .9;
    group_color_a = 0.05;
    selectionbutton_color_r = .3; 
    selectionbutton_color_g = .4;
    selectionbutton_color_b = .8;
    selectionbutton_color_a = .3;
    selectionbutton_color_r = .3; 
    selectionbutton_color_g = .3;
    selectionbutton_color_b = .7;
    selectionbutton_color_a = .3;
    filter_description_bg_r = 0.1;
    filter_description_bg_g = 0.1;
    filter_description_bg_b = 0.2;
    filter_description_bg_a = 0.05;
    highlight_r = .1;
    highlight_g = .2;
    highlight_b = 1.0;
    highlight_a = .3;
    combo_bg_r = .07;
    combo_bg_g = .05;
    combo_bg_b = .12;
    modrange_r = widgetcolor_r;
    modrange_g = widgetcolor_g;
    modrange_b = widgetcolor_b;
    modrange_a = .5;
    boldEdges = 1;
    
    colorize = 0.97;
    env1button_color_r = 1/colorize;
    env1button_color_g = 1/colorize;
    env1button_color_b = .1/colorize;
    env1button_color_a = .9;
      
    env2button_color_r = 1/colorize;
    env2button_color_g = .7/colorize;
    env2button_color_b = .1/colorize;
    env2button_color_a = 1;
      
    dynbutton_color_r = 1/colorize;
    dynbutton_color_g = .1/colorize;
    dynbutton_color_b = .1/colorize;;
    dynbutton_color_a = .1;
      
    lfobutton_color_r = .37/colorize;
    lfobutton_color_g = .1/colorize;
    lfobutton_color_b = .89/colorize;
    lfobutton_color_a = .3;
    
    env1_widget_r = env1button_color_r;
    env1_widget_g = env1button_color_g;
    env1_widget_b = env1button_color_b;
    env1_widget_a = env1button_color_a;
    
    env2_widget_r = env2button_color_r;
    env2_widget_g = env2button_color_g;
    env2_widget_b = env2button_color_b;
    env2_widget_a = env2button_color_a;
    
    dynamics_widget_r = dynbutton_color_r;
    dynamics_widget_g = dynbutton_color_g;
    dynamics_widget_b = dynbutton_color_b;
    dynamics_widget_a = dynbutton_color_a;
    
    lfo_widget_r = lfobutton_color_r*colorize;
    lfo_widget_g = lfobutton_color_g*colorize;
    lfo_widget_b = lfobutton_color_b*colorize;
    lfo_widget_a = lfobutton_color_a;
    
    gonio_axis_r = filter_description_r;
    gonio_axis_g = filter_description_g;
    gonio_axis_b = filter_description_b;
    gonio_axis_a = filter_description_a;
    
    label_color_r = fft_out_r;
    label_color_g = fft_out_g;
    label_color_b = fft_out_b;
    label_color_a = fft_out_a;
    
    filled_input = 1;  
    spline_knot_r = spline_r;
    spline_knot_g = spline_g;
    spline_knot_b = spline_b;
    spline_knot_a = 1.0;
    
    hint_bg_r = combo_bg_r;
    hint_bg_g = combo_bg_g;
    hint_bg_b = combo_bg_b;
    hint_bg_a = 0.8;
  );
);

MAXOVERSAMPLING = 8;
MAXBUFFERSIZE = MAXOVERSAMPLING*10000;

!gfx_ext_retina ? gfx_ext_retina = 1;

plugname = "FILTHER 3.04";
//fontface = "Sans Serif";
fontface = "Arial";
newUI = 1;
refreshDynMode = -1;
nFilters = 95;
nShapers = 6;
nModes = 10;
nModes2 = 6;
nLFO = 27;
lastOversample = 0;
lastpdcDelay = -1000;
lastIntegrationTime = -1000;
nTapSinc = slider54 < 5 ? 16 : slider54*4;
modulator.t = 0;
modulator.lastt = -1;
notesOn = 0;
israte = 1/srate;
log2 = log(2);

envWindow1.resetEnvelope(1, 1);
envWindow2.resetEnvelope(1, 1);

function comboMapping(stridx, idx_in)
  local(str)
  global()
  instance()
  (
    str = "";
    (stridx == 0) ?    (
     (idx_in == 1) ? ( 39 ) : 
     (idx_in == 2) ? ( 1 ) : 
     (idx_in == 3) ? ( 18 ) : 
     (idx_in == 4) ? ( 29 ) : 
     (idx_in == 5) ? ( 30 ) : 
     (idx_in == 6) ? ( 36 ) : 
     (idx_in == 7) ? ( 51 ) : 
     (idx_in == 8) ? ( 91 ) : 
     (idx_in == 9) ? ( 21 ) : 
     (idx_in == 10) ? ( 2 ) : 
     (idx_in == 11) ? ( 9 ) : 
     (idx_in == 12) ? ( 10 ) : 
     (idx_in == 13) ? ( 45 ) : 
     (idx_in == 14) ? ( 25 ) : 
     (idx_in == 15) ? ( 26 ) : 
     (idx_in == 16) ? ( 27 ) : 
     (idx_in == 17) ? ( 49 ) : 
     (idx_in == 18) ? ( 28 ) : 
     (idx_in == 19) ? ( 46 ) : 
     (idx_in == 20) ? ( 47 ) : 
     (idx_in == 21) ? ( 37 ) : 
     (idx_in == 22) ? ( 4 ) : 
     (idx_in == 23) ? ( 5 ) : 
     (idx_in == 24) ? ( 6 ) : 
     (idx_in == 25) ? ( 32 ) : 
     (idx_in == 26) ? ( 33 ) : 
     (idx_in == 27) ? ( 12 ) : 
     (idx_in == 28) ? ( 35 ) : 
     (idx_in == 29) ? ( 44 ) : 
     (idx_in == 30) ? ( 84 ) : 
     (idx_in == 31) ? ( 85 ) : 
     (idx_in == 32) ? ( 86 ) : 
     (idx_in == 33) ? ( 87 ) : 
     (idx_in == 34) ? ( 40 ) : 
     (idx_in == 35) ? ( 19 ) : 
     (idx_in == 36) ? ( 52 ) : 
     (idx_in == 37) ? ( 92 ) : 
     (idx_in == 38) ? ( 22 ) : 
     (idx_in == 39) ? ( 50 ) : 
     (idx_in == 40) ? ( 38 ) : 
     (idx_in == 41) ? ( 8 ) : 
     (idx_in == 42) ? ( 41 ) : 
     (idx_in == 43) ? ( 20 ) : 
     (idx_in == 44) ? ( 53 ) : 
     (idx_in == 45) ? ( 93 ) : 
     (idx_in == 46) ? ( 23 ) : 
     (idx_in == 47) ? ( 7 ) : 
     (idx_in == 48) ? ( 71 ) : 
     (idx_in == 49) ? ( 42 ) : 
     (idx_in == 50) ? ( 43 ) : 
     (idx_in == 51) ? ( 11 ) : 
     (idx_in == 52) ? ( 94 ) : 
     (idx_in == 53) ? ( 58 ) : 
     (idx_in == 54) ? ( 60 ) : 
     (idx_in == 55) ? ( 61 ) : 
     (idx_in == 56) ? ( 62 ) : 
     (idx_in == 57) ? ( 54 ) : 
     (idx_in == 58) ? ( 59 ) : 
     (idx_in == 59) ? ( 63 ) : 
     (idx_in == 60) ? ( 3 ) : 
     (idx_in == 61) ? ( 14 ) : 
     (idx_in == 62) ? ( 15 ) : 
     (idx_in == 63) ? ( 16 ) : 
     (idx_in == 64) ? ( 17 ) : 
     (idx_in == 65) ? ( 24 ) : 
     (idx_in == 66) ? ( 48 ) : 
     (idx_in == 67) ? ( 66 ) : 
     (idx_in == 68) ? ( 69 ) : 
     (idx_in == 69) ? ( 70 ) : 
     (idx_in == 70) ? ( 72 ) : 
     (idx_in == 71) ? ( 73 ) : 
     (idx_in == 72) ? ( 13 ) : 
     (idx_in == 73) ? ( 83 ) : 
     (idx_in == 74) ? ( 34 ) : 
     (idx_in == 75) ? ( 64 ) : 
     (idx_in == 76) ? ( 82 ) : 
     (idx_in == 77) ? ( 55 ) : 
     (idx_in == 78) ? ( 56 ) : 
     (idx_in == 79) ? ( 57 ) : 
     (idx_in == 80) ? ( 31 ) : 
     (idx_in == 81) ? ( 65 ) : 
     (idx_in == 82) ? ( 76 ) : 
     (idx_in == 83) ? ( 77 ) : 
     (idx_in == 84) ? ( 78 ) : 
     (idx_in == 85) ? ( 67 ) : 
     (idx_in == 86) ? ( 68 ) : 
     (idx_in == 87) ? ( 74 ) : 
     (idx_in == 88) ? ( 75 ) : 
     (idx_in == 89) ? ( 79 ) : 
     (idx_in == 90) ? ( 80 ) : 
     (idx_in == 91) ? ( 81 ) : 
     (idx_in == 92) ? ( 88 ) : 
     (idx_in == 93) ? ( 89 ) : 
     (idx_in == 94) ? ( 90 )
    ) : idx_in;
  );
function inverseComboMapping(stridx, idx_in)
  local()
  global()
  instance()
  (
    // Filters
    (stridx == 0) ?
    (
     (idx_in == 39) ? ( 1 ) : 
     (idx_in == 1) ? ( 2 ) : 
     (idx_in == 18) ? ( 3 ) : 
     (idx_in == 29) ? ( 4 ) : 
     (idx_in == 30) ? ( 5 ) : 
     (idx_in == 36) ? ( 6 ) : 
     (idx_in == 51) ? ( 7 ) : 
     (idx_in == 91) ? ( 8 ) : 
     (idx_in == 21) ? ( 9 ) : 
     (idx_in == 2) ? ( 10 ) : 
     (idx_in == 9) ? ( 11 ) : 
     (idx_in == 10) ? ( 12 ) : 
     (idx_in == 45) ? ( 13 ) : 
     (idx_in == 25) ? ( 14 ) : 
     (idx_in == 26) ? ( 15 ) : 
     (idx_in == 27) ? ( 16 ) : 
     (idx_in == 49) ? ( 17 ) : 
     (idx_in == 28) ? ( 18 ) : 
     (idx_in == 46) ? ( 19 ) : 
     (idx_in == 47) ? ( 20 ) : 
     (idx_in == 37) ? ( 21 ) : 
     (idx_in == 4) ? ( 22 ) : 
     (idx_in == 5) ? ( 23 ) : 
     (idx_in == 6) ? ( 24 ) : 
     (idx_in == 32) ? ( 25 ) : 
     (idx_in == 33) ? ( 26 ) : 
     (idx_in == 12) ? ( 27 ) : 
     (idx_in == 35) ? ( 28 ) : 
     (idx_in == 44) ? ( 29 ) : 
     (idx_in == 84) ? ( 30 ) : 
     (idx_in == 85) ? ( 31 ) : 
     (idx_in == 86) ? ( 32 ) : 
     (idx_in == 87) ? ( 33 ) : 
     (idx_in == 40) ? ( 34 ) : 
     (idx_in == 19) ? ( 35 ) : 
     (idx_in == 52) ? ( 36 ) : 
     (idx_in == 92) ? ( 37 ) : 
     (idx_in == 22) ? ( 38 ) : 
     (idx_in == 50) ? ( 39 ) : 
     (idx_in == 38) ? ( 40 ) : 
     (idx_in == 8) ? ( 41 ) : 
     (idx_in == 41) ? ( 42 ) : 
     (idx_in == 20) ? ( 43 ) : 
     (idx_in == 53) ? ( 44 ) : 
     (idx_in == 93) ? ( 45 ) : 
     (idx_in == 23) ? ( 46 ) : 
     (idx_in == 7) ? ( 47 ) : 
     (idx_in == 71) ? ( 48 ) : 
     (idx_in == 42) ? ( 49 ) : 
     (idx_in == 43) ? ( 50 ) : 
     (idx_in == 11) ? ( 51 ) : 
     (idx_in == 94) ? ( 52 ) : 
     (idx_in == 58) ? ( 53 ) : 
     (idx_in == 60) ? ( 54 ) : 
     (idx_in == 61) ? ( 55 ) : 
     (idx_in == 62) ? ( 56 ) : 
     (idx_in == 54) ? ( 57 ) : 
     (idx_in == 59) ? ( 58 ) : 
     (idx_in == 63) ? ( 59 ) : 
     (idx_in == 3) ? ( 60 ) : 
     (idx_in == 14) ? ( 61 ) : 
     (idx_in == 15) ? ( 62 ) : 
     (idx_in == 16) ? ( 63 ) : 
     (idx_in == 17) ? ( 64 ) : 
     (idx_in == 24) ? ( 65 ) : 
     (idx_in == 48) ? ( 66 ) : 
     (idx_in == 66) ? ( 67 ) : 
     (idx_in == 69) ? ( 68 ) : 
     (idx_in == 70) ? ( 69 ) : 
     (idx_in == 72) ? ( 70 ) : 
     (idx_in == 73) ? ( 71 ) : 
     (idx_in == 13) ? ( 72 ) : 
     (idx_in == 83) ? ( 73 ) : 
     (idx_in == 34) ? ( 74 ) : 
     (idx_in == 64) ? ( 75 ) : 
     (idx_in == 82) ? ( 76 ) : 
     (idx_in == 55) ? ( 77 ) : 
     (idx_in == 56) ? ( 78 ) : 
     (idx_in == 57) ? ( 79 ) : 
     (idx_in == 31) ? ( 80 ) : 
     (idx_in == 65) ? ( 81 ) : 
     (idx_in == 76) ? ( 82 ) : 
     (idx_in == 77) ? ( 83 ) : 
     (idx_in == 78) ? ( 84 ) : 
     (idx_in == 67) ? ( 85 ) : 
     (idx_in == 68) ? ( 86 ) : 
     (idx_in == 74) ? ( 87 ) : 
     (idx_in == 75) ? ( 88 ) : 
     (idx_in == 79) ? ( 89 ) : 
     (idx_in == 80) ? ( 90 ) : 
     (idx_in == 81) ? ( 91 ) : 
     (idx_in == 88) ? ( 92 ) : 
     (idx_in == 89) ? ( 93 ) : 
     (idx_in == 90) ? ( 94 )
    ) : idx_in;
  );

function comboStrings(stridx, curitem)
  local(str)
  global()
  instance()
  (
    str = "";
    (stridx == 0) ?
    (
      ( curitem == 0 ) ? ( str = "OFF"
      ) : ( curitem == 1 ) ? ( str = "LP RC-C"
      ) : ( curitem == 2 ) ? ( str = "LP Diode Ladder"
      ) : ( curitem == 3 ) ? ( str = "VOWEL Vowel"
      ) : ( curitem == 4 ) ? ( str = "LP Karlsen Ladder III (303)"
      ) : ( curitem == 5 ) ? ( str = "LP Karlsen Ladder IIIs (303)"
      ) : ( curitem == 6 ) ? ( str = "LP Waveshaped (Dangerous)"
      ) : ( curitem == 7 ) ? ( str = "HP Waveshaped (Dangerous)"
      ) : ( curitem == 8 ) ? ( str = "BP Waveshaped (Dangerous)"
      ) : ( curitem == 9 ) ? ( str = "LP Expensive Moog (ZDF)"
      ) : ( curitem == 10 ) ? ( str = "LP Cheap Moog (unstable)"
      ) : ( curitem == 11 ) ? ( str = "NOTCH Notch"
      ) : ( curitem == 12 ) ? ( str = "LP Narsty"
      ) : ( curitem == 13 ) ? ( str = "MOD Modulator"
      ) : ( curitem == 14 ) ? ( str = "FB Phaser (OTA)"
      ) : ( curitem == 15 ) ? ( str = "FB Phaser (FET)"
      ) : ( curitem == 16 ) ? ( str = "FB Delay Feedbok"
      ) : ( curitem == 17 ) ? ( str = "FB Phase Mangler"      
      ) : ( curitem == 18 ) ? ( str = "LP Kr0g MS-20 linear (ZDF)"
      ) : ( curitem == 19 ) ? ( str = "BP Kr0g MS-20 linear (ZDF)"
      ) : ( curitem == 20 ) ? ( str = "HP Kr0g MS-20 linear (ZDF)"
      ) : ( curitem == 21 ) ? ( str = "LP Kr0g MS-20 NL (ZDF)" 
      ) : ( curitem == 22 ) ? ( str = "BP Kr0g MS-20 NL (ZDF)"
      ) : ( curitem == 23 ) ? ( str = "HP Kr0g MS-20 NL (ZDF)"
      ) : ( curitem == 24 ) ? ( str = "EXP Experimental (Dangerous)"
      ) : ( curitem == 25 ) ? ( str = "LP Rezzy (ZDF)"
      ) : ( curitem == 26 ) ? ( str = "LP SSM 2040 NL (ZDF)"
      ) : ( curitem == 27 ) ? ( str = "LP SSM 2040 NL (Approx)"      
      ) : ( curitem == 28 ) ? ( str = "LP CEM 3389 NL (ZDF)"      
      ) : ( curitem == 29 ) ? ( str = "LP SSM 2040 L (ZDF)"        
      ) : ( curitem == 30 ) ? ( str = "LP CEM 3389 L (ZDF)"
      ) : ( curitem == 31 ) ? ( str = "DIST Sine"
      ) : ( curitem == 32 ) ? ( str = "LP FM Feedback"  
      ) : ( curitem == 33 ) ? ( str = "LP Filter FM-ish 2" 
      ) : ( curitem == 34 ) ? ( str = "DIST Broken connection"
      ) : ( curitem == 35 ) ? ( str = "LP Broken feedback (ZDF)"
      ) : ( curitem == 36 ) ? ( str = "LP Waspey Linear (ZDF)"
      ) : ( curitem == 37 ) ? ( str = "LP Waspey Non-Linear (ZDF)"
      ) : ( curitem == 38 ) ? ( str = "BP Waspey Non-Linear (ZDF)"      
      ) : ( curitem == 39 ) ? ( str = "LP Linear SVF (ZDF)"
      ) : ( curitem == 40 ) ? ( str = "BP Linear SVF (ZDF)"
      ) : ( curitem == 41 ) ? ( str = "HP Linear SVF (ZDF)"
      ) : ( curitem == 42 ) ? ( str = "NOTCH Linear SVF (ZDF)"   
      ) : ( curitem == 43 ) ? ( str = "PEAK Linear SVF (ZDF)"    
      ) : ( curitem == 44 ) ? ( str = "LP Everything is a saw (ZDF)"     
      ) : ( curitem == 45 ) ? ( str = "LP SVF w/shaped res (ZDF)"
      ) : ( curitem == 46 ) ? ( str = "LP Voodoo"
      ) : ( curitem == 47 ) ? ( str = "LP Junk (ZDF)"  
      ) : ( curitem == 48 ) ? ( str = "FB Comb"    
      ) : ( curitem == 49 ) ? ( str = "LP Combed resonance (LP)"
      ) : ( curitem == 50 ) ? ( str = "BP Combed resonance (BP)"
      ) : ( curitem == 51 ) ? ( str = "LP Kr0g MS-20 NL ][ (ZDF)"
      ) : ( curitem == 52 ) ? ( str = "BP Kr0g MS-20 NL ][ (ZDF)"
      ) : ( curitem == 53 ) ? ( str = "HP Kr0g MS-20 NL ][ (ZDF)"
      ) : ( curitem == 54 ) ? ( str = "WAH Weeping Demon"
      ) : ( curitem == 55 ) ? ( str = "DIST PWM Potatoes LP"
      ) : ( curitem == 56 ) ? ( str = "DIST PWM Potatoes BP"
      ) : ( curitem == 57 ) ? ( str = "DIST Bit reduction"      
      ) : ( curitem == 58 ) ? ( str = "NOISE Muck (Noise)"     
      ) : ( curitem == 59 ) ? ( str = "WAH Weeping Demon ]["
      ) : ( curitem == 60 ) ? ( str = "WAH Crybaby"       
      ) : ( curitem == 61 ) ? ( str = "WAH Crybaby High" 
      ) : ( curitem == 62 ) ? ( str = "WAH Crybaby Low" 
      ) : ( curitem == 63 ) ? ( str = "VOWEL Vowel SVF (ZDF)"
      ) : ( curitem == 64 ) ? ( str = "DIST Monstro (ZDF)"
      ) : ( curitem == 65 ) ? ( str = "DIST King of Tone"
      ) : ( curitem == 66 ) ? ( str = "MOD Modulon (ZDF)"
      ) : ( curitem == 67 ) ? ( str = "PITCH Octaver (Down)"
      ) : ( curitem == 68 ) ? ( str = "PITCH Octaver (Up)"
      ) : ( curitem == 69 ) ? ( str = "MOD Metallic (Mod)"
      ) : ( curitem == 70 ) ? ( str = "MOD Frazzle (Mod)"
      ) : ( curitem == 71 ) ? ( str = "BP Phone"
      ) : ( curitem == 72 ) ? ( str = "MOD Tuned modulon (ZDF)"
      ) : ( curitem == 73 ) ? ( str = "MOD Modulatrix (ZDF)"
      ) : ( curitem == 74 ) ? ( str = "PITCH Vibrato"
      ) : ( curitem == 75 ) ? ( str = "PITCH Spin"
      ) : ( curitem == 76 ) ? ( str = "DIST Wavefolder"
      ) : ( curitem == 77 ) ? ( str = "DIST Multi-Wavefolder" 
      ) : ( curitem == 78 ) ? ( str = "DIST Serge Wavefolder"
      ) : ( curitem == 79 ) ? ( str = "VERB Metallic diffuser"
      ) : ( curitem == 80 ) ? ( str = "VERB Sproing"
      ) : ( curitem == 81 ) ? ( str = "VERB Worp"
      ) : ( curitem == 82 ) ? ( str = "DIST Crunch"
      ) : ( curitem == 83 ) ? ( str = "DYN Athena Exciter"
      ) : ( curitem == 84 ) ? ( str = "LP Resonant 1"
      ) : ( curitem == 85 ) ? ( str = "LP Resonant 2"
      ) : ( curitem == 86 ) ? ( str = "LP Resonant 3"
      ) : ( curitem == 87 ) ? ( str = "LP Resonant 4"
      ) : ( curitem == 88 ) ? ( str = "Harmonizer x2"
      ) : ( curitem == 89 ) ? ( str = "Harmonizer x4"
      ) : ( curitem == 90 ) ? ( str = "Harmonizer x1.5"
      ) : ( curitem == 91 ) ? ( str = "LP Moog (NL)"
      ) : ( curitem == 92 ) ? ( str = "BP Moog (NL)"
      ) : ( curitem == 93 ) ? ( str = "HP Moog (NL)"
      ) : ( curitem == 94 ) ? ( str = "Notch Moog (NL)"
      );
    ) : (stridx == 1) ? 
    (
      ( curitem == 0 ) ? ( str = "Stereo"
      ) : ( curitem == 1 ) ? ( str = "Mono double"
      ) : ( curitem == 2 ) ? ( str = "M1/S2"
      ) : ( curitem == 3 ) ? ( str = "M2/S1"
      ) : ( curitem == 4 ) ? ( str = "Only side"
      ) : ( curitem == 5 ) ? ( str = "Only mid"
      ) : ( curitem == 6 ) ? ( str = "Stereo Boost"
      ) : ( curitem == 7 ) ? ( str = "Stereoize"
      ) : ( curitem == 8 ) ? ( str = "Subtle Stereo"
      ) : ( curitem == 9 ) ? ( str = "Inverted"
      );
    ) : (stridx == 2) ?
    (
      ( curitem == 0 ) ? ( str = "OFF"
      ) : ( curitem == 1 ) ? ( str = "Cosine"
      ) : ( curitem == 2 ) ? ( str = "Sine"
      ) : ( curitem == 3 ) ? ( str = "Cos^2"
      ) : ( curitem == 4 ) ? ( str = "Sin^2"
      ) : ( curitem == 5 ) ? ( str = "Ramp up"
      ) : ( curitem == 6 ) ? ( str = "Ramp down"
      ) : ( curitem == 7 ) ? ( str = "Exponential"
      ) : ( curitem == 8 ) ? ( str = "Exp + Atk"
      ) : ( curitem == 9 ) ? ( str = "1-Exponential"
      ) : ( curitem == 10 ) ? ( str = "Random"
      ) : ( curitem == 11 ) ? ( str = "Random Exps"
      ) : ( curitem == 12 ) ? ( str = "Rand Exps + Atk"
      ) : ( curitem == 13 ) ? ( str = "Single Exp"
      ) : ( curitem == 14 ) ? ( str = "Single Exp + Atk"  
      ) : ( curitem == 15 ) ? ( str = "Sixteenth pulse"
      ) : ( curitem == 16 ) ? ( str = "Eighth pulse"
      ) : ( curitem == 17 ) ? ( str = "Quarter pulse"
      ) : ( curitem == 18 ) ? ( str = "Half pulse"
      ) : ( curitem == 19 ) ? ( str = "Triplet"
      ) : ( curitem == 20 ) ? ( str = "Sine Pulse"
      ) : ( curitem == 21 ) ? ( str = "Polyrhythm"
      ) : ( curitem == 22 ) ? ( str = "Polyrhythm ]["      
      ) : ( curitem == 23 ) ? ( str = "Polyrhythm ]|["
      ) : ( curitem == 24 ) ? ( str = "Triangle"
      ) : ( curitem == 25 ) ? ( str = "Two harmonics"
      ) : ( curitem == 26 ) ? ( str = "Three harmonics"
      )
    ) : (stridx == 3) ?
    (
      ( curitem == 0 ) ? ( str = "Serial Dual Dist"
      ) : ( curitem == 1 ) ? ( str = "Serial"
      ) : ( curitem == 2 ) ? ( str = "Parallel Dual Dist"
      ) : ( curitem == 3 ) ? ( str = "Parallel"
      ) : ( curitem == 4 ) ? ( str = "Morph Dual Dist"
      ) : ( curitem == 5 ) ? ( str = "Morph"
      );
    ) : (stridx == 4) ?
    (
      ( curitem == 0 ) ? ( str = "Spline"
      ) : ( curitem == 1 ) ? ( str = "Squashed Tanh"
      ) : ( curitem == 2 ) ? ( str = "Sq. Fast Tanh"
      ) : ( curitem == 3 ) ? ( str = "Off"
      ) : ( curitem == 4 ) ? ( str = "Sine"
      ) : ( curitem == 5 ) ? ( str = "Tanh"
      );
    );
    
    str;
  );
  
function modulator()
  global(srate)
  local()
  instance( invpi2, twopi, invsrate, reset, modvalue, scaled_modvalue, modrate, t, modmax, scale )
  (
    modvalue = 0;
    scaled_modvalue = 0;
    scale = 0;
    reset = 1;
    modmax = 1;
    invsrate = 1.0/srate;
    invpi2 = .5/$pi;
    twopi = 2*$pi;
  );
    
modulator.modulator();

function updateModRate(slidervalue)
  local(cTime, cRate)
  global(updatered, slider38, cTempo)
  instance( invsrate, reset, modvalue, scaled_modvalue, modrate, t )
  (
    ((slider38&2) == 0) ? (
      modrate = (1+2*slidervalue)^4 - 1;
    ) : (
      cTime = slidervalue;
      cRate = ( cTime < 0.0196078 ) ? 256
      : ( cTime < 0.0392157 ) ? 224
      : ( cTime < 0.0588235 ) ? 192
      : ( cTime < 0.0784314 ) ? 160
      : ( cTime < 0.0980392 ) ? 144
      : ( cTime < 0.117647 ) ? 128
      : ( cTime < 0.137255 ) ? 112
      : ( cTime < 0.156863 ) ? 96
      : ( cTime < 0.176471 ) ? 80
      : ( cTime < 0.196078 ) ? 64
      : ( cTime < 0.215686 ) ? 56
      : ( cTime < 0.235294 ) ? 48
      : ( cTime < 0.254902 ) ? 40
      : ( cTime < 0.27451 ) ? 32
      : ( cTime < 0.294118 ) ? 28
      : ( cTime < 0.313725 ) ? 24
      : ( cTime < 0.333333 ) ? 16
      : ( cTime < 0.352941 ) ? 8
      : ( cTime < 0.372549 ) ? 7
      : ( cTime < 0.392157 ) ? 6
      : ( cTime < 0.411765 ) ? 5.33333
      : ( cTime < 0.431373 ) ? 5
      : ( cTime < 0.45098 ) ? 4
      : ( cTime < 0.470588 ) ? 3
      : ( cTime < 0.485196 ) ? 2.66667
      : ( cTime < 0.495196 ) ? 2
      : ( cTime < 0.509804 ) ? 1.33333
      : ( cTime < 0.529412 ) ? 1.16667
      : ( cTime < 0.54902 ) ? 1
      : ( cTime < 0.568627 ) ? 0.9375
      : ( cTime < 0.588235 ) ? 0.875
      : ( cTime < 0.607843 ) ? 0.833333
      : ( cTime < 0.627451 ) ? 0.8125
      : ( cTime < 0.647059 ) ? 0.75
      : ( cTime < 0.666667 ) ? 0.6875
      : ( cTime < 0.686275 ) ? 0.666667
      : ( cTime < 0.705882 ) ? 0.625
      : ( cTime < 0.72549 ) ? 0.5625
      : ( cTime < 0.745098 ) ? 0.5
      : ( cTime < 0.764706 ) ? 0.4375
      : ( cTime < 0.784314 ) ? 0.375
      : ( cTime < 0.803922 ) ? 0.333333
      : ( cTime < 0.823529 ) ? 0.3125
      : ( cTime < 0.843137 ) ? 0.25
      : ( cTime < 0.862745 ) ? 0.1875
      : ( cTime < 0.882353 ) ? 0.166667
      : ( cTime < 0.901961 ) ? 0.125
      : ( cTime < 0.921569 ) ? 0.0833333
      : ( cTime < 0.941176 ) ? 0.0625
      : ( cTime < 0.960784 ) ? 0.0416667
      : ( cTime < 0.980392 ) ? 0.03125
      : 0.015625;
      
      modrate = .25 * (cTempo/60) / cRate;
  );  
);

function updateScale(value)
  instance(scale)
  global()
  local()
  (
    scale = value;
  );

function getScale()
  instance(scale)
  global()
  local()
  (
    scale
  );

function updateModulator(alpha)
  instance( invpi2, twopi, invsrate, reset, modvalue, scaled_modvalue, modrate, t, lastt, lastrand, scale )
  global( slider38, slider36, modulatorDynamics, newmod )
  local(ct, st)
  (
    slider36 > 0 ? (
      modulatorDynamics = 1;
      
      t = t + modrate*invsrate;
      (slider38 & 1) && reset == 1 ? ( t = 0; reset = 0; lastt = -1; );

      newmod = slider36 == 1 ? .5 + .5 * cos(twopi*t)
      : ( slider36==2 )  ? .5 + .5 * sin(twopi*t)
      : ( slider36==3 )  ? ( ct = cos($pi*t); ct*ct )
      : ( slider36==4 )  ? ( st = sin($pi*t); st*st )
      : ( slider36==5 )  ? ( t-floor(t) )
      : ( slider36==6 )  ? ( 1-t+floor(t) )
      : ( slider36==7 )  ? ( exp(-4*(t-floor(t))) )
      : ( slider36==8 )  ? ( min((15*(t-floor(t))),1)*exp(-4*(t-floor(t))) )
      : ( slider36==9 )  ? ( 1-exp(-4*(t-floor(t))) )
      : ( slider36==10 ) ? ( ( t > (lastt+1) ) ? ( lastt = lastt+1; lastrand=rand() ); lastrand )
      : ( slider36==11 ) ? ( ( t > (lastt+1) ) ? ( lastt = lastt+1; lastrand=rand() ); exp(-4*lastrand*(t-floor(t))) )
      : ( slider36==12 ) ? ( ( t > (lastt+1) ) ? ( lastt = lastt+1; lastrand=rand() ); min((15*(.2+.8*lastrand)*(t-floor(t))),1)*exp(-4*lastrand*(t-floor(t))) )
      : ( slider36==13 ) ? ( exp(-t) )    
      : ( slider36==14 ) ? ( min((15*t),1)*exp(-t) )
      : ( slider36==15 ) ? ( (t-floor(t)) < .0625 )
      : ( slider36==16 ) ? ( (t-floor(t)) < .125 )
      : ( slider36==17 ) ? ( (t-floor(t)) < .25 )
      : ( slider36==18 ) ? ( (t-floor(t)) < .5 )
      : ( slider36==19 ) ? ( (3*t-floor(3*t)) < .5 )
      : ( slider36==20 ) ? ( ((8*t-floor(8*t)) < .5) * (.5 + .5*cos(twopi*t)) )
      : ( slider36==21 ) ? ( ((4*t-floor(4*t)) < .25) * (.5 + .5*cos(twopi*t)) * .5 + .5 * ((3*t-floor(3*t)) > .25) * (.5 + .5*sin(twopi*t)) )
      : ( slider36==22 ) ? ( ((8*t-floor(8*t)) < .25) * (.5 + .5*cos(twopi*t)) * .5 + .5 * ((6*t-floor(6*t)) > .25) * (.5 + .5*sin(twopi*t)) )
      : ( slider36==23 ) ? ( ((8*t-floor(8*t)) < .5) * .5 + .5 * ((3*t-floor(6*t)) < .5) * (.5+.5*sin(twopi*t)) )
      : ( slider36==24 ) ? ( 1-2*abs(t-floor(t)-0.5) )
      : ( slider36==25 ) ? ( sin(twopi*t)*.3+.5 + sin(2*twopi*t)*.2 )
      : ( slider36==26 ) ? ( sin(twopi*t)*.2+.5 + sin(2*twopi*t)*.2 + sin(4*twopi*t)*.1 );

      slider38 & 4 ? newmod -= .5;     
      modvalue = modvalue*alpha + (1-alpha) * newmod;
      scaled_modvalue = modvalue * scale;
      
    ) : ( modvalue = 0; scaled_modvalue = 0; modulatorDynamics = 0; );
  );

function getvalue( tval )
  instance( t, modvalue )
  global(slider38, slider35)
  local()
  (
    t = tval;
    
    this.updateModulator(slider35 & 16 == 16 ? 0.7 : 0);
    modvalue + (slider38 & 4 ? .5 : 0)
  );
  
function create_mod_window(_x, _y, _w, _h, _r, _g, _b, _a)
  instance(x, y, w, h, mod, r, g, b, a)
  local()
  global()
  (
    mod.modulator();
    x = _x;
    y = _y+1;
    w = _w;
    h = _h-2;
    r = _r;
    g = _g;
    b = _b;
    a = _a;
  );
  
function draw_modulator()
  instance(x, y, w, h, mod, r, g, b, a)
  local(dx, t, lx, ly, nx, ny)
  global()
  (
    gfx_set( 0, 0, 0, .1 );
    gfx_rect( x, y, w, h );
        
    gfx_set( r, g, b, a*.8 );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    
    gfx_set( r, g, b, a );
    dx = .5/w;
    lx = x;
    ly = 0.5 * h + y;
    t = 0;
    loop(2*w,
      ny = y + h - h*mod.getValue(t);
      nx = lx + .5;
      
      gfx_line( lx, ly, nx, ny );
      
      lx = nx;
      ly = ny;
      t = t + dx;
    );
  );

function gfx_wrapprint(str, maxlen)
  global(gfx_x, gfx_y)
  local(mp, len, str, lastLineStart, lastWordStart, cpos, tmp, mx, my, xref, yref)
  (
    xref = gfx_x;
    yref = gfx_y;
    len = strlen(str);
    lastLineStart = 0;
    lastWordStart = 0;
    cpos = 0;
    tmp = 1;
    mp = 0;
    loop(len + 1,
      // Found end of a word!
      ( str_getchar(str, cpos) == 32 || cpos == len ) ? (
        // Is the current line too long?
        gfx_measurestr( strcpy_substr( tmp, str, lastLineStart, cpos-lastLineStart ), mx, my );
        ( mx > maxlen ) ? (
          strcpy_substr( tmp, str, lastLineStart+mp, lastWordStart - lastLineStart );
          gfx_printf( tmp );
          // Yeah, terminate here
          lastLineStart = lastWordStart;
          gfx_x = xref;
          gfx_y += my;
          mp = 1;
        ) : (
          // Nope keep going
          lastWordStart = cpos;
        );
      );
      
      cpos += 1;
    );
    
    strcpy_substr(tmp, str, lastLineStart+mp, cpos - lastLineStart);
    gfx_printf(tmp)
  );

function filterDescription(filteridx, fx, wx, yloc)
global(gfx_x, gfx_y, slider47, wndX, wndY, wndPad, retina_scaling, fontface
      filter_description_r, filter_description_g, filter_description_b, filter_description_a)
local(fx, fy, wx, wx2, wy)
(
  wx2 = wx - 5;
  gfx_x = fx+5;
  gfx_y = yloc;

  gfx_set(filter_description_r, filter_description_g, filter_description_b, filter_description_a);

  gfx_setfont(5, fontface, 12*retina_scaling);
  ( filteridx == 0 ) ? (
    gfx_printf("OFF")
  ) : ( filteridx == 1 ) ? (
    gfx_printf("LP RC-C\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Simple state space filter. This filter does not use internal waveshaping and the output of the filter is waveshaped instead.", wx2);
  ) : ( filteridx == 2 ) ? (  
    gfx_printf("LP Diode Ladder\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter was based on a model by Dominique Wurtz which modelled the 303 diode ladder. The only modification is that rather than input clipping, the waveshaper is used.", wx2);
  ) : ( filteridx == 3 ) ? (
    gfx_printf("Vowel filter\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter uses 3 band pass filters to imitate vowel sounds.", wx2);
  ) : ( filteridx == 4 ) ? (  
    gfx_printf("LP Karlsen Fast Ladder III\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on a 303 diode ladder. The filter uses the waveshaper as non/ideal part rather than just clipping. Note that this filter doesn't completely maintain its tone when using different levels of supersampling.", wx2);
  ) : ( filteridx == 5 ) ? (  
    gfx_printf("LP Karlsen Fast Ladder III (sat)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter combines the 303 diode ladder filter with a fixed shelf filter. The filter uses the waveshaper as non/ideal part rather than just clipping. Note that this filter doesn't completely maintain its tone when using different levels of supersampling.", wx2);
  ) : ( filteridx == 6 ) ? (  
    gfx_printf("Waveshaped Resonance (LP) (dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter consists of two first order low-pass filters. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. This filter can get very mean depending on the waveshaping curve. Be careful! Note that this filter forces oversampling to be at least 2x.", wx2);
  ) : ( filteridx == 7 ) ? (  
    gfx_printf("Waveshaped Resonance (HP) (dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a waveshaped highpass filter. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. Stability can be enhanced by oversampling. Note that this filter forces oversampling to be at least 2x.", wx2);
  ) : ( filteridx == 8 ) ? (
    gfx_printf("Waveshaped Resonance (BP) (dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a waveshaped bandpass filter. Sort of. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. Stability can be enhanced by oversampling. Note that this filter forces oversampling to be at least 2x.", wx2);
  ) : ( filteridx == 9 ) ? (
    gfx_printf("Model of a Moog filter (risky)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on the paper Modeling and measuring a Moog voltage-controlled filter by Paschou et al. This filter requires 2x upsampling to remain stable. This version is more stable than the cheap version, but still be careful. High gain with high resonance can be problematic.", wx2);
  ) : ( filteridx == 10 ) ? (
    gfx_printf("Approximate Moog filter (dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Based on the paper Modeling and measuring a Moog voltage-controlled filter by Paschou et al. Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will bring in higher quality as the non-linearity makes it sensitive to aliasing problems. This version does not correctly compute the Jacobian. Be careful though!", wx2);
  ) : ( filteridx == 11 ) ? (
    gfx_printf("Basic notch filter\n\n"); gfx_x = fx+5;
  ) : ( filteridx == 12 ) ? (
    gfx_printf("Narsty (dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Saike's make things nasty filter. Combination of 3 filters with varying interacting resonances. No guarantees that this thing wont blow up in your face. Exclusively meant for basses. Note that this one does not maintain its character when changing the sampling rate.", wx2);
  ) : ( filteridx == 13 ) ? (
    gfx_printf("Modulator\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Passes a lowpassed version of the signal and modulates it with the signal itself. Second bandpass filtered version is added to provide the resonance peak. This filter is meant for sounds with limited high frequency content as it will sound awful with rich sounds.\n", wx2);
  ) : ( filteridx == 14 ) ? (
    gfx_printf("Phaser (risky)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("4 pass phaser based on operational transconductance amplifiers. Note that this one frequently has problem with spline voltage curves.", wx2);
  ) : ( filteridx == 15 ) ? (
    gfx_printf("Phaser based on FET (risky)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("4 pass phaser based on Field Effect Transistor elements.", wx2);
  ) : ( filteridx == 16 ) ? (
    gfx_printf("Phaser-like\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Non-linear phaser like filter with relatively long delays and distortion of difference signal.", wx2);
  ) : ( filteridx == 17 ) ? (
    gfx_printf("Phase mangler\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Magic??? I honestly forgot what the idea was behind this one.", wx2);
  ) : ( filteridx == 18 ) ? (
    gfx_printf("MS-20 linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);
  ) : ( filteridx == 19 ) ? (
    gfx_printf("MS-20 linear BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);
  ) : ( filteridx == 20 ) ? (
    gfx_printf("MS-20 linear HP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);        
  ) : ( filteridx == 21 ) ? (
    gfx_printf("MS-20 non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);
  ) : ( filteridx == 22 ) ? (
    gfx_printf("MS-20 non-linear BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);
  ) : ( filteridx == 23 ) ? (
    gfx_printf("MS-20 non-linear HP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);                
  ) : ( filteridx == 24 ) ? (
    gfx_printf("Multiphase (very dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Experimental thingamabob. Bits of phaser, bits of a saturating lowpass, some distortion gibberish and some ugly ass feedback. Be careful with this thing. Especially when you're combining it with a waveshaper. It has plenty of bite. P.S. It self-oscillates too. ;_;", wx2);
  ) : ( filteridx == 25 ) ? (
    gfx_printf("Rezzy\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Honestly, I forgot what this one represents really. It came around after an afternoon of screwing around with the feedback mechanism in the MS-20. It can sound quite bitey, which I like.", wx2);
  ) : ( filteridx == 26 ) ? (
    gfx_printf("4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback 4-pole SSM2040 emulation with non-linearity (tanh) in the model. The waveshaper is applied to the output and can be used to tame the output.", wx2);
  ) : ( filteridx == 27 ) ? (
    gfx_printf("Cheaper 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback 4-pole SSM2040 emulation with non-linearity (cheap tanh) in the model. The waveshaper is applied to the output and can be used to tame the output.", wx2);
  ) : ( filteridx == 28 ) ? (
    gfx_printf("4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback 4-pole CEM 3389 emulation with non-linearity (tanh) in the model. The waveshaper is applied to the output and can be used to tame the output.", wx2);
  ) : ( filteridx == 29 ) ? (
    gfx_printf("Linearized 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Linearized zero delay feedback 4-pole SSM2040 emulation. The waveshaper is applied to the output and can be used to tame the output. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);    
  ) : ( filteridx == 30 ) ? (
    gfx_printf("Linearized 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Linearized zero delay feedback 4-pole CEM 3389 emulation. The waveshaper is applied to the output and can be used to tame the output. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);        
  ) : ( filteridx == 31 ) ? (
    gfx_printf("Sine\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Take the sine of the signal. Cutoff controls frequency, resonance controls mix. Simple, but surprisingly satisfying. Use on basses, not high frequency content.", wx2); 
  ) : ( filteridx == 32 ) ? (
    gfx_printf("FM feedback\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Non-linear MS-20 but with the feedback signal FM modulated. I've had lucky sweet spots with this thing, but it's horrible. Most of the times it'll just sound horrendous.", wx2);     
  ) : ( filteridx == 33 ) ? (
    gfx_printf("FM MS-20\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter uses the input signal as modulation source for the cutoff of an MS-20 linear which then modifies the input signal. Huh?", wx2);    
  ) : ( filteridx == 34 ) ? (
    gfx_printf("Broken Connection\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Messy filter. Be careful with this one. It was actually sort of an accident, but it seems pretty stable and pretty unique. It is not invariant under oversampling particularly in the low frequency regions where it likes to lead a life of its own. It's based on the kr0g filter, but including a voltage inversion step in the feedback path (low to high, high to low, not just polarity switch).", wx2);    
  ) : ( filteridx == 35 ) ? (
    gfx_printf("Borked Waspey feedback (risky)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Circuit bended version of the non-linear WASP, makes for growly resonance, but be careful, is not unconditionally stable!.", wx2);
  ) : ( filteridx == 36 ) ? (
    gfx_printf("Wasp emulation (linearized)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Linearized approximation of the wasp filter.", wx2);
  ) : ( filteridx == 37 ) ? (
    gfx_printf("Wasp emulation LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Approximation of the wasp filter.", wx2);
  ) : ( filteridx == 38 ) ? (
    gfx_printf("Wasp emulation BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Approximation of the wasp filter.", wx2);    
  ) : ( filteridx == 39 ) ? (
    gfx_printf("SVF Lowpass filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( filteridx == 40 ) ? (
    gfx_printf("SVF Bandpass filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( filteridx == 41 ) ? (
    gfx_printf("SVF Highpass filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( filteridx == 42 ) ? (
    gfx_printf("SVF Notch filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( filteridx == 43 ) ? (
    gfx_printf("SVF Peak (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( filteridx == 44 ) ? (
    gfx_printf("Everything is a saw (dangerous)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Weird filter that tends to convert most things to saws. Based on biasing the wasp emulation severely. It can work pretty nicely with basses and high resonance, but be careful, it is pretty unpredictable.", wx2);  
  ) : ( filteridx == 45 ) ? (
    gfx_printf("SVF with waveshaped resonance (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("ZDF filter that lowpasses the signal twice. Once with and once without resonance. Subsequently it waveshapes the version with resonance minus the version without and adds the waveshaped resonance to the no resonance lowpass mix.", wx2);  
  ) : ( filteridx == 46 ) ? (
    gfx_printf("Voodoo\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This one is a meanie. It filters the signal with and without resonance, computes the difference, amplifies it, sa  turates it and then adds it to a moving average that gets added to the signal. The result is then waveshaped. Yum.", wx2);  
  ) : ( filteridx == 47 ) ? (
    gfx_printf("Junk (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This one is fickle. It filters the signal with and without resonance, computes the difference, amplifies it, saturates it and then adds it back to the signal. The result is then waveshaped. Yum.", wx2);
  ) : ( filteridx == 48 ) ? (
    gfx_printf("Comb\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Basic comb filter. Set resonance one to have alternating notches between left and right (wide) or zero for mono phasing. Waveshaper is applied before the comb.", wx2);
  ) : ( filteridx == 49 ) ? (
    gfx_printf("Combed resonance (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Signal is lowpassed twice with and without resonance. Resonance is lifted by differencing the signal, this resonance is amplified, saturated and mixed with a delayed copy of itself before being added to the signal. Waveshaper is applied after the filter.", wx2);
  ) : ( filteridx == 50 ) ? (
    gfx_printf("Combed BP (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Signal is BP passed twice with and without resonance. Resonance is lifted by differencing the signal, this resonance is mixed with a delayed copy of itself before being added to the signal. Waveshaper is applied after the filter. Not nearly as fun as the lowpassed version (previous).", wx2);
  ) : ( filteridx == 51 ) ? (
    gfx_printf("MS-20 non-linear LP MK ][\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity (tanh). This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);
  ) : ( filteridx == 52 ) ? (
    gfx_printf("MS-20 non-linear BP MK ][\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity (tanh). This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);
  ) : ( filteridx == 53 ) ? (
    gfx_printf("MS-20 non-linear HP MK ][\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity (tanh). This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2); 
  ) : ( filteridx == 54 ) ? ( 
    gfx_printf("Weeping\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a model of the weeping demon wah pedal, originally modelled by Chet Gnegy and used with permission. Cutoff controls the wah level. Cutoff controls the pre-highpass.", wx2);
  ) : ( filteridx == 55 ) ? ( 
    gfx_printf("PWM Potatoes LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Emulation of PWM modulation. Can be used to make scrunchy sounds. Cutoff controls cutoff of the post-PWM filter, resonance controls the oversampling of the pulse generator.", wx2);
  ) : ( filteridx == 56 ) ? ( 
    gfx_printf("PWM Potatoes BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Emulation of PWM modulation. Can be used to make scrunchy sounds. Cutoff controls cutoff of the post-PWM filter, resonance controls the oversampling of the pulse generator.", wx2);
  ) : ( filteridx == 57 ) ? (
    gfx_printf("Bit reduction\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Bitdepth reduction. Cutoff slider reduces the bitdepth. A filter is run before the bitcrusher which splits off the bass, to add it back later after the bitcrusher. Setting the resonance to zero disables this filter. Note: This thing sounds nice paired with some tanh distortion.", wx2);  
  ) : ( filteridx == 58 ) ? (
    gfx_printf("Muck\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Just adds a tiny bit of multiplicative noise. Only audible on pure tones.", wx2);  
  ) : ( filteridx == 59 ) ? (
    gfx_printf("Weeping Demon Mode II\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a model of the weeping demon wah pedal, originally modelled by Chet Gnegy and used with permission. Cutoff controls the wah level. Cutoff controls the pre-highpass. Prone to high resonance peaks.", wx2);
  ) : ( filteridx == 60 ) ? (
    gfx_printf("Crybaby emulation\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Emulation of a wah-wah filter based on a paper by M. Holters, this one took quite some doing to get to work. It's heavy on the CPU, but sounds pretty authentic.", wx2);
  ) : ( filteridx == 61 ) ? (
    gfx_printf("Modified Crybaby emulation\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Emulation of a wah-wah filter based on a paper by M. Holters, this one took quite some doing to get to work. It's heavy on the CPU, but sounds pretty authentic.", wx2);
  ) : ( filteridx == 62 ) ? (
    gfx_printf("Modified Crybaby emulation\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Emulation of a wah-wah filter based on a paper by M. Holters, this one took quite some doing to get to work. It's heavy on the CPU, but sounds pretty authentic.", wx2);
  ) : ( filteridx == 63 ) ? (
    gfx_printf("Vowel filter SVF");
  ) : ( filteridx == 64 ) ? (
    gfx_printf("Monstro (vowel madness)");
  ) : ( filteridx == 65 ) ? (
    gfx_printf("King of Tone Pedal (risky)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Modelled after the King of Tone pedal. Warning: This one doesn't respond nicely to live updating the resonance parameter without interia or very sharp gain transitions. It can produce clicks in such scenarios.", wx2);
  ) : ( filteridx == 66 ) ? (
    gfx_printf("Modulon\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Modulon works by modulating the signal with a set frequency and filtering the result.", wx2);
  ) : ( filteridx == 67 ) ? (
    gfx_printf("Octaver (Down)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This chunky monkey can be used to add deep bass. Recommended for monophonic sounds. Octaver adds bass one and two octaves down. Cutoff transitions between dry and wet. Resonance switches between using octave 1 and 2. Note that this effect is best applied only on the mid channel (left and right can easily go out of phase resulting in cluttered stereo image).", wx2);
  ) : ( filteridx == 68 ) ? (
    gfx_printf("Octaver (Up)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This chunky monkey can be used to add some harmonics. Recommended for monophonic sounds only. This effect adds bass one and two octaves down. Cutoff transitions between dry and wet, while resonance switches between using octave 1 and octave 2.", wx2);
  ) : ( filteridx == 69 ) ? (
    gfx_printf("Metallic\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Odd combination of FM and ring mod. Highly recommend running this thing over pure tones only (sines, tris and such).", wx2);
  ) : ( filteridx == 70 ) ? (
    gfx_printf("Frazzle\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Odd combination of FM and ring mod.", wx2);
  ) : ( filteridx == 71 ) ? (
    gfx_printf("Phone\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Cutoff regulates the level of non-linearity. Resonance regulates the downsampling. Note that this filter only works properly for no oversampling and x2 oversampling.", wx2);
  ) : ( filteridx == 72 ) ? (
    gfx_printf("Modulon (tuned)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Modulon works by modulating the signal with a set frequency and filtering the result. Considering that this filter is based on ring modulation, tuning is important. It is also recommended to use this filter in combination with keytracking.", wx2);
  ) : ( filteridx == 73 ) ? (
    gfx_printf("Modulatrix (tuned)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Modulatrix works by modulating the signal with a set frequency and filtering the result. Considering that this filter is based on ring modulation, tuning is important. It is also recommended to use this filter in combination with keytracking.", wx2);
  ) : ( filteridx == 74 ) ? (
    gfx_printf("Vibrato\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Simple vibrato effect.", wx2);
  ) : ( filteridx == 75 ) ? (
    gfx_printf("Emulation of a spinning sound source\n\n"); gfx_x = fx+5;
    gfx_wrapprint("", wx2);
  ) : ( filteridx == 76 ) ? (
    gfx_printf("Wavefolder\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Lockhart wavefolder based on a model by Esqueda et al (2017). Cutoff controls strength, resonance controls bias. Note that these are very sensitive to input gain.", wx2);
  ) : ( filteridx == 77 ) ? (
    gfx_printf("Multi-wavefolder\n\n"); gfx_x = fx+5;
    gfx_wrapprint("A stack of lockhart wavefolders based on a model by Esqueda et al (2017). Cutoff controls strength, resonance controls bias. Note that these are very sensitive to input gain.", wx2);
  ) : ( filteridx == 78 ) ? (
    gfx_printf("Serge wavefolder\n\n"); gfx_x = fx+5;
    gfx_wrapprint("A stack of lockhart wavefolders based on a model by Esqueda et al (2017). Cutoff controls strength, resonance controls bias. Note that these are very sensitive to input gain.", wx2);
  ) : ( filteridx == 79 ) ? (
    gfx_printf("Metallic diffuser\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Allpass-based reverb. Resonance around 0.5 is typically reverb level. Higher resonances lead to stranger soundscapes, with a sudden behavior shift around 0.9. Cutoff increases internal delays. Low cutoffs lead to metallic sounds. High cutoffs to more natural delay-type sounds.", wx2);  
  ) : ( filteridx == 80 ) ? (
    gfx_printf("Sproing\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Allpass-based stuttering sproing reverb.", wx2);  
  ) : ( filteridx == 81 ) ? (
    gfx_printf("Worp\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Allpass-based reverb. For a lot of drama, add a *tiny* bit of LFO modulation to the cutoff (size) parameter of this one.", wx2);  
  ) : ( filteridx == 82 ) ? (
    gfx_printf("Crunch\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Lowpasses the signal to isolate fundamentals. Distorts lowpassed signal, then highpasses this distorted signal and runs the right channel through a very short delay (widening). The result is fed back into the HP side to get a comb effect over the distortion. Cutoff controls frequency of the HP signal, while resonance controls the gain (more crunch).", wx2);  
  ) : ( filteridx == 83 ) ? (
    gfx_printf("Athena\n\n"); gfx_x = fx+5;
    gfx_wrapprint("A subtle exciter. Cutoff dials in the effect, resonance manipulates the dynamics. Athena compresses the signal, and then multiplies the compressed signal with a half-wave rectified copy of its middle band to add extra harmonics to the attack of the signal. While subtle, this can liven up dull synths and drums.", wx2);  
  ) : ( filteridx == 84 ) ? (
    gfx_printf("Resonant 1\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Playing around with resonance modification.", wx2);  
  ) : ( filteridx == 85 ) ? (
    gfx_printf("Resonant 2\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Playing around with resonance modification", wx2);  
  ) : ( filteridx == 86 ) ? (
    gfx_printf("Resonant 3\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Playing around with resonance modification.", wx2);  
  ) : ( filteridx == 87 ) ? (
    gfx_printf("Resonant 4\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Playing around with resonance modification", wx2);  
  ) : ( filteridx == 88 || filteridx == 89 || filteridx == 90 ) ? (
    gfx_printf("Harmonizer\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Adds parallel bandpasses at multiples of base frequency. Good for making shephards tones.", wx2);  
  ) : ( filteridx == 91 || filteridx == 92 || filteridx == 93 || filteridx == 94 ) ? (
     gfx_printf("Emulation of the moog.\n\n"); gfx_x = fx+5;
     gfx_wrapprint("A more efficient emulation of the moog filter.\nNote: The cutoff is clamped unless sufficient oversampling is used.\n.", wx2);  
  );
);

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr        = scopebuffer_in;
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );
  
function getBuffer()
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[];
  );
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer)
  (
    readptr = scopeptr;
    readptr -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
  
function readBuffer()
  local(c)
  global()
  instance(readptr, scopebuffermax, scopebuffer)
  (
    c = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c
  );
  
function readBufferFrac(frac)
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    c2 * (1.0-frac) + c1 * frac
    
    // Allpass interp
    //c1 = c1 + (1.0-frac) * c2 - ( 1.0 - frac ) * ls;
    //ls = c1;
  );

function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );  
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    memset( scopebuffer, 0, MAXBUFFERSIZE );
    /*scopeptr = scopebuffer;
    //loop(scopebuffermax - scopebuffer + 1,
    loop(MAXBUFFERSIZE,
      scopeptr[] = 0;
      scopeptr += 1;
    );*/
    
    scopeptr = scopebuffer;
  );

function initBufferNoReset(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );

function tanh(s)
local(c)
global()
instance()
(
  c = exp(8*s);
  s = 0.25*(c - 1) / (c + 1);
);

function actual_tanh(x)
local(em2x)
global()
instance()
(
/*  x2 = x*x;
  x3 = x*x*x;
  em2x = x + 0.16489087 * x3 + 0.00985468 * x2*x3;
  em2x * invsqrt(1 + em2x * em2x)*/
  
  em2x = exp(-2*x);
  (2/(1+em2x))-1
);

function speedy_tanh(x)
local(x2, x3, em2x)
global()
instance()
(
  x2 = x*x;
  x3 = x2*x;
  em2x = x + 0.16489087 * x3 + 0.00985468 * x2*x3;
  em2x * invsqrt(1 + em2x * em2x)
);

function fasttanh(x)
local()
global()
instance()
(
  x = x / (1 + abs(2*x));
  /*( x < -3 ) ? (
      x = -1;
  ) : ( x > 3 ) ? (
      x = 1;
  ) : ( 
      x = x * ( 27 + x * x ) / ( 27 + 9 * x * x );
    )*/
 // x = (-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*x)*x)*x)/(.2464845986383725+(.0609347197060491+(.1086202599228572+.02874707922475963*x)*x)*x);
);

/* Frequency slider transformation. Abstracted away in order to be able to ensure legacy axes. */
function f_trafo_hz(freq)
  local()
  global(slider54, legacyCutoff)
  instance()
  (
    legacyCutoff ? (
      ( pow(10, freq) - 1 ) / 9
    ) : (
      //exp( log(20/22050) + freq*(log(1) - log(20/22050)) )
      exp( (1-freq) * log(20/22050) )
    );
  );

function f_trafo(freq)
  local()
  global(slider54, legacyCutoff)
  instance()
  (
    legacyCutoff ? (
      (pow(10, freq)-1)/9 * $pi / (max(1,slider54));
    ) : (
      //exp( log(20/22050) + freq*(log(1) - log(20/22050)) ) * $pi / (max(1,slider54));
      exp( (1-freq) * log(20/22050) ) * $pi / (max(1,slider54));
    )
  );

//----------------------------------------------
// Filter initialization section
//----------------------------------------------
function initRC(freq, q)
  instance(len, v0, v1, a1, c)
  local(r)
  global(srate, slider54)
  (
    c = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    r = pow(0.5, (q*128+24) / 16.0);
    a1 = (1.0-r*c);   
  );

function init303(freq, q)
  local(dwc, dwc2, dwc3, qwc2, qwc3)
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    // This specific filter came from
    // Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
    wc  = .25 * f_trafo(freq);
    wc2 = wc*wc;
    wc3 = wc2*wc;
    wc4 = wc3*wc;
    b   = 1 / ( 1 + 8*wc + 20*wc2 + 16*wc3 + 2*wc4);
    g   = 2 * wc4 * b;
    
    k   = 20*q;
    A   = 1 + 0.5 * k;
    
    dwc = 2*wc;
    dwc2 = 2*wc2;
    qwc2 = 4*wc2;
    dwc3 = 2*wc3;
    qwc3 = 4*wc3;
    
    b0 = dwc+12*wc2+20*wc3+8*wc4;
    a0 = 1+6*wc+10*wc2+qwc3;
    a1 = dwc+8*wc2+6*wc3;
    a2 = dwc2+wc3;
    a3 = dwc3;
    
    b10 = dwc2+8*wc3+6*wc4;
    a10 = wc+4*wc2+3*wc3;
    a11 = 1+6*wc+11*wc2+6*wc3;
    a12 = wc+qwc2+qwc3;
    a13 = wc2+dwc3;
    
    b20 = dwc3+4*wc4;
    a20 = a13;
    a21 = wc+qwc2+4*wc3;
    a22 = 1+6*wc+10*wc2+qwc3;
    a23 = wc+qwc2+dwc3;
    
    c2  = a21 - a3;
    c3  = 1+6*wc+9*wc2+dwc3;
  ); 
  
function reset303()
  local(Kbig)
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    z1 = z2 = z3 = 0;
    y1 = y2 = y3 = y4 = 0;
  );

function initmoog(freq, q)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    cutoff = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    res = .1 * q;
    
    f  = (cutoff+cutoff);
    p  = f*(1.8-0.8*f);
    k  = 2.0 * sin(cutoff * $pi * 0.5) - 1.0;
    
    t  = (1.-p)*1.386249;
    t2 = 12.+t*t;
    r  = res*(t2+6.*t)/(t2-6.*t);
  );

function resetmoog()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    oldy1=oldy2=oldy3=y1=y2=y3=y4=oldx=0;
  );

// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = 0;
  );   
  
// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen_sat(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen_sat()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = b_lfcut = b_lf = b_lf1hp = b_lfhp = b_lfgain = 0;
  );  

function initdualfilt(freq, res)
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    f = f_trafo(freq);
    q = res;
    
    //set feedback amount given f and q between 0 and 1
    fb = q + q/(1.0 - f);
    fb = max(0, min(4, fb));
  );
  
function resetdualfilt()
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    d0 = d1 = 0.0000001;
  );
  
function initfancymoog(freq, q)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3, VT, fs                   
        )
  global(srate, slider54, tmp)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, ftarget)
  (
    fs      = max(slider54,1) * srate;
    //ftarget = 24*(pow(10, freq)-1)/9; //24    
    
    // TODO
    ftarget   = .5*(srate/1000)*f_trafo_hz(freq);
    //ftarget = 6*freq;
    VT      = 26/1000;
    A       = 0.5 * VT;
    hA      = 0.5 * A;
    T       = 1.0/fs;
    wc      = 4*$pi*ftarget*srate;
    wcT     = wc*T;
    g       = wcT*hA;
    k       = 1.1*q*4; // [0..4]
  );

function resetfancymoog()
  local()
  global()
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    y0 = y1 = y2 = y3 = y4 = d0 = d1 = d2 = d3 = d4 = 0;
  );
  
function capIt(sl, agcpre)
  local(thr)
  global()
  instance()
  (
    thr = 1.5*agcpre;
    (sl > thr) ? (
      thr + actual_tanh(sl - thr);
      //sl
    ) : ( sl < -thr ) ? (
      -thr + actual_tanh(sl + thr);
      //sl;
    ) : sl;
  );  
  
function bootvowel()
  instance()
  local(c, ptr)
  global(vowel_src, vowel_A, vowel_E, vowel_I, vowel_O, vowel_U, vowel_EE)
  (
    c = vowel_src;
    c[0] = vowel_A;
    c[1] = vowel_E;
    c[2] = vowel_I;
    c[3] = vowel_O;
    c[4] = vowel_U;
    c[5] = vowel_EE;
    
    // 34 39 57
    ptr = vowel_A;
    ptr[] = 660;        ptr += 1;
    ptr[] = 1700;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-15/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr = vowel_E;
    ptr[] = 530;        ptr += 1;
    ptr[] = 1850;       ptr += 1;
    ptr[] = 2500;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_I;
    ptr[] = 400;        ptr += 1;
    ptr[] = 2000;       ptr += 1;
    ptr[] = 2550;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_O;
    ptr[] = 300;        ptr += 1;
    ptr[] = 870;        ptr += 1;
    ptr[] = 2250;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_U;
    ptr[] = 640;        ptr += 1;
    ptr[] = 1200;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-11/6);  ptr += 1; // gain
    ptr[] = 2^(-13/6);   ptr += 1; // gain
    ptr[] = 9;          ptr += 1; // Q
    ptr[] = 10;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr   = vowel_EE; // These are correct
    ptr[] = 207;        ptr += 1; // freq
    ptr[] = 2300;       ptr += 1; // freq
    ptr[] = 3000;       ptr += 1; // freq
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q
);

function rfn(q,qq)
(
  q * (1+2*qq);
);

function resetvowel()
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(out, outA, outB, outC)
  global()
  (
    d2x  = d1x = 0;
    d2yA = d1yA = 0;
    d2yB = d1yB = 0;
    d2yC = d1yC = 0;
  );

function initvowel(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(ampfac, idx, ptr, loc, rloc, fact, fr1, fr2, fr3, q1, q2, q3, w0, cw, sw, alpha, a0, a0i, Q )
  global(slider54, srate, rfn, vowel_src)
  (
    c     = vowel_src;
    loc   = 5 * freq;
    idx   = floor( loc - 0.0001 );
    rloc  = loc-idx;
    rloc  = 1.0 - rloc;
    fact  = 2 * $pi / ( srate * ( max(1,slider54) ) );
    
    ampfac = 6;
    ptr   = c[idx];
    fr1   = ptr[]*rloc; ptr+=1;
    fr2   = ptr[]*rloc; ptr+=1;
    fr3   = ptr[]*rloc; ptr+=1;
    amp1  = ampfac*ptr[]*rloc; ptr+=1;
    amp2  = ampfac*ptr[]*rloc; ptr+=1;
    amp3  = ampfac*ptr[]*rloc; ptr+=1;
    q1    = ptr[]*rloc; ptr+=1;
    q2    = ptr[]*rloc; ptr+=1;
    q3    = ptr[]*rloc; ptr+=1;
  
    ptr   = c[idx+1];    
    rloc  = 1 - rloc;
    fr1   += ptr[]*rloc; ptr+=1;
    fr2   += ptr[]*rloc; ptr+=1;
    fr3   += ptr[]*rloc; ptr+=1;
    amp1  += ampfac*ptr[]*rloc; ptr+=1;
    amp2  += ampfac*ptr[]*rloc; ptr+=1;
    amp3  += ampfac*ptr[]*rloc; ptr+=1;
    q1    += ptr[]*rloc; ptr+=1;
    q2    += ptr[]*rloc; ptr+=1;
    q3    += ptr[]*rloc; ptr+=1;
  
    // Biquads RBJ BP
    Q     = rfn(q1, qin);
    w0    = fr1 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = rfn(q2, qin);
    w0    = fr2 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = rfn(q3, qin);
    w0    = fr3 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

// Biquads RBJ Notch
function initnotch(freq, q)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local( out, w0, cw, sw, alpha, a0, a0i )
  global(srate, slider54)
  (
    w0    = f_trafo(freq);
    q     = q*0.9 + .1;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    b0    = 1 * a0i;
    b1    = -2 * cw * a0i;
    b2    = a0i;
    a1    = -2 * cw * a0i;
    a2    = (1 - alpha) * a0i;
  );

function initsai0(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / max(slider54,1);
    w0c   = .1*f_trafo(freq) + .025*5*fact;
    qav   = qin*1.5 + .5;
  
    amp1  = 1;
    amp2  = 1;
    amp3  = 1;
      
    // Biquads RBJ BP
    Q     = qav*8;
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = qav*12;
    w0    = w0c*2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = qav*12;
    w0    = w0c/2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

function resetsai0()
  global()
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local( )
  (
    c = amp1 = amp2 = amp3 = Ab0 = Ab1 = Ab2 = Aa1 = Aa2 = Bb0 = Bb1 = Bb2 = Ba1 = Ba2 = Cb0 = Cb1 = Cb2 = Ca1 = Ca2 = d1x = d2x = d1yA = d2yA = d1yB = d2yB = d1yC = d2yC = 0;
  );

function initmodulator(freq, qin)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / (max(slider54,1));
    w0c   = .1*f_trafo(freq) + .25*fact;
    
    Q     = qin*15 + 20;
    amp   = qin*2;
    
    // Biquads RBJ BP
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0   = Q * alpha * a0i;
    Ab1   = 0 * a0i;
    Ab2   = - alpha * Q * a0i;
    Aa1   = -2 * cw * a0i;
    Aa2   = (1 - alpha) * a0i;
  
    Q     = 5+qin*15;
    fact  = $pi / ( srate * ( max(1,slider54) ) );
    w0    = w0c*.25;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = 0.5*(1-cw)*a0i;
    Bb1    = (1-cw)*a0i;
    Bb2    = 0.5*(1-cw)*a0i;
    Ba1    = -2*cw*a0i;
    Ba2    = (1 - alpha)*a0i;
  );
  
function resetmodulator()
  global()
  local()
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  (
    c = Ab0 = Ab1 = Ab2 = Aa1 = Aa2 = Bb0 = Bb1 = Bb2 = Ba1 = Ba2 = d1x = d2x = d1yA = d2yA = d1yB = d2yB = amp = 0;
  );

function initphaserOTA(freq, reso)
  global(slider54)
  local(Rf, g)
  instance(C1, C2, dw, dx, sq)
  (
    Rf = 25/1000;
    g = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    sq = .2*reso;
    // Rf = R1*Vt/R2
    C1 = Rf * g;
    C2 = - 1 / Rf;
  );
  
function resetphaserOTA()
  global()
  local()
  instance(C1, C2, dw, dx, sq)
  (
    dw = dx = 0;
  );

// Trapezoidal integrator
function TPT_step(g, x)
  local()
  global()
  instance(s, y)
  (
    y = g * x + s;
    s = y + g * x;
    
    y;
  );

  function init_newMoog(cutoff, resonance)
  local(fs, fc, g, p0s, nmp, gN, kgN, p0g, tmp, acc)
  global(srate, slider54)
  instance(VT2, rg1, rg2, rg3, rg4, qg1, qg2, qg3, qg4, si1, sf1, sg1, si2, sf2, sg2, si3, sf3, sg3, si4, sf4, sg4, k0g, k0s, VT2i, q0s, r1s, k)
  (
    k    = resonance* 3.9999999999999987;
    fc   = .5 * srate * exp( (1-cutoff) * log(20/22050) );
    fs   = srate * max(slider54,1);
    fc   = min(fc, fs/8);
    
    g    = tan($pi * fc / fs) / sqrt(1.0 + sqrt(k) - 2 * pow(k, 0.25) * 0.7071067811865476);
    VT2  = 0.052;
    VT2i = 19.23076923076923;
  
    // Ladder stages
    p0s = 1.0 / (1.0 + g);
    q0s = 1.0 - g;
    r1s = -g;
    k0s = VT2 * g * p0s;
  
    // Global filter
    nmp = (1.0 - p0s);
    gN  = nmp * nmp * nmp * nmp;
    kgN = k * gN;
    p0g = 1.0 / (1.0 + kgN);
    k0g = -VT2i * p0g;
    
    rg1 = -4.0*kgN;
    rg2 = -6.0*kgN;
    rg3 = -4.0*kgN;
    rg4 = -1.0*kgN;
    acc = tmp = p0s*(g - 1.0);
    qg1 = -4.0*(kgN + acc);
    acc = acc*tmp;
    qg2 = -6.0*(kgN + acc);
    acc = acc*tmp;
    qg3 = -4.0*(kgN + acc);
    acc = acc*tmp;
    qg4 = -1.0*(kgN + acc);
  );
  
  function eval_newMoog(x)
  local(yi, yd, yf)
  global()
  instance(rg1, rg2, rg3, rg4, qg1, qg2, qg3, qg4, si1, sf1, sg1, si2, sf2, sg2, si3, sf3, sg3, si4, sf4, sg4, k0g, k0s, VT2i, VT2, q0s, r1s, k,
           A, B, C, D, y, yo)
  (
    x *= VT2;
    yo = tanh(k0g * (x + sg1));
    A = yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf1);
    y    = yd + si1;
    yo   = tanh(VT2i * y);
    B = yo;
  
    si1 = yd + y;
    sf1 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf2);
    y    = yd + si2;
    yo   = tanh(VT2i * y);
    C = yo;
  
    si2 = yd + y;
    sf2 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf3);
    y    = yd + si3;
    yo   = tanh(VT2i * y);
    D = yo;
  
    si3 = yd + y;
    sf3 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf4);
    y    = yd + si4;
    yo   = tanh(VT2i * y);
  
    si4 = yd + y;
    sf4 = r1s * yi - q0s * yo;
    yf = k * y;
  
    sg1 = rg1 * x + qg1 * yf + sg2;
    sg2 = rg2 * x + qg2 * yf + sg3;
    sg3 = rg3 * x + qg3 * yf + sg4;
    sg4 = rg4 * x + qg4 * yf;
  );
  
function newMoog_LP(x)
local()
global()
instance(y, k, VT2i)
(
  -y * (1 + k) * VT2i
);
function newMoog_BP(x)
local()
global()
instance(VT2, B, C, VT2i)
(
  (C - B);
);

function newMoog_HP(x)
local()
global()
instance(A, B, C, D, yo)
(
  1.25 * (A - 4 * B + 6 * C - 4 * D + yo);
);

function newMoog_Notch(x)
local()
global()
instance(A, B, C, D)
(
  (A - 4 * B + 6 * C - 4 * D); 
);


function init_MS20lin(freq, reso)
  global(slider54)
  local(fg, invTerm, smallg, Gsq, norm)
  instance(a0, a1, a2, s1, s2, G, k)
  (
//    fg      = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    smallg  = .5 * f_trafo(freq);
    k       = 2*reso;
    invTerm = 1.0 / ( 1.0 + smallg );
    G       = smallg * invTerm;
    Gsq     = G*G;
    norm    = 1.0 / ( 1.0 + Gsq * k - G * k );
    
    a0      = Gsq * norm;
    a1      = G * norm;
    a2      = norm;
  );

function reset_MS20lin()
  global()
  local()
  instance(a0, a1, a2, s1, s2, G, k)
  (
    s1 = s2 = 0;
  );

function init_MS20(freq, reso)
  global(slider54)
  local(fg, invTerm)
  instance(s1, s2, G, Gsq, Gsqk, Gk, k, smallg)
  (
//    fg      = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    smallg  = .5 * f_trafo(freq);
    k       = 2*reso;
    invTerm = 1.0 / ( 1.0 + smallg );
    G       = smallg * invTerm;
    Gsq     = G*G;
    Gsqk    = Gsq * k;
    Gk      = G*k;
  ); 

function init_ssm_nonlin(freq, reso)
  global(slider54, srate, israte)
  local(h, K1, KOTA, C, dG, R, wrel)
  instance(hh, itau, K2, hhitau, f, rate, Kout)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;

    // Prewarping
    wrel    = 1.9 * 22050 * f_trafo(freq) * israte;
    f       = 20 * rate * tan( .5 * wrel );
    
    dG      = f;
    KOTA    = .00192;
    R       = 10000;
    K1      = 50;
    Kout    = 1;   
    K2      = 5 * reso;
    hh      = 0.5 * h;
    
    itau    = KOTA*K1*dG;
    hhitau  = hh * itau;
  );   
  
function reset_ssm_nonlin()
  global()
  local()
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    D0 = D1 = D2 = D3 = Di = 0;
  ); 
  
function init_cem_nonlin(freq, reso)
  global(slider54, srate, israte)
  local(h, K1, KOTA, C1, C2, dG1, dG2, R, wrel)
  instance(hh, itau, itau2, K2, hhitau, hhitau2, f, rate, Kout, res)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;

    // Prewarping
    wrel    = 1.28 * 22050 * f_trafo(freq) * israte;
    f       = 20 * rate * tan( .5 * wrel );
        
    dG1      = f;
    dG2      = f * 75;
    KOTA    = .00192;
    
    R       = 10000;
    K1      = 50;
    Kout    = 1;   
    res     = .5*reso;
    K2      = res * 20;
    hh      = 0.5 * h;
    
    itau    = KOTA*K1*dG1;
    itau2   = KOTA*K1*dG2;
    hhitau  = hh * itau;
    hhitau2 = hh * itau2;
  );     
  
function reset_cem_nonlin()
  global()
  local()
  instance(hh, itau, K2, hhitau, hhitau2, itau2, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout, res, ifdbk)
  (
    D0 = D1 = D2 = D3 = Di = 0;
  );
  
function init_ssm_lin(freq, reso)
  global(slider54, srate, israte)
  local(h, K1, KOTA, C, dG, R, wrel, rate, f, hh, hh2, hh3, hh4, itau, itau2, itau3, itau4)
  instance(x0, x1, x15, x2, x6, x7, x11, x13, x14, K2)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;

    // Prewarping
    wrel    = min(2 * 22050 * f_trafo(freq) * israte, 3.12); /* Terrible workaround for SSE issue */
    f       = 20 * rate * tan(.5 * wrel);
    
    dG      = f;
    KOTA    = .00192;
    R       = 10000;
    K1      = 50;
    K2      = 3*reso;
    hh      = 0.5*h;
    itau    = KOTA*K1*dG;
    
    itau2   = itau*itau;
    itau3   = itau2*itau;
    itau4   = itau2*itau2;
    
    hh2     = hh*hh;
    hh3     = hh*hh2;
    hh4     = hh2*hh2;
    
    x0      = hh*itau;
    x1      = x0 + 1;
    x15     = x1*x1*x1;    
    x2      = 1/(K2*hh4*itau4 + x15*x1);
    x6      = hh3*itau3;  
    x7      = K2*x6;
    x11     = x0*x1*x1;    
    x13     = hh2*itau2*x1;
    x14     = K2*x13;
  );      
  
function reset_ssm_lin()
  global()
  local()
  instance(x0, x1, x15, x2, x6, x7, x11, x13, x14, x16, Di, D0, D1, D2, D3, U0, U1, U2, U3, K2)
  (
    D0 = D1 = D2 = D3 = Di = 0;
  );  
  
function init_cem_lin(freq, reso)
  global(slider54, srate, israte)
  local(rate, f, h, hh, hh2, hh3, hh4, itau, itau2, hhitau, hhitau2, K1, KOTA, C1, C2, dG1, dG2, R, wrel)
  instance(res, x0, x1, x2, x3, x4, x5, x6, x11, x12, x13, x14, x15, x19, x27, x22, x23, x28, hh2, hh3, K2 )
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;
  
    // Prewarping
    wrel    = min(2 * 22050 * f_trafo(freq) * israte, 2.85); // Terrible workaround
    f       = 20 * rate * tan( .5 * wrel );
      
    dG1     = f;
    dG2     = f * 75;
    
    KOTA    = .00192;
    R       = 10000;
    K1      = 50;
    res     = .25*reso;
    K2      = res * 20;
    hh      = 0.5*h;
    
    itau    = KOTA*K1*dG1;
    itau2   = KOTA*K1*dG2;

    hh2     = hh*hh;
    hh3     = hh*hh2;
    hh4     = hh2*hh2;   

    x0      = K2*itau*itau*itau;
    x1      = hh*itau2;
    x2      = x1 + 1;
    x3      = hh*itau;
    x4      = x3 + 1;
    x5      = x4*x4*x4;
    x6      = 1/(hh4*itau2*x0 + x2*x5);
    x11     = itau2*hh3;
    x12     = itau*itau;
    x13     = K2*x12;
    x14     = x11*x13;
    x15     = x4*x4;
    x19     = K2*x3;
    x27     = x15*x2;
    x22     = hh2*x4;
    x23     = itau*itau2*x22;
    x28     = x2*x3*x4;
  );    
  
function reset_cem_lin()
  global()
  local()
  instance(K2, res, x0, x1, x2, x3, x4, x5, x6, x11, x12, x13, x14, x15, x19, x27, x22, x23, x28, hh2, hh3, D0, D1, D2, D3, U0, U1, U2, U3, Di)  
  (
    D0 = D1 = D2 = D3 = Di = 0;
  );
  
function init_MS20_nonlin(freq, reso)
  global(slider54)
  local()
  instance(y1, y2, d1, d2, h, hh, k)
  (
    h  = .5 * f_trafo(freq);
    hh = 0.5 * h;
    k  = 2*reso;
  );
  
function init_MS20_nonlin_2(freq, reso)
  global(slider54)
  local()
  instance(y1, y2, d1, d2, h, hh, k)
  (
    h  = f_trafo(freq);
    hh = 0.5 * h;
    k  = 2*reso;
  );  

function reset_MS20_nonlin()
  global()
  local()
  instance(d1, d2)
  (
    d1 = 0;
    d2 = 0;
  );
  
function resetrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local()
  global()
  (
    c = b0 = b1 = b2 = a1 = a2 = d1x = d2x = d1y = d2y = 0;
  );  
  
function initphaserFET(freq, reso)
  global(srate, slider54)
  local(IDSS, Vt, Vp, Fs, Vg, Rp, Q1, g )
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    /*IDSS = .001;  // 1 mA
    Vt   = 0.025; // 25mV
    Vp   = -3;
    Vg   = - 2 - reso;
    Rp   = 1; // ?
     
    iVpsq = 1 / (Vp * Vp);
    Q1 = 2 * IDSS * (Vg-Vt) * iVpsq; 
    C2 = 1 / Rp;
    g  = 1  - exp( - 2 * $pi * freq/max(slider54,1) );
  
    thresh = Vg - Vp;
    IDSSdivVpSq = IDSS * iVpsq;
      
    // We seek C1.
    // Q1*C1 - C2*C1 = g; Eq. 24 from the paper
    C1 = g / (Q1-C2);*/
    
    C1=.5*freq/max(1,slider54);C2=1;
  );  

function initSine(f, r)
  global(srate, slider54)
  local()
  instance(freq, res, fraw)
  (
    freq  = 80 * $pi * f_trafo_hz(f);
    res   = r;
    fraw  = f;
  );
 
function init_linearSVF(freq, res)
  global(srate, slider54)
  local(f0, ct, st, div)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    f0 = .5 * f_trafo(freq);
    k = 2 - 2*res;
    
    ct = cos(f0);
    st = sin(f0);
    div = 1.0 / (1.0 + k * st * ct);
    a1 = ct * ct * div;
    a2 = st * ct * div;
    a3 = st * st * div;
  ); 
  
function init_linearSVF_direct(freq, res)
  global(srate, slider54)
  local(f0, ct, st, div)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    f0 = .5 * $pi * freq / max(slider54,1);
    k = 2 - 2*res;
    
    ct = cos(f0);
    st = sin(f0);
    div = 1.0 / (1.0 + k * st * ct);
    a1 = ct * ct * div;
    a2 = st * ct * div;
    a3 = st * st * div;
  ); 
  
function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );  
  
function initvowelSVF(freq, qin)
  instance( c, svf1, svf2, svf3, svf4, svf5, svf6, amp1, amp2, amp3, fr1, fr2, fr3, q1, q2, q3 )
  local(loc, idx, rloc, fact, ampfac, sr, sq, ptr)
  global(vowel_src)
  (
    c     = vowel_src;
    loc   = 5 * freq;
    idx   = floor( loc - 0.0001 );
    rloc  = loc-idx;
    rloc  = 1.0 - rloc;
    
    sr    = 1/22050;
    sq    = .02;
    
    ampfac = .1;
    ptr   = c[idx];
    fr1   = ptr[]*rloc; ptr+=1;
    fr2   = ptr[]*rloc; ptr+=1;
    fr3   = ptr[]*rloc; ptr+=1;
    amp1  = ampfac*ptr[]*rloc; ptr+=1;
    amp2  = ampfac*ptr[]*rloc; ptr+=1;
    amp3  = ampfac*ptr[]*rloc; ptr+=1;
    q1    = ptr[]*rloc; ptr+=1;
    q2    = ptr[]*rloc; ptr+=1;
    q3    = ptr[]*rloc; ptr+=1;
    
    ptr   = c[idx+1];    
    rloc  = 1 - rloc;
    fr1   += ptr[]*rloc; ptr+=1;
    fr2   += ptr[]*rloc; ptr+=1;
    fr3   += ptr[]*rloc; ptr+=1;
    amp1  += ampfac*ptr[]*rloc; ptr+=1;
    amp2  += ampfac*ptr[]*rloc; ptr+=1;
    amp3  += ampfac*ptr[]*rloc; ptr+=1;
    q1    += ptr[]*rloc; ptr+=1;
    q2    += ptr[]*rloc; ptr+=1;
    q3    += ptr[]*rloc; ptr+=1;
  
    fr1 = fr1 * sr;
    fr2 = fr2 * sr;
    fr3 = fr3 * sr;
    
    q1 = 1-sqrt(q1)*sq;
    q2 = 1-sqrt(q2)*sq;
    q3 = 1-sqrt(q3)*sq;
    
    q1 = q1 * (.7+.28*qin);
    q2 = q2 * (.7+.28*qin);
    q3 = q3 * (.7+.28*qin);
    
    this.svf1.init_linearSVF_direct(fr1, q1);
    this.svf2.init_linearSVF_direct(fr2, q2);
    this.svf3.init_linearSVF_direct(fr3, q3);
    
    this.svf4.init_linearSVF_direct(fr1, q1);
    this.svf5.init_linearSVF_direct(fr2, q2);
    this.svf6.init_linearSVF_direct(fr3, q3);
  );  
  
function resetvowelSVF()
  instance( c, svf1, svf2, svf3, svf4, svf5, svf6, amp1, amp2, amp3 )
  local(loc, idx, rloc, fact, ampfac, ptr, fr1, fr2, fr3, q1, q2, q3)
  global()
  (
    this.svf1.reset_linearSVF();
    this.svf2.reset_linearSVF();
    this.svf3.reset_linearSVF();
    this.svf4.reset_linearSVF();
    this.svf5.reset_linearSVF();
    this.svf6.reset_linearSVF();
  );
  
function init_wasp_nonlin(freq, res)
  local(a, h)
  global(slider54, srate, israte)
  instance(nl, hah, hahnl, rate, wrel, f, r, offset)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;
  
    // Prewarping
    offset  = 0.01;
    wrel    = min(2 * 22050 * f_trafo(freq)*israte, 3.10); /* The clamp is a nasty workaround to make sure it doesn't reach pi */
    f       = 40 * rate * tan( .5 * wrel );
    
    r       = .8-.6*res;
    nl      = .35;
    a       = .08 * f;
    hah     = .5*a*h;
    hahnl   = hah*nl;
  );
  
function reset_wasp_nonlin()
  global()
  local()
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  (
    Di = D1 = D2 = 0;
  );
  
function init_wasp_nonlin_saw(freq, res)
  local(a, h)
  global(slider54, srate, israte)
  instance(nl, hah, hahnl, rate, wrel, f, r, offset)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;
  
    // Prewarping
    offset  = .4+res*.4;
    wrel    = min(2 * 22050 * f_trafo(freq)*israte, 3.13); /* The clamp is a nasty workaround to make sure it doesn't reach pi */
    f       = 40 * rate * tan( .5 * wrel );
    
    r       = .8-.6*res;
    nl      = .35;
    a       = .08 * f;
    hah     = .5*a*h;
    hahnl   = hah*nl;
  );  

function reset_wasp_nonlin_saw()
  global()
  local()
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  (
    Di = D1 = D2 = 0;
  );  
  
function clamp(x)
local(y)
global()
(
  x = 0.8 * x;
  y = 0.5 * (abs(x + 1) - abs(x - 1));
  x = y + .3*(x-y);
  //x = 1.5 * x - 0.5 * x * x * x;
  x = 1.25 * x;
);
  
function Dclamp(x)
(
  1
);  
  
function eval_wasp_nonlin_extrareso(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    offset  = 0.1;
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + tanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl)*(1-.8*V2);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );  
  
function eval_wasp_nonlin_realatanh(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = tanh(D1*nl+offset);
    td2nl   = tanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = tanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = tanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + tanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = tanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );
  
function eval_wasp_nonlin_expensive(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + fasttanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );  
  
// Checked for effect of tanh vs true_tanh  
function eval_wasp_nonlin(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = fasttanh(V1*nl+offset);
    tv2nl   = fasttanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)); // fasttanh ignored
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
       
      clterm  = nl*(Vi + resclamp - tv2nl); // nonlinearity ignored around whole eq
      clterm2 = clterm;           // nonlinearity ignored around whole eq
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + tv1nl); // nonlinearity ignored around tv1nl

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );    
  
function eval_wasp_nonlin_BP_old(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + fasttanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V1;
  );  
  
// Optimized based on coefficient magnitude
// Checked for effect of tanh vs true_tanh
function eval_wasp_nonlin_BP(Vi)
  local(idet, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, fixterm, V1, V2, f0, f1, resclamp, shrterm, clterm, clterm2)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset, Jc)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + fasttanh(tv1nl));
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (1.0 - Jc);
      V1      = V1 - f0*idet;
      V2      = V2 - (f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V1;
  );    
  
function init_wasplin(freq, res)
  global(srate, slider54, israte)
  local(f, h, hh, itau, wrel, rate)
  instance(U0, U1, Di, D0, D1, x0, x1, x2, x3, i1, K2)
  (
    rate    = (srate * max(slider54,1));
    h       = 1.0 / rate;
    
    wrel    = min(2 * 22050 * f_trafo(freq)*israte, 3.13);  /* The clamp is a nasty workaround to make sure it doesn't reach pi */
    f       = 20 * rate * tan( .5 * wrel );
    
    hh      = 0.5 * h;
    itau    = .08 * f;
    K2      = .8-.6*res;
    
    x0 = hh*itau;
    x1 = 2*x0;
    x2 = K2*x1;
    x3 = 4*x0*x0;
    i1 = 1.0/(x2 + x3 + 1);
  );
  
  function pwm_init(freq, reso)
    instance(len, ilen, c, svf)
    local()
    global(srate, slider54)
    (
      this.filter_SVF.init_linearSVF( freq, 0 );
    
      len = floor(8*reso)+2;//(1-freq)*(srate * max(slider54,1));
      ilen = 1/len;
   );
   
  function bit_init(freq, reso)
    instance(depth, idepth, res)
    local()
    global()
    (
      depth = 2^(freq*freq*freq * 16);
      idepth = 1/depth;
      res = reso;
      this.filter_SVF.init_linearSVF( reso, 0 );
    );
    
    function muck_init(freq, reso)
      instance(f, res)
      local()
      global()
      (
        f = freq;
        res = reso;
        this.filter_SVF.init_linearSVF( f, res );
      );
   
function weeping_init(freq, res, bass)
instance( a_0, a_1, a_2, a_3, b_0, b_1, b_2, b_3, ia_0,
          dx0, dx1, dx2, dx3, dy0, dy1, dy2, dy3 )
local(          
          x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21
          A0, A1, A2, A3, B0, B1, B2,
          bass, WAH, m_fudge, e_fudge,
          f, f2, f3,
          R108, R109, R110, R111, R113, R114, R115, R117, R120, R122, R123, C104, C105, C118, C119, VR6, VR7,
          WAH_theta, LO, LEVEL, Q, RANGE )
global(srate, slider54)
(
  LEVEL     = 10000.0;
  LO        = 100 + 99900 * res;
  WAH_theta = 5 + 12*freq;
  Q         = 100 + 249900*(.75*freq+.25);
  
  RANGE   = 2500*freq;

  R108 = 9790;   // 10e3; 
  R109 = 21300;  // 22e3; 
  R110 = 23900;  // 24e3; 
  R111 = 46400;  // 47e3; 
  R113 = 197000; // 200e3; 
  R114 = 10970;  // 11e3; 
  R115 = 982;    // 1e3; 
  R117 = 14770;  // 15e3; 
  R120 = 3520;   // 3.6e3; 
  R122 = 4950;   // 5.1e3; 
  R123 = 4650;   // 4.7e3; 
  
  C104 = .00000000276; // 2.7e-9;
  C105 = .0000000103;  // 10e-9;
  C118 = .0000000195;  // 18e-9; 
  C119 = .0000000101;  // 10e-9; 
  VR6  = 0;            // 20e3; 
  VR7  = 449000;       // 500e3;

  m_fudge = 1.1;
  e_fudge = 0.95*(1+.1*res);
  WAH = m_fudge * 16933367000 * pow(WAH_theta,(-4.45855*e_fudge));

  bass ? (
    LEVEL = 10000; Q = 10000*freq; LO = 100;
    x0 = LO + R122 + R123;
    x1 = C105*R117*x0;
    x2 = Q + R114;
    x3 = R109 + R110;
    x4 = R113 + VR7;
    x5 = WAH + x4;
    x6 = R108 + x2;
    x7 = R115 + RANGE + VR6;
    B2 = 0.0;
    A3 = 0.0;
    B1 = LEVEL*x1*x2*x3*x5;
    B0 = R123*x2*x3*x5*(LEVEL + R120);
    A2 = R109*R120*x1*x6*(C104 + C119)*(WAH*(x4 + x7) + x4*x7);
    A1 = C105*R108*R117*R120*x0*x3*x5;
    A0 = R110*R120*x0*x5*x6;
  ) : (
    x0 = LO + R122 + R123;
    x1 = C105*R111*R117*x0;
    x2 = Q + R114;
    x3 = R109 + R110;
    x4 = R113 + VR7;
    x5 = WAH + x4;
    x6 = x2*x3*x5;
    x7 = C118*R111*R123;
    x8 = C105*R117;
    x9 = x0*x8;
    x10 = R108 + x2;
    x11 = R115 + RANGE + VR6;
    x12 = WAH*(x11 + x4) + x11*x4;
    x13 = R110*R111;
    x14 = C118*R108*x5;
    x15 = C104*x12;
    x16 = R120*x0*x5;
    x17 = R108 + R111;

    B2 = C118*LEVEL*x1*x2*x3*x5;
    B1 = x6*(LEVEL*(x7 + x9) + R120*x7);
    B0 = R123*x6*(LEVEL + R120);
    A3 = C104*C118*R109*R120*x1*x10*x12;
    A2 = R120*x9*(R109*(R111*(x14 + x15) + x10*x15) + x13*x14);
    A1 = x16*(C118*x10*x13 + x17*x3*x8);
    A0 = R110*x16*(x17 + x2);
  );
    
  //double az0,az1,az2,az3,bz0,bz1,bz2,bz3;
  
  f = srate * max(1, slider54);
  f2 = f*f;
  f3 = f2*f;

  // Bilinear transform
  a_0 = 8*A3*f3 + 4*A2*f2 + 2*A1*f + A0;
  ia_0 = 1/a_0;
  a_3 = (-8*A3*f3 + 4*A2*f2 - 2*A1*f + A0)*ia_0;
  a_2 = (24*A3*f3 -4*A2*f2 - 2*A1*f + 3*A0)*ia_0;
  a_1 = (-24*A3*f3 -4*A2*f2 +2*A1*f + 3*A0)*ia_0;
  b_3 = (4*B2*f2 - 2*B1*f + B0)*ia_0;
  b_2 = (-4*B2*f2 - 2*B1*f + 3*B0)*ia_0;
  b_1 = (-4*B2*f2 +2*B1*f + 3*B0)*ia_0;
  b_0 = (4*B2*f2 + 2*B1*f + B0)*ia_0;
  a_0 = 1; 
);

function weeping_eval(sample)
instance( a_0, a_1, a_2, a_3, b_0, b_1, b_2, b_3, ia_0,
          dx0, dx1, dx2, dx3, dy0, dy1, dy2, dy3 )
global(srate)
local()
(
  dx3 = dx2;
  dx2 = dx1;
  dx1 = dx0;
  dx0 = sample;
  dy3 = dy2;
  dy2 = dy1;
  dy1 = dy0;
  
  dy0      = -a_1 * dy1 - a_2 * dy2 - a_3 * dy3 
             + (b_0 * dx0 + b_1 * dx1 + b_2 * dx2 + b_3 * dx3 );
  
  dy0
); 

function weeping_reset()
  instance( a_0, a_1, a_2, a_3, b_0, b_1, b_2, b_3, ia_0, ic
            dx0, dx1, dx2, dx3, dy0, dy1, dy2, dy3 )
  local()
  global()
  (
    dx3 = dx2 = dx1 = dx0 = 0;
    dy3 = dy2 = dy1 = dy0 = 0;
  );
  
 
function kot_lut(xloc, yloc)
  instance()
  local(ptr)
  global()
  (
    ptr = xloc;
    (ptr)[] = 0.0000000000000000000000000000000000000000000000000000000000000000000000;
    (ptr+=1)[] = 0.0000002272750297187890897817106163406042362851167126791551709175109863;
    (ptr+=1)[] = 0.0000004545523573290177498923273543413037245386476570274680852890014648;
    (ptr+=1)[] = 0.0000006818365740679524598656354242298682777345675276592373847961425781;
    (ptr+=1)[] = 0.0000009091391466737206086479107687570166973500818130560219287872314453;
    (ptr+=1)[] = 0.0000011364898614403173784817655672663150312473590020090341567993164062;
    (ptr+=1)[] = 0.0000013639665515893442292920476749396030413663538638502359390258789062;
    (ptr+=1)[] = 0.0000015917727765245184593455828048202960189883015118539333343505859375;
    (ptr+=1)[] = 0.0000018204409785609454137613903365600087624898151261731982231140136719;
    (ptr+=1)[] = 0.0000020513638719805324137448500343428037240300909616053104400634765625;
    (ptr+=1)[] = 0.0000022881844022928005752545114331875097946067398879677057266235351562;
    (ptr+=1)[] = 0.0000023369165300198341795830971057146285829730913974344730377197265625;
    (ptr+=1)[] = 0.0000023863436474180246963706659296677869974701025057584047317504882812;
    (ptr+=1)[] = 0.0000024366131224582609724751362106909269300558662507683038711547851562;
    (ptr+=1)[] = 0.0000024879035715163015945897238140327445421462471131235361099243164062;
    (ptr+=1)[] = 0.0000025404314853906905902029833566047045678715221583843231201171875000;
    (ptr+=1)[] = 0.0000025944592603240052647252302658875677821015415247529745101928710938;
    (ptr+=1)[] = 0.0000026503049319491250363943143919520650797494454309344291687011718750;
    (ptr+=1)[] = 0.0000027083539732545147541483560038599875952058937400579452514648437500;
    (ptr+=1)[] = 0.0000027690735942301342131213661573729822862333094235509634017944335938;
    (ptr+=1)[] = 0.0000028330300736588281070612964362975816356993163935840129852294921875;
    (ptr+=1)[] = 0.0000028664312687454564579359050924267648952081799507141113281250000000;
    (ptr+=1)[] = 0.0000029009097659996159753012685833528649936852161772549152374267578125;
    (ptr+=1)[] = 0.0000029365742958318774165327701142214067431268631480634212493896484375;
    (ptr+=1)[] = 0.0000029735445626418528360600766757837476461645564995706081390380859375;
    (ptr+=1)[] = 0.0000030119523524056179028356161619939257434452883899211883544921875000;
    (ptr+=1)[] = 0.0000030519427520501930822414624056015952646703226491808891296386718750;
    (ptr+=1)[] = 0.0000030936754918975680455760658010833097364411514718085527420043945312;
    (ptr+=1)[] = 0.0000031373264235994869768590562197907445352029753848910331726074218750;
    (ptr+=1)[] = 0.0000031830891472378593251113358675308262490943889133632183074951171875;
    (ptr+=1)[] = 0.0000032311768026458596567206203037381229137281479779630899429321289062;
    (ptr+=1)[] = 0.0000032818240415242349736159224032894243805458245333284139633178710938;
    (ptr+=1)[] = 0.0000033352891986002126872086666342642757854264345951378345489501953125;
    (ptr+=1)[] = 0.0000033918566819180485770327329597684240525268251076340675354003906250;
    (ptr+=1)[] = 0.0000034518396043778417216045528714829515593010000884532928466796875000;
    (ptr+=1)[] = 0.0000035155826808714051744846409985889579274953575804829597473144531250;
    (ptr+=1)[] = 0.0000035834654178215151178405264986714939823286840692162513732910156250;
    (ptr+=1)[] = 0.0000036559056246363073292308595862998288339440478011965751647949218750;
    (ptr+=1)[] = 0.0000037333632795692510365683641770928602454659994691610336303710937500;
    (ptr+=1)[] = 0.0000038163447857542747194297717838740169327138573862612247467041015625;
    (ptr+=1)[] = 0.0000039054076567958125965149968061851382117311004549264907836914062500;
    (ptr+=1)[] = 0.0000040011656752680690022944305639374107386174728162586688995361328125;
    (ptr+=1)[] = 0.0000041042945718534878992030633104715064973788685165345668792724609375;
    (ptr+=1)[] = 0.0000042155382776677333941982642184775897931103827431797981262207031250;
    (ptr+=1)[] = 0.0000043357158076219526877362504813095966937908087857067584991455078125;
    (ptr+=1)[] = 0.0000044657288385119806739141298801420987274468643590807914733886718750;
    (ptr+=1)[] = 0.0000046065700519521183580102553778434781861506053246557712554931640625;
    (ptr+=1)[] = 0.0000047593323193481105662502525510682005460694199427962303161621093750;
    (ptr+=1)[] = 0.0000049252188138949295193838757989102106193968211300671100616455078125;
    (ptr+=1)[] = 0.0000051055541431626049890578691869968963601422728970646858215332031250;
    (ptr+=1)[] = 0.0000053017966052763776071184848026618396943376865237951278686523437500;
    (ptr+=1)[] = 0.0000055155516820938343426888178511191540565050672739744186401367187500;
    (ptr+=1)[] = 0.0000057485868942271102884555497580798544277058681473135948181152343750;
    (ptr+=1)[] = 0.0000060028481553591214552306060125985709419182967394590377807617187500;
    (ptr+=1)[] = 0.0000062804777771751482123440031568595287581047159619629383087158203125;
    (ptr+=1)[] = 0.0000065838342915038130284243605983007796567108016461133956909179687500;
    (ptr+=1)[] = 0.0000069155142730754847230794681023358094762443215586245059967041015625;
    (ptr+=1)[] = 0.0000072783763648173485470834961907904414601944154128432273864746093750;
    (ptr+=1)[] = 0.0000076755677279836502242393175832191332119691651314496994018554687500;
    (ptr+=1)[] = 0.0000081105531618558816169331504575268354528816416859626770019531250000;
    (ptr+=1)[] = 0.0000085871471624484472975457477472716050215240102261304855346679687500;
    (ptr+=1)[] = 0.0000085871471624484659322705873418790645246190251782536506652832031250;
    (ptr+=1)[] = 0.0000090011886777615967647828143505250864109257236123085021972656250000;
    (ptr+=1)[] = 0.0000094468827383713019590731618801981994693051092326641082763671875000;
    (ptr+=1)[] = 0.0000099267602501288379382004406492612247348006349056959152221679687500;
    (ptr+=1)[] = 0.0000104435544875849889250290364328677128469280432909727096557617187500;
    (ptr+=1)[] = 0.0000110002172751887835580771046739556595639442093670368194580078125000;
    (ptr+=1)[] = 0.0000115999364623186860016271909623597480276657734066247940063476562500;
    (ptr+=1)[] = 0.0000122461547955997655871525700566060379514965461567044258117675781250;
    (ptr+=1)[] = 0.0000129425903002325456308315571041234193216951098293066024780273437500;
    (ptr+=1)[] = 0.0000136932582909924210044262660179725799025618471205234527587890625000;
    (ptr+=1)[] = 0.0000145024951432066187767891407567333317274460569024085998535156250000;
    (ptr+=1)[] = 0.0000153749839644346761617296759361295244161738082766532897949218750000;
    (ptr+=1)[] = 0.0000163157823188307988669827619521157657800358720123767852783203125000;
    (ptr+=1)[] = 0.0000173303521683185159844940020912318345835956279188394546508789062500;
    (ptr+=1)[] = 0.0000184245922078317219371113022674535386613570153713226318359375000000;
    (ptr+=1)[] = 0.0000196048727860490104623128471139636985753895714879035949707031250000;
    (ptr+=1)[] = 0.0000208780736183554699401249132861835278163198381662368774414062500000;
    (ptr+=1)[] = 0.0000222516245152946834004979714816130353938206098973751068115234375000;
    (ptr+=1)[] = 0.0000237335493676272404959919082312325144812348298728466033935546875000;
    (ptr+=1)[] = 0.0000253325136483904640662297158559823628820595331490039825439453125000;
    (ptr+=1)[] = 0.0000270578757131753265508748024226193251706718001514673233032226562500;
    (ptr+=1)[] = 0.0000289197422023221323999792736758607247793406713753938674926757812500;
    (ptr+=1)[] = 0.0000309290278730203741408728845829756437524338252842426300048828125000;
    (ptr+=1)[] = 0.0000330975202155234414437730283697902677886304445564746856689453125000;
    (ptr+=1)[] = 0.0000354379492360112522634368881213617896719370037317276000976562500000;
    (ptr+=1)[] = 0.0000379640628192202280832660832299296771452645771205425262451171875000;
    (ptr+=1)[] = 0.0000406907081169949504237046133958699556387728080153465270996093750000;
    (ptr+=1)[] = 0.0000436339194445857010045200508052687382587464526295661926269531250000;
    (ptr+=1)[] = 0.0000468110132050467188662319639735898135768366046249866485595703125000;
    (ptr+=1)[] = 0.0000502406904036941214376603415114885820003109984099864959716796875000;
    (ptr+=1)[] = 0.0000539431473595174259681901685059557394197327084839344024658203125000;
    (ptr+=1)[] = 0.0000579401952689646983869417584678274124598829075694084167480468750000;
    (ptr+=1)[] = 0.0000622553893299282879846695548664570196706335991621017456054687500000;
    (ptr+=1)[] = 0.0000669141681903553774005480314635008198820287361741065979003906250000;
    (ptr+=1)[] = 0.0000719440045470298001305253787762694628327153623104095458984375000000;
    (ptr+=1)[] = 0.0000773745677860820750808973356171804880432318896055221557617187500000;
    (ptr+=1)[] = 0.0000832378996280706091523415857125201000599190592765808105468750000000;
    (ptr+=1)[] = 0.0000895686038174703554048949882826491375453770160675048828125000000000;
    (ptr+=1)[] = 0.0000964040509795407459621083279266429144627181813120841979980468750000;
    (ptr+=1)[] = 0.0001037845998573449021610062836806775976583594456315040588378906250000;
    (ptr+=1)[] = 0.0001117538362386594940267245390508321634115418419241905212402343750000;
    (ptr+=1)[] = 0.0001203588309872411106753870013719165399379562586545944213867187500000;
    (ptr+=1)[] = 0.0001296504187060145015485124186938037382788024842739105224609375000000;
    (ptr+=1)[] = 0.0001396834986818906330571787854921694815857335925102233886718750000000;
    (ptr+=1)[] = 0.0001505173598938311493779934613357340822403784841299057006835937500000;
    (ptr+=1)[] = 0.0001622160320082327274529565563909727643476799130439758300781250000000;
    (ptr+=1)[] = 0.0001748486644395512478247778354045749438228085637092590332031250000000;
    (ptr+=1)[] = 0.0001884899357202318931694962067524556914577260613441467285156250000000;
    (ptr+=1)[] = 0.0002032204956034545657427708986730863216507714241743087768554687500000;
    (ptr+=1)[] = 0.0002191274425159670977917431011761095760448370128870010375976562500000;
    (ptr+=1)[] = 0.0002363048391875718424234159575902936012425925582647323608398437500000;
    (ptr+=1)[] = 0.0002548542695098295431978263625438785311416722834110260009765625000000;
    (ptr+=1)[] = 0.0002748854399206281866156753590502148654195480048656463623046875000000;
    (ptr+=1)[] = 0.0002965168288748602190736669559356641912017948925495147705078125000000;
    (ptr+=1)[] = 0.0003198763882461248906491357857362345384899526834487915039062500000000;
    (ptr+=1)[] = 0.0003451023008118097234672716489001231821021065115928649902343750000000;
    (ptr+=1)[] = 0.0003723437983059212823613859377758217306109145283699035644531250000000;
    (ptr+=1)[] = 0.0004017620448825965067535248564922767400275915861129760742187500000000;
    (ptr+=1)[] = 0.0004335310912204847454132217166034024558030068874359130859375000000000;
    (ptr+=1)[] = 0.0004678389049163486027721470250639868027064949274063110351562500000000;
    (ptr+=1)[] = 0.0005048884832679128784049815692469564964994788169860839843750000000000;
    (ptr+=1)[] = 0.0005448990550337146207202088099563752621179446578025817871093750000000;
    (ptr+=1)[] = 0.0005881073782844700855929054306159287079935893416404724121093750000000;
    (ptr+=1)[] = 0.0006347691420293359717760828253574345581000670790672302246093750000000;
    (ptr+=1)[] = 0.0006851604799148061164873468875669004773953929543495178222656250000000;
    (ptr+=1)[] = 0.0007395796049574564993284164771125688275787979364395141601562500000000;
    (ptr+=1)[] = 0.0007983485749882848975592097851006201381096616387367248535156250000000;
    (ptr+=1)[] = 0.0008618151992602169839119419236794783500954508781433105468750000000000;
    (ptr+=1)[] = 0.0009303550975060245276440640260773307090857997536659240722656250000000;
    (ptr+=1)[] = 0.0010043739236364871997980730000676885538268834352493286132812500000000;
    (ptr+=1)[] = 0.0010843097672432007103071605058630666462704539299011230468750000000000;
    (ptr+=1)[] = 0.0011706357471231657995519581660914809617679566144943237304687500000000;
    (ptr+=1)[] = 0.0012638628121790008475289202038993607857264578342437744140625000000000;
    (ptr+=1)[] = 0.0013645427662763371431248193843543958791997283697128295898437500000000;
    (ptr+=1)[] = 0.0014732715349657825656959353466390894027426838874816894531250000000000;
    (ptr+=1)[] = 0.0015906926934087053417121726539562587277032434940338134765625000000000;
    (ptr+=1)[] = 0.0017175012763924329961540138356212992221117019653320312500000000000000;
    (ptr+=1)[] = 0.0018544478929904625614383251175354416773188859224319458007812500000000;
    (ptr+=1)[] = 0.0020023431702267499750214074794030238990671932697296142578125000000000;
    (ptr+=1)[] = 0.0021620625520510157631381975562590014305897057056427001953125000000000;
    (ptr+=1)[] = 0.0023345514820352487699028909418075272697024047374725341796875000000000;
    (ptr+=1)[] = 0.0025208310004734692071071133767645733314566314220428466796875000000000;
    (ptr+=1)[] = 0.0027220037890199849477113058782151711056940257549285888671875000000000;
    (ptr+=1)[] = 0.0029392606986508688915460396628986927680671215057373046875000000000000;
    (ptr+=1)[] = 0.0031738877995947083893168993995459459256380796432495117187500000000000;
    (ptr+=1)[] = 0.0034272739949687638406905509924627040163613855838775634765625000000000;
    (ptr+=1)[] = 0.0037009192431938535070012896710522909415885806083679199218750000000000;
    (ptr+=1)[] = 0.0039964434378653096793798660257834853837266564369201660156250000000000;
    
    ptr = yloc;
    (ptr)[] = 0.0000000000000000000000000000000000000000000000000000000000000000000000;
    (ptr+=1)[] = 0.0499974111809210614021381502425356302410364151000976562500000000000000;
    (ptr+=1)[] = 0.0999792173768255937327253946023120079189538955688476562500000000000000;
    (ptr+=1)[] = 0.1499298481753241485403549404509249143302440643310546875000000000000000;
    (ptr+=1)[] = 0.1998338172182716476754649193026125431060791015625000000000000000000000;
    (ptr+=1)[] = 0.2496758163419069420640994394489098340272903442382812500000000000000000;
    (ptr+=1)[] = 0.2994409285040193213767167890182463452219963073730468750000000000000000;
    (ptr+=1)[] = 0.3491151514740411521131591143785044550895690917968750000000000000000000;
    (ptr+=1)[] = 0.3986867321580635503686096399178495630621910095214843750000000000000000;
    (ptr+=1)[] = 0.4481496137509251576069857492257142439484596252441406250000000000000000;
    (ptr+=1)[] = 0.4975123872180225448325074921740451827645301818847656250000000000000000;
    (ptr+=1)[] = 0.5073758787107911505387392026023007929325103759765625000000000000000000;
    (ptr+=1)[] = 0.5172376106452808430802292605221737176179885864257812500000000000000000;
    (ptr+=1)[] = 0.5270984116941410668744083523051813244819641113281250000000000000000000;
    (ptr+=1)[] = 0.5369593103710098569436581783520523458719253540039062500000000000000000;
    (ptr+=1)[] = 0.5468215771201838659720806390396319329738616943359375000000000000000000;
    (ptr+=1)[] = 0.5566867752774767863499505438085179775953292846679687500000000000000000;
    (ptr+=1)[] = 0.5665568227708185355950831763038877397775650024414062500000000000000000;
    (ptr+=1)[] = 0.5764340668222130981135364891088102012872695922851562500000000000000000;
    (ptr+=1)[] = 0.5863213743882237372062604663369711488485336303710937500000000000000000;
    (ptr+=1)[] = 0.5962222416513892619960301999526564031839370727539062500000000000000000;
    (ptr+=1)[] = 0.6011790568521447886141118033265229314565658569335937500000000000000000;
    (ptr+=1)[] = 0.6061409265706914073490452210535295307636260986328125000000000000000000;
    (ptr+=1)[] = 0.6111085283863871842058301808719988912343978881835937500000000000000000;
    (ptr+=1)[] = 0.6160826093403891645650105601816903799772262573242187500000000000000000;
    (ptr+=1)[] = 0.6210639929004470038975682655291166156530380249023437500000000000000000;
    (ptr+=1)[] = 0.6260535866233817303694308975536841899156570434570312500000000000000000;
    (ptr+=1)[] = 0.6310523905849797499101327957760076969861984252929687500000000000000000;
    (ptr+=1)[] = 0.6360615066539747619600575490039773285388946533203125000000000000000000;
    (ptr+=1)[] = 0.6410821486944094926840875814377795904874801635742187500000000000000000;
    (ptr+=1)[] = 0.6461156537890432316473265927925240248441696166992187500000000000000000;
    (ptr+=1)[] = 0.6511634945856613621018027515674475580453872680664062500000000000000000;
    (ptr+=1)[] = 0.6562272928782366676614401512779295444488525390625000000000000000000000;
    (ptr+=1)[] = 0.6613088345459712247276229390990920364856719970703125000000000000000000;
    (ptr+=1)[] = 0.6664100859854046321473219904873985797166824340820312500000000000000000;
    (ptr+=1)[] = 0.6715332121841049994870331829588394612073898315429687500000000000000000;
    (ptr+=1)[] = 0.6766805965990945193055949857807718217372894287109375000000000000000000;
    (ptr+=1)[] = 0.6818548630191798576305473034153692424297332763671875000000000000000000;
    (ptr+=1)[] = 0.6870588996079370902592131642450112849473953247070312500000000000000000;
    (ptr+=1)[] = 0.6922958853433357484519206082040909677743911743164062500000000000000000;
    (ptr+=1)[] = 0.6975693190910515761871124595927540212869644165039062500000000000000000;
    (ptr+=1)[] = 0.7028830515715597249126744827663060277700424194335937500000000000000000;
    (ptr+=1)[] = 0.7082413205062993988292419089702889323234558105468750000000000000000000;
    (ptr+=1)[] = 0.7136487892557192846965108401491306722164154052734375000000000000000000;
    (ptr+=1)[] = 0.7191105892920591768913141095254104584455490112304687500000000000000000;
    (ptr+=1)[] = 0.7246323668824904418173105113964993506669998168945312500000000000000000;
    (ptr+=1)[] = 0.7302203343939188684430519060697406530380249023437500000000000000000000;
    (ptr+=1)[] = 0.7358813266695874988343462064221967011690139770507812500000000000000000;
    (ptr+=1)[] = 0.7416228629697880769811035861494019627571105957031250000000000000000000;
    (ptr+=1)[] = 0.7474532150147404907514214755792636424303054809570312500000000000000000;
    (ptr+=1)[] = 0.7533814817172148625701311175362206995487213134765625000000000000000000;
    (ptr+=1)[] = 0.7594176712459478340022656084329355508089065551757812500000000000000000;
    (ptr+=1)[] = 0.7655727911185274958683066870435141026973724365234375000000000000000000;
    (ptr+=1)[] = 0.7718589470842863731192551313142757862806320190429687500000000000000000;
    (ptr+=1)[] = 0.7782894516239639015608986483130138367414474487304687500000000000000000;
    (ptr+=1)[] = 0.7848789429634490666387591772945597767829895019531250000000000000000000;
    (ptr+=1)[] = 0.7916435155737018281030259458930231630802154541015625000000000000000000;
    (ptr+=1)[] = 0.7986008632077307156649226271838415414094924926757812500000000000000000;
    (ptr+=1)[] = 0.8057704356078413399089299673505593091249465942382812500000000000000000;
    (ptr+=1)[] = 0.8131736101015950568537959952664095908403396606445312500000000000000000;
    (ptr+=1)[] = 0.8208338793920220144428867570240981876850128173828125000000000000000000;
    (ptr+=1)[] = 0.8208338793920222364874916820554062724113464355468750000000000000000000;
    (ptr+=1)[] = 0.8271644661145211019359635429282207041978836059570312500000000000000000;
    (ptr+=1)[] = 0.8336904435532230817074150763801299035549163818359375000000000000000000;
    (ptr+=1)[] = 0.8404273115375370251101116991776507347822189331054687500000000000000000;
    (ptr+=1)[] = 0.8473917767812859658249635685933753848075866699218750000000000000000000;
    (ptr+=1)[] = 0.8546018442958019933897162445646245032548904418945312500000000000000000;
    (ptr+=1)[] = 0.8620769152647821398360861167020630091428756713867187500000000000000000;
    (ptr+=1)[] = 0.8698378917483061689708279118349310010671615600585937500000000000000000;
    (ptr+=1)[] = 0.8779072885853479446538472075189929455518722534179687500000000000000000;
    (ptr+=1)[] = 0.8863093528609788940286762226605787873268127441406250000000000000000000;
    (ptr+=1)[] = 0.8950701912948123561974966833076905459165573120117187500000000000000000;
    (ptr+=1)[] = 0.9042179058893267118435232987394556403160095214843750000000000000000000;
    (ptr+=1)[] = 0.9137827381483989430677183918305672705173492431640625000000000000000000;
    (ptr+=1)[] = 0.9237972221350448931431742494169156998395919799804687500000000000000000;
    (ptr+=1)[] = 0.9342963465798540534379412747512105852365493774414062500000000000000000;
    (ptr+=1)[] = 0.9453177261740420833646680875972378998994827270507812500000000000000000;
    (ptr+=1)[] = 0.9569017820787704131646478344919160008430480957031250000000000000000000;
    (ptr+=1)[] = 0.9690919315497310559948118680040352046489715576171875000000000000000000;
    (ptr+=1)[] = 0.9819347864061586106387835570785682648420333862304687500000000000000000;
    (ptr+=1)[] = 0.9954803598581729584537924893083982169628143310546875000000000000000000;
    (ptr+=1)[] = 1.0097822809358110163202582043595612049102783203125000000000000000000000;
    (ptr+=1)[] = 1.0248980154254179186779083465808071196079254150390625000000000000000000;
    (ptr+=1)[] = 1.0408890918001190151187529409071430563926696777343750000000000000000000;
    (ptr+=1)[] = 1.0578213301140302338154697281424887478351593017578125000000000000000000;
    (ptr+=1)[] = 1.0757650711947601696039100716006942093372344970703125000000000000000000;
    (ptr+=1)[] = 1.0947954026921198344979302419233135879039764404296875000000000000000000;
    (ptr+=1)[] = 1.1149923775952734761318652090267278254032135009765625000000000000000000;
    (ptr+=1)[] = 1.1364412196838580282332031856640242040157318115234375000000000000000000;
    (ptr+=1)[] = 1.1592325089941781790514596650609746575355529785156250000000000000000000;
    (ptr+=1)[] = 1.1834623387176239628360008282470516860485076904296875000000000000000000;
    (ptr+=1)[] = 1.2092324329583503672580491183907724916934967041015625000000000000000000;
    (ptr+=1)[] = 1.2366502124099083559372047602664679288864135742187500000000000000000000;
    (ptr+=1)[] = 1.2658287922116928658766710213967598974704742431640625000000000000000000;
    (ptr+=1)[] = 1.2968868929605754658496152842417359352111816406250000000000000000000000;
    (ptr+=1)[] = 1.3299486420285153709386349873966537415981292724609375000000000000000000;
    (ptr+=1)[] = 1.3651432379294943242342696976265870034694671630859375000000000000000000;
    (ptr+=1)[] = 1.4026044454623378676672018627868965268135070800781250000000000000000000;
    (ptr+=1)[] = 1.4424698837334435363999318724381737411022186279296875000000000000000000;
    (ptr+=1)[] = 1.4848800629864284950087949255248531699180603027343750000000000000000000;
    (ptr+=1)[] = 1.5299771195580593730056762069580145180225372314453125000000000000000000;
    (ptr+=1)[] = 1.5779031914700860639300117327366024255752563476562500000000000000000000;
    (ptr+=1)[] = 1.6287983705310296045354334637522697448730468750000000000000000000000000;
    (ptr+=1)[] = 1.6827981609377185012732525137835182249546051025390625000000000000000000;
    (ptr+=1)[] = 1.7400303700759223168859080033143982291221618652343750000000000000000000;
    (ptr+=1)[] = 1.8006113557045633211117774408194236457347869873046875000000000000000000;
    (ptr+=1)[] = 1.8646415565671323744112442000187002122402191162109375000000000000000000;
    (ptr+=1)[] = 1.9322002427930706769387825261219404637813568115234375000000000000000000;
    (ptr+=1)[] = 2.0033394408492455340820015408098697662353515625000000000000000000000000;
    (ptr+=1)[] = 2.0780770184165233693818208848824724555015563964843750000000000000000000;
    (ptr+=1)[] = 2.1563889609469497621319078461965546011924743652343750000000000000000000;
    (ptr+=1)[] = 2.2382009374882709806797720375470817089080810546875000000000000000000000;
    (ptr+=1)[] = 2.3233793419586739048554591136053204536437988281250000000000000000000000;
    (ptr+=1)[] = 2.4117221095406158326568402117118239402770996093750000000000000000000000;
    (ptr+=1)[] = 2.5029497459795853053776681917952373623847961425781250000000000000000000;
    (ptr+=1)[] = 2.5966971661018054540193134016590192914009094238281250000000000000000000;
    (ptr+=1)[] = 2.6925071067624020137998286372749134898185729980468750000000000000000000;
    (ptr+=1)[] = 2.7898260409720516683762525644851848483085632324218750000000000000000000;
    (ptr+=1)[] = 2.8880036473634849158997894846834242343902587890625000000000000000000000;
    (ptr+=1)[] = 2.9862969466416284802789959940128028392791748046875000000000000000000000;
    (ptr+=1)[] = 3.0838801617003297472763279074570164084434509277343750000000000000000000;
    (ptr+=1)[] = 3.1798611471809872242033634393010288476943969726562500000000000000000000;
    (ptr+=1)[] = 3.2733048325503455444618339242879301309585571289062500000000000000000000;
    (ptr+=1)[] = 3.3632635172023128689033910632133483886718750000000000000000000000000000;
    (ptr+=1)[] = 3.4488130696746019943077499192440882325172424316406250000000000000000000;
    (ptr+=1)[] = 3.5290931864350043589695360424229875206947326660156250000000000000000000;
    (ptr+=1)[] = 3.6033489800320319673687663453165441751480102539062500000000000000000000;
    (ptr+=1)[] = 3.6709704526379631772670109057798981666564941406250000000000000000000000;
    (ptr+=1)[] = 3.7315260425215535100562647130573168396949768066406250000000000000000000;
    (ptr+=1)[] = 3.7847865529069855128341259842272847890853881835937500000000000000000000;
    (ptr+=1)[] = 3.8307364572718167750053908093832433223724365234375000000000000000000000;
    (ptr+=1)[] = 3.8695707876329894503442119457758963108062744140625000000000000000000000;
    (ptr+=1)[] = 3.9016774013682433697169926745118573307991027832031250000000000000000000;
    (ptr+=1)[] = 3.9276061421605548140689734282204881310462951660156250000000000000000000;
    (ptr+=1)[] = 3.9480279732894896227435310720466077327728271484375000000000000000000000;
    (ptr+=1)[] = 3.9636883003303475803136279864702373743057250976562500000000000000000000;
    (ptr+=1)[] = 3.9753592301354792049039588164305314421653747558593750000000000000000000;
    (ptr+=1)[] = 3.9837953659684881557723201694898307323455810546875000000000000000000000;
    (ptr+=1)[] = 3.9896969703921958405601344566093757748603820800781250000000000000000000;
    (ptr+=1)[] = 3.9936830958126972035415747086517512798309326171875000000000000000000000;
    (ptr+=1)[] = 3.9962758099085142760031885700300335884094238281250000000000000000000000;
    (ptr+=1)[] = 3.9978951735278598356160273397108539938926696777343750000000000000000000;
    (ptr+=1)[] = 3.9988633867338578831152062775800004601478576660156250000000000000000000;
    (ptr+=1)[] = 3.9994156749684628415764109377050772309303283691406250000000000000000000;
    (ptr+=1)[] = 3.9997151312716319182527513476088643074035644531250000000000000000000000;
    (ptr+=1)[] = 3.9998688563346247448748727038037031888961791992187500000000000000000000;
    (ptr+=1)[] = 3.9999432486297279432108098262688145041465759277343750000000000000000000;
    (ptr+=1)[] = 3.9999770287013616254512271552812308073043823242187500000000000000000000;
    (ptr+=1)[] = 3.9999913492087468824820462032221257686614990234375000000000000000000000;
  );
 
function kot_init(f, res)
  instance(ia0, b0, b1, b2, b3, b4, a0, a1, a2, a3, a4, alpha, iR9, TdivC7, C7divT)
  global(srate, slider54)
  local(fs, ap2, ap3, ap4, targetFreq, x0, x1, x2, x3, x4, x5, x6, x7)
  (
    fs = srate * max(1, slider54);
    targetFreq = 4194; /* Should be 4194 */
    alpha = targetFreq*2*$pi / tan(targetFreq*$pi/fs);
    
    ap2 = alpha*alpha;
    ap3 = alpha*ap2;
    ap4 = alpha*ap3;
    
    x0 = 0.01*alpha;
    x1 = ap3*(0.0000000060600000000000018208566131391792225491244039403682108968496323*res + 0.0000000014969999999999998969869420840906291958471996395019232295453548);
    x2 = ap2*(0.0000201000000000000006786238238021269353339448571205139160156250000000*res + 0.0000080100000000000012363070636678408220632263692095875740051269531250);
    x3 = ap4*(0.0000000000000089100000000000000257676479892952404404063860426932208725*res + 0.0000000000000008910000000000002786780816262836559381456364532445024729);
    x4 = x2 + x3;
    x5 = 0.02*alpha;
    x6 = 2*x1;
    x7 = -4*x3;
    
    b0 = x0 + x1 + x4;
    b1 = x5 - x6 + x7;
    b2 = -2*x2 + 6*x3;
    b3 = -x5 + x6 + x7;
    b4 = -x0 - x1 + x4;
    
    x0 = alpha*(0.0000100000000000000008180305391403130954586231382563710212707519531250*res + 0.0106009999999999993125499031521030701696872711181640625000000000000000);
    x1 = ap3*(0.0000000000608910000000000045891701104973771450229458324088227527681738*res + 0.0000000008970891000000000759592460660579466696917805279554158914834261);
    x2 = ap2*(0.0000001060000000000000094969808384602616424530197036801837384700775146*res + 0.0000060997000000000010778533447719507165629693190567195415496826171875);
    x3 = ap4*(0.0000000000000089100000000000000257676479892952404404063860426932208725*res + 0.0000000000000008910000000000002786780816262836559381456364532445024729);
    x4 = x2 + x3 + 1.0;
    x5 = 2*x1;
    x6 = 2*x0;
    x7 = -4*x3 + 4.0;

    a0 = x0 + x1 + x4;
    a1 = -x5 + x6 + x7;
    a2 = -2*x2 + 6*x3 + 6.0;
    a3 = x5 - x6 + x7;
    a4 =  -x0 - x1 + x4;

    ia0 = 1/a0;

    a1 = a1 * ia0;
    a2 = a2 * ia0;
    a3 = a3 * ia0;
    a4 = a4 * ia0;
    b0 = b0 * ia0;
    b1 = b1 * ia0;
    b2 = b2 * ia0;
    b3 = b3 * ia0;
    b4 = b4 * ia0;
    
    iR9 = 0.0001;
    TdivC7 = 10000000.0/fs;
    C7divT = 1/TdivC7;
  );  
 
function sinh(x)
  local()
  global()
  (
    .5*( exp(x) - exp(-x) )
  );
  
function cosh(x)
  local()
  global()
  (
    .5*( exp(x) + exp(-x) )
  );  
 
function kot_eval(sample) 
  instance(ia0, b0, b1, b2, b3, b4, a0, a1, a2, a3, a4, ic, icOut, Iin, iR9, TdivC7, C7divT
           dx1, dx2, dx3, dx4, dy1, dy2, dy3, dy4, sgn, ptr, ptr2 )
  global(srate, slider54, kot_LUT_x, kot_LUT_y)
  local(y, Vc, vout, x1, x2, y1, y2)
  (
    /////////////////////////////////////////////
    // Linear tone filter part
    /////////////////////////////////////////////
    y = b0 * sample + b1 * dx1 + b2 * dx2 + b3 * dx3 + b4 * dx4
                    - a1 * dy1 - a2 * dy2 - a3 * dy3 - a4 * dy4;

    dx4 = dx3;
    dx3 = dx2;
    dx2 = dx1;  
    dx1 = sample;

    dy4 = dy3;
    dy3 = dy2;
    dy2 = dy1;  
    dy1 = y;
    
    /////////////////////////////////////////////
    // Compute input current
    /////////////////////////////////////////////
    Vc = (y*iR9 + ic)/(TdivC7+iR9);
    Iin = (y-Vc)*iR9;
    ic = Vc*C7divT;

    sgn = sign(Iin);
    icOut = abs(Iin);

    icOut > 0.0031 ?
    (
      vout = 4;
    ) : (
      ptr   = kot_LUT_x;
      ptr2  = kot_LUT_y;
      while( icOut > ptr[] )
      (
        ptr += 1;
        ptr2 += 1;
      );
 
      y2 = ptr2[];
      y1 = (ptr2-1)[]; 
      x2 = ptr[];
      x1 = (ptr-1)[];
 
      vout = ((y2-y1) / (x2-x1)) * (icOut - x1) + y1;
    );
      
    vout*sgn*.2
  );
 
function kot_reset() 
  instance(b0, b1, b2, b3, b4, b5, b6, b7, a0, a1, a2, a3, a4, a5, a6, a7, ic, vout
           dx1, dx2, dx3, dx4, dy1, dy2, dy3, dy4)
  global(srate, slider54)
  local()
  (
    dx1 = dx2 = dx3 = dx4 = 0.00000001;
    dy1 = 1.1285 / 10000000000000000;
    dy2 = 4.7388 / 10000000000000000;
    dy3 = -1.1765 / 10000000000000000;
    dy4 = -4.7859 / 10000000000000000;
    ic = 3.686/1000000000000000000000000;
  ); 
 
function modulon_fixed_init(filterfreq, res)
  local(fact, fs)
  global(srate, slider54)
  instance(f, dt, svf)
  (
    //this.svf.init_linearSVF( filterfreq, res );
    
    fact = .5 * f_trafo_hz(filterfreq);
    this.svf.init_linearSVF_direct( fact, res );
    
    fs = srate * max(1, slider54);
    dt = 1/fs;
    
    f = .25 * fact;
    
    dt = dt * 2*$pi*srate*f;
  );
  
function modulatrix_init(filterfreq, res)
  local(fact)
  global(srate, slider54)
  instance(f, fs, dt, svf, reso)
  (
    //this.svf.init_linearSVF( filterfreq, res );
    fact = .125 * f_trafo_hz(filterfreq);
    this.svf.init_linearSVF_direct( fact, res );
    
    fs = srate * max(1, slider54);
    dt = 1/fs;
    f = .5 * fact;
    reso = res;
    
    dt = dt * 2*$pi*srate*f;
  );

function vibrato_init(filterfreq, res)
  local(fs, f, fact)
  global(srate, slider54)
  instance(dt, reso, ovs)
  (
    ovs   = max(1, slider54);
    fs   = srate * ovs;
    dt   = 1/fs;
    f    = .00125 * f_trafo_hz(filterfreq);
    reso = ( pow(10, res) - 1 ) / 9;
    
    dt = dt * 2*$pi*srate*f;
  );

function modulon_init(filterfreq, res)
  local()
  global(srate, slider54)
  instance(f, fs, dt, svf)
  (
    this.svf.init_linearSVF( filterfreq, res );
  
    fs = srate * max(1, slider54);
    dt = 1/fs;
    f = .5 * f_trafo_hz(filterfreq);
    
    dt = dt * 2*$pi*srate*f;
  );
   
function modulon_reset()
  local()
  global(srate, slider54)
  instance(fs, t, svf)
  (
    t = 0;
    
    this.svf.reset_linearSVF();
  );   
    
function octaver_init(filterfreq, res)
  local(f_est)
  global()
  instance(flipflopState, flipflopState2, bal1, bal2)
  (
    bal1 = filterFreq;
    bal2 = res;
    
    f_est = .005;
    this.svf.init_linearSVF_direct( f_est, 0 );
    this.svf2.init_linearSVF_direct( .5*f_est, 0 );
    this.svf3.init_linearSVF( .0005, 0 );
    this.svf4.init_linearSVF( .01, 0 ); //0.01
  ); 
  
function octaver_reset()
  local()
  global()
  instance(flipflopState, flipflopState2)
  (
    flipflopState = 1;
    flipflopState2 = 1;
    this.svf.reset_linearSVF();
    this.svf2.reset_linearSVF();
    this.svf3.reset_linearSVF();
    this.svf4.reset_linearSVF();
  );   
    
function octaverUp_init(filterfreq, res)
  local(f_est)
  global()
  instance(bal1, bal2)
  (
    bal1 = filterFreq;
    bal2 = res;
    
    this.svf1.init_linearSVF_direct( 0.001, 0 );
    this.svf2.init_linearSVF_direct( 0.001, 0 );
  ); 
  
function octaverUp_reset()
  local()
  global()
  instance()
  (
    this.svf1.reset_linearSVF();
    this.svf2.reset_linearSVF();
  );      
   
function metallic_init(filterFreq, reso)
  local()
  global(srate, slider54)
  instance(f, res, dt, dtref)
  (
    f = filterFreq;
    dtref = f_trafo_hz(filterfreq);
    dt = dtref/max(1, slider54);
    res = f_trafo_hz(reso);
  );   

function metallic_reset()
  local(x)
  global()
  instance(t)
  (
    x = 0;
    t = 0;
  );     
   
function frazzle_init(filterfreq, res)
  local(fs, f_est)
  global(srate, slider54)
  instance(f, dt bal2, dtref)
  (
    bal2 = res;
    dtref = f_trafo_hz(filterfreq);
    dt = dtref/max(1, slider54);
 
    this.svf1.init_linearSVF_direct( .25*filterFreq, 0 );
    this.svf2.init_linearSVF_direct( .25*filterFreq, 0 );
  ); 
  
function frazzle_reset()
  local()
  global()
  instance(t)
  (
    this.svf1.reset_linearSVF();
    this.svf2.reset_linearSVF();
    t = 0;
  );   

function phone_reset()
  local()
  instance(dx1, dx2, dx3, dx4, dx5, dx6, dx7, dx8, dx9, dx10,
           dy1, dy2, dy3, dy4, dy5, dy6, dy7, dy8, dy9, dy10)
  global()
  (
    dx1 = dx2 = dx3 = dx4 = dx5 = dx6 = dx7 = dx8 = dx9 = dx10 = dy1 = dy2 = dy3 = dy4 = dy5 = dy6 = dy7 = dy8 = dy9 = dy10 = 0;
  );
    
function phone_init(filterfreq, res)
  local(sr)
  global(srate, slider54)
  instance(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10,
           a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
           dx1, dx2, dx3, dx4, dx5, dx6, dx7, dx8, dx9, dx10,
           dy1, dy2, dy3, dy4, dy5, dy6, dy7, dy8, dy9, dy10, bal, cf, os )
  (
    os = max(1, slider54);
    sr = srate * max(1, slider54);
    ( sr < (44100 + 1) ) ? 
    (
      b0 = 0.00205760643761516330910166239220870920689776539802551269531250000000000000000000;
      b1 = -0.01300230403223860860262295346956307184882462024688720703125000000000000000000000;
      b2 = 0.03611773927007193296656595293825375847518444061279296875000000000000000000000000;
      b3 = -0.05559897873327889622485642462379473727196455001831054687500000000000000000000000;
      b4 = 0.04456592378198313830761634335431153886020183563232421875000000000000000000000000;
      b5 = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      b6 = -0.04456592378198315218540415116876829415559768676757812500000000000000000000000000;
      b7 = 0.05559897873327889622485642462379473727196455001831054687500000000000000000000000;
      b8 = -0.03611773927007192602767204903102538082748651504516601562500000000000000000000000;
      b9 = 0.01300230403223860686789947749275597743690013885498046875000000000000000000000000;
      b10 = -0.00205760643761516330910166239220870920689776539802551269531250000000000000000000;
      a0 = 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      a1 = -9.24232214711584632027552288491278886795043945312500000000000000000000000000000000;
      a2 = 38.74336175630326550844984012655913829803466796875000000000000000000000000000000000;
      a3 = -97.02631230369934201007708907127380371093750000000000000000000000000000000000000000;
      a4 = 160.78389497507961891642480622977018356323242187500000000000000000000000000000000000;
      a5 = -184.23786848061470777793147135525941848754882812500000000000000000000000000000000000;
      a6 = 147.85005776373105845777899958193302154541015625000000000000000000000000000000000000;
      a7 = -82.05166484355818568019458325579762458801269531250000000000000000000000000000000000;
      a8 = 30.13693741937723657997594273183494806289672851562500000000000000000000000000000000;
      a9 = -6.61494735462552529980939652887172996997833251953125000000000000000000000000000000;
      a10 = 0.65886321721615037638741796399699524044990539550781250000000000000000000000000000;
    
    ) : ( sr < (48000 + 1) ) ? 
    (
      b0 = 0.00181406623737622070546837704796416801400482654571533203125000000000000000000000;
      b1 = -0.01185691892466494458402426204202129156328737735748291015625000000000000000000000;
      b2 = 0.03391853660314574775425100483516871463507413864135742187500000000000000000000000;
      b3 = -0.05338568366902034234566798431842471472918987274169921875000000000000000000000000;
      b4 = 0.04337310212787757329744309231500665191560983657836914062500000000000000000000000;
      b5 = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      b6 = -0.04337310212787757329744309231500665191560983657836914062500000000000000000000000;
      b7 = 0.05338568366902034234566798431842471472918987274169921875000000000000000000000000;
      b8 = -0.03391853660314574775425100483516871463507413864135742187500000000000000000000000;
      b9 = 0.01185691892466494458402426204202129156328737735748291015625000000000000000000000;
      b10 = -0.00181406623737622070546837704796416801400482654571533203125000000000000000000000;
      a0 = 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      a1 = -9.32770196584267452521999075543135404586791992187500000000000000000000000000000000;
      a2 = 39.41528410689411998646392021328210830688476562500000000000000000000000000000000000;
      a3 = -99.37649975353495790386659791693091392517089843750000000000000000000000000000000000;
      a4 = 165.57592908894699235133884940296411514282226562500000000000000000000000000000000000;
      a5 = -190.50896195386002318628015927970409393310546875000000000000000000000000000000000000;
      a6 = 153.30449241522987335883954074233770370483398437500000000000000000000000000000000000;
      a7 = -85.19835879682526069700543303042650222778320312500000000000000000000000000000000000;
      a8 = 31.29461713520664289944761549122631549835205078125000000000000000000000000000000000;
      a9 = -6.86034916681714612707310152472928166389465332031250000000000000000000000000000000;
      a10 = 0.68154889151361119914440678257960826158523559570312500000000000000000000000000000;
    
    ) : ( sr < (88200 + 1) ) ? 
    (
      b0 = 0.00084778456917082383424710823049963437370024621486663818359375000000000000000000;
      b1 = -0.00636305696261136970182104022342173266224563121795654296875000000000000000000000;
      b2 = 0.02041987931497933270175160203052655560895800590515136718750000000000000000000000;
      b3 = -0.03500462986175388591103541102711460553109645843505859375000000000000000000000000;
      b4 = 0.02996292678355833363768034871554846176877617835998535156250000000000000000000000;
      b5 = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      b6 = -0.02996292678355831975989254090109170647338032722473144531250000000000000000000000;
      b7 = 0.03500462986175388591103541102711460553109645843505859375000000000000000000000000;
      b8 = -0.02041987931497933617119855398414074443280696868896484375000000000000000000000000;
      b9 = 0.00636305696261137577335320614224656310398131608963012695312500000000000000000000;
      b10 = -0.00084778456917082415950775997615096457593608647584915161132812500000000000000000;
      a0 = 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      a1 = -9.70341365893277618681622698204591870307922363281250000000000000000000000000000000;
      a2 = 42.45600693800650304865484940819442272186279296875000000000000000000000000000000000;
      a3 = -110.30487637891202723494643578305840492248535156250000000000000000000000000000000000;
      a4 = 188.45611354251255420422239694744348526000976562500000000000000000000000000000000000;
      a5 = -221.24029322655846385714539792388677597045898437500000000000000000000000000000000000;
      a6 = 180.74008653045305550222110468894243240356445312500000000000000000000000000000000000;
      a7 = -101.45865225370893369927216554060578346252441406250000000000000000000000000000000000;
      a8 = 37.45376813237525226440993719734251499176025390625000000000000000000000000000000000;
      a9 = -8.21033866888211782963935547741129994392395019531250000000000000000000000000000000;
      a10 = 0.81159904364919610575412889375002123415470123291015625000000000000000000000000000;
    ) : ( sr < (96000 + 1) ) ? 
    (
      b0 = 0.00077240479801301544990344005725546594476327300071716308593750000000000000000000;
      b1 = -0.00585378818700743857456059160426775633823126554489135742187500000000000000000000;
      b2 = 0.01893192711496094818302005080568051198497414588928222656250000000000000000000000;
      b3 = -0.03263791745070925010008267008743132464587688446044921875000000000000000000000000;
      b4 = 0.02803318231468709953446705185342580080032348632812500000000000000000000000000000;
      b5 = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      b6 = -0.02803318231468707871778534013174066785722970962524414062500000000000000000000000;
      b7 = 0.03263791745070926397787047790188807994127273559570312500000000000000000000000000;
      b8 = -0.01893192711496095165246700275929470080882310867309570312500000000000000000000000;
      b9 = 0.00585378818700743944192232959267130354419350624084472656250000000000000000000000;
      b10 = -0.00077240479801301577516409180290679614699911326169967651367187500000000000000000;
      a0 = 1.00000000000000000000000000000000000000000000000000000000000000000000000000000000;
      a1 = -9.73388341965657311050108546623960137367248535156250000000000000000000000000000000;
      a2 = 42.70972365355486033422494074329733848571777343750000000000000000000000000000000000;
      a3 = -111.24253483758502625278197228908538818359375000000000000000000000000000000000000000;
      a4 = 190.47411537594322794575418811291456222534179687500000000000000000000000000000000000;
      a5 = -224.02651069946892903317348100244998931884765625000000000000000000000000000000000000;
      a6 = 183.29820627959665557682455983012914657592773437500000000000000000000000000000000000;
      a7 = -103.01962347160191768580261850729584693908691406250000000000000000000000000000000000;
      a8 = 38.06378149602860361255807220004498958587646484375000000000000000000000000000000000;
      a9 = -8.34875104233623233085381798446178436279296875000000000000000000000000000000000000;
      a10 = 0.82547666552629450631428653650800697505474090576171875000000000000000000000000000;
    );
    
    cf = 1+8*filterfreq;
    bal = res;
  );    
  
function phone_eval(sample)
  local(y)
  global()
  instance(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10,
           a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
           dx1, dx2, dx3, dx4, dx5, dx6, dx7, dx8, dx9, dx10,
           dy1, dy2, dy3, dy4, dy5, dy6, dy7, dy8, dy9, dy10, p, bal, cf, yo, os )
  (
  
    y = b0 * sample + b1 * dx1 + b2 * dx2 + b3 * dx3 + b4 * dx4 + b5 * dx5 + b6 * dx6 + b7 * dx7 + b8 * dx8 + b9 * dx9 + b10 * dx10
                    - a1 * dy1 - a2 * dy2 - a3 * dy3 - a4 * dy4 - a5 * dy5 - a6 * dy6 - a7 * dy7 - a8 * dy8 - a9 * dy9 - a10 * dy10;
  
    dx10 = dx9;
    dx9  = dx8;
    dx8  = dx7;
    dx7  = dx6;
    dx6  = dx5;
    dx5  = dx4;
    dx4  = dx3;
    dx3  = dx2;
    dx2  = dx1;  
    dx1  = sample;
  
    dy10 = dy9;
    dy9  = dy8;
    dy8  = dy7;
    dy7  = dy6;
    dy6  = dy5;  
    dy5  = dy4;
    dy4  = dy3;
    dy3  = dy2;
    dy2  = dy1;  
    dy1  = y;
    
    p = p + 1;
    p > (4*os) ? (p = 0; yo = y;);
    y = (1-bal)*y + bal * yo;
    
    y = (1/cf)*tanh(cf*y)
  ); 
    
/* Run only when samplerate changes */
function dlop_init_srate(inrate)
  global()
  instance( A0_0_0, A0_0_1, A0_0_2, A0_0_5, A0_1_0, A0_1_1, A0_1_2, A0_1_5, A0_2_0, 
            A0_2_1, A0_2_2, A0_2_5, A0_3_3, A0_4_4, A0_5_0, A0_5_1, A0_5_2, A0_5_5, 
            A_0_0, A_0_1, A_0_2, A_0_3, A_0_4, A_0_5, A_1_0, A_1_1, A_1_2, A_1_3, 
            A_1_4, A_1_5, A_2_0, A_2_1, A_2_2, A_2_3, A_2_4, A_2_5, A_3_0, A_3_1, 
            A_3_2, A_3_3, A_3_4, A_3_5, A_4_0, A_4_1, A_4_2, A_4_3, A_4_4, A_4_5, 
            A_5_0, A_5_1, A_5_2, A_5_3, A_5_4, A_5_5, B0_0_0, B0_0_1, B0_1_0, B0_1_1, 
            B0_2_0, B0_2_1, B0_5_0, B0_5_1, B_0_0, B_0_1, B_1_0, B_1_1, B_2_0, B_2_1, 
            B_3_0, B_3_1, B_4_0, B_4_1, B_5_0, B_5_1, C0_0_0, C0_0_1, C0_0_2, C0_0_3, 
            C0_1_0, C0_1_1, C0_1_2, C0_1_3, C0_2_0, C0_2_1, C0_2_2, C0_2_3, C0_5_0, 
            C0_5_1, C0_5_2, C0_5_3, C_0_0, C_0_1, C_0_2, C_0_3, C_1_0, C_1_1, C_1_2, 
            C_1_3, C_2_0, C_2_1, C_2_2, C_2_3, C_3_0, C_3_1, C_3_2, C_3_3, C_4_0, C_4_1, 
            C_4_2, C_4_3, C_5_0, C_5_1, C_5_2, C_5_3, D0_0_0, D0_0_1, D0_0_2, D0_0_3, 
            D0_0_5, D_0_0, D_0_1, D_0_2, D_0_3, D_0_4, D_0_5, E0_0_0, E0_0_1, E_0_0, 
            E_0_1, F0_0_0, F0_0_1, F0_0_2, F0_0_3, F_0_0, F_0_1, F_0_2, F_0_3, G0_0_0, 
            G0_0_1, G0_0_2, G0_0_5, G0_1_0, G0_1_1, G0_1_2, G0_1_5, G0_2_0, G0_2_1, 
            G0_2_2, G0_2_5, G0_3_0, G0_3_1, G0_3_2, G0_3_5, GX_0_0, GX_1_1, GX_2_2, 
            GX_3_3, GX_4_4, GX_5_5, G_0_0, G_0_1, G_0_2, G_0_3, G_0_4, G_0_5, G_1_0, 
            G_1_1, G_1_2, G_1_3, G_1_4, G_1_5, G_2_0, G_2_1, G_2_2, G_2_3, G_2_4, G_2_5, 
            G_3_0, G_3_1, G_3_2, G_3_3, G_3_4, G_3_5, H0_0_0, H0_0_1, H0_1_0, H0_1_1, 
            H0_2_0, H0_2_1, H0_3_0, H0_3_1, H_0_0, H_0_1, H_1_0, H_1_1, H_2_0, H_2_1, 
            H_3_0, H_3_1, K0_0_0, K0_0_1, K0_0_2, K0_0_3, K0_1_0, K0_1_1, K0_1_2, K0_1_3, 
            K0_2_0, K0_2_1, K0_2_2, K0_2_3, K0_3_0, K0_3_1, K0_3_2, K0_3_3, K_0_0, K_0_1, 
            K_0_2, K_0_3, K_1_0, K_1_1, K_1_2, K_1_3, K_2_0, K_2_1, K_2_2, K_2_3, K_3_0, 
            K_3_1, K_3_2, K_3_3, Q_0_0, Q_0_1, Q_1_0, Q_1_1, U0_0_0, U0_0_1, UN_0_1, UN_1_1, 
            UN_2_0, UN_2_1, UN_3_1, UU_0_1, UU_1_1, UX_0_1, UX_1_1, UX_2_1, UX_3_0, UX_4_0,
            UX_4_1, UX_5_1, Ui, x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, xnm1_1, xnm1_2, 
            xnm1_3, xnm1_4, xnm1_5, xnm1_6, y_0_0,
            l_srate
             )
  local(    inv_S0_0_13, inv_S0_10_10, inv_S0_10_14, inv_S0_11_1, inv_S0_11_11, inv_S0_11_13, 
            inv_S0_11_14, inv_S0_11_2, inv_S0_11_3, inv_S0_11_5, inv_S0_11_6, inv_S0_11_7, 
            inv_S0_11_8, inv_S0_11_9, inv_S0_12_14, inv_S0_13_0, inv_S0_13_1, inv_S0_13_11, 
            inv_S0_13_13, inv_S0_13_14, inv_S0_13_2, inv_S0_13_3, inv_S0_13_5, inv_S0_13_6, 
            inv_S0_13_7, inv_S0_13_8, inv_S0_13_9, inv_S0_14_1, inv_S0_14_10, inv_S0_14_11, 
            inv_S0_14_12, inv_S0_14_13, inv_S0_14_14, inv_S0_14_2, inv_S0_14_3, inv_S0_14_5, 
            inv_S0_14_6, inv_S0_14_7, inv_S0_14_8, inv_S0_14_9, inv_S0_1_1, inv_S0_1_11, 
            inv_S0_1_13, inv_S0_1_14, inv_S0_1_2, inv_S0_1_3, inv_S0_1_5, inv_S0_1_6, inv_S0_1_7, 
            inv_S0_1_8, inv_S0_1_9, inv_S0_2_1, inv_S0_2_11, inv_S0_2_13, inv_S0_2_14, inv_S0_2_2, 
            inv_S0_2_3, inv_S0_2_5, inv_S0_2_6, inv_S0_2_7, inv_S0_2_8, inv_S0_2_9, inv_S0_3_1, 
            inv_S0_3_11, inv_S0_3_13, inv_S0_3_14, inv_S0_3_2, inv_S0_3_3, inv_S0_3_5, inv_S0_3_6, 
            inv_S0_3_7, inv_S0_3_8, inv_S0_3_9, inv_S0_4_4, inv_S0_5_1, inv_S0_5_11, inv_S0_5_13, 
            inv_S0_5_14, inv_S0_5_2, inv_S0_5_3, inv_S0_5_5, inv_S0_5_6, inv_S0_5_7, inv_S0_5_8, 
            inv_S0_5_9, inv_S0_6_1, inv_S0_6_11, inv_S0_6_13, inv_S0_6_14, inv_S0_6_2, inv_S0_6_3, 
            inv_S0_6_5, inv_S0_6_6, inv_S0_6_7, inv_S0_6_8, inv_S0_6_9, inv_S0_7_1, inv_S0_7_11, 
            inv_S0_7_13, inv_S0_7_14, inv_S0_7_2, inv_S0_7_3, inv_S0_7_5, inv_S0_7_6, inv_S0_7_7, 
            inv_S0_7_8, inv_S0_7_9, inv_S0_8_1, inv_S0_8_11, inv_S0_8_13, inv_S0_8_14, inv_S0_8_2, 
            inv_S0_8_3, inv_S0_8_5, inv_S0_8_6, inv_S0_8_7, inv_S0_8_8, inv_S0_8_9, inv_S0_9_1, 
            inv_S0_9_11, inv_S0_9_13, inv_S0_9_14, inv_S0_9_2, inv_S0_9_3, inv_S0_9_5, inv_S0_9_6, 
            inv_S0_9_7, inv_S0_9_8, inv_S0_9_9, csrate,
          
             
         t0, t1, t2, t3, t4, t5, t6, t7, t8, t9,
         t10, t11, t12, t13, t14, t15, t16, t17, t18, t19,
         t20, t21, t22, t23, t24, t25, t26, t27, t28, t29,
         t30, t31, t32, t33, t34, t35, t36, t37, t38, t39,
         t40, t41, t42, t43, t44, t45, t46, t47, t48, t49,
         t50, t51, t52, t53, t54, t55, t56, t57, t58, t59,
         t60, t61, t62, t63, t64, t65, t66, t67, t68, t69,
         t70, t71, t72, t73, t74, t75, t76, t77, t78, t79,               
         t80, t81, t82, t83, t84, t85, t86, t87, t88, t89,
         t90, t91, t92, t93, t94, t95, t96, t97, t98, t99,
         t100, t101, t102, t103, t104, t105, t106, t107, t108, t109,
         t110, t111, t112, t113, t114, t115, t116, t117, t118, t119,
         t120, t121, t122, t123, t124, t125, t126, t127, t128, t129,
         t130, t131, t132, t133, t134, t135, t136, t137, t138, t139,
         t140, t141, t142, t143, t144, t145, t146, t147, t148
    )
   (
      csrate = l_srate = inrate;
   
      t2 = csrate*0.0000000200000000000000000;
      t3 = csrate*0.0000004400000000000000200;
      GX_0_0 = t2;
      GX_1_1 = csrate*0.0000093999999999999998000;
      GX_2_2 = t2;
      GX_3_3 = t3;
      GX_4_4 = t3;
      GX_5_5 = 1.0/csrate;

      t2 = csrate*csrate;
      t3 = t2*t2;
      t4 = csrate*104148997837773310000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t5 = t2*168049188362960990000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t6 = csrate*t2*37900260583325013000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t7 = t3*4161400794005249200000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t8 = t4+t5+t6+t7+156587379389530910000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t9 = 1.0/t8;
      t10 = csrate*311676187869396580000000000.0000000000000000000000000;
      t11 = t2*71779970539618612000000.0000000000000000000000000;
      t12 = csrate*t2*1888946593147857900.0000000000000000000000000;
      t13 = t10+t11+t12;
      t14 = t9*t13*2147418458039436100000000000000000000000000000000000000000000000.0000000000000000000000000;
      t15 = csrate*1028165922870751900000000000000000000000000000.0000000000000000000000000;
      t16 = t2*45784920068708670000000000000000000000000.0000000000000000000000000;
      t17 = csrate*t2*9664759674985072600000000000000000000000.0000000000000000000000000;
      t18 = t15+t16+t17;
      t19 = csrate*103936039001803500000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t20 = t2*27001923363579069000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t21 = csrate*t2*5482265284429159900000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t22 = t3*494703213269570820000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t23 = t19+t20+t21+t22+156587379389530910000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t24 = csrate*198359885140591300000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t25 = t2*2792704785718975200000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t26 = csrate*t2*2458305008225491000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t27 = t3*436489500783226260000000000000000000000000000000000000000000.0000000000000000000000000;
      t28 = t24+t25+t26+t27;
      t29 = t9*t28*77069021000432611000000.0000000000000000000000000;
      t30 = csrate*2340686216037774100000000000000000000000000000.0000000000000000000000000;
      t31 = t2*469921302823437300000000000000000000000000.0000000000000000000000000;
      t32 = csrate*t2*12131605388000659000000000000000000000.0000000000000000000000000;
      t33 = t30+t31+t32+1471849183103021100000000000000000000000000000000.0000000000000000000000000;
      t34 = csrate*1888946593147857900.0000000000000000000000000;
      t35 = t34+9444732965739290400000.0000000000000000000000000;
      t36 = t9*t33*334362901746586200000000000000000000000000000.0000000000000000000000000;
      t37 = csrate*6422418416702718000.0000000000000000000000000;
      t38 = t37+4722366482869645200000.0000000000000000000000000;
      t39 = csrate*45784920068708670000000000000000000000000.0000000000000000000000000;
      t40 = t2*9664759674985072600000000000000000000000.0000000000000000000000000;
      t41 = t39+t40+1028165922870751900000000000000000000000000000.0000000000000000000000000;
      t42 = csrate*2696778064686603100000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t43 = t2*4351314231925824000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t44 = csrate*t2*981354042057917920000000000000000000000000000000000000000000000.0000000000000000000000000;
      t45 = t3*107751315918617600000000000000000000000000000000000000000000.0000000000000000000000000;
      t46 = t42+t43+t44+t45+4081635542626462800000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t47 = t9*t46*811656739243220270000000.0000000000000000000000000;
      t48 = csrate*52512715289510461000.0000000000000000000000000;
      t49 = t48+37778931862957162000000.0000000000000000000000000;
      t50 = csrate+33000.0000000000000000000000000;
      t51 = t9*t13*48024085516154660000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t52 = t9*t33*7477570348150926100000000000000000000000000000.0000000000000000000000000;
      t53 = csrate*38157467064493842000000000000000000000000000000.0000000000000000000000000;
      t54 = t2*8623430559329410300000000000000000000000000.0000000000000000000000000;
      t55 = csrate*t2*947264293648945560000000000000000000000.0000000000000000000000000;
      t56 = t53+t54+t55+23549586929648338000000000000000000000000000000000.0000000000000000000000000;
      t57 = t9*t56*20897681359161640000000000000000000000000000.0000000000000000000000000;
      t58 = csrate*19078733532246921000000000000000000000000000000.0000000000000000000000000;
      t59 = t2*3840723541071737800000000000000000000000000.0000000000000000000000000;
      t60 = csrate*t2*99193714643064222000000000000000000000.0000000000000000000000000;
      t61 = t58+t59+t60+11774793464824169000000000000000000000000000000000.0000000000000000000000000;
      t62 = t9*t61*41795362718323270000000000000000000000000000.0000000000000000000000000;
      t63 = csrate*9444732965739290400000.0000000000000000000000000;
      t64 = t2*1888946593147857900.0000000000000000000000000;
      t65 = t63+t64;
      t66 = t9*t35*t49*t50*41795362718323270000000000000000000000000000.0000000000000000000000000;
      t67 = csrate*t9*t49*t50*78949208016155746000000000000000000000000000000000000000000000.0000000000000000000000000;
      t68 = t9*t13*31579683206462300000000000000000000000000000000000000000000.0000000000000000000000000;
      t69 = t9*t46*36893488147419099000.0000000000000000000000000;
      t70 = csrate*156587379389530910000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t71 = t2*104148997837773310000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t72 = csrate*t2*168049188362960990000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t73 = t3*37900260583325013000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t74 = csrate*t3*4161400794005249200000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t75 = t70+t71+t72+t73+t74;
      t76 = 1.0/t75;
      t77 = csrate*435224570844252000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t78 = t2*702254400438290970000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t79 = csrate*t2*158379958263682010000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t80 = t3*17389918765192671000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t81 = t77+t78+t79+t80+654544300496910220000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000;
      t82 = t9*t81*117500.0000000000000000000000000;
      t83 = csrate*t9*t18*2911585293120157700000000000000000000000000.0000000000000000000000000;
      t84 = csrate*1246704751477586100000000000.0000000000000000000000000;
      t85 = t2*1770698536416802100000000.0000000000000000000000000;
      t86 = csrate*t2*52512715289510461000.0000000000000000000000000;
      t87 = t84+t85+t86;
      t88 = t9*t87*78949208016155746000000000000000000000000000000000000000000000.0000000000000000000000000;
      t89 = t9*t23;
      t90 = t9*t28*1133367955888715000.0000000000000000000000000;
      t91 = t9*t13*706236551708156790000000000000000000000000000000000000000000.0000000000000000000000000;
      t92 = csrate*t9*t18*42817430781178802000000000000000000000.0000000000000000000000000;
      t93 = t9*t13*97609929910883467000000000000000000000000000000000000000000.0000000000000000000000000;
      t94 = t9*t33*15198313715753920000000000000000000000000.0000000000000000000000000;
      t95 = t9*t56*949894607234619870000000000000000000000.0000000000000000000000000;
      t96 = t9*t13*1435440145748286000000000000000000000000000000000000000.0000000000000000000000000;
      inv_S0_0_13 = 1.0;
      inv_S0_1_1 = t9*t23*68000.0000000000000000000000000;
      inv_S0_1_2 = t29;
      inv_S0_1_3 = t14;
      inv_S0_1_5 = t51;
      inv_S0_1_6 = t9*t18*t35*1541380420008652100000000.0000000000000000000000000;
      inv_S0_1_7 = t14;
      inv_S0_1_8 = t14;
      inv_S0_1_9 = t14;
      inv_S0_1_11 = t83;
      inv_S0_1_13 = t89;
      inv_S0_1_14 = t93;
      inv_S0_2_1 = t29;
      inv_S0_2_2 = t9*(csrate*14462125656090909000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t2*29544935823730000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t3*2803318208527567900000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t2*17849526747323131000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+936728073133800930000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000)*12000.0000000000000000000000000;
      inv_S0_2_3 = t36;
      inv_S0_2_5 = t52;
      inv_S0_2_6 = t9*t35*t38*t41*240000.0000000000000000000000000;
      inv_S0_2_7 = t36;
      inv_S0_2_8 = t36;
      inv_S0_2_9 = t36;
      inv_S0_2_11 = csrate*t9*t38*t41*453347182355486010000000.0000000000000000000000000;
      inv_S0_2_13 = t90;
      inv_S0_2_14 = t94;
      inv_S0_3_1 = t14;
      inv_S0_3_2 = t36;
      inv_S0_3_3 = t47;
      inv_S0_3_5 = t57;
      inv_S0_3_6 = t66;
      inv_S0_3_7 = t47;
      inv_S0_3_8 = t47;
      inv_S0_3_9 = t47;
      inv_S0_3_11 = t67;
      inv_S0_3_13 = t68;
      inv_S0_3_14 = t69;
      inv_S0_4_4 = 390.0000000000000000000000000;
      inv_S0_5_1 = t51;
      inv_S0_5_2 = t52;
      inv_S0_5_3 = t57;
      inv_S0_5_5 = t9*t56*467348146759432880000000000000000000000000000.0000000000000000000000000;
      inv_S0_5_6 = t9*t35*t49*t50*934696293518865770000000000000000000000000000.0000000000000000000000000;
      inv_S0_5_7 = t57;
      inv_S0_5_8 = t57;
      inv_S0_5_9 = t57;
      inv_S0_5_11 = csrate*t9*t49*t50*1765591379270392000000000000000000000000000000000000000000000000.0000000000000000000000000;
      inv_S0_5_13 = t91;
      inv_S0_5_14 = t95;
      inv_S0_6_1 = t9*t41*t65*1541380420008652100000000.0000000000000000000000000;
      inv_S0_6_2 = t9*t41*(csrate*69578325019415553000000000000000000000000.0000000000000000000000000+t2*12131605388000659000000000000000000000.0000000000000000000000000+44601490397061246000000000000000000000000000.0000000000000000000000000)*240000.0000000000000000000000000;
      inv_S0_6_3 = t62;
      inv_S0_6_5 = t9*t61*934696293518865770000000000000000000000000000.0000000000000000000000000;
      inv_S0_6_6 = t9*t35*t41*t49*30000.0000000000000000000000000;
      inv_S0_6_7 = t62;
      inv_S0_6_8 = t62;
      inv_S0_6_9 = t62;
      inv_S0_6_11 = csrate*t9*t41*t49*56668397794435743000000.0000000000000000000000000;
      inv_S0_6_13 = t9*t41*t65*22667359117774299000.0000000000000000000000000;
      inv_S0_6_14 = t9*t61*1899789214469240000000000000000000000000.0000000000000000000000000;
      inv_S0_7_1 = t14;
      inv_S0_7_2 = t36;
      inv_S0_7_3 = t47;
      inv_S0_7_5 = t57;
      inv_S0_7_6 = t66;
      inv_S0_7_7 = t76*(csrate*211213336231417100000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t2*2262293496318552100000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t3*709262708789508200000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t2*3183761219565277800000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t3*76962231920350745000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+313174758779061810000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000)*1136363.6363636360000000000000000;
      inv_S0_7_8 = t47;
      inv_S0_7_9 = t47;
      inv_S0_7_11 = t67;
      inv_S0_7_13 = t68;
      inv_S0_7_14 = t69;
      inv_S0_8_1 = t14;
      inv_S0_8_2 = t36;
      inv_S0_8_3 = t47;
      inv_S0_8_5 = t57;
      inv_S0_8_6 = t66;
      inv_S0_8_7 = t47;
      inv_S0_8_8 = t76*(csrate*1386456035398161900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t2*227770380898722010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t3*82313914752666519000000000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t2*365174096951867380000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t3*9033372646822891300000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+1573325515041519100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000)*0.0000000002261962984145006;
      inv_S0_8_9 = t82;
      inv_S0_8_11 = t67;
      inv_S0_8_13 = t68;
      inv_S0_8_14 = t69;
      inv_S0_9_1 = t14;
      inv_S0_9_2 = t36;
      inv_S0_9_3 = t47;
      inv_S0_9_5 = t57;
      inv_S0_9_6 = t66;
      inv_S0_9_7 = t47;
      inv_S0_9_8 = t82;
      inv_S0_9_9 = t82;
      inv_S0_9_11 = t67;
      inv_S0_9_13 = t68;
      inv_S0_9_14 = t69;
      inv_S0_10_10 = 1000.0000000000000000000000000;
      inv_S0_10_14 = 1.0;
      inv_S0_11_1 = t83;
      inv_S0_11_2 = t9*t18*t38*453347182355486010000000.0000000000000000000000000;
      inv_S0_11_3 = t88;
      inv_S0_11_5 = t9*t87*1765591379270392000000000000000000000000000000000000000000000000.0000000000000000000000000;
      inv_S0_11_6 = t9*t18*t49*56668397794435743000000.0000000000000000000000000;
      inv_S0_11_7 = t88;
      inv_S0_11_8 = t88;
      inv_S0_11_9 = t88;
      inv_S0_11_11 = t9*(csrate*104117680361895400000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t2*147269675713816010000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+t3*2876050239882790100000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t2*8509478391503055200000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000+156587379389530910000000000000000000000000000000000000000000000000000000000000000000000000.0000000000000000000000000)*10000.0000000000000000000000000;
      inv_S0_11_13 = t92;
      inv_S0_11_14 = t9*t87*3588600364370715800000000000000000000000000000000000000000.0000000000000000000000000;
      inv_S0_12_14 = 1.0;
      inv_S0_13_0 = 1.0;
      inv_S0_13_1 = t89;
      inv_S0_13_2 = t90;
      inv_S0_13_3 = t68;
      inv_S0_13_5 = t91;
      inv_S0_13_6 = t9*t18*t35*22667359117774299000.0000000000000000000000000;
      inv_S0_13_7 = t68;
      inv_S0_13_8 = t68;
      inv_S0_13_9 = t68;
      inv_S0_13_11 = t92;
      inv_S0_13_13 = t9*(csrate*4144833420848175700000000000000000000000000000000000000000000000000.0000000000000000000000000+t2*2745213248496893100000000000000000000000000000000000000000000000000.0000000000000000000000000+t3*71365203550109241000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t2*630953816684278590000000000000000000000000000000000000000000000.0000000000000000000000000)*(-755578637259143.2500000000000000000000000);
      inv_S0_13_14 = t96;
      inv_S0_14_1 = t93;
      inv_S0_14_2 = t94;
      inv_S0_14_3 = t69;
      inv_S0_14_5 = t95;
      inv_S0_14_6 = t9*t35*t49*t50*1899789214469240000000000000000000000000.0000000000000000000000000;
      inv_S0_14_7 = t69;
      inv_S0_14_8 = t69;
      inv_S0_14_9 = t69;
      inv_S0_14_10 = 1.0;
      inv_S0_14_11 = csrate*t9*t49*t50*3588600364370715800000000000000000000000000000000000000000.0000000000000000000000000;
      inv_S0_14_12 = 1.0;
      inv_S0_14_13 = t96;
      inv_S0_14_14 = t9*(csrate*673948906620952620000000000000000000000000000000000000000000000000000.0000000000000000000000000+t2*1087773051233548000000000000000000000000000000000000000000000000000.0000000000000000000000000+t3*26937828979654412000000000000000000000000000000000000000000.0000000000000000000000000+csrate*t2*245332413224081180000000000000000000000000000000000000000000000.0000000000000000000000000+868826406265596790000000000000000000000000000000000000000000000000000.0000000000000000000000000)*(-313987133169524.3100000000000000000000000);

      UX_0_1 = -inv_S0_1_8+inv_S0_2_8;
      UX_1_1 = inv_S0_5_8;
      UX_2_1 = inv_S0_6_8-inv_S0_11_8;
      UX_3_0 = inv_S0_3_7-inv_S0_3_8-inv_S0_7_7+inv_S0_7_8;
      UX_4_0 = inv_S0_8_7-inv_S0_8_8-inv_S0_9_7+inv_S0_9_8;
      UX_4_1 = inv_S0_8_8-inv_S0_9_8;
      UX_5_1 = inv_S0_5_8-inv_S0_6_8;

      U0_0_0 = inv_S0_7_7-inv_S0_7_8;
      U0_0_1 = inv_S0_7_8;

      UN_0_1 = -inv_S0_2_8+inv_S0_3_8;
      UN_1_1 = inv_S0_3_8;
      UN_2_0 = -inv_S0_9_7+inv_S0_9_8;
      UN_2_1 = -inv_S0_9_8;
      UN_3_1 = -inv_S0_11_8;

      UU_0_1 = inv_S0_13_8;
      UU_1_1 = inv_S0_14_8;

      t2 = csrate*inv_S0_2_5*0.0000000400000000000000010;
      t3 = csrate*inv_S0_2_6*0.0000000400000000000000010;
      t4 = csrate*inv_S0_5_5*0.0000188000000000000000000;
      t5 = csrate*inv_S0_5_6*0.0000188000000000000000000;
      t6 = csrate*inv_S0_6_5*0.0000000400000000000000010;
      t7 = csrate*inv_S0_6_6*0.0000000400000000000000010;
      t8 = 1.0/csrate;
      t9 = inv_S0_6_5*t8*2.0;
      t10 = inv_S0_6_6*t8*2.0;
      A0_0_0 = csrate*inv_S0_1_1*0.0000000400000000000000010-csrate*inv_S0_1_2*0.0000000400000000000000010-csrate*inv_S0_2_1*0.0000000400000000000000010+csrate*inv_S0_2_2*0.0000000400000000000000010-1.0;
      A0_0_1 = t2-csrate*inv_S0_1_5*0.0000000400000000000000010;
      A0_0_2 = t3-csrate*inv_S0_1_6*0.0000000400000000000000010+csrate*inv_S0_1_11*0.0000000400000000000000010-csrate*inv_S0_2_11*0.0000000400000000000000010;
      A0_0_5 = t2-t3-csrate*inv_S0_1_5*0.0000000400000000000000010+csrate*inv_S0_1_6*0.0000000400000000000000010;
      A0_1_0 = csrate*inv_S0_5_1*(-0.0000188000000000000000000)+csrate*inv_S0_5_2*0.0000188000000000000000000;
      A0_1_1 = t4-1.0;
      A0_1_2 = t5-csrate*inv_S0_5_11*0.0000188000000000000000000;
      A0_1_5 = t4-t5;
      A0_2_0 = csrate*inv_S0_6_1*(-0.0000000400000000000000010)+csrate*inv_S0_6_2*0.0000000400000000000000010+csrate*inv_S0_11_1*0.0000000400000000000000010-csrate*inv_S0_11_2*0.0000000400000000000000010;
      A0_2_1 = t6-csrate*inv_S0_11_5*0.0000000400000000000000010;
      A0_2_2 = t7-csrate*inv_S0_11_6*0.0000000400000000000000010-csrate*inv_S0_6_11*0.0000000400000000000000010+csrate*inv_S0_11_11*0.0000000400000000000000010-1.0;
      A0_2_5 = t6-t7-csrate*inv_S0_11_5*0.0000000400000000000000010+csrate*inv_S0_11_6*0.0000000400000000000000010;
      A0_3_3 = csrate*inv_S0_3_3*0.0000008800000000000000400-csrate*inv_S0_3_7*0.0000008800000000000000400-csrate*inv_S0_7_3*0.0000008800000000000000400+csrate*inv_S0_7_7*0.0000008800000000000000400-1.0;
      A0_4_4 = csrate*inv_S0_8_8*0.0000008800000000000000400-csrate*inv_S0_8_9*0.0000008800000000000000400-csrate*inv_S0_9_8*0.0000008800000000000000400+csrate*inv_S0_9_9*0.0000008800000000000000400-1.0;
      A0_5_0 = inv_S0_5_1*t8*2.0-inv_S0_5_2*t8*2.0-inv_S0_6_1*t8*2.0+inv_S0_6_2*t8*2.0;
      A0_5_1 = t9-inv_S0_5_5*t8*2.0;
      A0_5_2 = t10-inv_S0_5_6*t8*2.0+inv_S0_5_11*t8*2.0-inv_S0_6_11*t8*2.0;
      A0_5_5 = t9-t10-inv_S0_5_5*t8*2.0+inv_S0_5_6*t8*2.0+1.0;

      t2 = 1.0/csrate;
      B0_0_0 = csrate*inv_S0_1_13*(-0.0000000400000000000000010)+csrate*inv_S0_2_13*0.0000000400000000000000010;
      B0_0_1 = csrate*inv_S0_1_14*(-0.0000000400000000000000010)+csrate*inv_S0_2_14*0.0000000400000000000000010;
      B0_1_0 = csrate*inv_S0_5_13*0.0000188000000000000000000;
      B0_1_1 = csrate*inv_S0_5_14*0.0000188000000000000000000;
      B0_2_0 = csrate*inv_S0_6_13*0.0000000400000000000000010-csrate*inv_S0_11_13*0.0000000400000000000000010;
      B0_2_1 = csrate*inv_S0_6_14*0.0000000400000000000000010-csrate*inv_S0_11_14*0.0000000400000000000000010;
      B0_5_0 = inv_S0_5_13*t2*-2.0+inv_S0_6_13*t2*2.0;
      B0_5_1 = inv_S0_5_14*t2*-2.0+inv_S0_6_14*t2*2.0;

      t2 = csrate*inv_S0_2_3*0.0000000400000000000000010;
      t3 = csrate*inv_S0_5_3*0.0000188000000000000000000;
      t4 = csrate*inv_S0_6_3*0.0000000400000000000000010;
      t5 = 1.0/csrate;
      t6 = inv_S0_6_3*t5*2.0;
      C0_0_0 = t2+csrate*inv_S0_1_2*0.0000000400000000000000010-csrate*inv_S0_1_3*0.0000000400000000000000010-csrate*inv_S0_2_2*0.0000000400000000000000010;
      C0_0_1 = t2-csrate*inv_S0_1_3*0.0000000400000000000000010;
      C0_0_2 = csrate*inv_S0_1_9*0.0000000400000000000000010-csrate*inv_S0_2_9*0.0000000400000000000000010;
      C0_0_3 = csrate*inv_S0_1_11*0.0000000400000000000000010-csrate*inv_S0_2_11*0.0000000400000000000000010;
      C0_1_0 = t3-csrate*inv_S0_5_2*0.0000188000000000000000000;
      C0_1_1 = t3;
      C0_1_2 = csrate*inv_S0_5_9*(-0.0000188000000000000000000);
      C0_1_3 = csrate*inv_S0_5_11*(-0.0000188000000000000000000);
      C0_2_0 = t4-csrate*inv_S0_6_2*0.0000000400000000000000010+csrate*inv_S0_11_2*0.0000000400000000000000010-csrate*inv_S0_11_3*0.0000000400000000000000010;
      C0_2_1 = t4-csrate*inv_S0_11_3*0.0000000400000000000000010;
      C0_2_2 = csrate*inv_S0_6_9*(-0.0000000400000000000000010)+csrate*inv_S0_11_9*0.0000000400000000000000010;
      C0_2_3 = csrate*inv_S0_6_11*(-0.0000000400000000000000010)+csrate*inv_S0_11_11*0.0000000400000000000000010;
      C0_5_0 = t6+inv_S0_5_2*t5*2.0-inv_S0_5_3*t5*2.0-inv_S0_6_2*t5*2.0;
      C0_5_1 = t6-inv_S0_5_3*t5*2.0;
      C0_5_2 = inv_S0_5_9*t5*2.0-inv_S0_6_9*t5*2.0;
      C0_5_3 = inv_S0_5_11*t5*2.0-inv_S0_6_11*t5*2.0;

      D0_0_0 = -inv_S0_7_1+inv_S0_7_2;
      D0_0_1 = inv_S0_7_5;
      D0_0_2 = inv_S0_7_6-inv_S0_7_11;
      D0_0_3 = inv_S0_7_3-inv_S0_7_7;
      D0_0_5 = inv_S0_7_5-inv_S0_7_6;

      E0_0_0 = inv_S0_7_13;
      E0_0_1 = inv_S0_7_14;

      F0_0_0 = -inv_S0_7_2+inv_S0_7_3;
      F0_0_1 = inv_S0_7_3;
      F0_0_2 = -inv_S0_7_9;
      F0_0_3 = -inv_S0_7_11;

      G0_0_0 = inv_S0_2_1-inv_S0_2_2-inv_S0_3_1+inv_S0_3_2;
      G0_0_1 = -inv_S0_2_5+inv_S0_3_5;
      G0_0_2 = -inv_S0_2_6+inv_S0_3_6+inv_S0_2_11-inv_S0_3_11;
      G0_0_5 = -inv_S0_2_5+inv_S0_2_6+inv_S0_3_5-inv_S0_3_6;
      G0_1_0 = -inv_S0_3_1+inv_S0_3_2;
      G0_1_1 = inv_S0_3_5;
      G0_1_2 = inv_S0_3_6-inv_S0_3_11;
      G0_1_5 = inv_S0_3_5-inv_S0_3_6;
      G0_2_0 = inv_S0_9_1-inv_S0_9_2;
      G0_2_1 = -inv_S0_9_5;
      G0_2_2 = -inv_S0_9_6+inv_S0_9_11;
      G0_2_5 = -inv_S0_9_5+inv_S0_9_6;
      G0_3_0 = inv_S0_11_1-inv_S0_11_2;
      G0_3_1 = -inv_S0_11_5;
      G0_3_2 = -inv_S0_11_6+inv_S0_11_11;
      G0_3_5 = -inv_S0_11_5+inv_S0_11_6;

      H0_0_0 = -inv_S0_2_13+inv_S0_3_13;
      H0_0_1 = -inv_S0_2_14+inv_S0_3_14;
      H0_1_0 = inv_S0_3_13;
      H0_1_1 = inv_S0_3_14;
      H0_2_0 = -inv_S0_9_13;
      H0_2_1 = -inv_S0_9_14+inv_S0_10_14;
      H0_3_0 = -inv_S0_11_13;
      H0_3_1 = inv_S0_10_14-inv_S0_11_14;

      K0_0_0 = inv_S0_2_2-inv_S0_2_3-inv_S0_3_2+inv_S0_3_3;
      K0_0_1 = -inv_S0_2_3+inv_S0_3_3;
      K0_0_2 = inv_S0_2_9-inv_S0_3_9;
      K0_0_3 = inv_S0_2_11-inv_S0_3_11;
      K0_1_0 = -inv_S0_3_2+inv_S0_3_3;
      K0_1_1 = inv_S0_3_3+inv_S0_4_4;
      K0_1_2 = -inv_S0_3_9;
      K0_1_3 = -inv_S0_3_11;
      K0_2_0 = inv_S0_9_2-inv_S0_9_3;
      K0_2_1 = -inv_S0_9_3;
      K0_2_2 = inv_S0_9_9+inv_S0_10_10;
      K0_2_3 = inv_S0_9_11+inv_S0_10_10;
      K0_3_0 = inv_S0_11_2-inv_S0_11_3;
      K0_3_1 = -inv_S0_11_3;
      K0_3_2 = inv_S0_11_9+inv_S0_10_10;
      K0_3_3 = inv_S0_10_10+inv_S0_11_11;

      Q_0_0 = inv_S0_7_7-inv_S0_7_8-inv_S0_8_7+inv_S0_8_8;
      Q_0_1 = inv_S0_7_8-inv_S0_8_8;
      Q_1_0 = inv_S0_8_7-inv_S0_8_8;
      Q_1_1 = inv_S0_8_8;
);

/* Run only when samplerate changes */
function dlop_init_cutoff(filterFreq, reso)
  global(srate)
  instance( A0_0_0, A0_0_1, A0_0_2, A0_0_5, A0_1_0, A0_1_1, A0_1_2, A0_1_5, A0_2_0, 
            A0_2_1, A0_2_2, A0_2_5, A0_3_3, A0_4_4, A0_5_0, A0_5_1, A0_5_2, A0_5_5, 
            A_0_0, A_0_1, A_0_2, A_0_3, A_0_4, A_0_5, A_1_0, A_1_1, A_1_2, A_1_3, 
            A_1_4, A_1_5, A_2_0, A_2_1, A_2_2, A_2_3, A_2_4, A_2_5, A_3_0, A_3_1, 
            A_3_2, A_3_3, A_3_4, A_3_5, A_4_0, A_4_1, A_4_2, A_4_3, A_4_4, A_4_5, 
            A_5_0, A_5_1, A_5_2, A_5_3, A_5_4, A_5_5, B0_0_0, B0_0_1, B0_1_0, B0_1_1, 
            B0_2_0, B0_2_1, B0_5_0, B0_5_1, B_0_0, B_0_1, B_1_0, B_1_1, B_2_0, B_2_1, 
            B_3_0, B_3_1, B_4_0, B_4_1, B_5_0, B_5_1, C0_0_0, C0_0_1, C0_0_2, C0_0_3, 
            C0_1_0, C0_1_1, C0_1_2, C0_1_3, C0_2_0, C0_2_1, C0_2_2, C0_2_3, C0_5_0, 
            C0_5_1, C0_5_2, C0_5_3, C_0_0, C_0_1, C_0_2, C_0_3, C_1_0, C_1_1, C_1_2, 
            C_1_3, C_2_0, C_2_1, C_2_2, C_2_3, C_3_0, C_3_1, C_3_2, C_3_3, C_4_0, C_4_1, 
            C_4_2, C_4_3, C_5_0, C_5_1, C_5_2, C_5_3, D0_0_0, D0_0_1, D0_0_2, D0_0_3, 
            D0_0_5, D_0_0, D_0_1, D_0_2, D_0_3, D_0_4, D_0_5, E0_0_0, E0_0_1, E_0_0, 
            E_0_1, F0_0_0, F0_0_1, F0_0_2, F0_0_3, F_0_0, F_0_1, F_0_2, F_0_3, G0_0_0, 
            G0_0_1, G0_0_2, G0_0_5, G0_1_0, G0_1_1, G0_1_2, G0_1_5, G0_2_0, G0_2_1, 
            G0_2_2, G0_2_5, G0_3_0, G0_3_1, G0_3_2, G0_3_5, GX_0_0, GX_1_1, GX_2_2, 
            GX_3_3, GX_4_4, GX_5_5, G_0_0, G_0_1, G_0_2, G_0_3, G_0_4, G_0_5, G_1_0, 
            G_1_1, G_1_2, G_1_3, G_1_4, G_1_5, G_2_0, G_2_1, G_2_2, G_2_3, G_2_4, G_2_5, 
            G_3_0, G_3_1, G_3_2, G_3_3, G_3_4, G_3_5, H0_0_0, H0_0_1, H0_1_0, H0_1_1, 
            H0_2_0, H0_2_1, H0_3_0, H0_3_1, H_0_0, H_0_1, H_1_0, H_1_1, H_2_0, H_2_1, 
            H_3_0, H_3_1, K0_0_0, K0_0_1, K0_0_2, K0_0_3, K0_1_0, K0_1_1, K0_1_2, K0_1_3, 
            K0_2_0, K0_2_1, K0_2_2, K0_2_3, K0_3_0, K0_3_1, K0_3_2, K0_3_3, K_0_0, K_0_1, 
            K_0_2, K_0_3, K_1_0, K_1_1, K_1_2, K_1_3, K_2_0, K_2_1, K_2_2, K_2_3, K_3_0, 
            K_3_1, K_3_2, K_3_3, Q_0_0, Q_0_1, Q_1_0, Q_1_1, U0_0_0, U0_0_1, UN_0_1, UN_1_1, 
            UN_2_0, UN_2_1, UN_3_1, UU_0_1, UU_1_1, UX_0_1, UX_1_1, UX_2_1, UX_3_0, UX_4_0,
            UX_4_1, UX_5_1, Ui, x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, xnm1_1, xnm1_2, 
            xnm1_3, xnm1_4, xnm1_5, xnm1_6, y_0_0,
            
            l_srate )
  local(
          I1_0_0, I1_0_1, I1_1_0, I1_1_1, T1_0_0, T1_0_1, T1_1_0, T1_1_1, T1_2_0, T1_2_1, 
          T1_3_0, T1_3_1, T1_4_0, T1_4_1, T1_5_0, T1_5_1, U0I1_0_0, U0I1_0_1, UNI1_0_0, 
          UNI1_0_1, UNI1_1_0, UNI1_1_1, UNI1_2_0, UNI1_2_1, UNI1_3_0, UNI1_3_1, alpha,
          t2, t3, t4, t5, t6, t7, t8, t9, t10, t11
  )
  (
      alpha = filterFreq;
      
      t2 = Q_0_0*100000.0000000000000000000000000;
      t3 = alpha*10000000000.0000000000000000000000000;
      t4 = Q_0_0*Q_1_1;
      t5 = Q_1_1*alpha*100000.0000000000000000000000000;
      t6 = alpha*alpha;
      t9 = Q_0_1*Q_1_0;
      t10 = Q_0_0*alpha*100000.0000000000000000000000000;
      t11 = t6*10000000000.0000000000000000000000000;
      t7 = t2+t3+t4+t5-t9-t10-t11;
      t8 = 1.0/t7;
      I1_0_0 = t8*(Q_1_1-alpha*100000.0000000000000000000000000+100000.0000000000000000000000000);
      I1_0_1 = -Q_0_1*t8;
      I1_1_0 = -Q_1_0*t8;
      I1_1_1 = t8*(Q_0_0+alpha*100000.0000000000000000000000000);

      T1_0_0 = GX_0_0*I1_1_0*UX_0_1*2.0;
      T1_0_1 = GX_0_0*I1_1_1*UX_0_1*2.0;
      T1_1_0 = GX_1_1*I1_1_0*UX_1_1*2.0;
      T1_1_1 = GX_1_1*I1_1_1*UX_1_1*2.0;
      T1_2_0 = GX_2_2*I1_1_0*UX_2_1*2.0;
      T1_2_1 = GX_2_2*I1_1_1*UX_2_1*2.0;
      T1_3_0 = GX_3_3*I1_0_0*UX_3_0*2.0;
      T1_3_1 = GX_3_3*I1_0_1*UX_3_0*2.0;
      T1_4_0 = GX_4_4*I1_0_0*UX_4_0*2.0+GX_4_4*I1_1_0*UX_4_1*2.0;
      T1_4_1 = GX_4_4*I1_0_1*UX_4_0*2.0+GX_4_4*I1_1_1*UX_4_1*2.0;
      T1_5_0 = GX_5_5*I1_1_0*UX_5_1*-2.0;
      T1_5_1 = GX_5_5*I1_1_1*UX_5_1*-2.0;

      U0I1_0_0 = I1_0_0*U0_0_0+I1_1_0*U0_0_1;
      U0I1_0_1 = I1_0_1*U0_0_0+I1_1_1*U0_0_1;

      UNI1_0_0 = I1_1_0*UN_0_1;
      UNI1_0_1 = I1_1_1*UN_0_1;
      UNI1_1_0 = I1_1_0*UN_1_1;
      UNI1_1_1 = I1_1_1*UN_1_1;
      UNI1_2_0 = I1_0_0*UN_2_0+I1_1_0*UN_2_1;
      UNI1_2_1 = I1_0_1*UN_2_0+I1_1_1*UN_2_1;
      UNI1_3_0 = I1_1_0*UN_3_1;
      UNI1_3_1 = I1_1_1*UN_3_1;

      A_0_0 = A0_0_0-T1_0_1*UX_0_1;
      A_0_1 = A0_0_1-T1_0_1*UX_1_1;
      A_0_2 = A0_0_2-T1_0_1*UX_2_1;
      A_0_3 = -T1_0_0*UX_3_0;
      A_0_4 = -T1_0_0*UX_4_0-T1_0_1*UX_4_1;
      A_0_5 = A0_0_5-T1_0_1*UX_5_1;
      A_1_0 = A0_1_0-T1_1_1*UX_0_1;
      A_1_1 = A0_1_1-T1_1_1*UX_1_1;
      A_1_2 = A0_1_2-T1_1_1*UX_2_1;
      A_1_3 = -T1_1_0*UX_3_0;
      A_1_4 = -T1_1_0*UX_4_0-T1_1_1*UX_4_1;
      A_1_5 = A0_1_5-T1_1_1*UX_5_1;
      A_2_0 = A0_2_0-T1_2_1*UX_0_1;
      A_2_1 = A0_2_1-T1_2_1*UX_1_1;
      A_2_2 = A0_2_2-T1_2_1*UX_2_1;
      A_2_3 = -T1_2_0*UX_3_0;
      A_2_4 = -T1_2_0*UX_4_0-T1_2_1*UX_4_1;
      A_2_5 = A0_2_5-T1_2_1*UX_5_1;
      A_3_0 = -T1_3_1*UX_0_1;
      A_3_1 = -T1_3_1*UX_1_1;
      A_3_2 = -T1_3_1*UX_2_1;
      A_3_3 = A0_3_3-T1_3_0*UX_3_0;
      A_3_4 = -T1_3_0*UX_4_0-T1_3_1*UX_4_1;
      A_3_5 = -T1_3_1*UX_5_1;
      A_4_0 = -T1_4_1*UX_0_1;
      A_4_1 = -T1_4_1*UX_1_1;
      A_4_2 = -T1_4_1*UX_2_1;
      A_4_3 = -T1_4_0*UX_3_0;
      A_4_4 = A0_4_4-T1_4_0*UX_4_0-T1_4_1*UX_4_1;
      A_4_5 = -T1_4_1*UX_5_1;
      A_5_0 = A0_5_0-T1_5_1*UX_0_1;
      A_5_1 = A0_5_1-T1_5_1*UX_1_1;
      A_5_2 = A0_5_2-T1_5_1*UX_2_1;
      A_5_3 = -T1_5_0*UX_3_0;
      A_5_4 = -T1_5_0*UX_4_0-T1_5_1*UX_4_1;
      A_5_5 = A0_5_5-T1_5_1*UX_5_1;

      B_0_0 = B0_0_0-T1_0_1*UU_0_1;
      B_0_1 = B0_0_1-T1_0_1*UU_1_1;
      B_1_0 = B0_1_0-T1_1_1*UU_0_1;
      B_1_1 = B0_1_1-T1_1_1*UU_1_1;
      B_2_0 = B0_2_0-T1_2_1*UU_0_1;
      B_2_1 = B0_2_1-T1_2_1*UU_1_1;
      B_3_0 = -T1_3_1*UU_0_1;
      B_3_1 = -T1_3_1*UU_1_1;
      B_4_0 = -T1_4_1*UU_0_1;
      B_4_1 = -T1_4_1*UU_1_1;
      B_5_0 = B0_5_0-T1_5_1*UU_0_1;
      B_5_1 = B0_5_1-T1_5_1*UU_1_1;

      C_0_0 = C0_0_0-T1_0_1*UN_0_1;
      C_0_1 = C0_0_1-T1_0_1*UN_1_1;
      C_0_2 = C0_0_2-T1_0_0*UN_2_0-T1_0_1*UN_2_1;
      C_0_3 = C0_0_3-T1_0_1*UN_3_1;
      C_1_0 = C0_1_0-T1_1_1*UN_0_1;
      C_1_1 = C0_1_1-T1_1_1*UN_1_1;
      C_1_2 = C0_1_2-T1_1_0*UN_2_0-T1_1_1*UN_2_1;
      C_1_3 = C0_1_3-T1_1_1*UN_3_1;
      C_2_0 = C0_2_0-T1_2_1*UN_0_1;
      C_2_1 = C0_2_1-T1_2_1*UN_1_1;
      C_2_2 = C0_2_2-T1_2_0*UN_2_0-T1_2_1*UN_2_1;
      C_2_3 = C0_2_3-T1_2_1*UN_3_1;
      C_3_0 = -T1_3_1*UN_0_1;
      C_3_1 = -T1_3_1*UN_1_1;
      C_3_2 = -T1_3_0*UN_2_0-T1_3_1*UN_2_1;
      C_3_3 = -T1_3_1*UN_3_1;
      C_4_0 = -T1_4_1*UN_0_1;
      C_4_1 = -T1_4_1*UN_1_1;
      C_4_2 = -T1_4_0*UN_2_0-T1_4_1*UN_2_1;
      C_4_3 = -T1_4_1*UN_3_1;
      C_5_0 = C0_5_0-T1_5_1*UN_0_1;
      C_5_1 = C0_5_1-T1_5_1*UN_1_1;
      C_5_2 = C0_5_2-T1_5_0*UN_2_0-T1_5_1*UN_2_1;
      C_5_3 = C0_5_3-T1_5_1*UN_3_1;

      D_0_0 = D0_0_0-U0I1_0_1*UX_0_1;
      D_0_1 = D0_0_1-U0I1_0_1*UX_1_1;
      D_0_2 = D0_0_2-U0I1_0_1*UX_2_1;
      D_0_3 = D0_0_3-U0I1_0_0*UX_3_0;
      D_0_4 = -U0I1_0_0*UX_4_0-U0I1_0_1*UX_4_1;
      D_0_5 = D0_0_5-U0I1_0_1*UX_5_1;

      E_0_0 = E0_0_0-U0I1_0_1*UU_0_1;
      E_0_1 = E0_0_1-U0I1_0_1*UU_1_1;

      F_0_0 = F0_0_0-U0I1_0_1*UN_0_1;
      F_0_1 = F0_0_1-U0I1_0_1*UN_1_1;
      F_0_2 = F0_0_2-U0I1_0_0*UN_2_0-U0I1_0_1*UN_2_1;
      F_0_3 = F0_0_3-U0I1_0_1*UN_3_1;

      G_0_0 = G0_0_0-UNI1_0_1*UX_0_1;
      G_0_1 = G0_0_1-UNI1_0_1*UX_1_1;
      G_0_2 = G0_0_2-UNI1_0_1*UX_2_1;
      G_0_3 = -UNI1_0_0*UX_3_0;
      G_0_4 = -UNI1_0_0*UX_4_0-UNI1_0_1*UX_4_1;
      G_0_5 = G0_0_5-UNI1_0_1*UX_5_1;
      G_1_0 = G0_1_0-UNI1_1_1*UX_0_1;
      G_1_1 = G0_1_1-UNI1_1_1*UX_1_1;
      G_1_2 = G0_1_2-UNI1_1_1*UX_2_1;
      G_1_3 = -UNI1_1_0*UX_3_0;
      G_1_4 = -UNI1_1_0*UX_4_0-UNI1_1_1*UX_4_1;
      G_1_5 = G0_1_5-UNI1_1_1*UX_5_1;
      G_2_0 = G0_2_0-UNI1_2_1*UX_0_1;
      G_2_1 = G0_2_1-UNI1_2_1*UX_1_1;
      G_2_2 = G0_2_2-UNI1_2_1*UX_2_1;
      G_2_3 = -UNI1_2_0*UX_3_0;
      G_2_4 = -UNI1_2_0*UX_4_0-UNI1_2_1*UX_4_1;
      G_2_5 = G0_2_5-UNI1_2_1*UX_5_1;
      G_3_0 = G0_3_0-UNI1_3_1*UX_0_1;
      G_3_1 = G0_3_1-UNI1_3_1*UX_1_1;
      G_3_2 = G0_3_2-UNI1_3_1*UX_2_1;
      G_3_3 = -UNI1_3_0*UX_3_0;
      G_3_4 = -UNI1_3_0*UX_4_0-UNI1_3_1*UX_4_1;
      G_3_5 = G0_3_5-UNI1_3_1*UX_5_1;

      H_0_0 = H0_0_0-UNI1_0_1*UU_0_1;
      H_0_1 = H0_0_1-UNI1_0_1*UU_1_1;
      H_1_0 = H0_1_0-UNI1_1_1*UU_0_1;
      H_1_1 = H0_1_1-UNI1_1_1*UU_1_1;
      H_2_0 = H0_2_0-UNI1_2_1*UU_0_1;
      H_2_1 = H0_2_1-UNI1_2_1*UU_1_1;
      H_3_0 = H0_3_0-UNI1_3_1*UU_0_1;
      H_3_1 = H0_3_1-UNI1_3_1*UU_1_1;

      K_0_0 = K0_0_0-UNI1_0_1*UN_0_1;
      K_0_1 = K0_0_1-UNI1_0_1*UN_1_1;
      K_0_2 = K0_0_2-UNI1_0_0*UN_2_0-UNI1_0_1*UN_2_1;
      K_0_3 = K0_0_3-UNI1_0_1*UN_3_1;
      K_1_0 = K0_1_0-UNI1_1_1*UN_0_1;
      K_1_1 = K0_1_1-UNI1_1_1*UN_1_1;
      K_1_2 = K0_1_2-UNI1_1_0*UN_2_0-UNI1_1_1*UN_2_1;
      K_1_3 = K0_1_3-UNI1_1_1*UN_3_1;
      K_2_0 = K0_2_0-UNI1_2_1*UN_0_1;
      K_2_1 = K0_2_1-UNI1_2_1*UN_1_1;
      K_2_2 = K0_2_2-UNI1_2_0*UN_2_0-UNI1_2_1*UN_2_1;
      K_2_3 = K0_2_3-UNI1_2_1*UN_3_1;
      K_3_0 = K0_3_0-UNI1_3_1*UN_0_1;
      K_3_1 = K0_3_1-UNI1_3_1*UN_1_1;
      K_3_2 = K0_3_2-UNI1_3_0*UN_2_0-UNI1_3_1*UN_2_1;
      K_3_3 = K0_3_3-UNI1_3_1*UN_3_1;
 );  
  
function dlop_vclamp(v)
  instance()
  global()
  local(Is, mxmx, q)
  (
    Is        = 0.0000000000000203000000000;
    mxmx      = .001;
    q         = Is*(exp(v)+.0000000000001);
    
    q < mxmx ? q : min(q,mxmx)
  );
  
function dlop_res(i1, i2, i3, i4)
  global()
  instance( df0Trial, df1Trial, df2Trial, df3Trial,
  
            J_0_0, J_0_1, J_0_2, J_0_3,
            J_1_0, J_1_1, J_1_2, J_1_3,
            J_2_0, J_2_1, J_2_2, J_2_3,
            J_3_0, J_3_1, J_3_2, J_3_3,
  
            p_0_0, p_1_0, p_2_0, p_3_0,
            K_0_0, K_0_1, K_0_2, K_0_3, 
            K_1_0, K_1_1, K_1_2, K_1_3,
            K_2_0, K_2_1, K_2_2, K_2_3,
            K_3_0, K_3_1, K_3_2, K_3_3,
            
            v1, v2, v3, v4,
            
            beta_f, beta_r, Is,
            mv,
            mxmx,
  )
  local(
    r500d13,
    t2, t3, t4, t5, t6, t7, t9,
    t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, 
    t20, t21, t22, t23, t24, t25, t26, t27, t29, 
    t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, 
    t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, 
    t50, t51, t52, t53, t54, t55, t56,
    t9I, t12I, t29I, t31I,
     )
  (
    r500d13   = 500/13;
    beta_r    = 4;
    beta_f    = 1430;
    Is        = 0.0000000000000203000000000;    
    mxmx      = .001;
    
    t2   = r500d13;
    t3   = K_0_0*i1;
    t4   = K_0_1*i2;
    t5   = K_0_2*i3;
    t6   = K_0_3*i4;
    t7   = 1.0/beta_r;
    v1   = p_0_0+t3+t4+t5+t6;
 
    t13  = t2*v1;
    t9I  = dlop_vclamp(-t13);
    t10  = 1.0/beta_f;
    t14  = K_1_0*i1;
    t15  = K_1_1*i2;
    t16  = K_1_2*i3;
    t17  = K_1_3*i4;
    v2   = p_1_0+t14+t15+t16+t17;
    
    t11  = (v1-v2);
    t18  = t2*t11;
    t12I = dlop_vclamp(-t18);
    
    t19  = K_0_0-K_1_0;
    t20  = K_0_1-K_1_1;
    t21  = beta_r-1.0;
    t22  = K_0_2-K_1_2;
    t23  = K_0_3-K_1_3;
    t24  = K_2_0*i1;
    t25  = K_2_1*i2;
    t26  = K_2_2*i3;
    t27  = K_2_3*i4;
    v3   = p_2_0+t24+t25+t26+t27;
    t32  = t2*v3;
    t29I = dlop_vclamp(-t32);
    
    t33  = K_3_0*i1;
    t34  = K_3_1*i2;
    t35  = K_3_2*i3;
    t36  = K_3_3*i4;
    v4   = p_3_0+t33+t34+t35+t36;
    t30  = (v3-v4);
    t37  = t2*t30;
    t31I = dlop_vclamp(-t37);
    
    t38 = K_2_0-K_3_0;
    t39 = K_2_1-K_3_1;
    t40 = K_2_2-K_3_2;
    t41 = K_2_3-K_3_3;
    t42 = t12I-Is;
    t43 = t9I-Is;
    t44 = t31I-Is;
    t45 = t29I-Is;
    
    J_0_0 = -(K_0_0*t2*t7*t9I+t2*t10*t12I*t19)-1.0;
    J_0_1 = -(K_0_1*t2*t7*t9I+t2*t10*t12I*t20);
    J_0_2 = -(K_0_2*t2*t7*t9I+t2*t10*t12I*t22);
    J_0_3 = -(K_0_3*t2*t7*t9I+t2*t10*t12I*t23);
    J_1_0 = (t2*t12I*t19-K_0_0*t2*t7*t9I*t21);
    J_1_1 = (t2*t12I*t20-K_0_1*t2*t7*t9I*t21)-1.0;
    J_1_2 = (t2*t12I*t22-K_0_2*t2*t7*t9I*t21);
    J_1_3 = (t2*t12I*t23-K_0_3*t2*t7*t9I*t21);
    J_2_0 = -(K_2_0*t2*t7*t29I+t2*t10*t31I*t38);
    J_2_1 = -(K_2_1*t2*t7*t29I+t2*t10*t31I*t39);
    J_2_2 = -(K_2_2*t2*t7*t29I+t2*t10*t31I*t40)-1.0;
    J_2_3 = -(K_2_3*t2*t7*t29I+t2*t10*t31I*t41);
    J_3_0 = (t2*t31I*t38-K_2_0*t2*t7*t21*t29I);
    J_3_1 = (t2*t31I*t39-K_2_1*t2*t7*t21*t29I);
    J_3_2 = (t2*t31I*t40-K_2_2*t2*t7*t21*t29I);
    J_3_3 = (t2*t31I*t41-K_2_3*t2*t7*t21*t29I)-1.0;
    
    df0Trial = -i1 + t7*t43 + t10*t42;
    df1Trial = -i2 - t42    + t7*t21*t43;
    df2Trial = -i3 + t7*t45 + t10*t44;
    df3Trial = -i4 - t44    + t7*t21*t45;
  ); 
  
function dlop_eval( Ui )
  global()
  instance( A0_0_0, A0_0_1, A0_0_2, A0_0_5, A0_1_0, A0_1_1, A0_1_2, A0_1_5, A0_2_0, 
            A0_2_1, A0_2_2, A0_2_5, A0_3_3, A0_4_4, A0_5_0, A0_5_1, A0_5_2, A0_5_5, 
            A_0_0, A_0_1, A_0_2, A_0_3, A_0_4, A_0_5, A_1_0, A_1_1, A_1_2, A_1_3, 
            A_1_4, A_1_5, A_2_0, A_2_1, A_2_2, A_2_3, A_2_4, A_2_5, A_3_0, A_3_1, 
            A_3_2, A_3_3, A_3_4, A_3_5, A_4_0, A_4_1, A_4_2, A_4_3, A_4_4, A_4_5, 
            A_5_0, A_5_1, A_5_2, A_5_3, A_5_4, A_5_5, B0_0_0, B0_0_1, B0_1_0, B0_1_1, 
            B0_2_0, B0_2_1, B0_5_0, B0_5_1, B_0_0, B_0_1, B_1_0, B_1_1, B_2_0, B_2_1, 
            B_3_0, B_3_1, B_4_0, B_4_1, B_5_0, B_5_1, C0_0_0, C0_0_1, C0_0_2, C0_0_3, 
            C0_1_0, C0_1_1, C0_1_2, C0_1_3, C0_2_0, C0_2_1, C0_2_2, C0_2_3, C0_5_0, 
            C0_5_1, C0_5_2, C0_5_3, C_0_0, C_0_1, C_0_2, C_0_3, C_1_0, C_1_1, C_1_2, 
            C_1_3, C_2_0, C_2_1, C_2_2, C_2_3, C_3_0, C_3_1, C_3_2, C_3_3, C_4_0, C_4_1, 
            C_4_2, C_4_3, C_5_0, C_5_1, C_5_2, C_5_3, D0_0_0, D0_0_1, D0_0_2, D0_0_3, 
            D0_0_5, D_0_0, D_0_1, D_0_2, D_0_3, D_0_4, D_0_5, E0_0_0, E0_0_1, E_0_0, 
            E_0_1, F0_0_0, F0_0_1, F0_0_2, F0_0_3, F_0_0, F_0_1, F_0_2, F_0_3, G0_0_0, 
            G0_0_1, G0_0_2, G0_0_5, G0_1_0, G0_1_1, G0_1_2, G0_1_5, G0_2_0, G0_2_1, 
            G0_2_2, G0_2_5, G0_3_0, G0_3_1, G0_3_2, G0_3_5, GX_0_0, GX_1_1, GX_2_2, 
            GX_3_3, GX_4_4, GX_5_5, G_0_0, G_0_1, G_0_2, G_0_3, G_0_4, G_0_5, G_1_0, 
            G_1_1, G_1_2, G_1_3, G_1_4, G_1_5, G_2_0, G_2_1, G_2_2, G_2_3, G_2_4, G_2_5, 
            G_3_0, G_3_1, G_3_2, G_3_3, G_3_4, G_3_5, H0_0_0, H0_0_1, H0_1_0, H0_1_1, 
            H0_2_0, H0_2_1, H0_3_0, H0_3_1, H_0_0, H_0_1, H_1_0, H_1_1, H_2_0, H_2_1, 
            H_3_0, H_3_1, K0_0_0, K0_0_1, K0_0_2, K0_0_3, K0_1_0, K0_1_1, K0_1_2, K0_1_3, 
            K0_2_0, K0_2_1, K0_2_2, K0_2_3, K0_3_0, K0_3_1, K0_3_2, K0_3_3, K_0_0, K_0_1, 
            K_0_2, K_0_3, K_1_0, K_1_1, K_1_2, K_1_3, K_2_0, K_2_1, K_2_2, K_2_3, K_3_0, 
            K_3_1, K_3_2, K_3_3, Q_0_0, Q_0_1, Q_1_0, Q_1_1, U0_0_0, U0_0_1, UN_0_1, UN_1_1, 
            UN_2_0, UN_2_1, UN_3_1, UU_0_1, UU_1_1, UX_0_1, UX_1_1, UX_2_1, UX_3_0, UX_4_0,
            UX_4_1, UX_5_1, 
            
            // States
            x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, Ui, 
            xh0, xh1, xh2, xh3, xh4, xh5
            i1, i2, i3, i4,
            
            // Trial residual
            df0Trial, df1Trial, df2Trial, df3Trial,
            
            // Trial currents
            i1Trial, i2Trial, i3Trial, i4Trial,
            
            // Jacobian
            J_0_0, J_0_1, J_0_2, J_0_3,
            J_1_0, J_1_1, J_1_2, J_1_3,
            J_2_0, J_2_1, J_2_2, J_2_3,
            J_3_0, J_3_1, J_3_2, J_3_3,
            
            // Transformed state
            p_0_0, p_1_0, p_2_0, p_3_0, 
            
            // Current residual
            df0, df1, df2, df3, output,

            // Step
            step1, step2, step3, step4,
            
           diff, step, nRej, err, newErr, iter )
  local(r163d20, r500d13, 
  
        // Temporary storage for the inverse
        x0,   x1,   x2,   x3,   x4,   x5,   x6,   x7,   x8,   x9,
        x10,  x11,  x12,  x13,  x14,  x15,  x16,  x17,  x18,  x19,
        x20,  x21,  x22,  x23,  x24,  x25,  x26,  x27,  x28,  x29,
        x30,  x31,  x32,  x33,  x34,  x35,  x36
 )
  (
      r163d20 = 163/20;
      r500d13 = 500/13;
      
      //this.reset_dlop();
      Ui = tanh(Ui);
      
      p_0_0 = H_0_1*r163d20+G_0_0*xh0+G_0_1*xh1+G_0_2*xh2+G_0_3*xh3+G_0_4*xh4+G_0_5*xh5+H_0_0*Ui;
      p_1_0 = H_1_1*r163d20+G_1_0*xh0+G_1_1*xh1+G_1_2*xh2+G_1_3*xh3+G_1_4*xh4+G_1_5*xh5+H_1_0*Ui;
      p_2_0 = H_2_1*r163d20+G_2_0*xh0+G_2_1*xh1+G_2_2*xh2+G_2_3*xh3+G_2_4*xh4+G_2_5*xh5+H_2_0*Ui;
      p_3_0 = H_3_1*r163d20+G_3_0*xh0+G_3_1*xh1+G_3_2*xh2+G_3_3*xh3+G_3_4*xh4+G_3_5*xh5+H_3_0*Ui;
      
      // Calculate residual and Jacobian
      this.dlop_res(i1, i2, i3, i4);
      
      df0 = df0Trial;
      df1 = df1Trial;
      df2 = df2Trial;
      df3 = df3Trial;
      err = abs(df0) + abs(df1) + abs(df2) + abs(df3);
      
      step = 1;
      nRej = 0;
      iter = 0;
      while( iter < 35 && err > 0.000001 ) ( 
        // Calculate inverse       
        x0 = J_0_0*J_1_1;
        x1 = -J_0_1*J_1_0 + x0;
        x2 = J_0_0*J_1_3 - J_0_3*J_1_0;
        x3 = J_0_0*J_1_2 - J_0_2*J_1_0;
        x4 = J_0_0*J_2_1 - J_0_1*J_2_0;
        x5 = x3*x4;
        x6 = x1*(J_0_0*J_2_2 - J_0_2*J_2_0) - x5;
        x7 = -J_0_1*x3 + J_0_2*x1;
        x8 = x1*(J_0_0*J_2_3 - J_0_3*J_2_0) - x2*x4;
        x9 = x6*(-J_0_1*x2 + J_0_3*x1) - x7*x8;
        x10 = J_0_0*J_3_1 - J_0_1*J_3_0;
        x11 = x1*(J_0_0*J_3_2 - J_0_2*J_3_0) - x10*x3;
        x12 = x11*x8;
        x13 = -x12 + x6*(x1*(J_0_0*J_3_3 - J_0_3*J_3_0) - x10*x2);
        x14 = 1.0/x13;
        x15 = df3*x14;
        x16 = 1.0/J_0_0;
        x17 = J_0_0*x1;
        x18 = x11*x17;
        x19 = x13*x17;
        x20 = 1.0/x1;
        x21 = 1.0/x6;
        x22 = df2*x14;
        x23 = x21*x22;
        x24 = x20*x23;
        x25 = J_0_0*x4;
        x26 = J_0_0*x6;
        x27 = -x10*x26 + x11*x25;
        x28 = df1*x14;
        x29 = x21*x28;
        x30 = x20*x29;
        x31 = J_1_0*x4 - J_2_0*x1;
        x32 = -x11*x31 + x6*(J_1_0*x10 - J_3_0*x1);
        x33 = df0*x14;
        x34 = x21*x33;
        x35 = x20*x34;
        x36 = x2*x6 - x3*x8;
        
        // Calculate next trial point
        step1 = x15*x9 - x16*x24*(x18*x9 - x19*x7) - x16*x30*(x13*(-J_0_1*x26 + x25*x7) - x27*x9) - x16*x35*(x13*(x0*x6 - x31*x7) - x32*x9);
        step2 = J_0_0*x15*x36 - x24*(x18*x36 - x19*x3) - x30*(x13*(J_0_0*x5 + x26) - x27*x36) - x35*(x13*(-J_1_0*x6 - x3*x31) - x32*x36);
        step3 = x15*x17*x8 - x23*(x12*x17 + x19) - x29*(-x13*x25 - x27*x8) - x34*(x13*x31 - x32*x8);
        step4 = -x1*x15*x26 + x18*x22 - x27*x28 - x32*x33;
        
        i1Trial = i1 + step1;
        i2Trial = i2 + step2;
        i3Trial = i3 + step3;
        i4Trial = i4 + step4;
        
        // Calculate residual at new trial point
        this.dlop_res(i1Trial, i2Trial, i3Trial, i4Trial);
        newErr = abs(df0Trial) + abs(df1Trial) + abs(df2Trial) + abs(df3Trial);
        
        // Did we get closer to the solution?
        newErr < err ?
        (
          // Accept step
          i1 = i1Trial;
          i2 = i2Trial;
          i3 = i3Trial;
          i4 = i4Trial;
          df0 = df0Trial;
          df1 = df1Trial;
          df2 = df2Trial;
          df3 = df3Trial;
          
          err = newErr;
          
          step = min(1, step*2);
        ) : (
          // Reject step and lower stepsize
          step = step * .5;
          nRej += 1;
        );
        
        iter += 1;
      );
      
      output = E_0_1*r163d20+F_0_0*i1+F_0_1*i2+F_0_2*i3+F_0_3*i4+D_0_0*xh0+D_0_1*xh1+D_0_2*xh2+D_0_3*xh3+D_0_4*xh4+D_0_5*xh5+E_0_0*Ui;
  
      x_0_0 = B_0_1*r163d20+C_0_0*i1+C_0_1*i2+C_0_2*i3+C_0_3*i4+A_0_0*xh0+A_0_1*xh1+A_0_2*xh2+A_0_3*xh3+A_0_4*xh4+A_0_5*xh5+B_0_0*Ui;
      x_1_0 = B_1_1*r163d20+C_1_0*i1+C_1_1*i2+C_1_2*i3+C_1_3*i4+A_1_0*xh0+A_1_1*xh1+A_1_2*xh2+A_1_3*xh3+A_1_4*xh4+A_1_5*xh5+B_1_0*Ui;
      x_2_0 = B_2_1*r163d20+C_2_0*i1+C_2_1*i2+C_2_2*i3+C_2_3*i4+A_2_0*xh0+A_2_1*xh1+A_2_2*xh2+A_2_3*xh3+A_2_4*xh4+A_2_5*xh5+B_2_0*Ui;
      x_3_0 = B_3_1*r163d20+C_3_0*i1+C_3_1*i2+C_3_2*i3+C_3_3*i4+A_3_0*xh0+A_3_1*xh1+A_3_2*xh2+A_3_3*xh3+A_3_4*xh4+A_3_5*xh5+B_3_0*Ui;
      x_4_0 = B_4_1*r163d20+C_4_0*i1+C_4_1*i2+C_4_2*i3+C_4_3*i4+A_4_0*xh0+A_4_1*xh1+A_4_2*xh2+A_4_3*xh3+A_4_4*xh4+A_4_5*xh5+B_4_0*Ui;
      x_5_0 = B_5_1*r163d20+C_5_0*i1+C_5_1*i2+C_5_2*i3+C_5_3*i4+A_5_0*xh0+A_5_1*xh1+A_5_2*xh2+A_5_3*xh3+A_5_4*xh4+A_5_5*xh5+B_5_0*Ui;    
    
      xh0 = x_0_0;
      xh1 = x_1_0;
      xh2 = x_2_0;
      xh3 = x_3_0;
      xh4 = x_4_0;
      xh5 = x_5_0;
  
      output
  );
 
function reset_dlop()
  instance(i1,i2,i3,i4,xh0, xh1, xh2, xh3, xh4, xh5, xh6)
  (
    i1 = .00000011;
    i2 = -.00016; 
    i3 = .00000026;
    i4 = -.000373;
    xh0 = 0.0011;
    xh1 = 0.54;
    xh2 = -0.005;
    xh3 = 0.173;
    xh4 = -0.168;
    xh5 = 0.000002;
  );
  
function reset_dlopH()
  instance(i1,i2,i3,i4,xh0, xh1, xh2, xh3, xh4, xh5, xh6)
  (
    i1 = .00000011;
    i2 = -.00016; 
    i3 = .00000026;
    i4 = -.000373;
    xh0 = 0.0004;
    xh1 = 0.2715;
    xh2 = -0.0026;
    xh3 = 0.086;
    xh4 = -0.084;
    xh5 = 0.000002;
  );

function reset_dlopL()
  instance(i1,i2,i3,i4,xh0, xh1, xh2, xh3, xh4, xh5, xh6)
  (
    i1 = .00000011;
    i2 = -.00016; 
    i3 = .00000026;
    i4 = -.000373;
    xh0 = 0.002;
    xh1 = 1.085;
    xh2 = -0.0106;
    xh3 = 0.346;
    xh4 = -0.336;
    xh5 = 0.000006;
  );    
   
function reset_wasplin()
  global()
  local()
  instance(U0, U1, Di, D0, D1, x0, x1, x2, x3, i1)
  (
    U0 = U1 = Di = D0 = D1 = x0 = x1 = x2 = x3 = i1 = 0;
  );
  
function resetphaserFET()
  global()
  local()
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    dw = dx = 0;
  ); 

// Generate windowed sinc filter at memory location FIR
// Inputs are:
//    fir   - Memory location to store windowed sinc
//    nt    - Number of taps
//    bw    - Fractional bandwidth
//     g    - Gain
function sinc(fir, nt, bw, g)
  local(a, ys, yg, yw, i, pibw2, pifc2, pidnt2, hnt)
  global()
  (
    pibw2   = 2.0*$pi*bw;
    pidnt2  = 2.0*$pi/nt;
    hnt     = 0.5*nt;
    i       = 1;
        
    loop(nt-1,
      // Sinc width
      a  = (i - hnt) * pibw2;
        
      // Sinc
      ys = (a != 0) ? sin(a)/a : 1.0;
 
      // Window gain
      yg = g * (4.0 * bw);
        
      // Hamming window (could be replaced with Kaiser in the future)
      yw = 0.54 - 0.46 * cos(i * pidnt2);
         
      // Calc FIR coeffs
      fir[i-1] = yw * yg * ys;
      
      i += 1;
    );
  );

// Generate sinc filters for a specific upsampling ratio
//
// Upsampling leads to a sample followed by N-1 zeroes. Hence 
// to compute each subsample, we only need 1/Nth of the taps.
// This is why we set up a specific filter for each subsample.
// i.e. for N=4, you get something like f1*Zn + f5*Zn-1 + ...
//
// Inputs:
//    N_in            - oversampling factor
//    tapsPerFilter   - Taps per subfilter (should be 8 in this implementation)
//    targetmem       - Location to store the coefficients
//    tmp             - Working memory
function updateSincFilter(N_in, tapsPerFilter, targetmem, tmp)
  local(nHist, iFilt, nTaps)
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N, delta)
  global()
  (
    N       = N_in;
    nHist   = tapsPerFilter;
    loc     = 0;
    coeffs  = targetmem;
    nTaps   = N*nHist;
    
    // Memory being set is conservatively large.
    memset(coeffs,0,10000);
    memset(tmp,0,10000);
    
    sinc(tmp, nTaps, .5/N, .5*N);
    
    // Divide sinc over the different filters
    iFilt = 0; // Filter idx for which subsample this filter is
    delta = 0; // Sample idx
    loop(nTaps,
      coeffs[delta + iFilt*100] = tmp[];
      iFilt += 1;
      iFilt == N ? ( iFilt = 0; delta += 1 );
      tmp += 1;
    );
  );

// Generate downsample filter
// Here, the full N*nHist tap filter has to be evaluated for every sample, 
// but only every Nth sample has to be evaluated.
function updateSincDownsampleFilter(N_in, nTaps_in, histmem, coeffmem)
  global()
  instance(hist, hend, hptr, coeffs, loc, N, delta, nTaps)
  local()
  (
    N       = N_in;
    hist    = histmem;
    coeffs  = coeffmem;
    nTaps   = nTaps_in;
    hptr    = hist;
    hend    = hist + nTaps;
    
    memset(coeffs,0,10000);
    sinc(coeffs, nTaps, .5/N, .5);
  );
  
function advanceHist(sample)
  global()
  instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
  local(nHist, nTaps)
  (
    hptr += 1;
    ( hptr == hend ) ? hptr = hist;
    hptr[] = sample;
  );

function sincDownSample()
  global()
  instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
  local(nHist, hm1, hptr2, out, cfptr)
  (
    hm1   = hist-1;
    hptr2 = hptr;
    cfptr = coeffs;
    out   = 0;
    
    loop(nTaps,
      out = out + hptr2[] * cfptr[];
      
      cfptr += 1;
      hptr2 -= 1;
      ( hptr2 == hm1 ) ? hptr2 = hend-1;
    );
    
    out
  );

function resetSincDown()
  global()
  instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
  local(nHist, hm1, hptr2)
  (
    hm1   = hist-1;
    hptr2 = hptr;
    
    loop(nTaps,
      hptr2[] = 0;
      
      hptr2 -= 1;
      ( hptr2 == hm1 ) ? hptr2 = hend-1;
    );
  );

// Maintain input sample history. Hardcoded for speed.
// Note h7 is omitted because for integer upsampling it is always zero!
function advanceSinc(sample)
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
  global()
  local(filt)
  (
    h6 = h5;
    h5 = h4;
    h4 = h3;
    h3 = h2;
    h2 = h1;
    h1 = h0;
    h0 = sample;
    loc = 0;
  );

function resetSincUp()
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
  global()
  local(filt)
  (
    h0 = h1 = h2 = h3 = h4 = h5 = h6 = 0;
  );

// Note h7 is omitted because for integer upsampling it is always zero!
function getSubSample()
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
  global()
  local(filt, out)
  (
    filt = coeffs + loc;

    //out = filt[] * h0 + (filt+=1)[] * h1 + (filt+=1)[] * h2 + (filt+=1)[] * h3 + (filt+=1)[] * h4 + (filt+=1)[] * h5 + (filt+=1)[] * h6;
    out =  filt[] * h0 + filt[1] * h1 + filt[2] * h2 + filt[3] * h3 + filt[4] * h4 + filt[5] * h5 + filt[6] * h6;

    loc += 100;
    out
  );
 
// IIR RBJ based up/down sampling
function updateFilter(newlen)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (Q, sc, pos, cpos, spos, alpha)
  global ()
  (  
    ( newlen != len ) ?
    (
      len   = newlen;
      Q     = 0.707;
      pos   = 0.85 / len * $pi;
      cpos  = cos(pos);
      spos  = sin(pos);
      alpha = spos/(2.0*Q);
       
      sc    = 1.0 / (1+alpha);
      a1    = -2 * cpos * sc;
      a2    = (1-alpha) * sc;
      b1    = (1-cpos) * sc;
      b2    = b0 = b1 * 0.5;
    
      // Input taps
      d1 = d2 = d3 = d4 = 0;
      
      // Output taps
      o1 = o2 = o3 = o4 = 0;
    )
  );

function inputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out  = sample*b0 + d1*b1 + d2*b2 - d3*a1 - d4*a2;
    d2   = d1;
    d1   = sample;
    d4   = d3;
    d3   = out;
  );
  
function resetioFilter()
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    d1 = d2 = d3 = d4 = o1 = o2 = o3 = o4 = 0;
  );

function outputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out = sample*b0 + o1*b1 + o2*b2 - o3*a1 - o4*a2;
    o2  = o1;
    o1  = sample;
    o4  = o3;
    o3  = out;
  );

function calcTuning(cutoff, refNote)
  local(tmp)
  global(legacyCutoff)
  instance()
  (
    legacyCutoff ? (
      tmp = 10^-cutoff;
      log( tmp + ( 1 - tmp ) * 2^(refNote/12) ) / log(10)
    ) : (
      - log(2^(refNote/12)) / log(20/22050)
    );
  );


function calcPitch(cutoff, pitch)
  local(tmp)
  global(legacyCutoff)
  instance()
  (
    legacyCutoff ? (
      tmp = 10^-cutoff;
      log( tmp + ( 1 - tmp ) * pitch ) / log(10);
    ) : (
      - log(pitch) / log(20/22050)
    );
  );
  
function getTuning(filterChoice, lastNote, cutoff)
  local(refNote, approxNoteFrequency, tmp)
  global(srate)
  instance()
  (
    refNote = lastNote-69+9+24;
    ( filterChoice == 1 ) ? (
      approxNoteFrequency = ( log( 2^(refNote/12)*(440/srate) ) + log(256*$pi) ) / ( 8 * log(2) );
    ) : ( filterChoice == 2 ) ? (
      approxNoteFrequency = calcTuning(cutoff, refNote);
    ) : ( filterChoice == 3 ) ? (
      // Note follow makes no sense in vowel context
      approxNoteFrequency = 0;
    ) : ( filterChoice == 4 ) ? (
      approxNoteFrequency = ( log( 2^(refNote/12)*(4*440/srate) ) + log(256*$pi) ) / ( 8 * log(2) );
    ) : ( filterChoice == 5 ) ? (
      approxNoteFrequency = ( log( 2^(refNote/12)*(4*440/srate) ) + log(256*$pi) ) / ( 8 * log(2) );
    ) : ( filterChoice > 5 && filterChoice < 16 ) ? (
      approxNoteFrequency = calcTuning(cutoff, refNote);
    ) : ( filterChoice == 16 ) ? (
      approxNoteFrequency = 0;
    ) : ( filterChoice == 17 ) ? (
      approxNoteFrequency = 0;
    ) : ( filterChoice > 17 && filterChoice < 24 ) ? (
      approxNoteFrequency = calcTuning(cutoff, refNote);
    ) : ( filterChoice == 24 ) ? (
      approxNoteFrequency = 0; // Experimental (untuneable)
    ) : ( filterChoice > 24 && filterChoice < 31 ) ? (
      approxNoteFrequency = calcTuning(cutoff, refNote);
    ) : ( filterChoice == 31 ) ? (
      approxNoteFrequency = 0;//2^(refNote/12); // Unclear, no resonant peak
    ) : ( filterChoice == 32 ) ? (
      approxNoteFrequency = 0; // Unclear, no resonant peak
    ) : ( filterChoice > 32 ) ? (
      // SVF pitch function (derivation)
      // tmp = .5 * ( ( pow(10, cutoff) - 1 ) / 9 ) * srate;
      // scalar = 9*tmp/(.5*srate);
      // approxNoteFrequency = log( 10^(-cutoff)* (scalar*2^(refNote/12)+1) ) / log(10);
      // approxNoteFrequency = log( 10^(-cutoff) * ((10^cutoff - 1)*2^(refNote/12)+1) ) / log(10);
      approxNoteFrequency = calcTuning(cutoff, refNote);
    );
    
    approxNoteFrequency;
  );
  
function getPitchMod(filterChoice, pitch, cutoff)
  local(approxNoteFrequency, tmp)
  global(srate)
  instance()
  (
    ( filterChoice == 1 ) ? (
      approxNoteFrequency = ( log( pitch*(440/srate) ) + log(256*$pi) ) / ( 8 * log(2) );
    ) : ( filterChoice == 2 ) ? (
      approxNoteFrequency = calcPitch(cutoff, pitch);
    ) : ( filterChoice == 3 ) ? (
      // Note follow makes no sense in vowel context
      approxNoteFrequency = 0;
    ) : ( filterChoice == 4 ) ? (
      approxNoteFrequency = ( log( pitch*(4*440/srate) ) + log(256*$pi) ) / ( 8 * log(2) );
    ) : ( filterChoice == 5 ) ? (
      approxNoteFrequency = ( log( pitch*(4*440/srate) ) + log(256*$pi) ) / ( 8 * log(2) );
    ) : ( filterChoice > 5 && filterChoice < 16 ) ? (
      approxNoteFrequency = calcPitch(cutoff, pitch);
    ) : ( filterChoice == 16 ) ? (
      approxNoteFrequency = 0;
    ) : ( filterChoice == 17 ) ? (
      approxNoteFrequency = 0;
    ) : ( filterChoice > 17 && filterChoice < 24 ) ? (
      approxNoteFrequency = calcPitch(cutoff, pitch);
    ) : ( filterChoice == 24 ) ? (
      approxNoteFrequency = 0; // Experimental (untuneable)
    ) : ( filterChoice > 24 && filterChoice < 31 ) ? (
      approxNoteFrequency = calcPitch(cutoff, pitch);
    ) : ( filterChoice == 31 ) ? (
      approxNoteFrequency = 0;//2^(refNote/12); // Unclear, no resonant peak
    ) : ( filterChoice == 32 ) ? (
      approxNoteFrequency = 0; // Unclear, no resonant peak
    ) : ( filterChoice > 32 ) ? (
      // SVF
      approxNoteFrequency = calcPitch(cutoff, pitch);
    );
    
    approxNoteFrequency;
  );  
  
function getHz(filterChoice, f)
  global(srate, slider54, lastFilterReso, lastFilterFreq, hzin)
  local(outHz, f)
  instance()
  (
    outHz = 0;
    hzin = f;
      ( filterChoice == 1 ) ? (
        outHz = pow(0.5, (128-f*128) / 16.0)*srate/$pi;
      ) : ( filterChoice == 2 ) ? (
        // filterFreq = max(filterFreq, 0.005);
        outHz = 0;
      ) : ( filterChoice == 3 ) ? (
        outHz = 0;
      ) : ( filterChoice == 4 ) ? (
        // filterFreq = max(filterFreq, 0.005);
        outHz = 0;
      ) : ( filterChoice == 5 ) ? (
        // filterFreq = max(filterFreq, 0.005);
        outHz = 0;
      ) : ( filterChoice == 6 ) ? (
        f = max(f, 0.003);
        outHz = srate * f_trafo_Hz(f) / 2.185; // dualFilt LP
      ) : ( filterChoice == 7 ) ? (
        f = max(f, 0.003);
        outHz = srate * f_trafo_Hz(f) / 2.25; // dualFilt HP
      ) : ( filterChoice == 8 ) ? (
        f = max(f, 0.003);
        outHz = srate * f_trafo_Hz(f) / 2.058; // dualFilt BP
      ) : ( filterChoice == 9 || filterChoice == 10 ) ? (
        f = max(f, 0.003);
        outHz = srate * f_trafo_Hz(f) / 1.75; // moogs
      ) : ( filterChoice == 11 ) ? (
        f = max(f, 0.003);
        outHz = .5 * srate * f_trafo_Hz(f); // notch
      ) : ( filterChoice == 12 ) ? (
        outHz = 1111*f_trafo_Hz(f) + 440; // narsty
      ) : ( filterChoice == 13 ) ? (
        outHz = 0; // modulator   
      ) : ( filterChoice == 14 ) ? (
        outHz = 0; // Phaser
      ) : ( filterChoice == 15 ) ? (
        outHz=.025*f*srate; // Phaser
      ) : ( filterChoice == 16 ) ? (
        outHz = 0;
      ) : ( filterChoice == 17 ) ? (
        outHz = 0;
      ) : ( filterChoice == 18 ) ? (
        f = max(f, 0.003);
        outHz = .5 * srate * f_trafo_Hz(f); // ms-20 linear
      ) : ( filterChoice == 19 ) ? (
        f = max(f, 0.003);
        outHz = .5 * srate * f_trafo_Hz(f); // ms-20 linear
      ) : ( filterChoice == 20 ) ? (
        f = max(f, 0.003);
        outHz = .5 * srate * f_trafo_Hz(f); // ms-20 linear
      ) : ( filterChoice == 21 ) ? (
        f = max(f, 0.006);
        outHz = .227 * srate * f_trafo_Hz(f); // ms-20 non-linear LP
      ) : ( filterChoice == 22 ) ? (
        f = max(f, 0.004);      
        outHz = .227 * srate * f_trafo_Hz(f); // ms-20 non-linear BP
      ) : ( filterChoice == 23 ) ? (
        f = max(f, 0.004);
        outHz = .227 * srate * f_trafo_Hz(f); // ms-20 non-linear HP
      ) : ( filterChoice == 24 ) ? (
        outHz = 0; // Experimental (untuneable)
      ) : ( filterChoice == 25 ) ? (
        f = max(f, 0.004);
        outHz = .227 * srate * f_trafo_Hz(f); // strange thing based on ms-20
      ) : ( filterChoice == 26 ) ? (
        f = max(f, 0.0045);
        //outHz = 2 * .203 * srate * f_trafo_Hz(f); // ssm
        outHz = 1.87 * .24 * srate * f_trafo_Hz(f); // ssm
      ) : ( filterChoice == 27 ) ? (
        f = max(f, 0.0045);    
        //outHz = 2 * .203 * srate * f_trafo_Hz(f); // ssm
        outHz = 1.7 * .24 * srate * f_trafo_Hz(f); // ssm
      ) : ( filterChoice == 28 ) ? (
        f = max(f, 0.007);
        outHz = 1.28 * .39 * srate * f_trafo_Hz(f); // cem (very approximate)
      ) : ( filterChoice == 29 ) ? (
        f = max(f, 0.01);   
        outHz = .444 * srate * f_trafo_Hz(f); // ssm linear
      ) : ( filterChoice == 30 ) ? (
        f = max(f, 0.01);
        outHz = .716 * srate * f_trafo_Hz(f); // cem linear
      ) : ( filterChoice == 31 ) ? (
        outHz = 0; // Unclear, no resonant peak
      ) : ( filterChoice == 32 ) ? (
        outHz = 0; // Unclear, no resonant peak
      ) : ( filterChoice == 33 ) ? (
        f = max(f, 0.007);
        outHz = 0;//0.153 * srate * f_trafo_Hz(f); // very rough (poorly tuned)
      ) : ( filterChoice == 34 ) ? (
        // filterFreq = max(filterFreq, 0.004);
        outHz = 0; // Too inaccurate
      ) : ( filterChoice == 35 ) ? ( 
        //filterFreq = max(filterFreq, 0.0048);
        outHz = 0; // Too inaccurate
      ) : ( filterChoice == 36 ) ? (
        outHz = .77 * srate * f_trafo_Hz(f); // Wasp linear
      ) : ( filterChoice == 37 ) ? (
        // filterFreq = max(filterFreq, 0.006);
        outHz = 0; // Too inaccurate
      ) : ( filterChoice == 38 ) ? (
        // filterFreq = max(filterFreq, 0.006);
        outHz = 0; // Too inaccurate
      ) : ( ( filterChoice > 38 ) && ( filterChoice < 44 ) ) ? (
        f = max(f, 0.0035);
        outHz = .5 * f_trafo_Hz(f) * srate;
      ) : ( filterChoice == 44 ) ? (
        // filterFreq = max(filterFreq, 0.02);
        outHz = 0; // Too inaccurate
      ) : ( filterChoice == 45 ) ? (
        f = max(f, 0.0035);
        outHz = .5 * f_trafo_Hz(f) * srate;
      ) : ( filterChoice == 46 ) ? (
        f = max(f, 0.0035);
        outHz = .5 * f_trafo_Hz(f) * srate;
      ) : ( filterChoice == 47 ) ? (
        f = max(f, 0.0035);
        outHz = .5 * f_trafo_Hz(f) * srate;
      ) : ( filterChoice == 48 ) ? (
        outHz = 0; // comb (inaccurate)
      ) : ( filterChoice == 49 ) ? (
        outHz = .5 * f_trafo_Hz(f) * srate; // combed resonance
      ) : ( filterChoice == 50 ) ? (
        outHz = .5 * f_trafo_Hz(f) * srate; // combed resonance
      ) : ( filterChoice == 51 ) ? (
        f = max(f, 0.004);
        outHz = .444 * srate * f_trafo_Hz(f);
      ) : ( filterChoice == 52 ) ? (
        f = max(f, 0.004);
        outHz = .444 * srate * f_trafo_Hz(f);
      ) : ( filterChoice == 53 ) ? (
        f = max(f, 0.004);
        outHz = .6 * srate * f_trafo_Hz(f);
      ) : ( filterChoice > 83 ) ? (
        f = max(f, 0.0035);
        outHz = .5 * f_trafo_Hz(f) * srate;
      );
      
      outHz
  );  
  
  function prepLerp(slideridx_in, memloc_in, currentValue, linear)
    instance(slideridx, ptr, memloc, cur_x, cur_y, next, delta, nextVal, prevVal)
    local(next_x, next_y, dx)
    global(samplesblock)
    (
      ( linear ) ? (
        slideridx = slideridx_in;
        memloc = memloc_in;
      
        nextVal = currentValue;
        (samplesblock > 0) && ( samplesblock < 44100 ) ? (
          delta = (nextVal - prevVal) / (samplesblock);
          cur_y = prevVal;
        ) : (
          delta = 0;
          cur_y = nextVal;
        );
        
        // This ensures we never change delta (curSample is never negative)
        next = -10000;
        prevVal = nextVal;
      ) : (
        slideridx = slideridx_in;
        memloc = memloc_in;
        
        cur_x = 0;
        cur_y = currentValue;
        
        // Fetch the points
        ptr = memloc;
        while( (next_x = slider_next_chg(slideridx, next_y)) > -1 )
        (
          ptr[] = cur_x;
          ptr += 1;
          ptr[] = (next_y - cur_y) / (next_x - cur_x);
          ptr += 1;
          
          cur_x = next_x;
          cur_y = next_y;
        );
        ptr[]  = samplesblock;
        ptr[1] = 0;
        ptr[2] = -100;
              
        ptr = memloc;
        cur_y = currentValue;
        delta = 0;
        
        next = ptr[];
        prevVal = cur_y;
      );
    );
  
  /*function prepLerp(slideridx_in, memloc_in, currentValue)
    instance(slideridx, ptr, memloc, cur_x, cur_y, next, delta)
    local(next_x, next_y, dx)
    global(F1, F2, F3, F4, F5, F6, F7, F8, F9, samplesblock)
    global(samplesblock)
    (
      
      F1 = memloc[0];
      F2 = memloc[1];
      F3 = memloc[2];
      F4 = memloc[3];
      F5 = memloc[4];
      F6 = memloc[5];
      F7 = memloc[6];
      F8 = memloc[7];
      F9 = memloc[8];
    );*/
  
  function lerpSample()
    instance(slideridx, ptr, memloc, cur_x, cur_y, delta, next)
    global(curSample, potato)
    local()
    (
      ( next == curSample ) ? (
        ptr += 1;
        delta = ptr[];
        ptr += 1;
        next = ptr[];
      );
      
      cur_y += delta
    );
    
function selectBuffer(isR, isFilt2, isGFX)
  global(delay_buf1, delay_buf2, delay_buf3, delay_buf4,
         delay_buf5, delay_buf6, delay_buf7, delay_buf8)
  (
    (isGFX == 1 ) ? (
      (isFilt2 == 1) ?
      (
        (isR == 1) ? delay_buf8 : delay_buf7
      ) : (
        (isR == 1) ? delay_buf6 : delay_buf5
      )
    ) : (
      (isFilt2 == 1) ?
      (
        (isR == 1) ? delay_buf4 : delay_buf3
      ) : (
        (isR == 1) ? delay_buf2 : delay_buf1
      )
    )
  );
  

function folder_init_old(cutoff, reso)
  local(RL)
  instance(alpha, beta, gamma, betagamma, dc_scum)
  global()
  (
    RL = (8000+49000*cutoff);

    /*alpha = - 2 * RL / 15000;
    beta  = RL * .00000000000000001;
    gamma = 1 / .025864;
    betagamma = beta*gamma;*/
    alpha = -0.0001333333333333 * RL;
    beta  = RL * .00000000000000001;
    gamma = 38.6637797711104199;
    betagamma = beta*gamma;
    dc_scum = .1 * reso;
  );
  
function folder_init(cutoff, reso)
  local(R, RL, Vt, iVt)
  instance(dc_scum, alpha, beta, delta)
  global()
  (
    R       = 15000;
    RL      = (8000+49000*cutoff);
    iVt     = 1/.025864;
    dc_scum = .1 * reso;
    
    alpha   = 2 * RL / R;
    beta    = (alpha + 1) * iVt;
    delta   = log( RL * .00000000000000001 * iVt );
  );  
  
function folder_res(sample, vout, alpha, l2betagamma, lgamma, lbeta)
  global()
  local(expv)
  instance(f_trial, J_trial)
  (
    expv    = exp( lgamma * (sample - vout) );
    J_trial = 1 + expv*l2betagamma;
    f_trial = vout - alpha*sample - lbeta * expv;
  );
  
  // Approximation to W(exp(x))
function lambertExpApprox(x)  
  local(ex, approx, v, c, p, t, f)
  global()
  instance()
  (
    ex = exp(x);
    
    approx = sqrt(2*$e*ex + 2) - 1;
    v = log(ex + 1);
    v = v - log(v);
    c = abs(ex + 1/$e);
    c = (c > 1.45);
    approx = (1 - c)*approx + c*v;
    loop(2,
      p = exp(approx);
      t = approx*p - ex;
//      f = (approx ~= -1);
//      t = f*t/(p*(approx + f) - 0.5*(approx + 2.0)*t/(approx + f));
      t = t/(p*(approx + 1) - 0.5*(approx + 2.0)*t/(approx + 1));
      approx = approx - t;
    );
    
    approx
  );
  
function folder_eval(sample)
  local(lambda)
  instance(alpha, beta, delta)
  global()
  (
    lambda = sign(sample);
    .025864 * lambda * lambertExpApprox( lambda * beta * sample + delta ) - alpha * sample
  );  
  
function serge_init(cutoff, reso)
  local(Is, nu, R1, Vt)
  instance(dc_scum, alpha, beta, delta)
  global()
  (
    Is = 0.00000000252;
    nu = 1.752;
    R1 = 33000;
    Vt = .025864;
    
    alpha = -2 * nu * Vt;
    beta = 1/(nu*Vt); 
    delta = log(R1*Is*beta);
  );  

function serge_eval(sample)
  local(lambda)
  instance(alpha, beta, delta)
  global()
  (
    lambda = sign(sample);
    sample + lambda * alpha * lambertExpApprox( lambda * beta * sample + delta  );
  );  
  
function folder_eval_old(sample)
  local(step, nRej, err, newErr, v_trial, l2betagamma, lgamma, lbeta, expv, lambda)
  instance(f_trial, J_trial, vout, iter
           alpha, beta, gamma)
  global()
  (
    step = 1;
    nRej = 0;
    iter = 0;

    lambda = sign(sample);
    lgamma = lambda*gamma;
    lbeta = lambda*beta;
    l2betagamma = lgamma*lbeta;
    
    vout = -0.001;
    
    this.folder_res(sample, vout, alpha, l2betagamma, lgamma, lbeta);
    err = abs(f_trial);
    
    while( iter < 15 && err > 0.00001 ) (
      v_trial = vout - step * f_trial/J_trial;
      
      this.folder_res(sample, v_trial, alpha, l2betagamma, lgamma, lbeta);
      newErr = abs(f_trial);
      
      (newErr < err) ?
      (
        // Accept step
        vout = v_trial;
        err = newErr;
      ) : (
        // Reject step and lower stepsize
        step = step * .5;
        nRej += 1;
      );
            
      iter += 1;
    );
  
    vout
  );  

function allpass(s)
  local(xhat, xhatm1)
  instance(f, a)
  global()
  (
    xhatm1 = this.readBufferFrac(f);
    xhat = s + a * xhatm1;
    this.updateBuffer(xhat);
    
    xhatm1 - a * xhat
  );  
  
function diffuser_clear()
  global()
  local()
  instance( otm1, itm1,
            allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8 )
  (
    allpass1.clearBuffer();
    allpass2.clearBuffer();
    allpass3.clearBuffer();
    allpass4.clearBuffer();
    allpass5.clearBuffer();
    allpass6.clearBuffer();
    allpass7.clearBuffer();
    allpass8.clearBuffer();
    otm1 = itm1 = 0;
  );  
  
function diffuser_init(filterFreq, filterReso, delayBuffer)
  instance(allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, r)
  local(cD, os, 
        f1, f2, f3, f4, f5, f6, f7, f8, 
        a1, a2, a3, a4, a5, a6, a7, a8,
        Fs)
  global(slider54, globalTime)
  (
    os = max(1,slider54);
    
    cD = delayBuffer;
    r  = 11.11111111111111111*(filterReso-.9)*(filterReso>.9);
    r  = r*r;
  
    filterFreq = 2*filterFreq;
    f1 = 100   + 100*filterFreq;
    f2 = 60    + 224*filterFreq;
    f3 = 40    + 306*filterFreq + 5*sin(globalTime);
    f4 = 80    + 560*filterFreq;
    f5 = 30    + 703*filterFreq + 10*sin(.5*globalTime);
    f6 = 90    + 130*filterFreq;
    f7 = 140.4 + 516*filterFreq + 5*sin(globalTime);
    f8 = 250   + 200*filterFreq;

    f1 = f1 * os;
    f2 = f2 * os;
    f3 = f3 * os;
    f4 = f4 * os;
    f5 = f5 * os;
    f6 = f6 * os;
    f7 = f7 * os;
    f8 = f8 * os;
    
    a1 = a2 = a3 = a4 = .9995*filterReso;
    a5 = a6 = a7 = a8 = .9995*filterReso;
  
    Fs = 10000*os;
    allpass1.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass1.setOffset(f1);
    allpass1.f = f1 - floor(f1);
    allpass1.a = a1;
    
    allpass2.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass2.setOffset(f2);
    allpass2.f = f2 - floor(f2);
    allpass2.a = a2;
    
    allpass3.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass3.setOffset(f3);
    allpass3.f = f3 - floor(f3);
    allpass3.a = a3;
        
    allpass4.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass4.setOffset(f4);
    allpass4.f = f4 - floor(f4);
    allpass4.a = a4;
    
    allpass5.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass5.setOffset(f5);
    allpass5.f = f5 - floor(f5);
    allpass5.a = a5;
    
    allpass6.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass6.setOffset(f6);
    allpass6.f = f6 - floor(f6);
    allpass6.a = a6;
    
    allpass7.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass7.setOffset(f7);
    allpass7.f = f7 - floor(f7);
    allpass7.a = a7;
    
    allpass8.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass8.setOffset(f8);
    allpass8.f = f8 - floor(f8);
    allpass8.a = a8;
  );
  
function diffuser_eval(sample)
  instance(allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, u8, r, otm1, itm1)
  local(cD, u1, u2, u3, u4, u5, u6, u7, v)
  global()
  (
    u1  = allpass1.allpass(sample);
    u2  = allpass2.allpass(u1);
    
    u3  = allpass3.allpass(u2);
    u4  = allpass4.allpass(u3);
    
    u5  = allpass5.allpass(u4-.025*u1);
    u6  = allpass6.allpass(u5);
    
    u7  = allpass7.allpass(u6-.025*u3);
    u8  = allpass8.allpass(u7);
    
    v = (1+2*r)*(u8-sample*r);
    
    // Small single pole highpass to prevent DC blowups.
    otm1=0.999*otm1 + v - itm1;
    itm1=v;
    
    otm1
  );
  
  
function space_clear()
  global()
  local()
  instance( otm1, itm1, u8, u9, u10,
            allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, allpass9, allpass10 )
  (
    allpass1.clearBuffer();
    allpass2.clearBuffer();
    allpass3.clearBuffer();
    allpass4.clearBuffer();
    allpass5.clearBuffer();
    allpass6.clearBuffer();
    allpass7.clearBuffer();
    allpass8.clearBuffer();
    allpass9.clearBuffer();
    allpass10.clearBuffer();
    otm1 = itm1 = 0;
    u8 = u9 = u10=0;
  );  
  
function space_init(filterFreq, filterReso, delayBuffer)
  instance(allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, allpass9, allpass10, r)
  local(cD, os, 
        f1, f2, f3, f4, f5, f6, f7, f8
        a1, a2, a3, a4, a5, a6, a7, a8
        Fs)
  global(slider54)
  (
    cD = delayBuffer;
    r  = 11.11111111111111111*(filterReso-.9)*(filterReso>.9);
    r  = r*r;
  
    filterFreq = 2*filterFreq;
    f1 = 100   + 200*filterFreq;
    f2 = 60    + 424*filterFreq;
    f3 = 40    + 606*filterFreq;
    f4 = 80    + 860*filterFreq;
    f5 = 30    + 303*filterFreq;
    f6 = 90    + 530*filterFreq;
    f7 = 140.4 + 716*filterFreq;
    f8 = 250   + 900*filterFreq;

    os = max(1,slider54);
    f1 = f1 * os;
    f2 = f2 * os;
    f3 = f3 * os;
    f4 = f4 * os;
    f5 = f5 * os;
    f6 = f6 * os;
    f7 = f7 * os;
    f8 = f8 * os;
        
    a1 = a2 = a3 = a4 = -.92*filterReso;
    a5 = a6 = a7 = a8 = -.92*filterReso;
 
    Fs = 10000;
    allpass1.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass1.setOffset(f1);
    allpass1.f = f1 - floor(f1);
    allpass1.a = a1;
    
    allpass2.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass2.setOffset(f2);
    allpass2.f = f2 - floor(f2);
    allpass2.a = a2;
    
    allpass3.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass3.setOffset(f3);
    allpass3.f = f3 - floor(f3);
    allpass3.a = a3;
        
    allpass4.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass4.setOffset(f4);
    allpass4.f = f4 - floor(f4);
    allpass4.a = a4;
    
    allpass5.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass5.setOffset(f5);
    allpass5.f = f5 - floor(f5);
    allpass5.a = a5;
    
    allpass6.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass6.setOffset(f6);
    allpass6.f = f6 - floor(f6);
    allpass6.a = a6;
    
    allpass7.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass7.setOffset(f7);
    allpass7.f = f7 - floor(f7);
    allpass7.a = a7;
    
    allpass8.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass8.setOffset(f8);
    allpass8.f = f8 - floor(f8);
    allpass8.a = a8;
    
    allpass9.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass9.setOffset(f8);
    allpass9.f = f8 - floor(f8);
    allpass9.a = a8;
    
    allpass10.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass10.setOffset(f8);
    allpass10.f = f8 - floor(f8);
    allpass10.a = a8;
  );
  
function space_eval(sample)
  instance(allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, allpass9, allpass10, u8, u9, u10, r, otm1, itm1)
  local(cD, u1, u2, u3, u4, u5, u6, u7, v)
  global()
  (
    u1  = allpass1.allpass(sample);
    u2  = allpass2.allpass(u1);
    
    u3  = allpass3.allpass(u2);
    u4  = allpass4.allpass(u3);
    
    u5  = allpass5.allpass(u4);
    u6  = allpass6.allpass(u5);
    
    u7  = allpass7.allpass(u6*(1-.85*u10));
    u8  = allpass8.allpass(u7);
    
    u9  = allpass9.allpass(u8-.9*u1);
    u10 = allpass10.allpass(u9-.9*u1);
    
    v = u10;
    v = (1+2*r)*(u10+sample*r);
    
    // Small single pole highpass to prevent DC blowups.
    otm1=0.999*otm1 + v - itm1;
    itm1=v;
    
    otm1
  );
  
  
function worp_clear()
  global()
  local()
  instance( otm1, itm1, u8,
            allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, allpass9, allpass10 )
  (
    allpass1.clearBuffer();
    allpass2.clearBuffer();
    allpass3.clearBuffer();
    allpass4.clearBuffer();
    allpass5.clearBuffer();
    allpass6.clearBuffer();
    allpass7.clearBuffer();
    allpass8.clearBuffer();
    allpass9.clearBuffer();
    allpass10.clearBuffer();
    otm1 = itm1 = 0;
    u8 = 0;
  );  
  
function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2
  );  
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );  
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );
  
function eval_linearSVF_notch(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1
  );
  
function eval_linearSVF_peak(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;
    
    v0 - k*v1 -2*v2
  );  
  
function crunch_init(filterFreq, filterReso, delayBuffer, _isR)
  instance(svflp, svfhp, svfbp, crunchLevel, cranchLevel, isR, haasLag)
  local(fr1, fr2, fr3, q, Fs, cD, f1)
  global(slider54, israte)
  (
    crunchLevel = 8*filterReso;
    cranchLevel = 3*filterReso;
    isR = _isR;
    
    fr1 = 150*israte;
    fr2 = (150+filterFreq*(2000-150))*israte;

    fr3 = 1000*israte;
    q = .7;
    
    Fs = 10000; cD = 0; f1 = 100*slider54;
    haasLag.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    haasLag.setOffset(f1);
    haasLag.f = f1 - floor(f1);
  
    this.svflp.init_linearSVF_direct(fr1, 0);
    this.svfhp.init_linearSVF_direct(fr2, 0);
    this.svfbp.init_linearSVF_direct(fr3, q);
    1
  );  
  
function crunch_reset()
  instance(svflp, svfhp, svfbp)
  local()
  global()
  (
    this.svflp.reset_linearSVF();
    this.svfhp.reset_linearSVF();
    this.svfbp.reset_linearSVF();
  );
    
function crunch_eval(sample)
  instance(svflp, svfhp, svfbp, crunchLevel, cranchLevel, isR, dl1, dl2, dl3, haasLag, bp)
  local(lp, crunch)
  global()
  (
    sample = sample;// + bp;
    lp = svflp.eval_linearSVF_LP(sample);
    crunch = tanh(crunchLevel*(sample-lp+cranchLevel*sample*bp));
    
    // Haas the high
    isR ? (
      crunch = haasLag.allpass(crunch);
    );
    
    crunch = svfhp.eval_linearSVF_HP(crunch);
    
    bp = svfbp.eval_linearSVF_BP(crunch+lp);
    
    sample+crunch
  );
  
function athena_init(filterFreq, filterReso, delayBuffer, _isR)
  instance(svflp, svfhp, svfhp2, fr, fc, tav, at, rt)
  local(fr1, fr2, fr3)
  global(slider54, israte)
  (
    fr = filterFreq;
    fc = filterReso;
    
    tav = 0.01;
    at = 0.1;
    rt = 0.003-0.0025*fc;
    
    fr1 = 200*israte;
    fr2 = 2000*israte;
    fr3 = (150+filterFreq*(2000-150))*israte;
  
    this.svfhp.init_linearSVF_direct(fr1, 0);
    this.svflp.init_linearSVF_direct(fr2, 0);
    this.svfhp2.init_linearSVF_direct(fr3, 0);
  );  
  
function athena_reset()
  instance(svflp, svfhp, svfhp2, g, rms_est)
  local()
  global()
  (
    this.svflp.reset_linearSVF();
    this.svfhp.reset_linearSVF();
    this.svfhp2.reset_linearSVF();
    g = 1;
    rms_est = 1;
  );
    
function athena_eval(sample)
  instance(svflp, svfhp, svfhp2, tav, rms_est, g, at, rt, fc, fr)
  local(s1, s2, scomp, f, g_now, rms_log, CT, ET, CS, ES, coeff)
  global()
  (
    sample = sample;// + bp;
    s1 = svfhp.eval_linearSVF_HP(sample);
    
    // Compressor unit
    CT = -25-15*fc;    // Threshold (dB)
    CS = 2.6;          // Slope
    rms_est = (1-tav)*rms_est + tav * s1*s1;
    rms_log = 10*log10(rms_est);
    g_now = min(0, CS*(CT-rms_log));
    f = 10^(g_now/20);
    coeff = (f < g_now) ? at : rt;
    g = (1-coeff)*g + coeff*f;
    scomp = g * s1;
    
    // Lowpass
    s2 = svflp.eval_linearSVF_LP(s1);

    // Half wave rectification
    s2 = (s2 + abs(s2))*.5;
    
    sample+15*scomp*fr*s2;
  );  
  
function worp_init(filterFreq, filterReso, delayBuffer, _isR)
  instance(allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, allpass9, allpass10, r, isR, reso, K, gain)
  local(cD, os, 
        f1, f2, f3, f4, f5, f6, f7, f8, f9, f10,
        a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
        Fs)
  global(slider54)
  (
    reso = filterReso;
    K = .942*reso;
    gain = 1/(1+2*reso);
    cD = delayBuffer;
    isR = _isR;
    r  = 11.11111111111111111*(filterReso-.9)*(filterReso>.9);
    r  = r*r;
  
    filterFreq = 2*filterFreq;
    f1 = 200    + 200*filterFreq;
    f2 = 360    + 424*filterFreq;
    f3 = 140    + 606*filterFreq;
    f4 = 380    + 860*filterFreq;
    f5 = 230    + 303*filterFreq;
    f6 = 490    + 530*filterFreq;
    f7 = 140.4  + 716*filterFreq;
    f8 = 2250   + 900*filterFreq;
    f9 = f7;
    f10 = f8;

    os = max(1,slider54);
    f1 = f1 * os;
    f2 = f2 * os;
    f3 = f3 * os;
    f4 = f4 * os;
    f5 = f5 * os;
    f6 = f6 * os;
    f7 = f7 * os;
    f8 = f8 * os;
    f9 = f9 * os;
    f10 = f10 * os;
    
    a1 = a2 = a3 = a4 = .5;
    a5 = a6 = a7 = a8 = .5;
    a9 = .85;
    a10 = .85;
 
    Fs = 5000*os;
    allpass1.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass1.setOffset(f1);
    allpass1.f = f1 - floor(f1);
    allpass1.a = a1;
    
    allpass2.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass2.setOffset(f2);
    allpass2.f = f2 - floor(f2);
    allpass2.a = a2;
    
    allpass3.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass3.setOffset(f3);
    allpass3.f = f3 - floor(f3);
    allpass3.a = a3;
        
    allpass4.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass4.setOffset(f4);
    allpass4.f = f4 - floor(f4);
    allpass4.a = a4;
    
    allpass5.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass5.setOffset(f5);
    allpass5.f = f5 - floor(f5);
    allpass5.a = a5;
    
    allpass6.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass6.setOffset(f6);
    allpass6.f = f6 - floor(f6);
    allpass6.a = a6;
    
    allpass7.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass7.setOffset(f7);
    allpass7.f = f7 - floor(f7);
    allpass7.a = a7;
    
    allpass8.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass8.setOffset(f8);
    allpass8.f = f8 - floor(f8);
    allpass8.a = a8;
    
    allpass9.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass9.setOffset(f9);
    allpass9.f = f9 - floor(f9);
    allpass9.a = a9;
    
    allpass10.initBufferNoReset(cD, cD+Fs); cD+=Fs+1;
    allpass10.setOffset(f10);
    allpass10.f = f10 - floor(f10);
    allpass10.a = a10;
  );
  
  
  
function worp_eval(sample)
  instance(allpass1, allpass2, allpass3, allpass4, allpass5, allpass6, allpass7, allpass8, allpass9, allpass10, r, otm1, itm1, isR,
           u8, K, reso, gain)
  local(cD, u2, u4, u6, u1, u3, u5, u7, u9, u10, v)
  global()
  (
    u1  = allpass1.allpass(sample + u8*K);
    u2  = allpass2.allpass(u1);
    
    u3  = allpass3.allpass(sample + u2*K);
    u4  = allpass4.allpass(u3);
    
    u5  = allpass5.allpass(sample + u4*K);
    u6  = allpass6.allpass(u5);
    
    u7  = allpass7.allpass(sample + u6*K);
    u8  = allpass8.allpass(u7);
    
    u9  = allpass9.allpass(u7+u8);
    u10 = allpass10.allpass(u2+u7);
    
    isR ? v = u1 + u3 + u5 + u7 + u9 : v = u2 + u4 + u6 + u8 + u10;
    v = v*gain;
    
    // Small single pole highpass to prevent DC blowups.
    otm1=0.999*otm1 + v - itm1;
    itm1=v;
    
    otm1
  );  
  
function updateActiveFilter(sliderValue, filterFreq, filterReso, isR, isFilt2, isGFX)
  global( filter_delay1, filter_delay2, /* Audio */
          filter_delay3, filter_delay4, 
          filter_delay5, filter_delay6, /* GFX   */
          filter_delay7, filter_delay8
          slider54, slider56, forceUpdate, selectBuffer
          srate, postResetWaitSamples,
          filter_delay1.initBufferNoReset, filter_delay2.initBufferNoReset, 
          filter_delay3.initBufferNoReset, filter_delay4.initBufferNoReset, 
          filter_delay5.initBufferNoReset, filter_delay6.initBufferNoReset, 
          filter_delay7.initBufferNoReset, filter_delay8.initBufferNoReset, 
          filter_delay1.setOffset, filter_delay2.setOffset,
          filter_delay3.setOffset, filter_delay4.setOffset,
          filter_delay5.setOffset, filter_delay6.setOffset,
          filter_delay7.setOffset, filter_delay8.setOffset )
  local(val, delayBuffer, delayBuffer2)
  instance()
 ( 
    this.filtertype = sliderValue;
    
    ( sliderValue == 1 ) ? (
      this.rc_filter.initRC(filterFreq, filterReso);
    ) : ( sliderValue == 2 ) ? (
      filterFreq = max(filterFreq, 0.005);
      this.filter_303.init303(filterFreq, filterReso);
    ) : ( sliderValue == 3 ) ? (
      this.filter_vowel.initvowel(filterFreq, filterReso);
    ) : ( sliderValue == 4 ) ? (
      filterFreq = max(filterFreq, 0.005);
      this.filter_karlsen.initkarlsen(filterFreq, filterReso);
    ) : ( sliderValue == 5 ) ? (
      filterFreq = max(filterFreq, 0.005);
      this.filter_karlsen_sat.initkarlsen_sat(filterFreq, filterReso);
    ) : ( sliderValue == 6 ) ? (
      ( slider54 < 2 ) ? ( 
        slider54 = 2;
        slider_automate(slider54);
        forceUpdate = 1;
      );
      filterFreq = max(filterFreq, 0.003);
      this.filter_dualfilt.initdualfilt(filterFreq, filterReso);
    ) : ( sliderValue == 7 ) ? (
      ( slider54 < 2 ) ? ( 
        slider54 = 2;
        slider_automate(slider54);
        forceUpdate = 1;
      );
      filterFreq = max(filterFreq, 0.003);
      this.filter_dualfiltHP.initdualfilt(filterFreq, filterReso);
    ) : ( sliderValue == 8 ) ? (
      ( slider54 < 2 ) ? ( 
        slider54 = 2;
        slider_automate(slider54);
        forceUpdate = 1;
      );
      filterFreq = max(filterFreq, 0.003);
      this.filter_dualfiltBP.initdualfilt(filterFreq, filterReso);
    ) : ( sliderValue == 9 || sliderValue == 10 ) ? (
      ( slider54 < 2 ) ? ( 
        slider54 = 2;
        slider_automate(slider54);
        forceUpdate = 1;
        );
      filterFreq = max(filterFreq, 0.003);
      this.filter_fancymoog.initfancymoog(filterFreq, filterReso);
    ) : ( sliderValue == 11 ) ? (
      filterFreq = max(filterFreq, 0.003);
      this.filter_notch.initnotch(filterFreq, filterReso);
    ) : ( sliderValue == 12 ) ? (
      this.filter_sai0.initsai0(filterFreq, filterReso);
    ) : ( sliderValue == 13 ) ? (
      this.filter_modulator.initmodulator(filterFreq, filterReso);
    ) : ( sliderValue == 14 ) ? (
      this.filter_phaser.initphaserOTA(filterFreq, filterReso);
      this.filter_phaser2.initphaserOTA(filterFreq*2, filterReso);
      this.filter_phaser3.initphaserOTA(filterFreq/2, filterReso);
      this.filter_phaser4.initphaserOTA(filterFreq/3, filterReso);   
    ) : ( sliderValue == 15 ) ? (
      this.filter_phaser.initphaserFET(filterFreq, filterReso);
      this.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
      this.filter_phaser3.initphaserFET(filterFreq/2, filterReso);
      this.filter_phaser4.initphaserFET(filterFreq/3, filterReso);
    ) : ( sliderValue == 16 ) ? (
      this.isGFX = isGFX;
      this.isFilt2 = isFilt2;
      this.filter_dualfilt.initdualfilt(max(filterFreq, 0.0001), filterReso);

      //filter_delay1.initBufferNoReset(delayBuffer, delayBuffer + max(1,slider54)*filterFreq * 1000);     
      //filter_delay2.initBufferNoReset(delayBuffer2, delayBuffer2 + max(1,slider54)*filterReso * 2000);
      !isGFX ? (
        !isFilt2 ? (
          filter_delay1.setOffset(1+max(1,slider54)*filterFreq * 1000);
          filter_delay2.setOffset(1+max(1,slider54)*filterReso * 2000);
        ) : (
          filter_delay3.setOffset(1+max(1,slider54)*filterFreq * 1000);
          filter_delay4.setOffset(1+max(1,slider54)*filterReso * 2000);
        )
      ) : (
        !isFilt2 ? (
          filter_delay5.setOffset(1+max(1,slider54)*filterFreq * 1000);
          filter_delay6.setOffset(1+max(1,slider54)*filterReso * 2000);
        ) : (
          filter_delay7.setOffset(1+max(1,slider54)*filterFreq * 1000);
          filter_delay8.setOffset(1+max(1,slider54)*filterReso * 2000);
        )
      )
    ) : ( sliderValue == 17 ) ? (
      this.isGFX = isGFX;
      this.isFilt2 = isFilt2;
      this.filter_dualfilt.initdualfilt(max(filterFreq, 0.0001), filterReso);

      //filter_delay1.initBufferNoReset(delayBuffer, delayBuffer + max(1,slider54)*filterFreq*(1000+4000*filterReso));
      //filter_delay2.initBufferNoReset(delayBuffer2, delayBuffer2 + max(1,slider54)*filterFreq*(1000+4000*filterReso)); 
      !isGFX ? (
        !isFilt2 ? (
          filter_delay1.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
          filter_delay2.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
        ) : (
          filter_delay3.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
          filter_delay4.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
        )
      ) : (
        !isFilt2 ? (
          filter_delay5.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
          filter_delay6.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
        ) : (
          filter_delay7.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
          filter_delay8.setOffset(1+max(1,slider54)*filterFreq*(1000+4000*filterReso));
        )
      )
    ) : ( sliderValue == 18 ) ? (
      filterFreq = max(filterFreq, 0.003);
      this.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
    ) : ( sliderValue == 19 ) ? (
      filterFreq = max(filterFreq, 0.003);
      this.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
    ) : ( sliderValue == 20 ) ? (
      filterFreq = max(filterFreq, 0.003);
      this.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
    ) : ( sliderValue == 21 ) ? (
      filterFreq = max(filterFreq, 0.006);
      this.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 22 ) ? (
      filterFreq = max(filterFreq, 0.004);    
      this.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 23 ) ? (
      filterFreq = max(filterFreq, 0.004);
      this.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 24 ) ? (
      this.filter_ms20.init_MS20_nonlin(max(filterFreq, 0.003), filterReso);
      this.filter_phaser.initphaserFET(max(filterFreq, 0.003), filterReso);
      this.filter_phaser2.initphaserFET(max(filterFreq, 0.003)*2, filterReso);
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + max(1,slider54)*filterReso * (50+isR));
    ) : ( sliderValue == 25 ) ? (
      filterFreq = max(filterFreq, 0.004);
      this.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 26 ) ? (
      filterFreq = max(filterFreq, 0.0045);
      this.filter_ssm.init_ssm_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 27 ) ? (
      filterFreq = max(filterFreq, 0.0045);    
      this.filter_ssm.init_ssm_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 28 ) ? (
      filterFreq = max(filterFreq, 0.007);
      this.filter_cem.init_cem_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 29 ) ? (
      filterFreq = max(filterFreq, 0.01);   
      this.filter_ssm_lin.init_ssm_lin(filterFreq, filterReso);
    ) : ( sliderValue == 30 ) ? (
      filterFreq = max(filterFreq, 0.01);
      this.filter_cem_lin.init_cem_lin(filterFreq, filterReso);
    ) : ( sliderValue == 31 ) ? (
      this.filter_sine.initSine(filterFreq, filterReso);
    ) : ( sliderValue == 32 ) ? (
      this.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      this.filter_sine.initSine(filterFreq, filterReso);
    ) : ( sliderValue == 33 ) ? (
      filterFreq = max(filterFreq, 0.007);
      this.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      this.filter_sine.initSine(filterFreq, filterReso);
    ) : ( sliderValue == 34 ) ? (
      filterFreq = max(filterFreq, 0.004);
      this.filter_broken.init_MS20_nonlin(.5*filterFreq, filterReso);
    ) : ( sliderValue == 35 ) ? (
      filterFreq = max(filterFreq, 0.0048);
      this.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 36 ) ? (
      filterFreq = max(filterFreq, 0.0048);
      this.filter_wasp_lin.init_wasplin(filterFreq, filterReso);
    ) : ( sliderValue == 37 ) ? (
      filterFreq = max(filterFreq, 0.006);
      this.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
    ) : ( sliderValue == 38 ) ? (
      filterFreq = max(filterFreq, 0.006);
      this.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
    ) : ( ( sliderValue > 38 ) && ( sliderValue < 44 ) ) ? (
      filterFreq = max(filterFreq, 0.0035);
      this.filter_SVF.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue == 44 ) ? (
      filterFreq = max(filterFreq, 0.02);
      this.filter_wasp.init_wasp_nonlin_saw(filterFreq, filterReso);
    ) : ( sliderValue == 45 ) ? (
      filterFreq = max(filterFreq, 0.0035);
      this.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
      this.filter_SVF.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue == 46 ) ? (
      filterFreq = max(filterFreq, 0.0035);
      this.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
      this.filter_SVF.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue == 47 ) ? (
      filterFreq = max(filterFreq, 0.0035);
      this.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
      this.filter_SVF.init_linearSVF( filterFreq, filterReso );
      this.filter_SVF2.init_linearSVF( filterFreq*.5, filterReso*.5 );
    ) : ( sliderValue == 48 ) ? (
      val = ( pow(10, filterFreq) - 1 ) / 9;
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.chan = isR;
      this.stereoize = filterReso > 0.5 ? 1 : 0;
      //this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + max(1,slider54)*val * 250);
      this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + 5000);
      this.filter_delay.setOffset(1+max(1,slider54)*val * 250);
    ) : ( sliderValue == 49 ) ? (
      /* Combed resonance */
      val = ( pow(10, filterFreq) - 1 ) / 9;
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.chan = isR;

      //this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + max(1,slider54)*val * 250);
      this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + 5000);
      this.filter_delay.setOffset(1+max(1,slider54)*val * 250);
      this.filter_SVF_nores.init_linearSVF( max(filterFreq, 0.0035), 0 );
      this.filter_SVF.init_linearSVF( max(filterFreq, 0.0035), filterReso );
    ) : ( sliderValue == 50 ) ? (
      val = ( pow(10, filterFreq) - 1 ) / 9;
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.chan = isR;
      this.stereoize = filterReso;
      //this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + max(1,slider54)*val * 250);  
      this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer + 5000);
      this.filter_delay.setOffset(1+max(1,slider54)*val * 250);
      this.filter_SVF_nores.init_linearSVF( max(filterFreq, 0.0035), 0 );
      this.filter_SVF.init_linearSVF( max(filterFreq, 0.0035), filterReso );
    ) : ( sliderValue == 51 ) ? (
      filterFreq = max(filterFreq, 0.004);
      this.filter_ms20.init_MS20_nonlin_2(filterFreq, filterReso);
    ) : ( sliderValue == 52 ) ? (
      filterFreq = max(filterFreq, 0.004);
      this.filter_ms20.init_MS20_nonlin_2(filterFreq, filterReso);
    ) : ( sliderValue == 53 ) ? (
      filterFreq = max(filterFreq, 0.004);
      this.filter_ms20.init_MS20_nonlin_2(filterFreq, filterReso);
    ) : ( sliderValue == 54 ) ? (
      this.weeping.weeping_init(filterFreq, filterReso, 0);
    ) : ( sliderValue == 55 ) ? (
      filterFreq = max(filterFreq, 0.0025);
      this.pwm.pwm_init(filterFreq, filterReso);
      sliderValue=sliderValue;
    ) : ( sliderValue == 56 ) ? (
      filterFreq = max(filterFreq, 0.0018);
      this.pwm.pwm_init(filterFreq, filterReso);
      sliderValue=sliderValue;      
    ) : ( sliderValue == 57 ) ? (
      this.bit.bit_init(filterFreq, filterReso);
    ) : ( sliderValue == 58 ) ? (
      this.muck.muck_init(filterFreq, filterReso);
    ) : ( slidervalue == 59 ) ? (
      this.weeping.weeping_init(filterFreq, filterReso, 1);
    ) : ( sliderValue == 60 ) ? (
      slider54 > 2 ? ( slider_automate( slider54 = 2 ); forceUpdate = 1; );
    
      (this.wah.l_srate != srate * max(1,slider54) ) ? (
        this.wah.dlop_init_srate(srate * max(1,slider54));
        postResetWaitSamples = 8192;
      );
      this.wah.dlop_init_cutoff(.8*filterFreq, filterReso);
    ) : ( sliderValue == 61 ) ? (
      slider54 != 2 ? ( slider_automate( slider54 = 2 ); forceUpdate = 1; );
    
      (this.wah.l_srate != .5 * srate * max(1,slider54) ) ? (
        this.wah.dlop_init_srate(.5 * srate * max(1,slider54));
        postResetWaitSamples = 8192;
      );
      this.wah.dlop_init_cutoff(.8*filterFreq, filterReso);
    ) : ( sliderValue == 62 ) ? (
      slider54 > 2 ? ( slider_automate( slider54 = 2 ); forceUpdate = 1; );
    
      (this.wah.l_srate != 2 * srate * max(1,slider54) ) ? (
        this.wah.dlop_init_srate(2 * srate * max(1,slider54));
        postResetWaitSamples = 8192;
      );
      this.wah.dlop_init_cutoff(.8*filterFreq, filterReso);
    ) : ( sliderValue == 63 ) ? (
      this.vowel_svf.initvowelSVF(filterFreq, filterReso);
    ) : ( sliderValue == 64 ) ? (
      this.vowel_svf.initvowelSVF(filterFreq, filterReso);
    ) : ( sliderValue == 65 ) ? (
      this.kot.kot_init(filterReso, filterFreq);
    ) : ( sliderValue == 66 ) ? (
      this.modulon.modulon_init(max(.5*filterFreq, 0.0075), filterReso);
    ) : ( sliderValue == 67 ) ? (
      this.octaver.octaver_init(filterFreq, filterReso);
    ) : ( sliderValue == 68 ) ? (
      this.octaverUp.octaverUp_init(filterFreq, filterReso);
    ) : ( sliderValue == 69 ) ? (
      this.metallic.metallic_init(filterFreq, filterReso);
    ) : ( sliderValue == 70 ) ? (
      this.frazzle.frazzle_init(filterFreq, filterReso);
    ) : ( sliderValue == 71 ) ? (
      this.phone.phone_init(filterFreq, filterReso);
    ) : ( sliderValue == 72 ) ? (
      this.modulon.modulon_fixed_init(max(filterFreq, 0.0075), filterReso);
    ) : ( sliderValue == 73 ) ? (
      this.modulon.modulatrix_init(max(filterFreq, 0.0075), filterReso);
    ) : ( sliderValue == 74 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.vibrato.vibrato_init(filterFreq, filterReso);
      this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer+50000);
    ) : ( sliderValue == 75 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.vibrato.vibrato_init(filterFreq, filterReso);
      this.vibrato.isR = isR;
      this.filter_delay.initBufferNoReset(delayBuffer, delayBuffer+50000);
    ) : ( sliderValue == 76 ) ? (
      this.folder.folder_init(filterFreq, filterReso);
    ) : ( sliderValue == 77 ) ? (
      this.folder1.folder_init(filterFreq, filterReso);
      this.folder2.folder_init(filterFreq, filterReso);
      this.folder3.folder_init(filterFreq, filterReso);
      this.folder4.folder_init(filterFreq, filterReso);
    ) : ( sliderValue == 78 ) ? (
      this.serge1.gain = filterFreq;
      this.serge1.serge_init(filterFreq, filterReso);
      this.serge2.serge_init(filterFreq, filterReso);
      this.serge3.serge_init(filterFreq, filterReso);
      this.serge4.serge_init(filterFreq, filterReso);
      this.serge5.serge_init(filterFreq, filterReso);
      this.serge6.serge_init(filterFreq, filterReso);
    ) : ( sliderValue == 79 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.diffuser.diffuser_init(filterFreq, filterReso, delayBuffer);
    ) : ( sliderValue == 80 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.space.space_init(filterFreq, filterReso, delayBuffer);
    ) : ( sliderValue == 81 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.worp.worp_init(filterFreq, filterReso, delayBuffer, isR);
    ) : ( sliderValue == 82 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.crunch.crunch_init(filterFreq, filterReso, delayBuffer, isR);
    ) : ( sliderValue == 83 ) ? (
      delayBuffer = selectBuffer( isR, isFilt2, isGFX );
      this.athena.athena_init(filterFreq, filterReso, delayBuffer, isR);
    ) : ( sliderValue > 83 && (sliderValue < 88) ) ? (
      filterFreq = max(filterFreq, 0.0035);
      this.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
      this.filter_SVF.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue == 88 ) ? (
      // Anything above 440 must be wrapped around to not exceed nyquist
      filterFreq = max(filterFreq, 0.0035);   
      filterReso = pow(filterReso, .1);
      this.amp = .707;
    
      val = -log(2.0)/log(20/22050);
      this.f1.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f2.reset_linearSVF(); );
      this.f2.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f3.reset_linearSVF(); );
      this.f3.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f4.reset_linearSVF(); );
      this.f4.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f5.reset_linearSVF(); );
      this.f5.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f6.reset_linearSVF(); );
      this.f6.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f7.reset_linearSVF(); );
      this.f7.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f8.reset_linearSVF(); );
      this.f8.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f9.reset_linearSVF(); );
      this.f9.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f10.reset_linearSVF(); );
      this.f10.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue == 89 ) ? (
      // Anything above 440 must be wrapped around to not exceed nyquist
      filterFreq = max(filterFreq, 0.0035);   
      filterReso = pow(filterReso, .1);
      this.amp = .707;
    
      val = -log(4.0)/log(20/22050);
      this.f1.init_linearSVF( filterFreq, filterReso );
      this.f2.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f3.reset_linearSVF(); this.f4.reset_linearSVF(); );
      this.f3.init_linearSVF( filterFreq, filterReso );
      this.f4.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f5.reset_linearSVF(); this.f6.reset_linearSVF(); );
      this.f5.init_linearSVF( filterFreq, filterReso );
      this.f6.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f7.reset_linearSVF(); this.f8.reset_linearSVF(); );
      this.f7.init_linearSVF( filterFreq, filterReso );
      this.f8.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f9.reset_linearSVF(); this.f10.reset_linearSVF(); );
      this.f9.init_linearSVF( filterFreq, filterReso );
      this.f10.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue == 90 ) ? (
      // Anything above 440 must be wrapped around to not exceed nyquist
      filterFreq = max(filterFreq, 0.0035);   
      filterReso = pow(filterReso, .1);
      this.amp = .5 * .707;
    
      val = -log(1.5)/log(20/22050);
      this.f1.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f2.reset_linearSVF(); );
      this.f2.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f3.reset_linearSVF(); );
      this.f3.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f4.reset_linearSVF(); );
      this.f4.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f5.reset_linearSVF(); );
      this.f5.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f6.reset_linearSVF(); );
      this.f6.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f7.reset_linearSVF(); );
      this.f7.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f8.reset_linearSVF(); );
      this.f8.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f9.reset_linearSVF(); );
      this.f9.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f10.reset_linearSVF(); );
      this.f10.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f11.reset_linearSVF(); );
      this.f11.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f12.reset_linearSVF(); );
      this.f12.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f13.reset_linearSVF(); );
      this.f13.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f14.reset_linearSVF(); );
      this.f14.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f15.reset_linearSVF(); );
      this.f15.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f16.reset_linearSVF(); );
      this.f16.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f17.reset_linearSVF(); );
      this.f17.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f18.reset_linearSVF(); );
      this.f18.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f19.reset_linearSVF(); );
      this.f19.init_linearSVF( filterFreq, filterReso );
      filterFreq += val; filterFreq > 0.9999 ? ( filterFreq -= 1; filterFreq = max(filterFreq, 0.0035); this.f20.reset_linearSVF(); );
      this.f20.init_linearSVF( filterFreq, filterReso );
    ) : ( sliderValue > 90 ) && ( sliderValue < 95 ) ? (
      // The new moogs :)
      this.newMoog.init_newMoog(filterFreq, filterReso);
    );
  );        

function getMinimalSmoothingFactor( filter )
  local()
  global()
  instance()
  (
    (filter == 2) ? (
      .99
    ) : ( filter == 6 ) ? (
      .975
    ) : ( filter == 11 ) ? (
      .975
    ) : 0;
  );

function updateSmoothing( force )
  (
    dynvalSmoothing = max( max( .9, getMinimalSmoothingFactor(slider47) ), getMinimalSmoothingFactor( slider40 ) )
  );

function updateActiveFilters( force )
  (  
    force ? updateSmoothing();
    filteredDynval = (1-dynvalSmoothing) * dynval + dynvalSmoothing * filteredDynval; // Avoid too steep transitions.
  
    gainModVal            = 0;
    cnt                   = 0;
    gainDynamics          ? (gainModVal += filteredDynval; cnt += 1;);
    env1GainButton.active ? (gainModVal += envelopeValue1; cnt += 1;);
    env2GainButton.active ? (gainModVal += envelopeValue2; cnt += 1;);
    cnt > 1               ? gainModVal /= cnt;
    gainLFO               ? gainModVal += modulator.scaled_modvalue;

    pregain  = 2^((slider52 + 40 * dyn_mod_gain * gainModVal)*0.166666666666666666666666666666666666666667);
    postgain = 2^((slider53 + 40 * dyn_mod_outgain * gainModVal)*0.166666666666666666666666666666666666666667);
  
    // Cutoff and resonance handling filter 1
    currentSkip += 1;
    currentSkip > skipFactor ? currentSkip = 0;
    
    ( slider47 > 0 ) ? (
      
      sliderCutoff  = cutoffLerp.lerpSample();
      sliderReso    = resoLerp.lerpSample();
      followKey1    ? sliderCutoff = sliderCutoff + approxNoteFrequencyFilter1 * slider33;
      followPitch1  ? sliderCutoff = sliderCutoff + pitchLerp1.lerpSample() * slider33;
      
      /* Only update cutoff and resonance every N samples */
      ( currentSkip == 0 )? (
        filter1ModValCutoff     = 0;
        cnt                     = 0;
        F1_dyn_cutoff           ? (filter1ModValCutoff += filteredDynval; cnt += 1;);
        F1_env1_cutoff          ? (filter1ModValCutoff += envelopeValue1; cnt += 1;);
        F1_env2_cutoff          ? (filter1ModValCutoff += envelopeValue2; cnt += 1;);
        cnt > 1                 ? filter1ModValCutoff /= cnt;
        F1_lfo_cutoff           ? filter1ModValCutoff += modulator.scaled_modvalue;
        
        filter1ModValReso       = 0;
        cnt                     = 0;
        F1_dyn_reso             ? (filter1ModValReso += filteredDynval; cnt += 1;);
        F1_env1_reso            ? (filter1ModValReso += envelopeValue1; cnt += 1;);
        F1_env2_reso            ? (filter1ModValReso += envelopeValue2; cnt += 1;);
        cnt > 1                 ? filter1ModValReso /= cnt;
        F1_lfo_reso             ? filter1ModValReso += modulator.scaled_modvalue;
        
        filterFreq = max( 0, min( 1, sliderCutoff + dyn_mod_filt * filter1ModValCutoff ) );
        filterReso = max( 0, min( .99, sliderReso + dyn_mod_reso * filter1ModValReso ) );
      )
    );    
    
    updateFiltersNow = ( ( ( filterFreq != lastFilterFreq ) || ( filterReso != lastFilterReso ) ) ) || force;
    ( updateFiltersNow ) ? (
      lastFilterReso = filterReso;
      lastFilterFreq = filterFreq;
      L.updateActiveFilter(slider47, filterFreq, filterReso, 0, 0, 0);
      R.updateActiveFilter(slider47, filterFreq, filterReso, 1, 0, 0);
    );

    // Cutoff and resonance handling filter 2
    currentSkip2 += 1;
    currentSkip2 > skipFactor ? currentSkip2 = 0;
    
    ( slider40 > 0 ) ? (
      sliderCutoff2 = cutoffLerp2.lerpSample();
      sliderReso2   = resoLerp2.lerpSample();
      followKey2    ? sliderCutoff2  = sliderCutoff2  + approxNoteFrequencyFilter2 * slider33;
      followPitch2  ? sliderCutoff2 = sliderCutoff2 + pitchLerp2.lerpSample() * slider33;
      
      /* Only update cutoff and resonance every N samples */
      (currentSkip2 == 0) ? (
        filter2ModValCutoff      = 0;
        cnt                      = 0;
        F2_dyn_cutoff            ? (filter2ModValCutoff += filteredDynval; cnt += 1;);
        F2_env1_cutoff           ? (filter2ModValCutoff += envelopeValue1; cnt += 1;);
        F2_env2_cutoff           ? (filter2ModValCutoff += envelopeValue2; cnt += 1;);
        cnt > 1                  ? filter2ModValCutoff /= cnt;
        F2_lfo_cutoff            ? filter2ModValCutoff += modulator.scaled_modvalue;
        
        filter2ModValReso        = 0;
        cnt                      = 0;
        F2_dyn_reso              ? (filter2ModValReso += filteredDynval; cnt += 1;);
        F2_env1_reso             ? (filter2ModValReso += envelopeValue1; cnt += 1;);
        F2_env2_reso             ? (filter2ModValReso += envelopeValue2; cnt += 1;);
        cnt > 1                  ? filter2ModValReso /= cnt;
        F2_lfo_reso              ? filter2ModValReso += modulator.scaled_modvalue;
        
        filterFreq2 = max( 0, min( 1, sliderCutoff2 + dyn_mod_filt2 * filter2ModValCutoff ) );
        filterReso2 = max( 0, min( .99, sliderReso2 + dyn_mod_reso2 * filter2ModValReso ) );
      );
    );    
    
    updateFiltersNow = ( ( ( filterFreq2 != lastFilterFreq2 ) || ( filterReso2 != lastFilterReso2 ) ) ) || force;
    ( updateFiltersNow ) ? (
      lastFilterReso2 = filterReso2;
      lastFilterFreq2 = filterFreq2;
      L2.updateActiveFilter(slider40, filterFreq2, filterReso2, 0, 1, 0);
      R2.updateActiveFilter(slider40, filterFreq2, filterReso2, 1, 1, 0);
    );
 ); 
 
function resetActiveFilter(filterType, isGFX)
  local(maxOversampling)
  (
    maxOversampling = 8;
    ( filterType == 1 ) ? (
      maxOversampling = maxOversampling;
    ) : ( filterType == 2 ) ? (
      this.filter_303.reset303();
    ) : ( filterType == 3 ) ? (
      this.filter_vowel.resetvowel();
    ) : ( filterType == 4 ) ? (
      this.filter_karlsen.resetkarlsen();
    ) : ( filterType == 5 ) ? (
      this.filter_karlsen_sat.resetkarlsen_sat();
    ) : ( filterType == 6 ) ? (
      this.filter_dualfilt.resetdualfilt();
    ) : ( filterType == 7 ) ? (
      this.filter_dualfiltHP.resetdualfilt();
    ) : ( filterType == 8 ) ? (
      this.filter_dualfiltBP.resetdualfilt();
    ) : ( filterType == 9 ) ? (
      this.filter_fancymoog.resetfancymoog();
    ) : ( filterType == 10 ) ? (
      this.filter_fancymoog.resetfancymoog();
    ) : ( filterType == 11 ) ? (
      this.filter_notch.resetrbj();
    ) : ( filterType == 12 ) ? (
      this.filter_sai0.resetsai0(0);
    ) : ( filterType == 13 ) ? (
      this.filter_modulator.resetmodulator();
    ) : ( filterType == 14 ) ? (
      os = 0; jnk = 0;
      this.filter_phaser.resetphaserOTA();
    ) : ( filterType == 15 ) ? (
      os = 0;
      this.filter_phaser.resetphaserFET();
    ) : ( filterType == 16 ) ? (
      os1 = os2 = ys1 = 0;
      this.filter_dualfilt.resetdualfilt();
      !this.isGFX ? (
        !this.isFilt2 ? ( 
          filter_delay1.clearBuffer();
          filter_delay2.clearBuffer();
        ) : (
          filter_delay3.clearBuffer();
          filter_delay4.clearBuffer();
        )
      ) : (
        !this.isFilt2 ? ( 
          filter_delay5.clearBuffer();
          filter_delay6.clearBuffer();
        ) : (
          filter_delay7.clearBuffer();
          filter_delay8.clearBuffer();
        )
      );
    ) : ( filterType == 17 ) ? (
      os1 = os2 = os3 = 0;
      this.filter_dualfilt.resetdualfilt();
      !this.isGFX ? (
        !this.isFilt2 ? ( 
          filter_delay1.clearBuffer();
          filter_delay2.clearBuffer();
        ) : (
          filter_delay3.clearBuffer();
          filter_delay4.clearBuffer();
        )
      ) : (
        !this.isFilt2 ? ( 
          filter_delay5.clearBuffer();
          filter_delay6.clearBuffer();
        ) : (
          filter_delay7.clearBuffer();
          filter_delay8.clearBuffer();
        )
      );
    ) : ( filterType == 18 ) ? (
      this.filter_ms20lin.reset_MS20lin();
    ) : ( filterType == 19 ) ? (
      this.filter_ms20lin.reset_MS20lin();
    ) : ( filterType == 20 ) ? (
      this.filter_ms20lin.reset_MS20lin();
    ) : ( filterType == 21 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 22 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 23 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 24 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
      this.filter_phaser.resetphaserFET();
      this.filter_phaser2.resetphaserFET();
      this.filter_delay.clearBuffer();
    ) : ( filterType == 25 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 26 ) ? (
      this.filter_ssm.reset_ssm_nonlin();
    ) : ( filterType == 27 ) ? (
      this.filter_ssm.reset_ssm_nonlin();
    ) : ( filterType == 28 ) ? (
      this.filter_cem.reset_cem_nonlin();
    ) : ( filterType == 29 ) ? (
      this.filter_ssm_lin.reset_ssm_lin();
    ) : ( filterType == 30 ) ? (
      this.filter_cem_lin.reset_cem_lin();
    ) : ( filterType == 32 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 33 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 34 ) ? (
      this.filter_broken.reset_MS20_nonlin();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 35 ) ? (
      this.filter_wasp.reset_wasp_nonlin();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 36 ) ? (
      this.filter_wasp_lin.reset_wasplin();
    ) : ( filterType == 37 ) ? (
      this.filter_wasp.reset_wasp_nonlin();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 38 ) ? (
      this.filter_wasp.reset_wasp_nonlin();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( ( filterType > 38 ) && ( filterType < 44 ) ) ? (
      this.filter_SVF.reset_linearSVF( );
    ) : ( filterType == 44 ) ? (
      this.filter_wasp.reset_wasp_nonlin_saw();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 45 ) ? (
      this.filter_SVF_nores.reset_linearSVF();
      this.filter_SVF.reset_linearSVF();
    ) : ( filterType == 46 ) ? (
      this.filter_SVF_nores.reset_linearSVF();
      this.filter_SVF.reset_linearSVF();
      this.resoint = 0;
    ) : ( filterType == 47 ) ? (
      this.filter_SVF_nores.reset_linearSVF();
      this.filter_SVF.reset_linearSVF();
      this.filter_SVF2.reset_linearSVF();
    ) : ( filterType == 48 ) ? (
      this.filter_delay.clearBuffer();
    ) : ( filterType == 49 ) ? (
      this.filter_SVF_nores.reset_linearSVF();
      this.filter_SVF.reset_linearSVF();
      this.filter_delay.clearBuffer();
    ) : ( filterType == 50 ) ? (
      this.filter_SVF_nores.reset_linearSVF();
      this.filter_SVF.reset_linearSVF();
      this.filter_delay.clearBuffer();
    ) : ( filterType > 50 && filterType < 54 ) ? (
      this.filter_ms20.reset_MS20_nonlin();
    ) : ( filterType == 54 || filterType == 59 ) ? (
      this.weeping_reset();
    ) : ( filterType == 55 ) ? (
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 60 ) ? (
      this.wah.reset_dlop();
      loop(100000,
        this.wah.dlop_eval(0);
      );
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 61 ) ? (
      this.wah.reset_dlopH();
      loop(100000,
        this.wah.dlop_eval(0);
      );
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 62 ) ? (
      this.wah.reset_dlopL();
      loop(200000,
        this.wah.dlop_eval(0);
      );
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 63 ) ? (
      this.vowel_svf.resetvowelSVF();
    ) : ( filterType == 64 ) ? (
      this.vowel_svf.resetvowelSVF();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 65 ) ? (
      this.kot.kot_reset();
    ) : ( filterType == 66 ) ? (
      this.modulon.modulon_reset();
    ) : ( filterType == 67 ) ? (
      this.octaver.octaver_reset();
    ) : ( filterType == 68 ) ? (
      this.octaverUp.octaverUp_reset();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 69 ) ? (
      this.metallic.metallic_reset();
    ) : ( filterType == 70 ) ? (
      this.frazzle.frazzle_reset();
    ) : ( filterType == 71 ) ? (
      this.phone.phone_reset();
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 72 ) ? (
      this.modulon.modulon_reset();
    ) : ( filterType == 73 ) ? (
      this.modulon.modulon_reset();
    ) : ( filterType == 74 ) ? (
      this.vibrato.t = 0;
      this.filter_delay.clearBuffer();
    ) : ( filterType == 75 ) ? (
      this.vibrato.t = 0;
      this.filter_delay.clearBuffer();
    ) : ( filterType == 77 ) ? (
      !isGFX ? postResetWaitSamples = 8192;
    ) : ( filterType == 79 ) ? (
      this.diffuser.diffuser_clear();
    ) : ( filterType == 80 ) ? (
      this.space.space_clear();
    ) : ( filterType == 81 ) ? (
      this.worp.worp_clear();
    ) : ( filterType == 82 ) ? (
      this.crunch.crunch_reset();
    ) : ( filterType == 83 ) ? (
      this.athena.athena_reset();
    ) : ( filterType > 83 ) ? (
      this.filter_SVF_nores.reset_linearSVF();
      this.filter_SVF.reset_linearSVF();
    );
  );
 
function resetActiveFilters()
  (
    // Reset the offset correction
    otm1 = otm2 = itm1 = itm2 = 0;
  
    // Reset up and downsampling filters
    sincFilterL.resetSincUp();
    sincFilterR.resetSincUp();
    sincDownL.resetSincDown();
    sincDownR.resetSincDown();
    filterL.resetioFilter();
    filterR.resetioFilter();
    
    L.resetActiveFilter( slider47, 0 );
    R.resetActiveFilter( slider47, 0 );
    L2.resetActiveFilter( slider40, 0 );
    R2.resetActiveFilter( slider40, 0 );
    
    agcpost = agcpre = agcsumpost = agcsumpre = 1;
  );

itm1=itm2=otm1=otm2=0;
forceUpdate=0;

movavgLN = 0;
movavgLP = 0;
movavgRN = 0;
movavgRP = 0;

updateActiveFilters(1);

function setN(S, N)
local(changed)
global(slider1, slider2)
(
  ( S == 1 ) ? (
    slider1=N; slider_automate(slider1);
  )
  : ( S == 2 ) ? (
    slider2=N; slider_automate(slider2);
  );
);

function manipulateXYSliders(S, i, x, y)
(
  // gfx_set(1,1,1,1);
  // gfx_x=0;
  // gfx_y=50;
  // gfx_printf("HEY %d, %d, %f, %f", S, i, x, y);
  (S == 2) ? (
     (i==1) ? ( slider3=x;  slider_automate(slider3);  slider4=y;  slider_automate(slider4);  )
    :(i==2) ? ( slider5=x;  slider_automate(slider5);  slider6=y;  slider_automate(slider6);  )
    :(i==3) ? ( slider7=x;  slider_automate(slider7);  slider8=y;  slider_automate(slider8);  )
    :(i==4) ? ( slider9=x;  slider_automate(slider9);  slider10=y; slider_automate(slider10); )
    :(i==5) ? ( slider11=x; slider_automate(slider11); slider12=y; slider_automate(slider12); )
    :(i==6) ? ( slider13=x; slider_automate(slider13); slider14=y; slider_automate(slider14); )
    :(i==7) ? ( slider15=x; slider_automate(slider15); slider16=y; slider_automate(slider16); )
    :(i==8) ? ( slider18=y; slider_automate(slider18); )
  )
  : ( S==1 ) ? (
     (i==1) ? ( slider19=x; slider_automate(slider19); slider20=y; slider_automate(slider20); )
    :(i==2) ? ( slider21=x; slider_automate(slider21); slider22=y; slider_automate(slider22); )
    :(i==3) ? ( slider23=x; slider_automate(slider23); slider24=y; slider_automate(slider24); )
    :(i==4) ? ( slider25=x; slider_automate(slider25); slider26=y; slider_automate(slider26); )
    :(i==5) ? ( slider27=x; slider_automate(slider27); slider28=y; slider_automate(slider28); )
    :(i==6) ? ( slider29=x; slider_automate(slider29); slider30=y; slider_automate(slider30); )
    :(i==7) ? ( slider31=x; slider_automate(slider31); slider32=y; slider_automate(slider32); )
    :(i==8) ? ( slider34=y; slider_automate(slider34); )
  );
  
  forceUpdate = 1;
);

function manipulateYSlider(S, i, y)
(
  // gfx_set(1,1,1,1);
  // gfx_x=0;
  // gfx_y=50;
  // gfx_printf("HEY %d, %d, %f, %f", S, i, x, y);
  (S == 2) ? (
     (i==1) ? ( slider4=y;  slider_automate(slider4);  )
    :(i==2) ? ( slider6=y;  slider_automate(slider6);  )
    :(i==3) ? ( slider8=y;  slider_automate(slider8);  )
    :(i==4) ? ( slider10=y; slider_automate(slider10); )
    :(i==5) ? ( slider12=y; slider_automate(slider12); )
    :(i==6) ? ( slider14=y; slider_automate(slider14); )
    :(i==7) ? ( slider16=y; slider_automate(slider16); )
    :(i==8) ? ( slider18=y; slider_automate(slider18); )
  )
  : ( S==1 ) ? (
     (i==1) ? ( slider20=y; slider_automate(slider20); )
    :(i==2) ? ( slider22=y; slider_automate(slider22); )
    :(i==3) ? ( slider24=y; slider_automate(slider24); )
    :(i==4) ? ( slider26=y; slider_automate(slider26); )
    :(i==5) ? ( slider28=y; slider_automate(slider28); )
    :(i==6) ? ( slider30=y; slider_automate(slider30); )
    :(i==7) ? ( slider32=y; slider_automate(slider32); )
    :(i==8) ? ( slider34=y; slider_automate(slider34); )
  );
  
  forceUpdate = 1;
);

function grabY(S, i)
(
  (S == 2) ? (
     (i==1) ? ( slider4; )
    :(i==2) ? ( slider6; )
    :(i==3) ? ( slider8; )
    :(i==4) ? ( slider10; )
    :(i==5) ? ( slider12; )
    :(i==6) ? ( slider14; )
    :(i==7) ? ( slider16; )
    :(i==8) ? ( slider18; )
  )
  : ( S==1 ) ? (
     (i==1) ? ( slider20 )
    :(i==2) ? ( slider22 )
    :(i==3) ? ( slider24 )
    :(i==4) ? ( slider26 )
    :(i==5) ? ( slider28 )
    :(i==6) ? ( slider30 )
    :(i==7) ? ( abs(slider32) )
    :(i==8) ? ( abs(slider34) )
  );
);
  
function grabFinalY(S)
(
  (S == 2) ? grabY(S, slider2-1) : grabY(S, slider1-1)
);

// Really dumb sorting algorithm
// Double buffered to make sure that we don't get clicks
function f_sort_spline(N_write, xloc_write, yloc_write, tempx, tempy, tempz)
  instance(splineIdx, indices)
  local(cyl, last, mini, iter, tmp, eps, shift,
        ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z )
  global(gfx_x, gfx_y)
( 
  // First copy it to temp 
  ptr_from_X  = xloc_write;
  ptr_from_Y  = yloc_write;
  ptr_to_X    = tempx;
  ptr_to_Y    = tempy;
  ptr_to_Z    = tempz;
  iter        = 0;
  loop(N_write,
    ptr_to_X[] = ptr_from_X[];
    ptr_to_X += 1; ptr_from_X += 1;
    ptr_to_Y[] = ptr_from_Y[];
    ptr_to_Y += 1; ptr_from_Y += 1;
    ptr_to_Z[] = iter;
    ptr_to_Z += 1;
    iter += 1;
  );
  
  // Make sure there are no duplicate x'es
  ptr_to_X = tempx+1;
  eps = 0.001;
  shift = 0.0001;  
  loop(N_write-1,
    ptr_from_X = tempx;
    loop(N_write,
      ( abs(ptr_to_X[] - ptr_from_X[]) < eps ) ? 
      (
        cyl = ptr_to_X[];
        cyl < 1 ? (
          ptr_to_X[] += shift;
          shift = shift / 2;
        ) : (
          ptr_to_X[] -= shift;
          shift = shift / 2;
        );
      );
      ptr_from_X += 1;
    );
    ptr_to_X += 1;
  );
  
  // Sort it
  ptr_to_X = xloc_write;
  ptr_to_Y = yloc_write;
  ptr_to_Z = indices;
  last = -1;
  loop(N_write,
    ptr_from_X = tempx;
    ptr_from_Y = tempy;
    ptr_from_Z = tempz;
    mini = 1000;
    loop(N_write,
      ( ( ptr_from_X[] > last ) && ( ptr_from_X[] < mini ) ) ?
      (
        mini       = ptr_from_X[];
        ptr_to_X[] = mini;
        ptr_to_Y[] = ptr_from_Y[];
        ptr_to_Z[] = ptr_from_Z[];
      );
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;      
    );
    last = mini;
    ptr_to_X += 1;
    ptr_to_Y += 1;
    ptr_to_Z += 1;
  );
);

function f_update_spline(xloc_read, yloc_read, N_write, c1_write, c2_write, c3_write, tempx, tempy, tempz)
  instance(splineIdx, indices)
  local(cc1, m, mNext, cm, dx, dxNext, invdx, tmp,
        ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z)
  global(gfx_x, gfx_y)
  (
    // Initialize coeffs
    ptr_to_X   = c1_write;
    loop(9,
      ptr_to_X[] = 0;
      ptr_to_X += 1;
    );
    ptr_to_X   = c2_write;
    loop(9,
      ptr_to_X[] = 0;
      ptr_to_X += 1;
    );
    ptr_to_X   = c3_write;
    loop(9,
      ptr_to_X[] = 0;
      ptr_to_X += 1;
    );  
  
    // Calculate differences
    ptr_from_X  = xloc_read;
    ptr_from_Y  = yloc_read;
    ptr_to_X    = tempx;
    ptr_to_Y    = tempy;  
    
    // tempx contains dxs, tempy the slopes (dy/dx)    
    loop(N_write-1,
      ptr_to_X[]  = ptr_from_X[1] - ptr_from_X[];
      ptr_to_Y[]  = ( ptr_from_Y[1] - ptr_from_Y[] ) / ptr_to_X[];
      ptr_to_X    += 1;
      ptr_to_Y    += 1;
      ptr_from_X  += 1;
      ptr_from_Y  += 1;
    );
    
    // Make sure the last node does not go bonkers
    ptr_to_Y -= 1;
    ptr_to_Y[] = max(min(5, ptr_to_Y[]), -5);
    
    // calculate first degree coefficients
    ptr_from_X  = tempx; // dx
    ptr_from_Y  = tempy; // dy/dx (ms)
    ptr_to_X    = c1_write;
    
    ptr_to_X[]  = ptr_from_Y[];
    ptr_to_X   += 1;
    loop(N_write-2,
      m     = ptr_from_Y[];
      mNext = ptr_from_Y[1];
      ( m * mNext <= 0 ) ? ( ptr_to_X[] = 0; ):
      (
        dx = ptr_from_X[];
        dxNext = ptr_from_X[1];
        cm = dx + dxNext;
        ptr_to_X[] = 3.0*cm/((cm+dxNext)/m + (cm+dx)/mNext);
      );
      ptr_to_X   += 1;
      ptr_from_X += 1;
      ptr_from_Y += 1;
    );
    ptr_to_X[] = ptr_from_Y[];
    
    // calculate second degree coefficients
    ptr_from_X = tempx; // dx
    ptr_from_Y = tempy; // dy/dx (ms)
    ptr_from_Z = c1_write;    // c1s
    ptr_to_X   = c2_write;
    ptr_to_Y   = c3_write;
    loop(N_write-1,
      invdx = 1 / ptr_from_X[];
      cc1 = ptr_from_Z[];
      m = ptr_from_Y[];
      cm = cc1 + ptr_from_Z[1] - m - m;
      ptr_to_X[] = (m - cc1 - cm)*invdx;
      ptr_to_Y[] = cm*invdx*invdx;
      
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;
      ptr_to_X   += 1;
      ptr_to_Y   += 1;
    );
  );

function sort_spline(gfx)
  instance(splineIdx, indices, 
           N_gfx, N_audio,
           xloc_gfx, yloc_gfx, 
           xloc_audio, yloc_audio,
           tempx_gfx, tempy_gfx, tempz_gfx
           tempx_audio, tempy_audio, tempz_audio
           )
  local()
  global()
  (
    gfx ?
      this.f_sort_spline(N_gfx, xloc_gfx, yloc_gfx, tempx_gfx, tempy_gfx, tempz_gfx)
    : this.f_sort_spline(N_audio, xloc_audio, yloc_audio, tempx_audio, tempy_audio, tempz_audio)
  );

function update_spline(gfx)
  instance(splineIdx, indices, 
           N_gfx, N_audio,
           xloc_gfx, yloc_gfx, 
           xloc_audio, yloc_audio,
           c1_gfx, c2_gfx, c3_gfx,
           c1_audio, c2_audio, c3_audio,
           tempx_gfx, tempy_gfx, tempz_gfx
           tempx_audio, tempy_audio, tempz_audio
           )
  local()
  global()
  (
    gfx ?
      this.f_update_spline(xloc_gfx, yloc_gfx, N_gfx, c1_gfx, c2_gfx, c3_gfx, tempx_gfx, tempy_gfx, tempz_gfx)
    : this.f_update_spline(xloc_audio, yloc_audio, N_audio, c1_audio, c2_audio, c3_audio, tempx_audio, tempy_audio, tempz_audio)
  );

// Linear search empirically turned out to be faster than binary search (small number of nodes, less branching I guess).
function evalSplineLin(x)
  instance(N_gfx, splineIdx, xloc_read, yloc_gfx, xloc_gfx, c1_gfx, c2_gfx, c3_gfx )
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    i = -1;
    xHere = xloc_gfx-1;
    
    while(
      i += 1;
      xHere += 1;
      
      x >= xHere[] && ( i < N_gfx )
    );
        
    i = max( 0, i-1 );
        
    diff    = x - xloc_gfx[i];
    diffSq  = diff * diff;
    out     = yloc_gfx[i] + c1_gfx[i]*diff + c2_gfx[i]*diffSq + c3_gfx[i]*diff*diffSq;
    
    out;
  );
  
function evalSplineAudioLin(x)
  instance(N_audio, splineIdx, xloc_audio, yloc_audio, c1_audio, c2_audio, c3_audio, iAudio )
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio )
  global()
  (
    iAudio = -1;
    xHereAudio = xloc_audio-1;
    
    while(
      iAudio += 1;
      xHereAudio += 1;
      
      x >= xHereAudio[] && ( iAudio < N_audio )
    );
    
    iAudio       = max(0, iAudio-1);
    diffAudio    = x - xloc_audio[iAudio];
    diffSqAudio  = diffAudio * diffAudio;
          
    out = yloc_audio[iAudio] + c1_audio[iAudio]*diffAudio + c2_audio[iAudio]*diffSqAudio + c3_audio[iAudio]*diffAudio*diffSqAudio;
    
    out;
  );  

// Get first derivative of the spline (needed for some analog models)
function evalSplineAudioDiff(x)
  instance(N_audio, splineIdx, xloc_audio, yloc_audio, c1_audio, c2_audio, c3_audio, iAudio )
  local(lowAudio, highAudio, interpAudio, xHereAudio, diffAudio, out, midAudio )
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_audio[N_audio-1] : 
    (
      ( x < 0 ) ? out = 0 :
      ( 
        iAudio = max( 0, highAudio );
        diffAudio    = x - xloc_audio[iAudio];
        out = c1_audio[iAudio] + diffAudio*(2*c2_audio[iAudio] + 3*diffAudio*c3_audio[iAudio]);
      )
    );
    
    out;
  );  

// Plot the spline nodes
function plot_spline(x, y, w, h)
  instance(ldyn, ldyn2, ldyn3, ldyn4, N_gfx, splineIdx, xloc_gfx, yloc_gfx, indices, cap_mode, drag_node,
           hoveridx, hoverSize)
  local(dhere, xx, res, lastx, lasty, dx, yout, nx, ny, epsx, epsy, xc, yc, yout,
        ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z)
  global(block_analyzers, gfx_x, gfx_y, distortPlot, slider56, dynval, distortionDynamics
         spline_r, spline_g, spline_b, spline_a,
         spline_knot_r, spline_knot_g, spline_knot_b, spline_knot_a,
         dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a)
  (
    epsx = 5;
    epsy = 5;
    ptr_from_X = xloc_gfx;
    ptr_from_Y = yloc_gfx;
    ptr_from_Z = indices;
        
    gfx_set( spline_knot_r, spline_knot_g, spline_knot_b, spline_knot_a );
    gfx_x = 0;
    gfx_y = 0;
    ( slider56 == 0 ) ? (
      ( hoveridx > -1 ) ? (
        xc = x + w*ptr_from_X[hoveridx] - epsx;
        yc = y + h*(1-ptr_from_Y[hoveridx]) - epsy;
        gfx_circle(floor(xc+.5*epsx+1), floor(yc+.5*epsx)+1, hoverSize);
      );
    
      loop(N_gfx,
        xc = x + w*ptr_from_X[] - epsx;
        yc = y + h*(1-ptr_from_Y[]) - epsy;
        gfx_rect(floor(xc+.5*epsx-1), floor(yc+.5*epsx-1), epsx, epsy);        
        
        gfx_x = xc;
        gfx_y = yc-14;
        gfx_printf("%d", ptr_from_Z[]);
        ptr_from_X += 1;
        ptr_from_Y += 1;
        ptr_from_Z += 1;
      );
    );
    
    ( slider56 == 4 ) ? ( 
      gfx_rect( x+.75*w - 5, y + .5*h, 10, 2 );
      gfx_rect( x+.25*w - 5, y + .5*h, 10, 2 );
      gfx_rect( x+.25*w - 2, y + .5*h-4, 4, 10 );
    );
    
    gfx_set( spline_r, spline_g, spline_b, spline_a );
    xx = 0;
    res = 500;
    lastx = x;
    lasty = y+h;
    dx = 1/res;
    loop(res,
      xx = xx + dx;
      ( slider56 == 0 ) ? (
        yout = this.evalSplineLin(xx);
      ) : ( slider56 == 1 ) ? ( 
        yout = tanh(xx);
      ) : ( slider56 == 2 ) ? (
        yout = fasttanh(xx);
      ) : ( slider56 == 4 ) ? (
        yout = xx < 0.5 ? sin(2*$pi*xx) : sin(2*$pi*(-xx));
      )  : ( slider56 == 5 ) ? (
        yout = actual_tanh(xx);
      ) : (
        yout = xx;
      );

      nx = floor(x + w*xx - 1);
      ny = floor(y + h*(1-yout) - 1);
      gfx_line(lastx-1, lasty, nx-1, ny, 1);
      gfx_line(lastx, lasty-1, nx, ny-1, 1);
      gfx_line(lastx, lasty, nx, ny, 1);
      lastx = nx;
      lasty = ny;
    );
    
    // Draw intermediate if dynamically processed
    ( distortionDynamics ) ? (
      // Graph interpolant
      xx = 0;
      res = 500;
      lastx = x;
      lasty = y+h;
      dx = 1/res;
      
      dhere = dynval;      
      gfx_set( dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a );
      loop(res,
        xx = xx + dx;
        ( slider56 == 0 ) ? (
          yout = xx * (1-dhere) + dhere * this.evalSplineLin(xx);
        ) : ( slider56 == 1 ) ? ( 
          yout = xx * (1-dhere) + dhere * tanh(xx);
        ) : ( slider56 == 2 ) ? (
          yout = xx * (1-dhere) + dhere * fasttanh(xx);
        ) : ( slider56 == 4 ) ? (
          yout = xx * (1-dhere) + dhere * (xx < 0.5 ? sin(2*$pi*xx) : sin(2*$pi*(-xx)));
        ) : ( slider56 == 5 ) ? (
          yout = xx * (1-dhere) + dhere * actual_tanh(xx);
        ) : (
          yout = xx;
        );
  
        nx = x + w*xx - 1;
        ny = y + h*(1-yout) - 1;
        gfx_line(lastx, lasty, nx, ny, 0);
        lastx = nx;
        lasty = ny;
      );
      
      ( block_analyzers == 0 ) ?
      (
        xx = 0;
        res = 500;
        lastx = x;
        lasty = y+h;
        dx = 1/res;
        gfx_set( dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a * .24 );
        loop(res,
          xx = xx + dx;
          ( slider56 == 0 ) ? (
            yout = xx * (1-ldyn2) + ldyn2 * this.evalSplineLin(xx);
          ) : ( slider56 == 1 ) ? ( 
            yout = xx * (1-ldyn2) + ldyn2 * tanh(xx);
          ) : ( slider56 == 2 ) ? (
            yout = xx * (1-ldyn2) + ldyn2 * fasttanh(xx);
          ) : ( slider56 == 4 ) ? (
            yout = xx * (1-ldyn2) + ldyn2 * (xx < 0.5 ? sin(2*$pi*xx) : sin(2*$pi*(-xx)));
          ) : ( slider56 == 5 ) ? (
            yout = xx * (1-dhere) + dhere * actual_tanh(xx);
          ) : (
            yout = xx;
          );
        
          nx = x + w*xx - 1;
          ny = y + h*(1-yout) - 1;
          gfx_line(lastx, lasty, nx, ny, 0);
          lastx = nx;
          lasty = ny;
        );
        
        xx = 0;
        res = 500;
        lastx = x;
        lasty = y+h;
        dx = 1/res;
        
        gfx_set( dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a * .12 );
        loop(res,
          xx = xx + dx;
          ( slider56 == 0 ) ? (
            yout = xx * (1-ldyn4) + ldyn4 * this.evalSplineLin(xx);
          ) : ( slider56 == 1 ) ? ( 
            yout = xx * (1-ldyn4) + ldyn4 * tanh(xx);
          ) : ( slider56 == 2 ) ? (
            yout = xx * (1-ldyn4) + ldyn4 * fasttanh(xx);
          ) : ( slider56 == 4 ) ? (
            yout = xx * (1-ldyn4) + ldyn4 * (xx < 0.5 ? sin(2*$pi*xx) : sin(2*$pi*(-xx)));
          ) : (
            yout = xx;
          );
        
          nx = x + w*xx - 1;
          ny = y + h*(1-yout) - 1;
          gfx_line(lastx, lasty, nx, ny, 0);
          lastx = nx;
          lasty = ny;
        );
      );
      
      ldyn4 = ldyn3;
      ldyn3 = ldyn2;
      ldyn2 = ldyn;
      ldyn = dhere;
    );
  );
  
function evalDist(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineLin(xx);
  );  
  
function evalDistAudio(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioLin(xx);
  );
  
function evalDiff(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioDiff(xx);
  );  
  
//NODE_PROXIMITY = 5;
function findNearest(x, y)
  instance(N_gfx, splineIdx, xloc_gfx, yloc_gfx, c1_gfx, c2_gfx, c3_gfx, drag_node)
  local(minDist, best, dx, dy, dist, left, i, right)
  global()
(
    // Find nearest point that may have been clicked
    i       = 0;
    minDist = 100000000000000;
    best    = -1;
    loop(N_gfx,
       dx = (x - xloc_gfx[i]);
       dy = ((1-y) - yloc_gfx[i]);
       dist = dx*dx + dy*dy;          
       ( dist < minDist ) ? 
       (
         minDist = dist;
         best = i;
       );
       
       i = i + 1;
     );
             
    // Found a point, then we change the capture mode
    ( minDist < .0015 ) ? ( drag_node = best; ) : -1;
);

//NODE_PROXIMITY = 5;
function killNode(i)
  instance(N_gfx, splineIdx, xloc_gfx, yloc_gfx, indices, drag_node)
  local(i, lastY)
  global()
  (
    lastY = grabFinalY(splineIdx);
  
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N_gfx-2))&&(i<(N_gfx+1))
    );
    
    manipulateXYSliders(splineIdx, indices[drag_node], xloc_gfx[i], yloc_gfx[i]);    
    manipulateYSlider(splineIdx, N_gfx-2, lastY);
    
    setN(splineIdx, N_gfx-1);
  );
  
function addNode(x, y)
  instance(N_gfx, splineIdx, xloc_gfx, yloc_gfx, xloc_gfx, yloc_gfx, indices, drag_node)
  local(i, lastY)
  global()
  (
    lastY = grabFinalY(splineIdx);
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N_gfx-1))&&(i<(N_gfx+2))
    );

    manipulateXYSliders(splineIdx, indices[N_gfx], xloc_gfx[i], yloc_gfx[i]);  
    manipulateXYSliders(splineIdx, indices[N_gfx-1], x, y);
    
    manipulateYSlider(splineIdx, N_gfx, lastY);
    setN(splineIdx, N_gfx+1);
  );

//NODE_PROXIMITY = 5;
function processMouse(x, y, dx, dy, mc, lmc, th)
  instance(offs, N_gfx, splineIdx, indices, cap_mode, drag_node,
           hoveridx, hoverSize, hover)
  local(left, right, lastleft, lastright, i, numberloc, nearest)
  global(manipulateXYSliders, gfx_x, gfx_y, slider35, maxNodes)
  (
    left      = mc & 1;
    right     = mc & 2;
    lastleft  = lmc & 1;
    lastright = lmc & 2;
  
    numberloc = 14/th;
    
    nearest = hover.findNearest(x, y);
    ( nearest > -1 ) ? (
      hoverIdx = nearest;
      hoverSize += .5 * (8-hoverSize);
    ) : hoverSize = .75*hoverSize;
    
    ( left ) ? 
    (
      ( cap_mode == 0 && !lastleft ) ?
      (
        drag_node = -1;
        this.findNearest(x,y) > -1 ? offs = 0;
        this.findNearest(x, y+numberloc) > -1 ? offs = numberloc;
        ( drag_node > -1 ) ? ( drag_node = indices[drag_node]; cap_mode = 1; )
      ) : ( cap_mode == 1 ) ? (
        // We've already selected a node.
        x = max( min( x, .9999 ), 0.00001 );
        y = max( min( y, .9999 ), 0.00001 );
        manipulateXYSliders(splineIdx, drag_node, x, max(0, (1-y) - offs));
      );
    ) : (
      ( right && !lastright ) ?
      (
        ( cap_mode == 0 ) ?
        (
          drag_node = -1;
          this.findNearest(x,y);
          this.findNearest(x, y+numberloc);
          
          // Are we clicking an existing one?
          ( drag_node > -1 ) ? 
          (
            // Kill it!
            ( N_gfx > 2 ) ? (
              this.killNode(drag_node);
              cap_mode = 2;
            )
          ):(
            // Add one?
            ( N_gfx < maxNodes ) ? (
              ( x > 0 && y > 0 && x < 1 && y < 1 ) ? (
              this.addNode(x, 1-y);
              cap_mode = 2; )
            );
          );
        );
      ) : ( cap_mode = 0; )
    )
  );

// Generate a spline object
function gen_spline(N_in, splineIdx_in, 
                    xloc_in, yloc_in, 
                    xloc_in2, yloc_in2, 
                    indices_in, 
                    tempx_in, tempy_in, tempz_in, 
                    tempx_in2, tempy_in2, tempz_in2, 
                    c1_in, c2_in, c3_in, 
                    c1_in2, c2_in2, c3_in2)
  instance( N_gfx, N_audio, 
            splineIdx, 
            xloc_gfx, yloc_gfx, 
            xloc_audio, yloc_audio,
            indices, 
            tempx_gfx, tempy_gfx, tempz_gfx,
            tempx_audio, tempy_audio, tempz_audio,
            c1_gfx, c2_gfx, c3_gfx, 
            c1_audio, c2_audio, c3_audio, 
            cap_mode)
  global()
(
  !N_gfx ? (
    N_gfx       = N_in;
    N_audio     = N_in;
    xloc_gfx    = xloc_in;
    yloc_gfx    = yloc_in;
    xloc_audio  = xloc_in2;
    yloc_audio  = yloc_in2;  
    indices     = indices_in;
    tempx_gfx   = tempx_in;
    tempy_gfx   = tempy_in;
    tempz_gfx   = tempz_in;
    tempx_audio = tempx_in2;
    tempy_audio = tempy_in2;
    tempz_audio = tempz_in2;
    c1_gfx      = c1_in;
    c2_gfx      = c2_in;
    c3_gfx      = c3_in;
    c1_audio    = c1_in2;
    c2_audio    = c2_in2;
    c3_audio    = c3_in2;    
  
    splineIdx  = splineIdx_in;
    cap_mode   = 0;
  );
);

function setN(N_new)
  local()
  global()
  instance(N_read, N_write, splineIdx, xloc, yloc, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  (
    N_write = N_new;
  );

function groupWidget(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in)
  local(siz, jnk)
  global(fontface, retina_scaling, widgetFontSize, boldGroups)
  instance(x, y, w, h, r, g, b, a, label)
  (
    x       = x_in-2*retina_scaling;
    y       = y_in-6*retina_scaling;
    w       = w_in+4*retina_scaling;
    h       = h_in+4*retina_scaling;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
    
    boldGroups ? (
      gfx_setfont(6, fontface, widgetFontSize*retina_scaling, 'b');
    ) : ( 
      gfx_setfont(6, fontface, widgetFontSize*retina_scaling);
    );
    gfx_measurestr(label, siz, jnk);
    
    x + 8 + siz
  );
  
function groupWidget_draw()
  local(siz, jnk)
  global(gfx_x, gfx_y, gfx_mode, retina_scaling, widgetFontSize, fontface,
         font_color_r, font_color_g, font_color_b, font_color_a,
         group_color_r, group_color_g, group_color_b, group_color_a,
         highlight_r, highlight_g, highlight_b, highlight_a, boldEdges, boldGroups )
  instance(x, y, w, h, r, g, b, a, label, highlighted )
  (    
    gfx_set( group_color_r, group_color_g, group_color_b, group_color_a );
    gfx_rect( x, y, w, h );
        
    gfx_setfont(6);    
    gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + 8;
    gfx_y = y - .5*jnk + 1 - boldGroups;
    gfx_printf(label);
    gfx_set( r, g, b, .4 );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+5, y);
    gfx_line(x+siz+10, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    
    ( boldEdges == 1 ) ? (
      gfx_set( r, g, b, a );
      gfx_line(x, y-1, x+5, y-1);
      gfx_line(x-1, y, x-1, y+h);
      gfx_line(x+w+1, y, x+w+1, y+h);
      gfx_line(x+siz+9, y-1, x+w, y-1);
      gfx_line(x, y+h+1, x+w, y+h+1);
    );
    
    (highlighted > 0) ? (
      gfx_set( r, g, b, .4*highlighted );
      gfx_line(x, y-1, x+5, y-1);
      gfx_line(x-1, y, x-1, y+h);
      gfx_line(x+w+1, y, x+w+1, y+h);
      gfx_line(x+siz+9, y-1, x+w, y-1);
      gfx_line(x, y+h+1, x+w, y+h+1);
      gfx_set( highlight_r, highlight_g, highlight_b, highlight_a*highlighted );
      gfx_mode = 1;
      gfx_rect( x-8, y-8, w+16, h+16 );
      gfx_mode = 0;
    );
  );

function toggleLight(x_in, y_in, w_in, h_in, label_in, align_in, r_in, g_in, b_in, a_in, active_in)
  local(jnk, jnk1)
  global()
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft, initialized)
  (
    x       = x_in;
    y       = y_in;
    w       = w_in;
    h       = h_in;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
    align   = align_in;
    !initialized ? (
      active  = active_in;
      lastleft = 0;
    );
    initialized = 1;
  );

function toggleLight_processMouse(xx, yy, mc)
  local(left)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    left = mc & 1;
    left ? (
      ( (lastleft ~= 1 ) && ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ) ? ( 
        active = 1 - active;
      );
    );
    
    lastleft = left;
  );
 
function toggleLight_draw()
  local(jnk, siz)
  global(gfx_x, gfx_y,
        font_color_r, font_color_g, font_color_b, font_color_a )
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    gfx_set( r, g, b, .2 + .5*active );
    gfx_rect( x, y, w, h );
  
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );
    ( align == 0 ) ?
    (
      gfx_x = x+15;
      gfx_y = y+2;
    ) : (
      gfx_measurestr(label, siz, jnk);
      gfx_x = x - siz-3;
      gfx_y = y+1;
    );
    gfx_printf( label );  
  );  
  
function selectionButton(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in, hint_in)
  local()
  global()
  instance(x, y, w, h, r, g, b, a, active, label, lastleft, hint)
  (
      x       = x_in;
      y       = y_in;
      w       = w_in;
      h       = h_in;
      r       = r_in;
      g       = g_in;
      b       = b_in;
      a       = a_in;
      !label  ? label = label_in;
      !hint   ? hint = hint_in;
  );
  
function setLabel( _label )
  local()
  global()
  instance(label)
  (
    label = _label;
  );

function drawHint_draw()
  global(gfx_x, gfx_y, gfx_w, gfx_h, mouse_x, mouse_y, hintTime, currentHint, retina_scaling, fontface,
         font_color_r, font_color_g, font_color_b, font_color_a,
         hint_bg_r, hint_bg_g, hint_bg_b, hint_bg_a )
  local(w, h)
  global()
  (
    ( hintTime > .99 ) ? (
      gfx_setfont(7, fontface, 14*retina_scaling);
      gfx_measurestr(currentHint,w,h);
      
      gfx_x = mouse_x+15;
      gfx_y = mouse_y+15;
      ( gfx_x > 0.5*gfx_w ) ? gfx_x = mouse_x - w - 8;
      ( gfx_y > 0.5*gfx_h ) ? gfx_y = mouse_y - h - 8;
      
      gfx_set( hint_bg_r, hint_bg_g, hint_bg_b, hint_bg_a );
      gfx_rect(gfx_x-2, gfx_y-2, w+4, h+4);
      gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );      
      gfx_printf(currentHint);
    );
  );

function updateHintTime(hint, hoverType)
  global(gfx_x, gfx_y, mouse_x, mouse_y, hintTime, currentHint, delta_time, lx, ly, hover)
  local()
  global()
  (
    ( (lx - mouse_x) || ( ly - mouse_y ) ) > 0 ? hintTime = 0;
    
    hint != 0 ? (
      currentHint = hint;
      hintTime = hintTime + 1 * delta_time;
      hover = hoverType;
      hintTime = min(1, hintTime)
    ) : (
      0
    )
  );
  
function selectionButton_draw()
  local(jnk, siz, hln)
  global(gfx_x, gfx_y, buttonFontSize, retina_scaling, fontface,
         font_color_r, font_color_g, font_color_b, font_color_a,
         bg_color_r, bg_color_g, bg_color_b )
  instance(x, y, w, h, r, g, b, a, active, label, lastleft, htime, style, mode)
  (
    style == 2 ? (
      hln = (.17 + .3*(1-active))*htime;
      gfx_set( bg_color_r, bg_color_g, bg_color_b, 1 );
      gfx_rect( x, y, ceil(w), ceil(h) );
    );
    
    hln = (.17 + .3*(1-active))*htime;
    gfx_set( min(1,r + hln), min(1,g + hln), min(1,b + hln), .2 + .5*active );
    ( mode == 0 ) ? (
      gfx_rect( x, y, ceil(w), ceil(h) );
    ) : ( mode == 1 ) ? (
      gfx_rect( x, y, ceil(w*.5), ceil(h) );
    ) : (
      gfx_rect( ceil(x+.5*w), y, ceil(w*.5), ceil(h) );
    );
    
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );
    retina_scaling > 1 ? gfx_setfont(8, fontface, buttonFontSize*retina_scaling);
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + .5 * (w-siz);
    gfx_y = y - .5*(jnk-h) + 1;
    gfx_printf( label );
  );


function selectionButton_linkbutton()
  local(jnk, siz, hln)
  global(gfx_x, gfx_y, buttonFontSize, retina_scaling, fontface,
         font_color_r, font_color_g, font_color_b, font_color_a )
  instance(x, y, w, h, r, g, b, a, active, label, lastleft, htime)
  (
    retina_scaling > 1 ? gfx_setfont(8, fontface, buttonFontSize*retina_scaling);
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + .5 * (w-siz);
    gfx_y = y - .5*(jnk-h) + 1;
    
    //gfx_set( .3, .3, .3, 1 );
    //gfx_roundrect( floor(x+.35*w)+2, floor(y + .33*h)+1,  ceil(.55*w), floor(.2*h), 4);
    //gfx_roundrect( floor(x+.35*w)+2, floor(y + .47*h)+1,  ceil(.55*w), floor(.2*h), 4);
    
    active ? gfx_set( font_color_r, font_color_g, font_color_b, font_color_a ) : gfx_set( min(1,.4 + hln), min(1,.4 + hln), min(1,.4 + hln), 1 );
    gfx_arc( floor(x), floor(y + w+.05*h), floor(.6*w), 0*$pi, .5*$pi, 1);
    gfx_arc( floor(x), floor(y + w+.55*h), floor(.6*w), .5*$pi, $pi, 1);
    
    gfx_roundrect( floor(x+.35*w), floor(y + .33*h),  ceil(.55*w), floor(.2*h), 4);
    gfx_roundrect( floor(x+.35*w), floor(y + .47*h),  ceil(.55*w), floor(.2*h), 4);
    
    //gfx_arc( x+.8*w, y + 5*h,  .35*w, 0, 2*$pi, 1);
    //gfx_arc( x+.8*w, y + .5*h, .35*w, 0, 2*$pi, 1);
  );

function highlightNow()
  global()
  local()
  instance(htime)
  (
    htime = 1;
  );
  
function selectionButton_processMouse(xx, yy, mc)
  local(left, right, change)
  global(updateHintTime, gfx_x, gfx_y, delta_time)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastright, lastleft, htime, hint, modes, mode, hoverType)
  (
    change = 0;
    left = mc & 1;
    right = mc & 2;
    ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ?
    (
      left ? (
        ( (lastleft ~= 1 ) ) ? ( 
          active = 1 - active;
          change = 1;
        );
      );
      
      right ? (
        ( (lastright ~= 2 ) ) ? ( 
          change = 2;
          
          mode = mode + 1;
          mode > modes ? mode = 0;
        );        
      );
      
      htime = updateHintTime(hint, hoverType);
    ) : htime = max( 0.6 * htime, updateHintTime(0, hoverType) );
    
    lastleft = left;
    lastright = right;
    change
  );
  
function selectionButton_setActive(active_in)
  local()
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    active = active_in;
  );  

function combobox(x_in, y_in, w_in, h_in, r_in, g_in, b_in, a_in, nitems_in, stridx_in, goup_in, cols_in, hint_in )
  local()
  global(newUI)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, hasfocus, goup, cols, thisUI, htime, hint)
  (
      !thisUI ?     thisUI = newUI += 1;
      x             = x_in;
      y             = y_in+1;
      w             = w_in;
      h             = ceil(h_in-2);
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      nitems        = nitems_in;
      stridx        = stridx_in;
      goup          = goup_in;
      cols          = cols_in;
      hint          = hint_in;
      //cap           = 0;
      //curitem       = 0;
      //open          = 0;
      //lastleft      = 0;
      //hasfocus      = 0;
      //htime         = 0;
      //hover         = 8;
  );
  
function combobox_setcuritem( item )
  local(i, xtxt)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, lastset)
  (
    curitem = inverseComboMapping(stridx, item);
  );  
  
function combobox_draw()
  local(i, xtxt, x1, x2, x3, y1, y2, y3, pad, wi)
  global(gfx_x, gfx_y, lastUI, retina_scaling, 
         highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a,
         font_color_r, font_color_g, font_color_b, font_color_a,
         disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a )
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup, cols, thisUI, htime, disabled)
  (
    gfx_set( min(1,r + .15*htime), min(1,g + .15*htime), min(1,b + .25*htime), .1 );
    gfx_rect( x, y, w, h );
    
    disabled == 1 ? gfx_set( disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a ) :
    ( 
      lastUI == thisUI ? gfx_set( highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a ) : gfx_set( r, g, b, a );
    );
    
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    
    pad = .3*h;
    wi = .5 * (h-pad);
    x1 = x+w-wi-pad;
    x2 = x+w-pad;
    x3 = x+w-.5*wi-pad;
    
    y1 = y+pad;
    y2 = y+pad;
    y3 = y+h-pad;
    
    gfx_line(x1, y1, x2, y2);
    gfx_line(x2, y2, x3, y3);
    gfx_line(x3, y3, x1, y1);
  
    xtxt = x+3*retina_scaling;
    gfx_x = xtxt;
    gfx_y = y+4*retina_scaling;
    
    disabled == 0 ? gfx_set( font_color_r, font_color_g, font_color_b, font_color_a ) : gfx_set( disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a );
    gfx_printf(comboStrings(stridx, comboMapping(stridx, curitem)));
  );
  
function combobox_getCurItem()
  instance(stridx, curitem)
  global()
  local()
  (
    comboMapping(stridx, curitem)
  );
  
function combobox_draw_top()
  local(i, i_internal, j, xtxt, x1, x2, x3, y1, y2, y3, pad, wi, delta, ny, hasMarked)
  global(gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, font_color_r, font_color_g, font_color_b, font_color_a, combo_bg_r, combo_bg_g, combo_bg_b )
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup, cols, dangerousElements)
  (    
    xtxt = x+3;
    delta = goup ? (nitems/cols+1)*h : 0;
    gfx_x = xtxt;
    gfx_y = y + 4 - delta;
    ny = ceil(nitems/cols);
    
    hasMarked = dangerousElements > 0;
    open ?
    (
      gfx_set( combo_bg_r, combo_bg_g, combo_bg_b, 1 );
      //gfx_set( r*.3, g*.3, b*.3, 1 );
      gfx_rect( x - (cols-1)*w, y-delta+h-1, cols*w+2, h * ny + 2 );  
      //gfx_set( r*.1, g*.1, b*.1, 1 );
      //gfx_rect( x - (cols-1)*w+1, y-delta+h, cols*w, h * ny );
      i = 0; j = 0;
      gfx_set( r, g, b, a, 0.95 );
      loop( cols, 
        loop( ny,
          gfx_x = xtxt - (cols-1-j)*w + 1;
          gfx_y += h;
          hover == i ? (
            gfx_rect( gfx_x-3, gfx_y - 3, w, h );
            gfx_set( 1-font_color_r, 1-font_color_g, 1-font_color_b, 1 );
          ) : gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );

          i_internal = comboMapping(stridx, i);
          ( hasMarked && dangerousElements[i_internal] ) ? (
            gfx_set( gfx_r+.3, gfx_g-.5, gfx_b-.5, .75*gfx_a );
            gfx_printf("[%s]", comboStrings(stridx, i_internal));
            gfx_set( gfx_r-.3, gfx_g+.5, gfx_b+.5, gfx_a/.75 );
          ) : gfx_printf(comboStrings(stridx, i_internal));
          i += 1;
        );
        gfx_y = y + 4 - delta;
        j += 1;
      );
      gfx_set( 1, 1, 1, .1 );
    )
  );

function combobox_processMouse(xx, yy, mc)
  local(over, left, right, change, delta, xmin, xmax, ymin, ymax, xl, yl, ny, hasMarked, olditem)
  global(gfx_x, gfx_y, lastUI, lastChar, mouse_wheel)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, lastright, hasfocus, goup, cols, thisUI, htime, hint, disabled, dangerousElements)  
  (
    disabled == 0 ? (
      delta   = goup ? (nitems/cols+1)*h : 0;
      change  = 0;
      left    = mc & 1;
      right   = mc & 2;
      
      olditem = curitem;
      xmin    = x - (cols-1)*w;
      ymin    = y + h - delta;
      xmax    = x + w;
      ny      = ceil(nitems/cols);
      ymax    = ymin + ny*h;
      
      hasMarked = dangerousElements > 0;
      over = xx > x && xx < ( x+w ) && yy > y && yy < ( y + h );
      
      ( lastUI == thisUI ) ?
      (
        ( lastChar == 1685026670 ) ? 
        ( 
          curitem = curitem + 1;
          curitem > nitems - 1 ? curitem = 0;
          while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
          (
            curitem = curitem + 1;
            curitem > nitems - 1 ? curitem = 0;
          );
          
          change = 1;
          mouse_wheel = 0;
        ) : (
          ( lastChar == 30064 ) ? 
          (
            curitem = curitem - 1;
            curitem < 0 ? curitem = nitems-1;
            while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
            (
              curitem = curitem - 1;
              curitem < 0 ? curitem = nitems-1;
            );
            
            change = 1;
            mouse_wheel = 0;
          );
        );
      );
      
      ( over ) ?
      (
        ( mouse_wheel < 0 ) ? 
        ( 
          curitem = curitem + 1;
          curitem > nitems - 1 ? curitem = 0;
          
          while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
          (
            curitem = curitem + 1;
            curitem > nitems - 1 ? curitem = 0;
          );
          
          change = 1;
          mouse_wheel = 0;
        ) : 
        (
          ( mouse_wheel > 0 ) ? 
          (
            curitem = curitem - 1;
            curitem < 0 ? curitem = nitems-1;
            
            while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
            (
              curitem = curitem - 1;
              curitem < 0 ? curitem = nitems-1;
            );
            
            change = 1;
            mouse_wheel = 0;
          );
        );
      );
      
      over ? (
        htime = updateHintTime(hint, 0);
      ) : htime = updateHintTime(0, 0);
      
      open ? 
      (
        xl = min( max( 0, floor((xx - xmin)/w)), cols-1 );
        yl = floor((yy-ymin)/h);
  //      hover = min( nitems-1, max( 0, xl * floor(nitems/cols) + floor((max(ymin,min(ymax-h,yy)) - (y-delta))/h) - 1 ) );
        
        hover = min( nitems-1, max( 0, xl * ny + max(0, min(ny-1, yl)) ) );
        
        ( !lastleft && left ) ? (
          open = 0;
          ( xx > xmin && xx < xmax && yy > (y+h-delta) && yy < ( ymax ) ) ? ( curitem = hover; change = 1 );
        ) : ( !lastright && right ) ? (
          hover > 0 ? dangerousElements[comboMapping(stridx, hover)] = 1 - dangerousElements[comboMapping(stridx, hover)];
        )
      ) : (
        ( lastleft == 0 && left && over ) ? (
          open = 1; hasfocus = 1; lastUI = thisUI;
        )
      );
      
      ( !left && !open ) ? hasfocus = 0;
      
      lastleft = left;
      lastright = right;
      
      change
    );
  );
  
function sliderWidget(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in, two_values, minval_in, maxval_in, default_in, unit_in, isInteger_in, hint_in )
  local()
  global(newUI)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastright, lastclick, yslidercenter, cap, twoval, unit, isInteger, thisUI, htime, hint, onmarker)
  (
      !thisUI ? thisUI = newUI+=1;
      x             = x_in+2;
      y             = y_in;
      w             = w_in-4;
      h             = h_in;
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      yslidercenter = y + 0.3 * h;

      !label ? label = label_in;
      !hint ? hint  = hint_in;
      !unit ? unit  = unit_in;
      twoval        = two_values; /* Do we have two values? */
      minval        = minval_in;
      maxval        = maxval_in;
      default       = ( default_in - minval ) / ( maxval - minval );
      isInteger     = isInteger_in;
      
      /*htime         = 0;
      onmarker      = 0;
      lastclick     = 0;
      cap           = 0;
      lastleft      = 0;
      lastright     = 0;
      value         = 0;
      value2        = 0;*/
  );
  
function sliderWidget_setValue(value_in)
  local()
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
  (
    value = ( value_in - minval ) / ( maxval - minval )
  );
  
function sliderWidget_getValue()
  local(v)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval, isInteger)
  (
    v = value * ( maxval - minval ) + minval;
    v = isInteger ? floor(v+0.499999) : v;
    v
  );  
  
function sliderWidget_draw()
  local(jnk, siz, q, str, modmax, modmin, modoffset, tmp)
  global(slider38, gfx_x, gfx_y, lastUI, retina_scaling,widgetFontSize, modulator.scaled_modvalue, mlevel, fontface, modulatorDynamics,
         font_color_r, font_color_g, font_color_b, font_color_a, slider_marker_r, slider_marker_g, slider_marker_b, slider_marker_a,
         highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a,
         disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a, modulator.getScale,
         modrange_r, modrange_g, modrange_b, modrange_a )
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval, unit, thisUI, htime, overridevalue, overrideunit, onmarker, hasFilterDynamics, hasModulatorDynamics, disabled, dynval, postMeter)
  (
    gfx_setfont(1, fontface, widgetFontSize*retina_scaling);
    gfx_set( min(1,r + .25*htime), min(1,g + .25*htime), min(1,b + .25*htime), .1 );
  
    ( disabled == 0 ) ? (
      gfx_rect( x-3*retina_scaling, yslidercenter-.25*h, w+6*retina_scaling, h*.5 );
        
      ( modulatorDynamics && hasModulatorDynamics == 1 ) ? (
        gfx_set( modrange_r, modrange_g, modrange_b, modrange_a );
        modoffset = slider38 & 4 ? .5 * value2*w * modulator.getScale();
        modmax = x + (hasFilterDynamics+modulator.getScale()) * value2 * w + value*w - modoffset;
        modmin = x + value*w - modoffset;
        modmax < modmin ? 
        (
          tmp = modmax;
          modmax = modmin;
          modmin = tmp;
        );
        modmin = max( x, min( x+w, modmin ) );
        modmax = max( x, min( x+w, modmax ) );
        
        // Modulation range indicator
        gfx_rect( modmin, yslidercenter - 2, modmax - modmin, 1 );
        gfx_rect( modmin, yslidercenter + 2, modmax - modmin, 1 );
      );
  
      lastUI == thisUI ? gfx_set( highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a ) : gfx_set( r, g, b, 0.8 );
      gfx_line(x, yslidercenter, x+w, yslidercenter);
      gfx_set( r*.3, g*.3, b*.3, 0.8 );
      gfx_line(x + retina_scaling, yslidercenter + 1, x+w + retina_scaling, yslidercenter + 1);

      gfx_set( r, g, b, .2 );    
      gfx_rect( x-2*retina_scaling + value*w+5, yslidercenter - .3*h, 1, h*.6+1 );
      gfx_rect( x-2*retina_scaling + value*w-2, yslidercenter - .3*h, 1, h*.6+1 );
      gfx_rect( x-2*retina_scaling + value*w-1, yslidercenter - .3*h, 6, 1 );
      gfx_rect( x-2*retina_scaling + value*w-1, yslidercenter + .3*h-1, 6, 1 );
      
      gfx_set( r, g, b, 1.0 );
      gfx_rect( x-2*retina_scaling + value*w, yslidercenter - .2*h, 4*retina_scaling, h*.4 );
      gfx_set( r*.2, g*.2, b*.2, 0.4 );
      gfx_rect( x-retina_scaling + value*w, yslidercenter - .2*h + 1, 2*retina_scaling, h*.4-2 );
      
      onmarker == 1 ? 
      (
        gfx_set( 1, 1, 1, 0.4 );
        gfx_rect( x-2*retina_scaling + value*w-1, yslidercenter - .2*h-1, 4*retina_scaling+2, h*.4+2 );
      );
      
      gfx_set( modrange_r, modrange_g, modrange_b, modrange_a );
      value2 > 0 ? gfx_rect( x + value*w, yslidercenter - .1*h, value2*w+1, h*.3 ) : gfx_rect( x + (value+value2)*w, yslidercenter - .1*h, abs(value2)*w, h*.3 );
  
      gfx_set( slider_marker_r, slider_marker_g, slider_marker_b, slider_marker_a );
      mlevel = hasModulatorDynamics*modulator.scaled_modvalue + (hasFilterDynamics > 0 ? dynval : 0);
      mlevel = x + (value+value2*mlevel)*w;
      mlevel = max( x, min( x+w, mlevel ) );
      gfx_rect( mlevel-1, yslidercenter - .2*h, 2, h*.4 );
    ) : (
      // Look of disabled widget
      gfx_set( disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a*.2 );
      gfx_rect( x-3*retina_scaling, yslidercenter-.25*h, w+6*retina_scaling, h*.5 );
      gfx_set( disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a );
      gfx_line(x + retina_scaling, yslidercenter, x+w + retina_scaling, yslidercenter);
    );
    
    disabled == 0 ? gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );
    gfx_x = x;
    gfx_y = y + 11*retina_scaling;
    gfx_printf( label );
    
    ( overridevalue == 0 ) ? (
      sprintf( str, "%2.3g%s", this.sliderWidget_getValue(), unit );
    ) : (
      ( overridevalue == -2000 ) ? (
        sprintf( str, "%s", overrideunit );
      ) : ( overridevalue == -1000 ) ? (
        sprintf( str, "%2.3g (%s)", this.sliderWidget_getValue(), overrideunit );
      ) : (
        ( overridevalue > 1000 ) ? (
          sprintf( str, "%2.3g (%2.3g k%s)", this.sliderWidget_getValue(), overridevalue/1000, overrideunit );
        ) : (
          sprintf( str, "%2.3g (%2.3g %s)", this.sliderWidget_getValue(), overridevalue, overrideunit );      
        )
      );
    );
    gfx_measurestr(str, siz, jnk);
    !postMeter ? (
      gfx_x = x + w - siz;
      gfx_y = y + 11*retina_scaling;
    ) : (
      gfx_x = postMeter < 2 ? x + w + 4 : postMeter - siz - 2;
      gfx_y = y + 0.5*jnk;
    );
    gfx_printf( str );
  );
  
function sliderWidget_setValue2(value_in)
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 = value_in;
   );
   
// Set value in a non-normalized manner
function sliderWidget_setValue2_nn(value_in)
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 = ( value_in > 0 ) ? value_in * (1.0 - value) : value_in * value;
   );
  
function sliderWidget_getValue2()
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2
   ); 
   
function sliderWidget_getValue2_nn()
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 > 0 ? value2 / (1.0 - value) : value2 / value
   );    
  
function sliderWidget_processMouse(xx, yy, dx, dy, mc)
  local(left, right, change, newcap, onslider, shft, ctrl, mul, ym)
  global(gfx_x, gfx_y, mouse_wheel, mouse_cap, lastUI, lastChar, retina_scaling)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastright, lastclick, yslidercenter, cap, twoval, thisUI, htime, hint, onmarker, lastrightclick, disabled)
  (
    disabled == 0 ? 
    (
      left  = mc & 1;
      right = mc & 2;
      ctrl  = mc & 4;
      shft  = mc & 8;
      
      change = 0;
      newcap = 0;
      ym = .5*h;
      onslider = ( ( xx > x ) && ( xx < (x+w) ) && ( yy > (yslidercenter-ym) ) && ( yy < (yslidercenter+ym) ) );
      onmarker = abs( value * w + x - xx ) < 8*retina_scaling && ( yy > (yslidercenter-ym) ) && ( yy < (yslidercenter+ym) );
      
      onslider ? (
        htime = updateHintTime(hint, 0);
      ) : htime = updateHintTime(0, 0);
      
      ( lastUI == thisUI ) ?
      (
        ( lastChar == 1919379572 ) ? value = value + .001;
        ( lastChar == 1818584692 ) ? value = value - .001;      
      );
      
      left ? (
        ( ( lastleft == 0 ) && ( time_precise() - lastclick ) < .2 ) ?
        (
          value       = default;
          change      = 1;
        ) : ( ( cap == 1 ) || ( ( onslider || onmarker ) && lastleft == 0 ) ) ? ( 
          ((shft == 0) && (ctrl == 0)) ? (
            value       = (xx-x)/w;
          ) : (
            mul         = 1;
            shft ? mul *= 0.125;
            ctrl ? mul *= 0.1666666666667;
            value       = value - mul*dx/w;
          );
          change      = 1;
          newcap      = 1;
          lastclick   = time_precise();
          lastUI      = thisUI;
        );
      ) : ( 
        twoval && right ? 
        (
          ( ( cap == 2 ) || ((onmarker || onslider) && lastright == 0) ) ? ( 
            ( ( lastright == 0 ) && ( time_precise() - lastrightclick ) < .15 ) ?
            (
              value2 = 0;
              change = 2;
              lastrightclick = time_precise();
            ) : (
              value2 = (xx-x)/w - value;
              change = 2;
              newcap = 2;
              lastrightclick = time_precise();
            )
          );
        ) : ( (mouse_wheel ~= 0) && onslider ) ? (
          ( shft && twoval ) ? (
            value2 = value2 + .00001 * mouse_wheel; change = 1;
          ) : (
            value = value + .00001 * mouse_wheel;  change = 1;
          );
          mouse_wheel = 0;
        );
      );
      
      lastleft  = left;
      lastright = right;
      cap       = newcap;
      value     = value > 1.0 ? 1 : value;
      value     = value < 0.0 ? 0 : value;
      twoval ? (
        value2 = (value2+value) > 1.0 ? 1.0-value : value2;
        value2 = (value2+value) < 0.0 ? -value : value2;    
      );
      
      change
    ) : 0;
  );

function init_window_spline(N, splineIdx, 
                     splineCoordsX, splineCoordsY, 
                     splineCoordsX2, splineCoordsY2,
                     indices,
                     tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ,
                     tempCoordStorageX2, tempCoordStorageY2, tempCoordStorageZ2,
                     c1_storage, c2_storage, c3_storage,
                     c1_storage2, c2_storage2, c3_storage2 )
  instance(spline)
  global()
  local()
  (
    spline = spline.gen_spline(N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, tempCoordStorageX2, tempCoordStorageY2, tempCoordStorageZ2, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2);
  );

function gen_window(xp, yp, wp, hp, hint_in)
  instance(x, y, w, h, spline, shaperSelect, hint)
  global(buttonOff.selectionButton, retina_scaling, shaperSelect.combobox,
         widgetcolor_r, widgetcolor_g, widgetcolor_b, widgetcolor_a, nShapers )
  local(hy, bw, bh, wR, wG, wB, wA)
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    hint = hint_in;
    
    hy = 15*retina_scaling;
    bw = 55*retina_scaling;
    bh = 10*retina_scaling;

    shaperSelect.combobox(x+5, y+4, bw*1.6, 20 * retina_scaling, widgetcolor_r, widgetcolor_g, widgetcolor_b, widgetcolor_a, nShapers, 4, 0, 1, "Waveshaper selection." );
  );

function gen_dynamics(xp, yp, wp, hp, hint_in)
  instance(x, y, w, h, yref, sc, cap_mode, inLight, outLight, dynLight, lastleft, 
           RMSButton, RMSButton2, RMSButton3, MIDIButton, MIDIButton2, MWButton,
           hint)
  global(inLight.toggleLight, retina_scaling,RMSButton.selectionButton,MIDIButton.selectionButton,MIDIButton2.selectionButton,
         selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a,
         rms_in_r, rms_in_g, rms_in_b, rms_in_a, rms_out_r, rms_out_g, rms_out_b, rms_out_a,
         dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a )
  local(hy, bw, bh, ych, xoff, yoff)
  (
    x     = xp;
    y     = yp;
    w     = wp;
    h     = hp;
    !hint ? hint = hint_in;
     
    bw = 10*retina_scaling;
    bh = 10*retina_scaling;
    ych = 2*bh;
    xoff = x+w-15*retina_scaling;
    yoff = y+5*retina_scaling;
    inLight.toggleLight(xoff, yoff, bw, bh, "In", 1, rms_in_r, rms_in_g, rms_in_b, rms_in_a, 1);
    outLight.toggleLight(xoff, yoff+ych, bw, bh, "Out", 1, rms_out_r, rms_out_g, rms_out_b, rms_out_a, 1);
    dynLight.toggleLight(xoff, yoff+2*ych, bw, bh, "Dynamics", 1, dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a, 1);    
    
    hy = 15*retina_scaling;
    bw = 65*retina_scaling;
    bh = 10*retina_scaling;
    RMSButton.selectionButton(x+5, y+4, bw, bh, "Driven RMS", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "RMS\n\nSelecting this mode bases dynamics on RMS value after the pre-gain stage.");
    MIDIButton.selectionButton(x+5, y+4 + hy, bw, bh, "MIDI", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Note trigger\n\nSelecting this mode bases dynamics on MIDI note triggers.");
    MIDIButton2.selectionButton(x+5, y+4 + 2*hy, bw, bh, "MIDI Velocity",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Note trigger\n\nSelecting this mode bases dynamics on MIDI notes\nand uses the velocity information from the notes.");    
    RMSButton2.selectionButton(x+5, y+4 + 3*hy, bw, bh, "Pre-Gain RMS", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Pre-Gain RMS\n\nSelecting this mode bases dynamics on RMS value of the signal prior to pre-gain.");
    RMSButton3.selectionButton(x+5, y+4 + 4*hy, bw, bh, "Sidechain", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Sidechain RMS\n\nSelecting this mode bases dynamics on RMS value of channel 3 and 4 (side chain).");
    MWButton.selectionButton(x+5, y+4 + 5*hy, bw, bh, "Modwheel", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Modwheel\n\nSet dynamic variable with modwheel.");
        
    !sc ? sc = h;
  );

function processMouse(mx, my, dx, dy, mc, lmc)
  instance(x, y, w, h, spline, shaperSelect, htime, hint)
  global(slider56, shaperSelect.combobox_processMouse)
  local()  
  (  
    shaperSelect.open == 0 ? (
      spline.processMouse((mx-x)/w, (my-y)/h, dx/w, dy/h, mc, lmc, h);
      
      ( (mx > x) && (my > y) && (mx<(x+w)) && (my<(y+h)) ) ? htime = updateHintTime(hint, 0);
    );
    
    ( spline.cap_mode == 0 ) ? (
      shaperSelect.combobox_setcuritem(slider56);
      shaperSelect.combobox_processMouse(mx, my, mc) ? ( slider_automate( slider56=shaperSelect.curitem; ); );
    );
  );

function sort_spline(gfx)
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.sort_spline(gfx);
  );

function update_spline(gfx)
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.update_spline(gfx);
  );

function rotatedPrint(x, y, str, rot)
local(sw,sh,olddest)
global(gfx_x, gfx_y, gfx_dest, gfx_mode,
       label_color_r, label_color_g, label_color_b, label_color_a )
(
  gfx_measurestr(str, sw, sh);
  sw += 1;
  olddest = gfx_dest;
  gfx_dest = 1; 
  gfx_setimgdim(1, sw, sw);
  gfx_set( 0, 0, 0, 1 );
  gfx_rect(0, 0, sw, sw);
  gfx_x = 1;
  gfx_y = 1;
  gfx_set( label_color_r, label_color_g, label_color_b, label_color_a );
  gfx_printf(str);
  gfx_dest = olddest;
  gfx_mode = 1;
  gfx_x = x;
  gfx_y = y;
  gfx_blit(1, 1.0, rot);
  gfx_mode = 0;
);

function ylabel(str)
  instance(x, y, w, h)
  globals(retina_scaling)
  local(sw, sh)
  (
    gfx_measurestr(str, sw, sh);
    rotatedPrint(x-16*retina_scaling, y+0.5*(h-sw), str, -.5*$pi); 
  );
  
function xlabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y,
          font_color_r, font_color_g, font_color_b, font_color_a,
          label_color_r, label_color_g, label_color_b, label_color_a )
  local(sw, sh)
  (
    gfx_set( label_color_r, label_color_g, label_color_b, label_color_a );
    gfx_measurestr(str, sw, sh);
    gfx_x = x + 0.5*(w-sw);
    gfx_y = y + h + 12;
    gfx_printf(str);
  );

function draw_text(str, rx, ry)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y,
          font_color_r, font_color_g, font_color_b, font_color_a )
  local()
  (
    gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );
    gfx_x = x + w*rx;
    gfx_y = y + h*ry;
    gfx_printf(str);
  );

function draw_grid(N)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y
          grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local(dx, dy)
  (  
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    dx = w/(N-1);
    dy = h/(N-1);    
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    gfx_x = x;
    gfx_y = y+h;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );
  
function draw_grid(N, dy)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y,
          grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local(dx, dy)
  (
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    dx = w/(N-1);  
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    
    gfx_x = x;
    gfx_y = y+h;
    loop(min(100, floor(h/dy)),
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );  

function draw_back()
  instance(x, y, w, h, yref, sc)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y,
          backface_color_r, backface_color_g, backface_color_b, backface_color_a )
  local()
  (
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);
  );

function draw_window(movAvgL, movAvgR, movAvgOL, movAvgOR)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline, buttonSine, shaperSelect)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, buttonOff.selectionButton_draw, voltage_opacity)
  (
    this.draw_back();
    this.draw_grid(10);
    spline.plot_spline(x, y, w, h);
    
    gfx_set( 0.6 + max(-.2,(movAvgL - 1)), .1, .1, voltage_opacity);
    gfx_rect(x,y+h+2,w*min(1,movAvgL),2);
    gfx_rect(x,y+h+4,w*min(1,movAvgR),2);
    gfx_set( 0.2, .2, 0.9 + max(movAvgOL - 1, -.5), voltage_opacity);
    movAvgOL = min(movAvgOL, 1);
    movAvgOR = min(movAvgOR, 1);
    gfx_rect(x-2,y+h-h*movAvgOL,2,h*movAvgOL);
    gfx_rect(x-4,y+h-h*movAvgOR,2,h*movAvgOR);
    
    shaperSelect.combobox_draw();  
    shaperSelect.combobox_draw_top();  
    
    /*buttonOff.selectionButton_draw();
    buttonArctan.selectionButton_draw();
    buttonFast.selectionButton_draw();
    buttonSpline.selectionButton_draw();
    buttonSine.selectionButton_draw();*/
  );
  
function draw_buffer(scopeptr, scopebuffer, scopebuffermax, mul, fill)
  instance(x, y, w, h, yref, sc, cap_mode)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(lx, ly, xx, dx, lptr, yy, lastx, lasty, scale, isc)
  (
    xx = x;
    dx = w/(scopebuffermax-scopebuffer);
    lptr = scopeptr;
    scale = (mul > 0) ? mul*h : sc;

    gfx_x = xx;
    gfx_y = yref;
    isc = h/scale;
    loop(scopebuffermax-scopeptr,
      yy = yref - scale*min(isc,lptr[]);
      
      lptr += 1;
      
      fill ? (
        gfx_triangle( xx-dx, y+h,
                      xx-dx, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += dx;
    );
    
    lptr = scopebuffer;
    loop(scopeptr - scopebuffer,
      yy = yref - scale*min(isc,lptr[]);
      
      fill ? (
        gfx_triangle( xx-dx, y+h,
                      xx-dx, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      lptr += 1;
      ly = yy;
      xx += dx;
    );
  );  

function draw_dynamics(thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight, RMSButton, RMSButton2, RMSButton3, MIDIButton, MIDIButton2, MWButton, highlighted)
  globals(slider45, gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, gfx_mode, inLight.toggleLight_draw, RMSButton.selectionButton_draw, MIDIButton.selectionButton_draw, MIDIButton2.selectionButton_draw,
          thresh_color_r, thresh_color_g, thresh_color_b, thresh_color_a, fontface, widgetFontSize
          highlight_r, highlight_g, highlight_b, highlight_a )
  local(texloc, texxloc, lineloc, tw, th)
  (
    yref = y+h;
    this.draw_grid(10, 10*sc/h);
    gfx_set( 0.0, 0.0, 0.0, 1.0 );
    
    gfx_measurestr("Thresh", tw, th);
    texxloc = x + .5*(w-1.1*tw);
    ((slider45 < 2 || slider45 > 5)&&!( (slider45 == 10) || (slider45 == 11) ) ) ? (
      gfx_x = texxloc;
      texloc = yref-sc*thresh-9;
      ( texloc > y ) ? (
        gfx_y = texloc;
        gfx_printf( "Thresh" );
      );
      lineloc = yref - sc*thresh+1;
      ( lineloc > y ) ? gfx_line( x, lineloc, x + w, yref -sc * thresh + 1 );
    
      gfx_set( thresh_color_r, thresh_color_g, thresh_color_b, thresh_color_a );
      gfx_x = texxloc+2;
      ( texloc > y ) ? (
        gfx_y = texloc-1;
        gfx_printf( "Thresh" );
      );
    
      ( lineloc > y ) ? (
        gfx_line( x, yref - sc*thresh, x + w, yref -sc*thresh );
        ( highlight == 1 ) ? gfx_rect( x, yref - sc*thresh-1, w, 2 );
      );
    );
    
    (highlighted > 0) ? (
      gfx_set( highlight_r, highlight_g, highlight_b, highlight_a * highlighted );
      gfx_mode = 1;
      gfx_rect( x-8, y-8, w+16, h+16 );
      gfx_mode = 0;
    );
    
    gfx_setfont(1, fontface, widgetFontSize);
    inLight.toggleLight_draw();
    outLight.toggleLight_draw();
    dynLight.toggleLight_draw();
    
    RMSButton.selectionButton_draw();
    MIDIButton.selectionButton_draw();
    MIDIButton2.selectionButton_draw();    
    RMSButton2.selectionButton_draw();
    RMSButton3.selectionButton_draw();
    MWButton.selectionButton_draw();
  );
  
function processMouseDynamics(xx, yy, dx, dy, mc, thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight, lastleft, RMSButton, RMSButton2, RMSButton3, MIDIButton, MIDIButton2, lastRight, MWButton, htime, hint)
  local(left, right, buttonClicked)
  global(slider45, forceUpdate, gfx_x, gfx_y, mouse_wheel, slider59, inLight.toggleLight_processMouse, outLight.toggleLight_processMouse, dynLight.toggleLight_processMouse, RMSButton.selectionButton_setActive, MIDIButton.selectionButton_setActive, MIDIButton2.selectionButton_setActive, RMSButton.selectionButton_processMouse, MIDIButton.selectionButton_processMouse, MIDIButton2.selectionButton_processMouse)
  (
    left  = mc & 1;
    right = mc & 2;   
    
    inLight.toggleLight_processMouse(xx, yy, mc);
    outLight.toggleLight_processMouse(xx, yy, mc);
    dynLight.toggleLight_processMouse(xx, yy, mc);    
    
    buttonClicked = 0;
    RMSButton.selectionButton_processMouse(xx, yy, mc)   ? ( slider45 = slider45 & 1;       slider_automate(slider45); buttonClicked = 1; );
    MIDIButton.selectionButton_processMouse(xx, yy, mc)  ? ( slider45 = 2 + (slider45 & 1); slider_automate(slider45); buttonClicked = 1; );
    MIDIButton2.selectionButton_processMouse(xx, yy, mc) ? ( slider45 = 4 + (slider45 & 1); slider_automate(slider45); buttonClicked = 1; );
    RMSButton2.selectionButton_processMouse(xx, yy, mc)  ? ( slider45 = 6 + (slider45 & 1); slider_automate(slider45); buttonClicked = 1; );
    RMSButton3.selectionButton_processMouse(xx, yy, mc)  ? ( slider45 = 8 + (slider45 & 1); slider_automate(slider45); buttonClicked = 1; );
    MWButton.selectionButton_processMouse(xx, yy, mc)    ? ( slider45 = 10 + (slider45 & 1); slider_automate(slider45); buttonClicked = 1; );

    RMSButton.selectionButton_setActive(slider45<2);
    MIDIButton.selectionButton_setActive(slider45>1&&slider45<4);
    MIDIButton2.selectionButton_setActive(slider45>3&&slider45<6);
    RMSButton2.selectionButton_setActive(slider45>5&&slider45<8);
    RMSButton3.selectionButton_setActive(slider45>7&&slider45<10);
    MWButton.selectionButton_setActive(slider45>9&&slider45<12);    

    ( buttonClicked == 0 ) ?
    (
      highlight = 0;
      ( (mouse_wheel ~= 0) && xx > x && yy > y && xx < (x+w) && yy < (y+h) ) ?
      (
        sc += .5*mouse_wheel;
        mouse_wheel = 0;
        ( sc < 0 ) ? sc = 0.01;
      );
      
      ( right ) ? 
      (
        ( cap_mode == 5 ) ? (
          thresh = thresh + .002*dy;
          ( thresh < 0 ) ? thresh = 0;
          ( thresh > h/sc ) ? thresh = h/sc;
          ( thresh > 1 ) ? thresh = 1;
          
          slider59 = thresh;
          slider_automate(slider59);
          forceUpdate = 1;                  
        ) : ( cap_mode == 0 ) ? (
          ( xx > x && yy > (y-8) && xx < (x+w) && yy < (y+h) && lastRight == 0 ) ? (
            cap_mode = 5;
          )
        )
      ) : ( left ) ?
      (
        ( cap_mode == 0 ) ? 
        (
          ( xx > x && yy > (y-8) && xx < (x+w) && yy < (y+h) && lastleft == 0 ) ?
          (
            ( yy > (yref - sc*thresh - 8) ) && ( yy < (yref - sc*thresh + 8) ) ?
            (
              cap_mode = 2;
            ) : (
              cap_mode = 1;
            );
          );
        ) : ( cap_mode == 1 ) ? (
          sc += 15 * dy;
         ( sc < 100 ) ? sc = 100;
         ( sc > 5000 ) ? sc = 5000;
        ) : (
          thresh += dy/h/(sc/h);
          ( thresh < 0 ) ? thresh = 0;
          ( thresh > h/sc ) ? thresh = h/sc;
          ( thresh > 1 ) ? thresh = 1;        
          slider59 = thresh;
          slider_automate(slider59);
          forceUpdate = 1;
        );
      ) : (
        cap_mode = 0;
        ( xx > x && yy > 0 && xx < (x+w) && yy < (y+h) ) ?
        (
          ( yy > (yref - sc*thresh-10) ) && ( yy < (yref - sc*thresh+10) ) ?
          (
            highlight = 1;
          );
          
          htime = updateHintTime(hint, 0);
        );
      );
    );
    
    lastleft = left;
    lastright = right;
    thresh
  );  

function initRMS(N, loc_in)
  local()
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    sc      = 1.0/N;
    ptr     = loc_in;
    loc     = loc_in;
    loc_end = loc_in + N;
    
    loop(N+1,
     ptr[]  = 0;
     ptr   += 1; 
    );
    
    ptr = loc_in;
    movavg  = 0;
  );

function updateRMS(sr, sl)
  local( M )
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    M       = max(sr*sr, sl*sl);
    M       = sc * min(M, 2.4);
    
    movAvg -= ptr[];
    movAvg  = 0.999999999*movAvg; // Very simple DC corr (dissipate energy)
    ptr[]   = M;
    movAvg += M;
    
    ptr    += 1;
    ptr > loc_end ? ptr = loc;
        
    movAvg
  );
  
function updateIntegrationTime()
  (
    integrationTime = ( 1 + 7*rms_x4_1.active ) * ( 1 + 3*rms_x4_2.active ) * slider64;
    ( (lastIntegrationTime != integrationTime) || (slider35 & 1 != lookAhead) ) ? 
    (
      lastIntegrationTime = integrationTime;      
      lookAhead           = slider35 & 1;
    
      ndelay = ceil(srate*lastIntegrationTime/1000);
      RMS1.initRMS(ndelay, 100000);
      RMS2.initRMS(ndelay, 200000);

      ndelay = ndelay * 0.5;
      preBufferL.initBuffer(300000, 300000 + ndelay);
      preBufferR.initBuffer(400000, 400000 + ndelay);
      preBufferMod.initBuffer(1600000, 1600000 + ndelay);
      
      lookAhead ? (
        // delays the first two channels (spl0/spl1).
        lookAheadDelay = ndelay;
      ) : ( 
        lookAheadDelay = 0;
      );
    );
  );
  
//////////////////////////////////////////////////////////  
// Spectrum code
//////////////////////////////////////////////////////////
function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );
  
function feedSampleLP(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, last)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );  
  
function impulse()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, last)
  local()
  (
    recPtr = rStart;
    memset(recPtr, 0, fftSize);
  );
  
function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 

function prepareBuffer(mul)
  local(buf1, buf2, buf3)
  global(fftSize)
  instance(recPtr, rStart, rEnd, window, fftLoc)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize/2 + 1,
      buf3[] = mul*buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize/2 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
  );

function calcFFT(mul)
  global(fftSize)
  instance(window, rStart, fftLoc, slope, yshift)
  local(buf3, yOut, i, prec, ty)
  (
    this.prepareBuffer(mul);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

function calcIncrementalFFT()
  global(fftSize)
  instance(fftLoc, mxpos, lastpeak)
  local(mx, buf3, yOut, i, ty, buf4, buf5, mf, c, x0, y1, y2, y3, mxtmp, sum, N_use, peak, tpeak)
  (
    this.prepareBuffer(1);
    
    i       = 16; // Implicit HP by starting at a specific freq bin
    yOut    = fftLoc + i;
    buf3    = fftLoc + 2*i;
    buf4    = fftLoc + 4*i;
    buf5    = fftLoc + 6*i;
    mx      = -1000000000000000000000000000;
    mxtmp   = 0;
    mf      = 1;
    sum     = 0;
    N_use   = fftSize/32;
    loop(N_use,   
      peak    = (sqr(buf3[])+sqr(buf3[1]));
      ty      =  peak * (sqrt(sqr(buf4[])+sqr(buf4[1])));
      ty      *= sqrt(sqr(buf5[])+sqr(buf5[1]));
      ty      *= mf;

      ty > mx ? (
        mx     = ty;
        mxtmp  = i;
        tpeak  = peak;
      );
      
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;
      buf4    += 4;
      buf5    += 6;
      
      i += 1;
      mf = mf * .9;
      sum     += ty;
    );
    
    // Interpolate to find the peak
    buf3  = fftLoc;
    buf3  += mxtmp*2-2;
    y1    = sqr(buf3[])+sqr(buf3[1]); buf3 += 2;
    y2    = sqr(buf3[])+sqr(buf3[1]); buf3 += 2;
    y3    = sqr(buf3[])+sqr(buf3[1]); 
    
    c     = (y1-y2) / (y2-y3);
    x0    = ( 1.0 + c*( 1.0 - 4.0 ) )  /  (2.0*( 1.0 + c - c*2.0 ));
    
    x0 > 0 && x0 < 2 ?
      mxtmp = mxtmp - 1 + x0;
    
    // Some gating
    lastpeak = 0.95 * lastpeak;
    tpeak > .2 * lastpeak ? (
      lastpeak = tpeak;
      mxpos = mxtmp;
    );
  );  
  
function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    //cap = 0;
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

function drawGrid()  
  global(   fftSize, srate, gfx_x, gfx_y,
            grid_color_r, grid_color_g, grid_color_b, grid_color_a, 
            backface_color_r, backface_color_g, backface_color_b, backface_color_a,
            font_color_r, font_color_g, font_color_b, font_color_a,
            label_color_r, label_color_g, label_color_b, label_color_a )
  instance(x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset )
  local(xx, i, wsc, N, xl)
  (    
    i = 0;

    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);

    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    
    i = 0;
    wsc = w/log(1+fftSize*0.5-hzoffset);
    xl = x;
    gfx_y = y+h+2;
    
    gfx_setfont(1);
    loop(16,
      xx = x + log(1+i*fftSize/srate-hzoffset)*wsc;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(xx, y, xx, y+h);
      
      ( (xx - xl) > 30 ) ? (
        gfx_set( label_color_r, label_color_g, label_color_b, label_color_a );
        gfx_x = xx+2;
        gfx_line(xx, y+h, xx, y+h+7);
        (i>999) ? (
          gfx_printf("%dk", .001*i);
        ) : (
          gfx_printf("%d", i);
        );
        xl = xx;
      );
      
      ( i < 100 ) ? (i += 20) :
      ( i < 1000 ) ? (i += 200) :
      ( i < 10000 ) ? (i += 2000) :
      ( i < 100000 ) ? (i += 20000);
    );
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    N = 8;
    xx = y;
    i = 0;
    gfx_measurestr("8", wsc, xl);
    loop(N,
      gfx_set( label_color_r, label_color_g, label_color_b, label_color_a );
      gfx_x = x+w-20;
      gfx_y = xx-.5*xl;
      i > 0 ? gfx_printf("-%d", 4.41*i*floorLevel/N);
      
      xx += h/N;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(x, xx, x+w, xx);
      i += 1;
    );
  );
  
function drawLine(x1, y1, x2, y2)
  local(dx, dy, x, smooth)
  global(gfx_x, gfx_y)
  instance()
  (
    smooth = 1;
    x1 = floor(x1);
    x2 = floor(x2);
    gfx_x=x1;
    gfx_y=y1;
    x2 = floor(x2);
    y2 = floor(y2);
    
    smooth ? (
      (x2 - x1) > 4 ? (
        dx = 1.0/(x2-x1);
        dy = (y2 - y1)*6*dx;
        x = 0;
        loop(x2-x1,
          x2 = x1 + 1;
          y2 = y1 + dy * ( x - x*x );
          
          gfx_line(x1, y1-1, x2, y2-1, 1);
          gfx_lineto(x2,y2,1);
          x1 = x2;
          y1 = y2;
          x = x + dx;
        );
      ) : (
        gfx_line(x1, y1-1, x2, y2-1, 1);
        gfx_lineto(x2,y2,1);
      );
    ) : (
      gfx_line(x1, y1-1, x2, y2-1, 1);
      gfx_lineto(x2,y2,1); 
    );
  );

function fftWindow_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, ly, lcap, cap, thisUI, htime, hint)
  global(dnoisefloor_freq, dsteps_fft, mouse_wheel, lastUI)
  local(over)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dnoisefloor_freq -= .5*(mouse_y-ly);
      dnoisefloor_freq > 35 ? dnoisefloor_freq = 35;
      dnoisefloor_freq < -15 ? dnoisefloor_freq = -15;
    ) : ( 
      cap = 0;
      ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
        cap = 1;
      );
    );
    
    mouse_wheel > 0 && over ? lastUI = thisUI;
    
    abs(floor(mouse_wheel/240)) > 0 && over ?
    (
      dsteps_fft += floor(mouse_wheel/240);
      dsteps_fft > 8 ? dsteps_fft = 8;
      dsteps_fft < -4 ? dsteps_fft = -4;
      mouse_wheel = 0;
    );
    
    ly = mouse_y;
    lcap = mouse_cap;
    
    over ? htime = updateHintTime(hint, 0);
    
    over
  );

function drawFFT(fill, oversamplingFactor, mul)
  global(retina_scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate, gfx_mode,
    fft_out_r, fft_out_g, fft_out_b, fft_out_a,
    fft_in_r, fft_in_g, fft_in_b, fft_in_a, dsteps_fft,
    fft_filt_r, fft_filt_g, fft_filt_b, fft_filt_a,
    fft_filt2_r, fft_filt2_g, fft_filt2_b, fft_filt2_a,
    pitchFFT.mxpos, currentPeakHzEstimate,
    highlight_r, highlight_g, highlight_b, highlight_a
  )
  instance(hstep, x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset, highlighted)
  local(copyval, stepsize, buf, i, ixsc, txl, tx, ty, wsc, fill, tx0, lx0, lx, ly, ty2, ly2, fill_slast, fill_slmin, cum, cumelem)
  (
    this.calcFFT(mul);
    //this.calcIncrementalFFT();
 
    cum = -10000000;
    cumelem = 0;
    i = 0;
    ixsc = 0;
    wsc = w/log(1+fftsize*0.5-hzoffset);
    fill_slmin = y;

    buf = fftLoc + fftsize*0.5 - 2;
    stepsize = floor((4+dsteps_fft)*retina_scaling);
    copyval = buf[];
    loop( stepsize*200,
      (buf+=1)[] = copyval;
    );
    
    gfx_set( .4, .4, .8, .1 );
    //gfx_x = x; gfx_y = y;
    //gfx_printf("%f", currentPeakHzEstimate);
    tx = floor(x + log(1.0+pitchFFT.mxpos-hzoffset)*wsc);
    drawLine(tx, y, tx, y+h);
    
    hstep = .5 * stepsize;
    buf = fftLoc; // +.5*((7+dsteps_fft)) ;
    txl = x;
    lx = x;
    ly = y - max(buf[], -floorLevel)*h / floorLevel;
    buf += 1;
    loop(fftsize*0.5+stepsize*200,
      tx = floor(x + log(1.0+ixsc-hzoffset)*wsc);
      cum = max(cum, buf[]);
      cumelem += 1;
      
      ( (tx != txl) && (tx-txl > stepsize) && tx > x && i && ( tx < (x+w+stepsize) ) ) ? // 
      ( 
        ty = y - max(cum, -floorLevel)*h / floorLevel;
        //ty = y - log(cum)+100;
        txl = floor(tx);
        
        fill == 1 ? (
          gfx_r=fft_in_r;
          gfx_g=fft_in_g;
          gfx_b=fft_in_b;
          gfx_a=fft_in_a;
        ) : ( fill == 3 ) ? (
          gfx_r=fft_filt_r;
          gfx_g=fft_filt_g;
          gfx_b=fft_filt_b;
          gfx_a=fft_filt_a;
        ) : (
          gfx_r=fft_filt2_r;
          gfx_g=fft_filt2_g;
          gfx_b=fft_filt2_b;
          gfx_a=fft_filt2_a;
        );
        
        tx = min(tx, x+w);
        (fill) ? 
        (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0 ? 
          (
            gfx_triangle(lx0-hstep,max(y+h,ly),lx0-hstep,ly,tx0-1-hstep,ty,tx0-1-hstep,max(y+h,ty));
          ) : (
            tx0 > fill_slast ? 
            (
              fill_slast < h ? gfx_line(fill_slast,h,fill_slast,fill_slmin);
              fill_slmin=h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          
          fill_slast=tx0;        
        );
          
        (fill==0) ? (
          gfx_set( fft_out_r, fft_out_g, fft_out_b, fft_out_a );
          drawLine(lx-hstep, ly, tx-hstep, ty);
        ) : ( fill==3 ) ? (
          gfx_set( fft_filt_r*2, fft_filt_g*2, fft_filt_b*2, fft_filt_a );
          drawLine(lx-hstep, ly, tx-hstep, ty);
        ) : ( fill==2 ) ? (
          gfx_set( fft_filt2_r*2, fft_filt2_g*2, fft_filt2_b*2, fft_filt2_a );
          drawLine(lx-hstep, ly, tx-hstep, ty);
        );
        lx=tx; ly=ty; ly2=ty2; cum = -1000000; cumelem = 0;
      );
      
      buf+=1; i+=1; ixsc+=oversamplingFactor;
    );
    
    (highlighted > 0) ? (
      gfx_set( highlight_r, highlight_g, highlight_b, highlight_a * highlighted );
      gfx_mode = 1;
      gfx_rect( x-8, y-8, w+16, h+16 );
      gfx_mode = 0;
    );
  );
  
function drawLineFFT(peakLocation, filtidx)
  global(retina_scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate,
    fft_out_r, fft_out_g, fft_out_b, fft_out_a,
    fft_in_r, fft_in_g, fft_in_b, fft_in_a, dsteps_fft,
    fft_filt_r, fft_filt_g, fft_filt_b, fft_filt_a,
    fft_filt2_r, fft_filt2_g, fft_filt2_b, fft_filt2_a,
  )
  instance(x, y, w, h, hzoffset)
  local(wsc, tx, base, i)
  (
    wsc = w/log(1+fftSize*0.5-hzoffset);
    base = fftSize*peakLocation;
    tx = floor(x + log(1.0+base-hzoffset)*wsc);
    
    ( filtidx == 1 ) ? (
      gfx_r=fft_filt_r+.1;
      gfx_g=fft_filt_g+.1;
      gfx_b=fft_filt_b+.1;
      gfx_a=.9;
    ) : (
      gfx_r=fft_filt2_r+.1;
      gfx_g=fft_filt2_g+.1;
      gfx_b=fft_filt2_b+.1;
      gfx_a=.9;
    );
    
    drawLine(tx, y, tx, y+h);
    
    i = 1;
    while( tx < x+w*.92 ) (
      tx = floor(x + log(1.0+i*base-hzoffset)*wsc);
      i = i * 2;
      drawLine(tx, y, tx, y+h);
      gfx_a *= .7;
    );
  );
  
function initSpectrum(memoryOffset)
  global(fftSize, srate, newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 20*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );
  
function initGonioMeter(in, sampleCount)
  global(sampleCount, srate, newUI)
  instance(rStart, rEnd, recPtr, samples, thisUI)
  local()
  (
    samples = sampleCount;
    rStart = in;
    rEnd = in + sampleCount - 1;
    recPtr = in;
    thisUI = newUI+=1;
  );    
 
function feedGonio(l1, r1)
  global()
  instance(rStart, rEnd, recPtr)
  local()
  (
    recPtr[] = l1;
    (recPtr+=1)[] = r1;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );
  
function drawGonioWindow(recPtr)  
  global( grid_color_r, grid_color_g, grid_color_b, grid_color_a, 
          backface_color_r, backface_color_g, backface_color_b, backface_color_a )
  instance(x, y, w, h)
  local()
  (    
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);

    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
  );
  
function drawGonioTop()
  global( gonio_axis_r, gonio_axis_g, gonio_axis_b, gonio_axis_a, gfx_x, gfx_y, fontface, widgetFontSize, retina_scaling )
  instance(x, y, w, h, fw, fh)
  local(r)
  (
    r = .25;
    gfx_set(gonio_axis_r, gonio_axis_g, gonio_axis_b, gonio_axis_a);
    gfx_line( x-r*w+.5*w, y-r*w+.5*h+2, x+r*w+.5*w, y+r*w+.5*h+2 );
    gfx_line( x-r*w+.5*w, y+r*w+.5*h+2, x+r*w+.5*w, y-r*w+.5*h+2 );

    gfx_setfont(9, fontface, 14*retina_scaling);
        
    r = .29;
    gfx_measurestr("L", fw, fh);
    gfx_x = x-r*w+.5*w - .5*fw;
    gfx_y = y-r*w+.5*h+2 - .5*fh;
    gfx_printf( "L" ); 
    
    gfx_measurestr("R", fw, fh);
    gfx_x = x+r*w+.5*w - .5*fw;
    gfx_y = y-r*w+.5*h+2 - .5*fh;
    gfx_printf( "R" );
    
    gfx_measurestr("R", fw, fh);
    gfx_x = x + 10;
    gfx_y = y + .5*h - .5*fh;
    gfx_printf( "+S" ); 
    
    gfx_measurestr("R", fw, fh);
    gfx_x = x + w - 10 - fw;
    gfx_y = y + .5*h - .5*fh;
    gfx_printf( "-S" );
    
    gfx_measurestr("M", fw, fh);
    gfx_x = x + .5*w - .5*fw;
    gfx_y = y + 5;
    gfx_printf( "M" );
  );

function gonio_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, ly, lcap, cap)
  local(over)
  global(dgonio_zoom)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dgonio_zoom -= .03*(mouse_y-ly);
      dgonio_zoom < -.9 ? dgonio_zoom = -.9;
      dgonio_zoom > 9   ? dgonio_zoom = 9;
    ) : ( 
      cap = 0;
      ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
        cap = 1;
      );
    );
  
    ly = mouse_y;
    lcap = mouse_cap;
    
    over
  );  
  
function drawGonioMeter(cl)
  global( gonio_out_r, gonio_out_g, gonio_out_b, gonio_out_a, 
          gonio_in_r, gonio_in_g, gonio_in_b, gonio_in_a, dgonio_zoom, gfx_a )
  local(step, ptr, sign0, sign1, s0, s1, angle, vert, horiz, radius, xx, yy, cx, cy)
  instance(x, y, w, h, recPtr, rStart, rEnd, samples)
  (
    ptr = recPtr+2;
    
    cx = x + 0.5*w;
    cy = y + 0.5*h;    
    
    cl == 1 ? gfx_set( gonio_out_r, gonio_out_g, gonio_out_b, gonio_out_a ) : gfx_set( gonio_in_r, gonio_in_g, gonio_in_b, gonio_in_a );

    loop(samples,
      s0 = ptr[];
      s1 = (ptr+=1)[];
      sign0 = sign( s0 );
      sign1 = sign( s1 );
      angle = atan( s0 / s1 );
      (sign0 == 1 && sign1 == -1) || (sign0 == -1 && sign1 == -1) ? angle += 3.141592654;
      (sign0 == -1 && sign1 == 1) ? angle += 6.283185307;
      s1 == 0 ? s0 > 0 ? angle = 1.570796327 : angle = 4.71238898;
      s0 == 0 ? s1 > 0 ? angle = 0 : angle = 3.141592654;
      radius = (1+dgonio_zoom) * sqrt( sqr(s0)+sqr(s1) ) ;
      radius > 1 ? radius = 1;
      angle -= .25*$pi;
      xx = cx - .5*h*sin(angle)*radius;
      yy = cy - .5*h*cos(angle)*radius;
      gfx_a = .5 * gonio_out_a; 
      gfx_circle(xx, yy, 1.5, 1);
      gfx_a = gonio_out_a;
      gfx_circle(xx, yy, 1, 1);
      
      ptr += 1;
      ptr > rEnd ? ptr = rStart;
    );
  );  
    
function importNodes(s1x, s2x, s1y, s2y, gfx)
  local(setter)
  (
    setter = s2x;
    setter[] = 0; setter += 1;
    setter[] = slider3; setter += 1;
    setter[] = slider5; setter += 1;
    setter[] = slider7; setter += 1;
    setter[] = slider9; setter += 1;
    setter[] = slider11; setter += 1;
    setter[] = slider13; setter += 1;
    setter[] = slider15; setter += 1;
    setter[] = 1; setter += 1;
    setter[] = 1; setter += 1;
    
    setter = s2y;
    setter[] = 0; setter += 1;
    setter[] = slider4; setter += 1;
    setter[] = slider6; setter += 1;
    setter[] = slider8; setter += 1;
    setter[] = slider10; setter += 1;
    setter[] = slider12; setter += 1;
    setter[] = slider14; setter += 1;
    setter[] = slider16; setter += 1;
    setter[] = slider18; setter += 1;
    setter[] = 1; setter += 1;
    
    setter = s1x;
    setter[] = 0; setter += 1;
    setter[] = slider19; setter += 1;
    setter[] = slider21; setter += 1;
    setter[] = slider23; setter += 1;
    setter[] = slider25; setter += 1;
    setter[] = slider27; setter += 1;
    setter[] = slider29; setter += 1;
    setter[] = abs(slider31); setter += 1;
    setter[] = 1; setter += 1;
    setter[] = 1; setter += 1;
    
    setter = s1y;
    setter[] = 0; setter += 1;
    setter[] = slider20; setter += 1;
    setter[] = slider22; setter += 1;
    setter[] = slider24; setter += 1;
    setter[] = slider26; setter += 1;
    setter[] = slider28; setter += 1;
    setter[] = slider30; setter += 1;
    setter[] = abs(slider32); setter += 1;
    setter[] = abs(slider34); setter += 1;  
    setter[] = 1; setter += 1;
    
    gfx ? (
      window1.spline.N_gfx = slider1;
      window2.spline.N_gfx = slider2;
    ) : (
      window1.spline.N_audio = slider1;
      window2.spline.N_audio = slider2;
    );
    
    s1x[slider1-1] = 1;
    s2x[slider2-1] = 1;
  );
  
function updateNodeCount()
  instance(nodes, memory)  
  local(xptr, tmp, tv)
  global()
  (
    tmp = 2;
    xptr = memory+2;
    tv = xptr[];
    while( tv > 0 )
    (
      xptr += 2;
      tmp += 1;
      tv = xptr[];
    );
    
    nodes = tmp;
  );
  
function updateNodeCount2()
  instance(nodes, memory)  
  local(xptr, tmp, tv)
  global()
  (
    tmp = 2;
    xptr = memory+2;
    tv = xptr[];
    while( tv < 1 )
    (
      xptr += 2;
      tmp += 1;
      tv = xptr[];
    );
    
    nodes = tmp+1;
  );  
   
function bsort()
  instance(nodes, memory, curveMemory, grabbed)  
  local(xptr, xptr2, tmpx, tmpy, tmpc, cur, next, i)
  global()
  (
    this.updateNodeCount();
  
    loop(nodes-2,
      xptr = memory;
      xptr2 = curveMemory;
      i = 1;
      loop(nodes-2,
        cur  = xptr[];
        next = xptr[2];
        ( cur > next ) ? (
          tmpx = cur;
          tmpc = xptr2[];
          tmpy = xptr[1];
          xptr[]  = next;
          xptr[1] = xptr[3];
          xptr[2] = tmpx;
          xptr[3] = tmpy;
          xptr2[] = xptr2[1];
          xptr2[1] = tmpc;
          
          ( grabbed == i ) ? ( 
            grabbed += 1;
          ) : ( grabbed == (i+1) ) ? (
            grabbed -= 1 ;
          );
        );
        
        xptr += 2;
        xptr2 += 1;
        i += 1;
      );
    );
    
    this.updateNodeCount2();
  );      
  
function removeDuplicates()
  instance(nodes, memory, curveMemory, grabbed)  
  local(xptr, xptr2, tmpx, tmpy, tmpc, cur, next, i)
  global()
  (
    xptr = memory;
    xptr2 = curveMemory;
  
    loop(nodes-2,
      cur  = xptr[];
      next = xptr[2];
      ( cur == next ) ? (
        xptr[] = 1;
      );

      xptr += 2;
      i += 1;
    );
  );  
  
function updateEnvRate()
  instance(invsrate, ispeed)
  global(srate, tempo)
  local()
  (
    invsrate = tempo/(srate*ispeed*60*4);
  );
 
function envelopeTempo(cTime)
  instance( cRate, tempoLabel )
  local()
  global()
  (
  ( cTime < 0.0416667 ) ?
  (
    tempoLabel = "1/16";
    cRate = 0.0625;
  ) : ( cTime < 0.0833333 ) ?
  (
    tempoLabel = "1/12";
    cRate = 0.0833333;
  ) : ( cTime < 0.125 ) ?
  (
    tempoLabel = "1/8";
    cRate = 0.125;
  ) : ( cTime < 0.166667 ) ?
  (
    tempoLabel = "1/6";
    cRate = 0.166667;
  ) : ( cTime < 0.208333 ) ?
  (
    tempoLabel = "1/5";
    cRate = 0.2;
  ) : ( cTime < 0.25 ) ?
  (
    tempoLabel = "1/4";
    cRate = 0.25;
  ) : ( cTime < 0.291667 ) ?
  (
    tempoLabel = "1/3";
    cRate = 0.333333;
  ) : ( cTime < 0.333333 ) ?
  (
    tempoLabel = "1/2";
    cRate = 0.5;
  ) : ( cTime < 0.375 ) ?
  (
    tempoLabel = "1";
    cRate = 1;
  ) : ( cTime < 0.416667 ) ?
  (
    tempoLabel = "2";
    cRate = 2;
  ) : ( cTime < 0.458333 ) ?
  (
    tempoLabel = "3";
    cRate = 3;
  ) : ( cTime < 0.5 ) ?
  (
    tempoLabel = "4";
    cRate = 4;
  ) : ( cTime < 0.541667 ) ?
  (
    tempoLabel = "6";
    cRate = 6;
  ) : ( cTime < 0.583333 ) ?
  (
    tempoLabel = "7";
    cRate = 7;
  ) : ( cTime < 0.625 ) ?
  (
    tempoLabel = "8";
    cRate = 8;
  ) : ( cTime < 0.666667 ) ?
  (
    tempoLabel = "12";
    cRate = 12;
  ) : ( cTime < 0.708333 ) ?
  (
    tempoLabel = "16";
    cRate = 16;
  ) : ( cTime < 0.75 ) ?
  (
    tempoLabel = "24";
    cRate = 24;
  ) : ( cTime < 0.791667 ) ?
  (
    tempoLabel = "32";
    cRate = 32;
  ) : ( cTime < 0.833333 ) ?
  (
    tempoLabel = "64";
    cRate = 64;
  ) : ( cTime < 0.875 ) ?
  (
    tempoLabel = "128";
    cRate = 128;
  ) : ( cTime < 0.916667 ) ?
  (
    tempoLabel = "256";
    cRate = 256;
  ) : ( cTime < 0.958333 ) ?
  (
    tempoLabel = "512";
    cRate = 512;
  ) : ( cTime < 1 ) ?
  (
    tempoLabel = "1024";
    cRate = 1024;
  )
); 
 
function updateEnvelopeSpeed() 
  instance( ispeed, cRate, tempoLabel, speedSlider )
  global()
  local()
  (
    this.envelopeTempo(speedSlider.value);
    speedSlider.overrideunit = tempoLabel;
    speedSlider.overrideValue = -2000;
    ispeed = cRate;
    this.updateEnvRate();
  ); 
 
function updateToggles()
  instance(soften, midiTrigger, midiVel, aLoop, snap, softening, triggering, useVelocities, snapping, autoloop, bidi, bidiLoop)
  global()
  local()
  (
    !softening      ? ( softening = 1;      soften.active = 1; );
    !triggering     ? ( triggering = 1;     midiTrigger.active = 1; );
    !useVelocities  ? ( useVelocities = 1;  midiVel.active = 1; );
    !snapping       ? ( snapping = 2;       snap.active == 0; );
    !autoloop       ? ( autoloop = 2;       aLoop.active = 0; );
    
    bidi            ? bidiLoop.active = 1 : bidiLoop.active = 0;
    
    soften.active == 1      ? softening = 1 : softening = 2;
    midiTrigger.active == 1 ? triggering = 1 : triggering = 2;
    midiVel.active == 1     ? useVelocities = 1 : useVelocities = 2;
    snap.active == 1        ? snapping = 1 : snapping = 0;
    aLoop.active == 1       ? autoloop = 1 : autoloop = 2;
  ); 
 
function resetEnvelopeCurve()
  instance(memory, curveMemory, speedSlider, loopStart, loopEnd, loopType, division, zoom, offset)
  global()
  local(xptr, xptr2)
  (
    xptr = memory;
    xptr2 = curveMemory;
      
    speedSlider.value = .36;
    loopStart = 0.4;
    loopEnd = 0.5;
    loopType = 0;
    division = 1;
    zoom = 1;
    offset = 0;
      
    // Nullify
    memset(memory,0,5000);
    memset(curveMemory,0,5000);  
    
    xptr[] = 0.1; // t = .1,  y = 1
    xptr2[] = 0;
    xptr += 1; xptr[] = 1;
    xptr += 1; xptr[] = 0.2; // t = 0.2, y = 0.5
    xptr2 += 1; xptr2[] = 0;
    xptr += 1; xptr[] = 0.5;
    xptr += 1; xptr[] = 0.3; // t = 0.3, y = 0.4
    xptr2 += 1; xptr2[] = 0;
    xptr += 1; xptr[] = 0.4;      
    xptr += 1; xptr[] = 0.6; // t = 0.6, y = 0.4
    xptr2 += 1; xptr2[] = 0;
    xptr += 1; xptr[] = 0.4;            
    xptr += 1; xptr[] = 1;   // t = 1.0, y = 1.0
    xptr2 += 1; xptr2[] = 0;
    xptr += 1; xptr[] = 0;
      
    this.updateNodeCount();
    this.bsort();
    this.resetEnvelope(1, 1);  
  ); 

function randomEnvelopeCurve()
  instance(memory, curveMemory, speedSlider, loopStart, loopEnd, loopType, division, zoom, offset, snap)
  global()
  local(xptr, xptr2, tmp, N)
  (
    xptr = memory - 1;
    xptr2 = curveMemory - 1;
      
    speedSlider.value = .36;
    loopStart = 0.4;
    loopEnd = 0.5;
    loopType = 0;
    division = 1;
    zoom = 1;
    offset = 0;
      
    // Nullify
    memset(memory,0,5000);
    memset(curveMemory,0,5000);
    
    !snap.active ? (
      loop(1+floor(100*rand()),
        xptr += 1; xptr[] = rand();
        xptr += 1; xptr[] = rand();
        xptr2 += 1; xptr2[] = floor(rand(3));
      );
      
      loopStart = rand()*.98+.01;
      loopEnd = rand()*.98+.01;
    ) : (
      N = pow(2, floor(rand()*3+2));
      loop(1+floor(2*N*rand()),
        xptr += 1; xptr[] = ceil(rand()*(N-2)+1)/N;
        xptr += 1; xptr[] = rand();
        xptr2 += 1; xptr2[] = floor(rand(3));
      );
      
      loopStart = floor(rand()*N)/N;
      loopEnd = floor(rand()*N);
    );
    
    speedSlider.value = rand()*.5+.1;;
    
    // Cap
    xptr += 1; xptr[] = 1;   // t = 1.0, y = 1.0
    xptr += 1; xptr[] = 0;

    loopStart > loopEnd ?
    (
      tmp = loopEnd;
      loopEnd = loopStart;
      loopStart = tmp;
    );
    
    division = 1;
    zoom = 1;
    offset = 0;
    
    this.updateNodeCount();
    this.bsort();
    // Remove duplicates
    snap.active ? (
      this.removeDuplicates();
      this.bsort();
    );
    this.resetEnvelope(1, 1);
  );  
 
function initEnvelope(x_in, y_in, w_in, h_in, envelopeMemory, typeMemory, nodes_in, title_in, in_wR, in_wG, in_wB, in_wA)
  global( newUI, srate, retina_scaling,
          selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a,
          widgetcolor_r, widgetcolor_g, widgetcolor_b, widgetcolor_a,)
  instance(memory, curveMemory, nodes, thisUI, x, y, w, h, h_graph, h_total, invsrate, cpos, loopStart, loopEnd, loopType, ispeed, division, title,
           speedSlider, offset, zoom,
           soften, midiTrigger, aLoop, midiVel, snap, clear, random, bidiLoop,
           softening, triggering, autoloop, useVelocities, snapping, wR, wG, wB, wA )
  local(xptr, bw, bh, cx)
  (
    wR = in_wR;
    wG = in_wG;
    wB = in_wB;
    wA = in_wA;
  
    cx = 0.12;
    x = x_in;
    y = y_in;
    w = w_in;
    h_total = h_in;
    h_graph = h_in * (1-cx);
    h = h_in*(.9-cx);
  
    bw = 16.5 * retina_scaling;
    bh = 12 * retina_scaling;

    soften.selectionButton(x+.5*bw, y-.5*bh, 2*bw, bh, "SOFT", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Soften envelope");
    midiTrigger.selectionButton(x+2.8*bw, y-.5*bh, 2*bw, bh, "TRIG", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Trigger on MIDI note");
    aLoop.selectionButton(x+5.1*bw, y-.5*bh, 2*bw, bh, "LOOP", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "When reaching loop, loop independent\nof whether MIDI note is still active");
    bidiLoop.selectionButton(x+7.4*bw, y-.5*bh, 2*bw, bh, "BIDI", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Loop bi-directionally");
    midiVel.selectionButton(x+9.7*bw, y-.5*bh, 2*bw, bh, "VEL", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Use MIDI Velocity");
    snap.selectionButton(x+12*bw, y-.5*bh, 2*bw, bh, "SNAP", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Snap to grid");
    clear.selectionButton(x+14.3*bw, y-.5*bh, 2*bw, bh, "RESET", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Clear envelope back to standard");
    random.selectionButton(x+16.6*bw, y-.5*bh, 2*bw, bh, "RAND", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Randomize envelope");
    
    soften.style = 2;
    midiTrigger.style = 2;
    midiVel.style = 2;
    snap.style = 2;
    clear.style = 2;
    random.style = 2;
    aloop.style = 2;
    bidiLoop.style = 2;
    this.updateToggles();
    
    speedSlider.sliderWidget(x+2, y + h_graph - .5*cx*h_in, .9*w, 2*cx*h_in, "", widgetcolor_r, widgetcolor_g, widgetcolor_b, widgetcolor_a, 0, 0, 1, .36, " ", 0, "Envelope length (measures)");
    speedSlider.yslidercenter = speedSlider.y + 0.5 * speedSlider.h;
    speedSlider.postMeter = x+w;
  
    !nodes  ? nodes = nodes_in;
    !thisUI ? (       
      title = title_in;
      memory = envelopeMemory;
      curveMemory = typeMemory;
      xptr = memory;
      thisUI = newUI+=1;
      
      speedSlider.value = .36;
      loopStart = 0.4;
      loopEnd = 0.5;
      loopType = 0;
      division = 1;
      zoom = 1;
      offset = 0;
      
      xptr[] = 0.1; // t = .1,  y = 1
      xptr += 1; xptr[] = 1;
      xptr += 1; xptr[] = 0.2; // t = 0.2, y = 0.5
      xptr += 1; xptr[] = 0.5;
      xptr += 1; xptr[] = 0.3; // t = 0.3, y = 0.4
      xptr += 1; xptr[] = 0.4;      
      xptr += 1; xptr[] = 0.6; // t = 0.6, y = 0.4
      xptr += 1; xptr[] = 0.4;            
      xptr += 1; xptr[] = 1;   // t = 1.0, y = 1.0
      xptr += 1; xptr[] = 0;
      
      this.updateNodeCount();
      this.bsort();
      this.resetEnvelope(1, 1);
    );
    
    this.updateEnvelopeSpeed();
  );  
  
// Clips line to X range  
function safeLine(x1, y1, x2, y2, xmin, xmax)
  local(w)
  global()
  instance()
  (
    ( (x2 > xmin) && (x1 < xmax) ) ? (
      w = xmax - xmin;
      x1 = x1 - xmin;
      x2 = x2 - xmin;
    
      x1 < 0 ? (
        y1 = y1 - ( ( y2 - y1 ) / ( x2 - x1 ) ) * x1;
        x1 = 0;
      );
      x2 > (xmax-xmin) ? (
        y2 = y2 - ( ( y2 - y1 ) / ( x2 - x1 ) ) * (x2-w);
        x2 = w;
      );
      
      gfx_line(xmin + x1, y1,     xmin+x2, y2);
      gfx_line(xmin + x1, y1 - 1, xmin+x2, y2-1);
    );
  );
  
function drawEnvelopeWindow()  
  global( grid_color_r, grid_color_g, grid_color_b, grid_color_a, 
          backface_color_r, backface_color_g, backface_color_b, backface_color_a,
          fontface, widgetFontSize, retina_scaling,
          font_color_r, font_color_g, font_color_b, font_color_a,
          highlight_r, highlight_g, highlight_b, highlight_a,
          gfx_x, gfx_y, gfx_mode, boldEdges )
  instance(x, y, w, h, h_graph, h_total, nodes, memory, curveMemory, curTime, loopStart, loopEnd, grabbed, over, title, division,
           x4_1, x4_2, x4_3, x4_4, x3_1, x3_2, x5, bw, bh, offset, zoom, speedSlider, wR, wG, wB, wA, 
           soften, midiTrigger, aLoop, midiVel, snap, highlighted,
           clear, random, hoveridx, hoverSize, bidiLoop )
  local(xptr, xptr2, ctype, tn, tnm1, yn, ynm1, dy, xs, ys, ym, siz, jnk, cuts, ymin, ymax, xc, dx, idx, idt, tc, t, t2, t3, y1, y2
        lps, lpe, xmax)
  (    
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h_graph);

    xs = w-4;
    ys = h-4;
    ym = y+h_graph-2;
    xmax = x + w;
    
    cuts = 1;
    division == 1 ? cuts = 16 + 16*floor(zoom/2) :
    division == 2 ? cuts = 9 + 9*floor(zoom/2);

    xc = x-xs*offset;
    dx = zoom*xs/cuts;
    gfx_set(1, 1, 1, .1);
    loop(cuts-1,
      xc += dx;
      (xc > x && xc < x+w) ? (      
        gfx_line(xc, y+1, xc, y+h_graph);
      );
    ); 
    
    gfx_set(1,1,1,1);
    xptr = memory;
    xptr2 = curveMemory;
    tnm1 = - w*offset;
    ynm1 = 0;
    
    (hoveridx > 0 && hoveridx < (nodes-1)) ? (
      gfx_circle(x+zoom*xptr[2*(hoveridx-1)]*xs - xs*offset, ym-xptr[2*(hoveridx-1)+1]*ys-1, hoverSize);
    );
    
    loop(nodes-1,
      tn = zoom*xptr[]*xs - xs*offset; xptr += 1;
      yn = xptr[]*ys; xptr += 1;
      ctype = xptr2[]; xptr2 += 1;
      
      (tn > 0) && (tnm1 < w) ? 
      (
        (ctype == 0) ?
        (
          tnm1 < 0 ? (
            ynm1 = ynm1 - ( ( yn - ynm1 ) / ( tn - tnm1 ) ) * tnm1;
            tnm1 = 0;
          );
          tn > w ? (
            yn = yn - ( ( yn - ynm1 ) / ( tn - tnm1 ) ) * (tn-w);
            tn = w;
          ) : gfx_circle(x+tn, ym-yn-1, 2);
          gfx_line(x+tnm1, ym-ynm1,   x+tn, ym-yn);
          gfx_line(x+tnm1, ym-ynm1-1, x+tn, ym-yn-1);
        ) : (ctype == 1) ? (
          // Smooth
          dy = (yn - ynm1);
          
          dx = 10;
          idt = 1 / dx;
          idx = (tn - tnm1) * idt;
          xc = x+tnm1;
          tc = t2 = t3 = 0;
          loop(dx, 
            y1 = ynm1+dy*(3*t2-2*t3);
            tc += idt;
            t2 = tc*tc;
            t3 = t2*tc;
            y2 = ynm1+dy*(3*t2-2*t3);
//            gfx_line(xc, ym-y1, xc+idx, ym-y2);
//            gfx_line(xc, ym-y1-1, xc+idx, ym-y2-1);
            safeLine(xc, ym-y1, xc+idx, ym-y2, x, xmax);
            xc += idx;
          );
          (x + tn) < xmax ? gfx_circle(x+tn, ym-yn-1, 2);
        ) : (ctype == 2) ? (
          // Exponential 1
          dy = (yn - ynm1);
          
          dx = 10;
          idt = 1 / dx;
          idx = (tn - tnm1) * idt;
          xc = x+tnm1;
          tc = t2 = t3 = 0;
          loop(dx, 
            y1 = ynm1+dy*(1-exp(-5*tc));
            tc += idt;
            y2 = ynm1+dy*(1-exp(-5*tc));
//            gfx_line(xc, ym-y1, xc+idx, ym-y2);
//            gfx_line(xc, ym-y1-1, xc+idx, ym-y2-1);
            safeLine(xc, ym-y1, xc+idx, ym-y2, x, xmax);
            xc += idx;
          );
          (x + tn) < xmax ? gfx_circle(x+tn, ym-yn-1, 2);
        ) : (
          // Exponential 2
          dy = (yn - ynm1);
          
          dx = 10;
          idt = 1 / dx;
          idx = (tn - tnm1) * idt;
          xc = x+tnm1;
          tc = t2 = t3 = 0;
          loop(dx, 
            y1 = ynm1+dy*tc*tc*tc;
            tc += idt;
            y2 = ynm1+dy*tc*tc*tc;
//            gfx_line(xc, ym-y1, xc+idx, ym-y2);
//            gfx_line(xc, ym-y1-1, xc+idx, ym-y2-1);
            safeLine(xc, ym-y1, xc+idx, ym-y2, x, xmax);
            xc += idx;
          );
          (x + tn) < xmax ? gfx_circle(x+tn, ym-yn-1, 2);
        );
      );
      
      tnm1 = tn;
      ynm1 = yn;
    );
    
    ymin = y+h_graph-h;
    ymax = y+h_graph;
    xc   = x+zoom*xs*curTime-xs*offset;
    ( xc > x && xc < x+w ) ? gfx_line( xc, ymin, xc, ymax );
    
    // Loop start
    lps = min(x+w-2, max(x+2, x+w*(zoom*loopStart-offset)));
    over == -2 ? ( 
      gfx_set(.5,.5, 1,.3);
      gfx_line( lps+1, ymin, lps+1, ymax );
      gfx_line( lps-1, ymin, lps-1, ymax );
      gfx_set(.7,.7, 1,.6);
      gfx_line( lps, ymin, lps, ymax );
    ) : ( 
      gfx_set(.7,.7, 1,.3);
      gfx_line( lps, ymin, lps, ymax );
    );
    
    // Loop end
    lpe = min(x+w-2, max(x+2, x+w*(zoom*loopEnd-offset)));
    over == -1 ? ( 
      gfx_set(.5,.5, 1,.3);
      gfx_line( lpe+1, ymin, lpe+1, ymax ); 
      gfx_line( lpe-1, ymin, lpe-1, ymax ); 
      gfx_set(.7,.7, 1,.6);
      gfx_line( lpe, ymin, lpe, ymax );
    ) : (
      gfx_set(.7,.7, 1,.3);
      gfx_line( lpe, ymin, lpe, ymax );
    );
    
    gfx_set(.7,.7,1,.1);
    gfx_rect( lps, ymin, lpe-lps, h );
    
    gfx_setfont(1, fontface, widgetFontSize*retina_scaling);    
    gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );
    gfx_measurestr(title, siz, jnk);
    gfx_x = x + w - siz - 10;
    gfx_y = y - .5*jnk + 1;
    gfx_printf(title);
    gfx_set( wR, wG, wB, .4 );
    gfx_line(x, y, x, y+h_total);
    gfx_line(x+1, y, x + w - siz - 13, y);
    gfx_line(x+w-8, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h_total);
    gfx_line(x+1, y+h_graph, x+w-1, y+h_graph);
    
    gfx_line(x+1, y+h_total, x+w, y+h_total);

    (highlighted > 0) ? (
      gfx_set( wR, wG, wB, .4 * highlighted );
      gfx_line(x, y-1, x + w - siz - 13, y-1);
      gfx_line(x-1, y, x-1, y+h_total);
      gfx_line(x+w+1, y, x+w+1, y+h_total);
      gfx_line(x+w-8, y-1, x+w, y-1);
      gfx_line(x, y+h_total+1, x+w, y+h_total+1);
      
      gfx_set( highlight_r, highlight_g, highlight_b, highlight_a * highlighted );
      gfx_mode = 1;
      gfx_rect( x-8, y-8, w+16, h_total+16 );
      gfx_mode = 0;
    );

    ( boldEdges == 1 ) ? (
      gfx_set( wR, wG, wB, wA );
      gfx_line(x, y-1, x + w - siz - 13, y-1);
      gfx_line(x-1, y, x-1, y+h_total);
      gfx_line(x+w+1, y, x+w+1, y+h_total);
      gfx_line(x+w-8, y-1, x+w, y-1);
      gfx_line(x, y+h_total+1, x+w, y+h_total+1);
    );

    speedSlider.sliderwidget_draw();
    soften.selectionButton_draw();
    midiTrigger.selectionButton_draw();
    midiVel.selectionButton_draw();
    snap.selectionButton_draw();
    clear.selectionButton_draw();
    random.selectionButton_draw();
    bidiLoop.selectionButton_draw();
    aLoop.selectionButton_draw();
  ); 
 
 
function envTrafoX(mx)
  instance(x, w, zoom, offset)
  local()
  global()
  (
    mx = (mx - x)/(w-4);
    mx = (mx + offset)/zoom;
    mx = max(0.000000001,min(1,mx))
  );
  
function envTrafoY(my)
  instance(y, h, h_graph)
  local(ym)
  global()
  (
    ym = y+h_graph-2;
    my = (ym - my)/(h-4);
    my = max(0,min(1,my))
  );  
  
function enviTrafoX(mx)
  instance(x, w, zoom, offset)
  local()
  global()
  (
    mx = mx*zoom - offset;
    mx = mx*(w-4)+x;
  );
  
function enviTrafoY(my)
  instance(y, h, h_graph)
  local(ym)
  global()
  (
    ym = y+h_graph-2;
    my = ym - my*(h-4)
  );   
 
envelopeDist = 0.15; 
 
function selectEnvelopePoint(ex, ey)
  instance(x, y, w, h, ar, nodes, memory, zoom)
  local(xptr, dx, dy, ndist, dist, i, cur)
  global(envelopeDist)
  (
    xptr = memory;
    dist = 10000000000000000;
    cur = 0;
    i = 0;
    ar = w/h;
    loop(nodes,
      i += 1;
      dx = (ex - xptr[])*zoom*ar;
      xptr += 1;
      dy = ey - xptr[];
      xptr += 1;
      
      ndist = sqrt(dx * dx + dy * dy);
      ( ndist < dist ) ?
      (
        dist = ndist;
        cur = i;
      );
    );
    
    (dist < envelopeDist) ? cur : -1;
  );
  
function selectEnvelopePointByX(ex)
  instance(x, y, w, h, nodes, memory, zoom)
  local(cpos, ct, cnode)
  global()
  (
    cpos = memory;
    ct = cpos[];
    cnode = 0;
    while( (ct < ex) && (cnode < nodes) )
    ( 
      cpos  += 2;
      cnode += 1;
      ct = cpos[];
    );    
    
    cnode
  );  
  
/*function moveEnvPt(idx, dx, dy)
  instance(x, y, w, h, nodes, memory)
  local(xptr, ym, dx, dy, ndist, dist, i, cur)
  (
    xptr = memory;
    xptr += 2*(idx-1);
    xptr[] = max(0, min(1, xptr[]+dx/w)); xptr += 1;
    xptr[] = max(0, min(1, xptr[]+dy/h));
  );*/
  
function setEnvPt(idx, ex, ey)
  instance(x, y, w, h, memory)
  local(xptr)
  global()
  (
    xptr = memory;
    xptr += 2*(idx-1);    
    
    xptr[] = ex; xptr += 1;
    xptr[] = ey;
    
    this.bsort();
  );  
  
function getEnvX(idx)
  instance(x, y, w, h, memory)
  local(xptr)
  global()
  (
    xptr = memory;
    xptr += 2*(idx-1);
    xptr[]
  );  
  
function getEnvY(idx)
  instance(x, y, w, h, memory)
  local(xptr)
  global()
  (
    xptr = memory;
    xptr += 2*(idx-1) + 1;
    xptr[]
  );  
 
  
function removeEnvelopePointsBetweenX(ex1, ex2)
  instance(x, y, w, h, nodes, memory, curveMemory, zoom)
  local(cpos, ct, cnode, endX, endY)
  global()
  (
    cpos = memory;
    ct = cpos[];
    cnode = 0;
    while( cnode < nodes )
    ( 
      ( (ct > ex1) && (ct < ex2) ) ? 
      (
        // ct contains current xpos
        // cpos[1] contains current ypos
        endX = memory[2*((nodes-1)-1)];
        endY = memory[2*((nodes-1)-1) + 1];
        
        // Replace the detected node with the node at the end.
        //curveMemory[cnode-2] = curveMemory[nodes-2];
        curveMemory[cnode] = curveMemory[nodes-2];
        cpos[] = endX;
        cpos[1] = endY;
        
        // Set node at the end to zero
        memory[2*((nodes-1)-1)] = 0;
        memory[2*((nodes-1)-1) + 1] = 0;
         
        // Reduce nodecount
        nodes -= 1;
      ) : (
        cpos  += 2;
        cnode += 1;
      );
      ct = cpos[];
    );    
    
    this.bsort();
  );   
 
N_CURVES = 3; 
 
function rotateCurves(cidx, my)
  instance(curveMemory, cy)
  local(chg)
  global(N_CURVES)
  (
    chg = .1*(cy - my);
    // Toggle curves
    (chg > 1) ?
    (
      curveMemory[cidx] += 1;
      cy = my;
    ) : (chg < -1) ? (
      curveMemory[cidx] -= 1;
      cy = my;
    );
    
    ( curveMemory[cidx] > N_CURVES ) ? curveMemory[cidx] = 0;
    ( curveMemory[cidx] < 0 ) ? curveMemory[cidx] = N_CURVES;  
  ); 
 
function processMouse()
  instance(x, y, w, h, h_graph, nodes, memory, curveMemory, grabbed, lastleft, lastright, lx, ly, loopStart, loopEnd, over, zoom, offset, 
           speedSlider, soften, midiTrigger, aLoop, midiVel, snap, snapping, division, lastLeftTime, cidx, cy, htime, clear, random, bidiLoop,
           hoveridx, hoverSize, bidi )
  local(left, right, xptr, ym, idx, mx, my, mc, ex, ey, endX, endY, newgrab, ymin, ymax, cuts, tx, tx2, now)
  global(retina_scaling, mouse_x, mouse_y, mouse_cap, mouse_wheel, gfx_x, gfx_y, dbl, N_CURVES)
  (
    mx = mouse_x;
    my = mouse_y;
    mc = mouse_cap;
    left = (mc & 1);
    right = (mc & 2);
    ymin = y+h_graph-h;
    ymax = y+h_graph;
    
    // Find nearest
    ( ( ( my > ymin ) && ( my < ymax ) && ( (mouse_cap & 4) == 0 ) ) || grabbed ) ? (
      ex = abs(mx - this.enviTrafoX(loopStart));
      ey = abs(mx - this.enviTrafoX(loopEnd));
      over = ex < ey ? -2 : -1;
    ) : over = 0;
    
    // If nearest is not close enough, reset selection
    min(ex,ey) > 10/zoom ? over = 0;
    
    // Check if we are close to an envelope
    ( mx > x && my > ymin && mx < (x+w) && my < ymax && ( (mouse_cap & 4) == 0 ) ) ?
    (
      idx = this.selectEnvelopePoint(this.envTrafoX(mx), this.envTrafoY(my));
      ( idx > 0 ) ? 
      (
        hoveridx = idx;
        hoverSize += .5 * (8*retina_scaling-hoverSize);
      ) : ( hoverSize = .75*hoverSize; );
    ) : ( hoverSize = .75*hoverSize; );
    
    time_precise(now);
    cuts = 1;
    division == 1 ? cuts = 16 + 16*floor(zoom/2) :
    division == 2 ? cuts = 9 + 9*floor(zoom/2);
    
    ( left > 0 ) ?
    (
      ( lastleft == 0 ) ? (
        ( mx > x && my > ymin && mx < (x+w) && my < ymax ) ?
        (
          idx = this.selectEnvelopePoint(this.envTrafoX(mx), this.envTrafoY(my));
          ( (idx > 0) && (idx < nodes-1) && ( (mouse_cap & 4) == 0 ) ) ? (
            grabbed = idx;
          ) : (
            grabbed = over;
            
            // Nothing grabbed?
            ( grabbed == 0 ) ? (
              (mouse_cap & 16) ? (
                (mouse_cap & 4) ? (
                  grabbed = -5;
                  cidx = this.selectEnvelopePointByX( this.envTrafoX(mx) );
                  cy = my;
                ) : (
                  grabbed = -4;
                  cidx = this.selectEnvelopePointByX( this.envTrafoX(mx) );
                  cy = my;
                );
              ) : ( (now - lastLeftTime) < .3 ) ? (
                // Double click? Change envelope shape
                idx = this.selectEnvelopePointByX( this.envTrafoX(mx) );
                curveMemory[idx] += 1;
                ( curveMemory[idx] > N_CURVES ) ? curveMemory[idx] = 0;
                
                // Control held, change all of them.
                (mouse_cap & 4) ? (
                  xptr = curveMemory;
                  loop(N_CURVES,
                    xptr[] = curveMemory[cidx];
                    xptr += 1;
                   );
                );
                
                dbl = idx;
              ) : ( mouse_cap & 4 ) ? (
                // Step sequencing
                grabbed = -10;
              ) : (
                // Or drag offset?
                grabbed = -3;
              );
            ) 
          );
          lastLeftTime = now;
        )
      ) : ( grabbed == -10 ) ? (
        // Step sequencer-style fill
        ex = this.envTrafoX(mx);
        ey = this.envTrafoY(my);
        tx = floor(ex * cuts) / cuts;
        tx2 = ceil(ex * cuts) / cuts;
        this.removeEnvelopePointsBetweenX(tx, tx2);

        curveMemory[nodes] = 0;
        this.setEnvPt(nodes, tx+0.0000001, ey);
        idx = this.selectEnvelopePoint(ex, ey);
        curveMemory[nodes] = 0;
        this.setEnvPt(nodes, tx2-0.0000001, ey);
        idx = this.selectEnvelopePoint(ex, ey);
      ) : ( grabbed > 0 ) ?
      (
        // Dragging a node
        ex = this.envTrafoX(mx);
        ey = this.envTrafoY(my);
        ( snapping == 1 ) ? (
          tx = floor(ex * cuts + .5) / cuts;

          (tx < ex) ? ex = tx - 0.0000001 : ex = tx + 0.0000001;
        );
        ex = min(max(0.001,ex),1-.001);
        this.setEnvPt( grabbed, ex, ey );
      ) : ( grabbed == -5 ) ? (
        // Changing all curve shapes
        this.rotateCurves(cidx, my);
        xptr = curveMemory;
        loop(N_CURVES,
          xptr[] = curveMemory[cidx];
          xptr += 1;
        );
      ) : ( grabbed == -4 ) ?
      (
        // Change one curve shape
        this.rotateCurves(cidx, my);
      ) : ( grabbed == -3 ) ? 
      (
        // Pan
        offset = min( zoom-1, max( 0, offset - this.envTrafoX(mx) + this.envTrafoX(lx) ) );
      ) : ( grabbed == -2 ) ?
      (
        // Move loop end
        ex = this.envTrafoX(mx);
        ( snapping == 1 ) ? ex = floor(ex * cuts + .5) / cuts;
        
        ex = min(ex, loopEnd - 0.01);
        loopStart = ex;
      ) : ( grabbed == -1 ) ?
      (
        // Move loop start
        ex = this.envTrafoX(mx);
        ( snapping == 1 ) ? ex = floor(ex * cuts + .5) / cuts;
        
        ex = max(ex, loopStart + 0.01);
        loopEnd = ex;
      );
    ) : (
      grabbed = 0;
    );
    
    ( right > 0 ) ?
    (
      ( lastright == 0 ) ? (
        ( mx > x && my > ymin && mx < (x+w) && my < ymax ) ?
        (
          endX = this.getEnvX(nodes-1);
          endY = this.getEnvY(nodes-1);
          ex = this.envTrafoX(mx);
          ey = this.envTrafoY(my);
          idx = this.selectEnvelopePoint(ex, ey);
          ( idx > 0 ) ? (
            // Remove node
            curveMemory[idx-1] = curveMemory[nodes-2];
            this.setEnvPt(idx, endX, endY);
            this.setEnvPt(nodes, 0, 0);
          ) : (
            // Add node
            ( snapping == 1 ) ? (
              tx = floor(ex * cuts + .5) / cuts;
              ex = tx < ex ? ex = tx - 0.000000001;
              ex = tx > ex ? ex = tx + 0.000000001;
            );
            this.setEnvPt(nodes, ex, ey);
            idx = this.selectEnvelopePoint(ex, ey);
            curveMemory[idx-1] = curveMemory[idx];
            curveMemory[idx] = 0;
          );
        );
      );
    );
    
    ( grabbed == 0 ) ? (
      speedSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);    
      soften.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
      midiTrigger.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
      midiVel.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
      snap.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
      aLoop.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
      bidiLoop.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( 
        bidi = bidiLoop.active;
      );
      
      clear.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? (
        this.resetEnvelopeCurve();
        clear.active = 0;
      );
      
      random.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? (
        this.randomEnvelopeCurve();
        random.active = 0;
      );
    );
    
    this.updateEnvelopeSpeed();
    this.updateToggles();
    
    ( abs(mouse_wheel) > 0 ) ? (
      ( mx > x && my > ymin && mx < (x+w) && my < ymax ) ?
      (
        zoom = max(1,zoom + .001*mouse_wheel);
        mouse_wheel = 0;
        offset = min( zoom-1, max( 0, offset - this.envTrafoX(mx) + this.envTrafoX(lx) ) );
      );
    );
    
    ( mx > x && my > ymin && mx < (x+w) && my < ymax ) ? htime = updateHintTime("Envelope\n\nRMB - Add/Delete node.\nLMB + Drag - Drag node.\nLMB + Drag - Scroll when zoomed\nScrollwheel - Zoom\nDoubleclick - Change envelope type.\nAlt + LMB + Drag - Change envelope type.\nCtrl + LMB + Drag - Enter values step sequencer style\n\nNote: The envelope loops in shaded area whose extremities can be dragged.", 0);
    
    lx = mx;
    ly = my;
    lastleft = left;
    lastright = right;
  );  

function calcEnvelope(t)
  global( grid_color_r, grid_color_g, grid_color_b, grid_color_a, 
          backface_color_r, backface_color_g, backface_color_b, backface_color_a )
  instance(memory, nodes)
  local(xptr, tn, tnm1, yn, ynm1, dy)
  (
    xptr = memory;
    loop(nodes,
      tn = xptr[];
      tn > t ? (
        xptr += 1;
        yn = xptr[];
        xptr -= 2;
        ynm1 = xptr[];
        xptr -= 1;
        tnm1 = xptr[];
      );
      xptr += 2;
    );
    
    // Lerp it baby
    dy = (yn - ynm1) / ( tn - tnm1 );
    ynm1 + dy * (t-tnm1);
  );

function evaluateEnvelope(notesOn)
  global(test, env_buf1)
  instance(autoloop, triggering, ret, curTime, invsrate, cpos, cpos2, memory, curveMemory, tn, tnm1, yn, ynm1, dy, invdx, cnode, nodes, loopStart, loopEnd, softening, smoothMem, useVelocities, curvel, curCurve, bidi)
  local(xptr,t2, t3, tmp)
  (
    //ret = this.calcEnvelope(curTime);
    ( cnode < nodes ) ? (
      ( bidi == 2 ) ? (
        /* Backwards movement */
        while( (curTime < tnm1) && (cnode > -2) )
        ( 
          tn        = cpos[2];
          yn        = cpos[3];
          tnm1      = cpos[];
          ynm1      = cpos[1];
          curCurve  = cpos2[];
          
          dy        = (yn - ynm1);
          invdx     =  1 / ( tn - tnm1 );
          curCurve == 0 ? dy *= invdx;
          
          cpos  -= 2;
          cpos2 -= 1;
          cnode -= 1;
        );
      ) : (
        /* Forward movement */
        while( (curTime > tn) && (cnode < nodes) )
        ( 
          tnm1      = cpos[];
          ynm1      = cpos[1];
          tn        = cpos[2];
          yn        = cpos[3];
          curCurve  = cpos2[];
          
          dy        = (yn - ynm1);
          invdx     =  1 / ( tn - tnm1 );
          curCurve == 0 ? dy *= invdx;
          
          cpos  += 2;
          cpos2 += 1;
          cnode += 1;
        );
      );     
      
      memory == env_buf1 ? test = curCurve;
      
      curCurve == 0 ? (
        ret = ynm1 + dy * (curTime-tnm1)
      ) : ( curCurve == 1 ) ? 
      ( 
        tmp = (curTime - tnm1)*invdx;
        t2  = tmp*tmp;
        t3  = tmp*t2;
        ret = ynm1+dy*(3*t2-2*t3);
      ) : ( curCurve == 2 ) ? 
      (
        tmp = (curTime - tnm1)*invdx;
        ret = ynm1+dy*(1-exp(-5*tmp))
      ) : ( curCurve == 3 ) ? 
      (
        tmp = (curTime - tnm1)*invdx;
        ret = ynm1+dy*tmp*tmp*tmp
      );
      
      ( useVelocities == 1 ) ? ret = curvel * ret;
      
      /* Handle looping */
      ( bidi > 0 ) ? (
        ( bidi == 1 ) ? (
          curTime = curTime + invsrate;
          ( (((triggering == 1) && notesOn) || (autoloop == 1)) && (curTime > loopEnd) ) ? (
            bidi = 2;
            
            tn        = cpos[2];
            yn        = cpos[3];
            tnm1      = cpos[];
            ynm1      = cpos[1];
            curCurve  = cpos2[];
            
            dy        = (yn - ynm1);
            invdx     =  1 / ( tn - tnm1 );
            curCurve == 0 ? dy *= invdx;
          );
        ) : (
          curTime = curTime - invsrate;
          ( (((triggering == 1) && notesOn) || (autoloop == 1)) && (curTime < loopStart) ) ? (
            bidi = 1;
            
            tnm1      = cpos[];
            ynm1      = cpos[1];
            tn        = cpos[2];
            yn        = cpos[3];
            curCurve  = cpos2[];
            
            dy        = (yn - ynm1);
            invdx     =  1 / ( tn - tnm1 );
            curCurve == 0 ? dy *= invdx;
          );
        );
      ) : (
        curTime = curTime + invsrate;
        ( (((triggering == 1) && notesOn) || (autoloop == 1)) && (curTime > loopEnd) ) ? (
          curTime = loopStart + (curTime - loopEnd); 
          cnode = 0; 
          cpos = memory; 
          cpos2 = curveMemory;
      
          tnm1      = 0;
          ynm1      = 0;
          
          tn        = cpos[];
          yn        = cpos[1];
      
          dy        = (yn - ynm1);
          invdx     =  1 / ( tn - tnm1 );
          curCurve  = cpos2[];
          curCurve == 0 ? dy *= invdx;
          cpos2 += 1;
        );
      );
      
      softening == 1 ? (
        smoothMem = smoothMem + .05 * ( ret - smoothMem );
      ) : (
        ret
      );
    ) : (
      softening == 1 ? (
        smoothMem = smoothMem - .05 * smoothMem;
      ) : (
        0
      );
    )
  );  

//////////////////////////////////////////////////////////
// Memory layout
//////////////////////////////////////////////////////////
//RMS1          = 100000;
//RMS2          = 200000;
//preBufferL    = 300000;
//preBufferR    = 400000;
bufferDist      = 65536;

delay_buf1      = 70 * 65536;
delay_buf2      = delay_buf1 + 500000;
delay_buf3      = delay_buf2 + 1000000;
delay_buf4      = delay_buf3 + 1500000;

sinc_tmp        = 900000;
sinc_flt        = 910000; // Upsample filters are spaced at 100 difference. There are N filters, with 8 taps per filter.
sinc_flt2       = 920000;
sinc_flt3       = 930000; // Downsamplers
sinc_flt4       = 940000;
sinc_hist1      = 950000; // Downsampler history
sinc_hist2      = 960000;

danger_list     = 960000-500; // List of dangerous filters
danger_list2    = 960000-100; // List of dangerous modes

note_mem        = 970000;
memset(note_mem, -1337, 10000);

cutoff_mem      = 1000000;
reso_mem        = 1100000;
cutoff_mem2     = 1200000;
reso_mem2       = 1300000;

memset(cutoff_mem,  -1337, 10000);
memset(reso_mem,    -1337, 10000);
memset(cutoff_mem2, -1337, 10000);
memset(reso_mem2,   -1337, 10000);

cutoff_buffer   = 1400000;
reso_buffer     = 1500000;
//mod_buffer    = 1600000
pitch_buffer1   = 1700000;
pitch_buffer2   = 1800000;

// Keep this stuff away from clobber risks (0)
splineOffset    = 2097152;
negative_xloc   = 100 + splineOffset;
negative_yloc   = 200 + splineOffset;
positive_xloc   = 300 + splineOffset;
positive_yloc   = 400 + splineOffset;
negative_xloc2  = 500 + splineOffset;
negative_yloc2  = 600 + splineOffset;
positive_xloc2  = 700 + splineOffset;
positive_yloc2  = 800 + splineOffset;
temp_xloc       = 900 + splineOffset;
temp_yloc       = 1000 + splineOffset;
pos_c1s         = 1100 + splineOffset;
pos_c2s         = 1200 + splineOffset;
pos_c3s         = 1300 + splineOffset;
neg_c1s         = 1400 + splineOffset;
neg_c2s         = 1500 + splineOffset;
neg_c3s         = 1600 + splineOffset;
pos_c1s2        = 1700 + splineOffset;
pos_c2s2        = 1800 + splineOffset;
pos_c3s2        = 1900 + splineOffset;
neg_c1s2        = 2000 + splineOffset;
neg_c2s2        = 2100 + splineOffset;
neg_c3s2        = 2200 + splineOffset;
temp_indices    = 2300 + splineOffset;
pos_indices     = 2400 + splineOffset;
neg_indices     = 2500 + splineOffset;
vowel_A         = 2600 + splineOffset;
vowel_E         = 2650 + splineOffset;
vowel_I         = 2700 + splineOffset;
vowel_O         = 2750 + splineOffset;
vowel_U         = 2800 + splineOffset;
vowel_EE        = 2850 + splineOffset;
vowel_src       = 2900 + splineOffset;
kot_LUT_x       = 3000 + splineOffset;
kot_LUT_y       = 3200 + splineOffset;
temp_xloc2      = 3400 + splineOffset;
temp_yloc2      = 3500 + splineOffset;
temp_indices2   = 3600 + splineOffset;

bootvowel();
kot_lut(kot_LUT_x, kot_LUT_y);
Nbuf            = 20000;

//fftSize         = 32768;
fftSize         = 2*8192;
audioBufIn      = 40*bufferDist;
audioBufOut     = 42*bufferDist;
gonioBuffer1    = 44*bufferDist;
gonioBuffer2    = 46*bufferDist;
spectrumIn.initSpectrum(audioBufIn);
spectrumOut.initSpectrum(audioBufOut);
gonioIn.initGonioMeter(gonioBuffer1, 1000);
gonioOut.initGonioMeter(gonioBuffer2, 1000);

inVol.initBuffer(20000, 20000+Nbuf-1);
outVol.initBuffer(20000+Nbuf, 20000+2*Nbuf-1);
dynBuf.initBuffer(20000+Nbuf*2, 20000+3*Nbuf-1);

L.filter_delay.initBuffer(delay_buf1, delay_buf1 + 1000);
R.filter_delay.initBuffer(delay_buf2, delay_buf2 + 2000);
L2.filter_delay.initBuffer(delay_buf3, delay_buf3 + 1000);
R2.filter_delay.initBuffer(delay_buf4, delay_buf4 + 2000);
L_gfx.filter_delay.initBuffer(delay_buf5, delay_buf5 + 1000);
R_gfx.filter_delay.initBuffer(delay_buf6, delay_buf6 + 2000);
L2_gfx.filter_delay.initBuffer(delay_buf7, delay_buf7 + 1000);
R2_gfx.filter_delay.initBuffer(delay_buf8, delay_buf8 + 2000);

stereo_delay_bufferL.initBuffer(delay_buf1, delay_buf1 + 1000);
stereo_delay_bufferR.initBuffer(delay_buf1, delay_buf1 + 1000);

fb_buf1         = 48*bufferDist;
fb_buf2         = 50*bufferDist;

// Fixed feedback buffers
fb_bufferL.initBuffer(fb_buf1, fb_buf1+120000);
fb_bufferR.initBuffer(fb_buf2, fb_buf2+120000);

pitchTrackerBuf = 52*bufferDist;
pitchFFT.initSpectrum(pitchTrackerBuf);

filterABuf = 54*bufferDist;
filterA_gfx.initSpectrum(filterABuf);
filterA_gfx.initWindow(4);
filterBBuf = 56*bufferDist;
filterB_gfx.initSpectrum(filterBBuf);
filterB_gfx.initWindow(4);

delay_buf5      = 58*bufferDist;
delay_buf6      = delay_buf5 + 100000;
delay_buf7      = delay_buf6 + 100000;
delay_buf8      = delay_buf7 + 100000;

env_buf1        = 66*65536;
env_buf_shapes1 = 67*65536;
env_buf2        = 68*65536;
env_buf_shapes2 = 69*65536;

filter_delay1.initBuffer(delay_buf1, delay_buf1 + 50000);
filter_delay2.initBuffer(delay_buf2, delay_buf2 + 50000);
filter_delay3.initBuffer(delay_buf3, delay_buf3 + 50000);
filter_delay4.initBuffer(delay_buf4, delay_buf4 + 50000);
filter_delay5.initBuffer(delay_buf5, delay_buf5 + 50000);
filter_delay6.initBuffer(delay_buf6, delay_buf6 + 50000);
filter_delay7.initBuffer(delay_buf7, delay_buf7 + 50000);
filter_delay8.initBuffer(delay_buf8, delay_buf8 + 50000);

dynval = 0;
n_pos = 8;
n_neg = 8;
initialized = 1;

function updateLegacyStatus()
(
  (slider35 & 16384) ? (
    legacyCutoff = 0;
  ) : (
    legacyCutoff = 1;
  );
);

function updateSliders( hard )
(
  slider54 < 1 ? slider54 = 1;
  
  modulator.updateModRate(slider37);
  modulator.updateScale(slider39);
  ((slider38&2) == 2) ? (
    cTime = slider37;
    ( cTime < 0.0196078 ) ? (
      tempoLabel = "256";
    ) : ( cTime < 0.0392157 ) ?
    (
      tempoLabel = "224";
    ) : ( cTime < 0.0588235 ) ?
    (
      tempoLabel = "192";
    ) : ( cTime < 0.0784314 ) ?
    (
      tempoLabel = "160";
    ) : ( cTime < 0.0980392 ) ?
    (
      tempoLabel = "144";
    ) : ( cTime < 0.117647 ) ?
    (
      tempoLabel = "128";
    ) : ( cTime < 0.137255 ) ?
    (
      tempoLabel = "112";
    ) : ( cTime < 0.156863 ) ?
    (
      tempoLabel = "96";
    ) : ( cTime < 0.176471 ) ?
    (
      tempoLabel = "80";
    ) : ( cTime < 0.196078 ) ?
    (
      tempoLabel = "64";
    ) : ( cTime < 0.215686 ) ?
    (
      tempoLabel = "56";
    ) : ( cTime < 0.235294 ) ?
    (
      tempoLabel = "48";
    ) : ( cTime < 0.254902 ) ?
    (
      tempoLabel = "40";
    ) : ( cTime < 0.27451 ) ?
    (
      tempoLabel = "32";
    ) : ( cTime < 0.294118 ) ?
    (
      tempoLabel = "28";
    ) : ( cTime < 0.313725 ) ?
    (
      tempoLabel = "24";
    ) : ( cTime < 0.333333 ) ?
    (
      tempoLabel = "16";
    ) : ( cTime < 0.352941 ) ?
    (
      tempoLabel = "8";
    ) : ( cTime < 0.372549 ) ?
    (
      tempoLabel = "7";
    ) : ( cTime < 0.392157 ) ?
    (
      tempoLabel = "6";
    ) : ( cTime < 0.411765 ) ?
    (
      tempoLabel = "16/3";
    ) : ( cTime < 0.431373 ) ?
    (
      tempoLabel = "5";
    ) : ( cTime < 0.45098 ) ?
    (
      tempoLabel = "4";
    ) : ( cTime < 0.470588 ) ?
    (
      tempoLabel = "3";
    ) : ( cTime < 0.485196 ) ?
    (
      tempoLabel = "8/3";
    ) : ( cTime < 0.495196 ) ?
    (
      tempoLabel = "2";
    ) : ( cTime < 0.509804 ) ?
    (
      tempoLabel = "4/3";
    ) : ( cTime < 0.529412 ) ?
    (
      tempoLabel = "7/6";
    ) : ( cTime < 0.54902 ) ?
    (
      tempoLabel = "1";
    ) : ( cTime < 0.568627 ) ?
    (
      tempoLabel = "15/16";
    ) : ( cTime < 0.588235 ) ?
    (
      tempoLabel = "7/8";
    ) : ( cTime < 0.607843 ) ?
    (
      tempoLabel = "5/6";
    ) : ( cTime < 0.627451 ) ?
    (
      tempoLabel = "13/16";
    ) : ( cTime < 0.647059 ) ?
    (
      tempoLabel = "3/4";
    ) : ( cTime < 0.666667 ) ?
    (
      tempoLabel = "11/16";
    ) : ( cTime < 0.686275 ) ?
    (
      tempoLabel = "2/3";
    ) : ( cTime < 0.705882 ) ?
    (
      tempoLabel = "5/8";
    ) : ( cTime < 0.72549 ) ?
    (
      tempoLabel = "9/16";
    ) : ( cTime < 0.745098 ) ?
    (
      tempoLabel = "1/2";
    ) : ( cTime < 0.764706 ) ?
    (
      tempoLabel = "7/16";
    ) : ( cTime < 0.784314 ) ?
    (
      tempoLabel = "3/8";
    ) : ( cTime < 0.803922 ) ?
    (
      tempoLabel = "1/3";
    ) : ( cTime < 0.823529 ) ?
    (
      tempoLabel = "5/16";
    ) : ( cTime < 0.843137 ) ?
    (
      tempoLabel = "1/4";
    ) : ( cTime < 0.862745 ) ?
    (
      tempoLabel = "3/16";
    ) : ( cTime < 0.882353 ) ?
    (
      tempoLabel = "1/6";
    ) : ( cTime < 0.901961 ) ?
    (
      tempoLabel = "1/8";
    ) : ( cTime < 0.921569 ) ?
    (
      tempoLabel = "1/12";
    ) : ( cTime < 0.941176 ) ?
    (
      tempoLabel = "1/16";
    ) : ( cTime < 0.960784 ) ?
    (
      tempoLabel = "1/24";
    ) : ( cTime < 0.980392 ) ?
    (
      tempoLabel = "1/32";
    ) : (
      tempoLabel = "1/64";
    );
  );
  
  overSampling.sliderWidget_setValue(slider54);
  inGain.sliderWidget_setValue(slider52);
  inGain.sliderWidget_setValue2_nn(slider51);
  outGain.sliderWidget_setValue(slider53);
  keyAmount.sliderWidget_setValue(slider33);
  slider35 & 2 == 0 ? outGain.sliderWidget_setValue2_nn(0) : outGain.sliderWidget_setValue2_nn(slider17);
  
  // Filter 1
  filterSelect.combobox_setcuritem(slider47);
  filterSelect.dangerousElements = danger_list;
  modeSelect.combobox_setcuritem(slider46);
  modeSelect.dangerousElements = danger_list2;
  lfoSelect.combobox_setcuritem(slider36);
  cutoffSlider.sliderWidget_setValue(slider48);
  resonanceSlider.sliderWidget_setValue(slider49); 
  cutoffSlider.sliderWidget_setValue2_nn(slider62);
  resonanceSlider.sliderWidget_setValue2_nn(slider63);
  
  // Filter 2
  filterSelect2.combobox_setcuritem(slider40);
  filterSelect2.dangerousElements = danger_list;
  modeSelect2.combobox_setcuritem(floor(slider50*.5));
  cutoffSlider2.sliderWidget_setValue(slider41);
  resonanceSlider2.sliderWidget_setValue(slider42); 
  cutoffSlider2.sliderWidget_setValue2_nn(slider43);
  resonanceSlider2.sliderWidget_setValue2_nn(slider44);  

  // Dynamics 
  threshSlider.sliderWidget_setValue(slider59);
  attackSlider.sliderWidget_setValue(slider60);
  decaySlider.sliderWidget_setValue(slider61);
  rmsSlider.sliderWidget_setValue(slider64);
  
  // Feedback block
  feedbackAmount.sliderWidget_setValue(slider15);
  feedbackAmount.sliderWidget_setValue2_nn(slider31);
  feedbackDelay.sliderWidget_setValue(slider16);
  feedbackDelay.sliderWidget_setValue2_nn(slider32);
  
  // LFO block
  lfoFrequency.sliderWidget_setValue(slider37);
  modulationFactor.sliderWidget_setValue(slider39);
  lfoFrequency.sliderWidget_setValue2_nn(mod_LFO_rate);
  modulationFactor.sliderWidget_setValue2_nn(mod_LFO_amount);

  // Morph
  morphSlider.sliderWidget_setValue(slider18);
  morphSlider.sliderWidget_setValue2_nn(slider34);
  
  lookAheadButton.active          = slider35 & 1 ? 1 : 0;
  inClip.active                   = slider55 & 1 ? 1 : 0;
  outClip.active                  = slider55 & 2 ? 1 : 0;
  inertia.active                  = slider55 & 4 ? 1 : 0;
  dynButton.active                = slider45 & 1 ? 1 : 0;
  bypassFilter1.active            = slider35 & 4 ? 1 : 0;
  bypassFilter2.active            = slider35 & 8 ? 1 : 0;
  lfoSmoothButton.active          = slider35 & 16 ? 1 : 0;
  feedbackActive.active           = slider35 & 32 ? 1 : 0;
  dynamicFeedback.active          = slider35 & 64 ? 1 : 0;
  lfoFeedback.active              = slider35 & 128 ? 1 : 0;
  feedbackDelay_x8_1.active       = slider35 & 256 ? 1 : 0;
  feedbackDelay_x8_2.active       = slider35 & 512 ? 1 : 0;
  feedbackDelay_x8_3.active       = slider35 & 8192 ? 1 : 0;
  dynamicMorph.active             = slider35 & 1024 ? 1 : 0;
  lfoMorph.active                 = slider35 & 2048 ? 1 : 0;
  dynamicLFOButton.active         = slider35 & 4096 ? 1 : 0;
  legacySliders.active            = slider35 & 16384 ? 0 : 1; // Reversed order is not accidental. Legacy is the default for older presets!
  updateLegacyStatus();
   
  force_mono.active               = force_mono_output;
  globalbypass.active             = global_bypass;

  atk_x4_1.active                 = slider57 & 1 ? 1 : 0;
  atk_x4_2.active                 = slider57 & 2 ? 1 : 0;
  decay_x4_1.active               = slider57 & 4 ? 1 : 0;
  decay_x4_2.active               = slider57 & 8 ? 1 : 0;
  rms_x4_1.active                 = slider57 & 16 ? 1 : 0;
  rms_x4_2.active                 = slider57 & 32 ? 1 : 0;
  firButton.active                = slider50&1 ? 1 : 0;
  
  lfoResetButton.active           = (slider38&1) ? 1 : 0;
  tempoLFOButton.active           = (slider38&2) ? 1 : 0;
  centeredLFOButton.active        = (slider38&4) ? 1 : 0;
  
  // Remove 2 nodes if we're using feedback and are over the limit
  maxNodes = (9-max(2*(slider35&32>0),floor(slider50*.5)>3));
  slider1 > maxNodes ? ( slider_automate( slider1 = maxNodes ); hard=1; );
  slider2 > maxNodes ? ( slider_automate( slider2 = maxNodes ); hard=1; );
  
  dynamics = slider58;
  dyn_thresh = slider59;

  atkmul          = ( 1 + 7*atk_x4_1.active ) * ( 1 + 3*atk_x4_2.active );
  ( (slider45 == 10) || (slider45 == 11) ) ? (
    dyn_atk_time  = exp( log(.000001) + (1-slider59)*(log(.005) - log(.000001)) ) * ( 44100 / srate );
    dyn_atk       = exp( log(.000001) + (1-slider60*.02)*(log(.005) - log(.000001)) ) * ( 44100 / srate );
  ) : ( slider45 == 1 || slider45 == 7 || slider45 == 9 ) ? (
    // Direct RMS mode (doesn't need samplerate)
    dyn_atk       = (2^(2*(atkmul * slider60-25)/25));
    dyn_decay     = slider61/50;
  ) : (
    decaymul       = ( 1 + 7*decay_x4_1.active ) * ( 1 + 3*decay_x4_2.active );
    dyn_atk_time   = max(5,atkmul * slider60 * srate / 100);
    dyn_atk        = 1 / dyn_atk_time;
    dyn_decay_time = log2 * max(.05, decaymul * slider61) * srate / 100 + 0.0001;
    dyn_decay      = 1 / dyn_decay_time;
 
    ( slider45 == 2 || slider45 == 4 ) ? (
      dyn_hold_time = max(5, slider59 * srate);
      dyn_hold_end  = dyn_hold_time + dyn_atk_time;
    )
  );
 
  dyn_mod_filt    = cutoffSlider.sliderWidget_getValue2();
  dyn_mod_reso    = resonanceSlider.sliderWidget_getValue2();
  dyn_mod_filt2   = cutoffSlider2.sliderWidget_getValue2();
  dyn_mod_reso2   = resonanceSlider2.sliderWidget_getValue2();
  dyn_mod_gain    = inGain.sliderWidget_getValue2();
  dyn_mod_outgain = outGain.sliderWidget_getValue2_nn();
 
  filterDynamics1     = 0;
  filterDynamics2     = 0;
  F1_dyn_cutoff       = 0;
  F2_dyn_cutoff       = 0;
  F1_dyn_reso         = 0;
  F2_dyn_reso         = 0;  
  F1_lfo_cutoff       = 0;
  F2_lfo_cutoff       = 0;
  F1_lfo_reso         = 0;
  F2_lfo_reso         = 0;
  F1_env1_cutoff      = 0;
  F2_env1_cutoff      = 0;
  F1_env1_reso        = 0;
  F2_env1_reso        = 0;
  F1_env2_cutoff      = 0;
  F2_env2_cutoff      = 0;
  F1_env2_reso        = 0;
  F2_env2_reso        = 0;
  
  distortionDynamics  = dynamics & 2 > 0;
  filterDynamics1     = dynamics & 4 > 0;
  filterLFO1          = dynamics & 8 > 0;
  filterDynamics2     = dynamics & 16 > 0;
  filterLFO2          = dynamics & 32 > 0;
  gainDynamics        = dynamics & 64 > 0;
  gainLFO             = dynamics & 128 > 0;
  followKey1          = dynamics & 256 > 0;
  followKey2          = dynamics & 512 > 0;
  followPitch1        = dynamics & 1024 > 0;
  followPitch2        = dynamics & 2048 > 0;
  
  // For legacy purposes (there used to be only filters on/off)
  ( dynamics & 1 ) ? ( filterDynamics1 = filterDynamics2 = filterLFO1 = filterLFO2 = gainDynamics = gainLFO = 1; followKey1 = followKey2 = 0; );
  
  filterDynamics1 ? (
    F1_dyn_cutoff       = (dynamicFilterButton.mode == 0) || (dynamicFilterButton.mode == 1);
    F1_dyn_reso         = (dynamicFilterButton.mode == 0) || (dynamicFilterButton.mode == 2);
  );
  filterDynamics2 ? (
    F2_dyn_cutoff       = (dynamicFilterButton2.mode == 0) || (dynamicFilterButton2.mode == 1);
    F2_dyn_reso         = (dynamicFilterButton2.mode == 0) || (dynamicFilterButton2.mode == 2);
  );
  filterLFO1 ? (
    F1_lfo_cutoff       = (lfoFilterButton.mode == 0) || (lfoFilterButton.mode == 1);
    F1_lfo_reso         = (lfoFilterButton.mode == 0) || (lfoFilterButton.mode == 2);
  );
  filterLFO2 ? (
    F2_lfo_cutoff       = (lfoFilterButton2.mode == 0) || (lfoFilterButton2.mode == 1);
    F2_lfo_reso         = (lfoFilterButton2.mode == 0) || (lfoFilterButton2.mode == 2);
  );
  (env1FilterButton.active == 1) ? (
    F1_env1_cutoff      = (env1FilterButton.mode == 0) || (env1FilterButton.mode == 1);
    F1_env1_reso        = (env1FilterButton.mode == 0) || (env1FilterButton.mode == 2);
  );
  (env2FilterButton.active == 1) ? (
    F1_env2_cutoff      = (env2FilterButton.mode == 0) || (env2FilterButton.mode == 1);
    F1_env2_reso        = (env2FilterButton.mode == 0) || (env2FilterButton.mode == 2);
  );
  (env1Filter2Button.active == 1) ? (
    F2_env1_cutoff      = (env1Filter2Button.mode == 0) || (env1Filter2Button.mode == 1);
    F2_env1_reso        = (env1Filter2Button.mode == 0) || (env1Filter2Button.mode == 2);
  );
  (env2Filter2Button.active == 1) ? (
    F2_env2_cutoff      = (env2Filter2Button.mode == 0) || (env2Filter2Button.mode == 1);
    F2_env2_reso        = (env2Filter2Button.mode == 0) || (env2Filter2Button.mode == 2);
  );
  
  dynamicFilterButton.active      = filterDynamics1;
  dynamicFilterButton2.active     = filterDynamics2;
  lfoFilterButton.active          = filterLFO1;
  lfoFilterButton2.active         = filterLFO2;
  dynamicWaveShapingButton.active = distortionDynamics; 
  dynamicGainButton.active        = gainDynamics;
  lfoGainButton.active            = gainLFO;
  keyFollow1.active               = followKey1;
  keyFollow2.active               = followKey2;
  pitchFollow1.active             = followPitch1;
  pitchFollow2.active             = followPitch2;
        
  showSpectrumInButton.active     = 1 - hideSpectrumIn;
  showSpectrumOutButton.active    = 1 - hideSpectrumOut;
  showFiltersButton.active        = 1 - hideSpectrumFilters;
    
  ( ( slider56 == 0 ) || ( hard == 1 ) ) ? ( 
    importNodes( window1.spline.xloc_audio, window2.spline.xloc_audio, window1.spline.yloc_audio, window2.spline.yloc_audio, 0 );
    window1.sort_spline(0);
    window2.sort_spline(0);
    window1.update_spline(0);
    window2.update_spline(0);
  );

  // Only update the oversampling filters when needed.
  ( slider54 != lastOversample ) ? 
  (
    lastOversample = slider54;   

    filterL.updateFilter(slider54);
    filterR.updateFilter(slider54);
    // Memory for the sincs is located at sinc_tmp, sinc_flt, sinc_flt2, sinc_flt3 and sinc_flt4
    sincFilterL.updateSincFilter(slider54, 8, sinc_flt,  sinc_tmp);
    sincFilterR.updateSincFilter(slider54, 8, sinc_flt2, sinc_tmp);
    nTapSinc = slider54 < 5 ? 16 : slider54*4;
    sincDownL.updateSincDownsampleFilter(slider54, nTapSinc, sinc_hist1, sinc_flt3);
    sincDownR.updateSincDownsampleFilter(slider54, nTapSinc, sinc_hist2, sinc_flt4);  
 );
  
  // Calculate group delay incurred by sincs
  iN = 1.0 / slider54;
  cDelay  = (slider50 & 1) ? iN * (.5 * 7 * slider54 - 1) : 0;
  cDelay += (slider50 & 1) ? iN * (.5 * nTapSinc - 1) : 0;
  updateIntegrationTime(); // updates lookAheadDelay
  cDelay += lookAheadDelay;  
 
  pdcDelay = cDelay;
);

function initGUI()
(
  // Initialize object instances
  window1.init_window_spline(10, 1, negative_xloc, negative_yloc, negative_xloc2, negative_yloc2, pos_indices, temp_xloc, temp_yloc, temp_indices, temp_xloc2, temp_yloc2, temp_indices2, neg_c1s, neg_c2s, neg_c3s, neg_c1s2, neg_c2s2, neg_c3s2);
  window2.init_window_spline(10, 2, positive_xloc, positive_yloc, positive_xloc2, positive_yloc2, neg_indices, temp_xloc, temp_yloc, temp_indices, temp_xloc2, temp_yloc2, temp_indices2, pos_c1s, pos_c2s, pos_c3s, pos_c1s2, pos_c2s2, pos_c3s2);
  
  updateSliders(1);
  updateActiveFilters(1);
);

function setupGUI()
(
  UI_Loaded = 1; // gfx_ext_retina = 2;
  retina_scaling = gfx_ext_retina * (1+extraScale);
  rescale_factor ? retina_scaling *= rescale_factor;
  widgetFontSize = 12 + linuxMode;
  buttonFontSize = 11;
  
  gfx_setfont(1, fontface, widgetFontSize);
  gfx_measurestr("LookAhead", str_width, str_height);
  font_factor    = 47 / str_width; // 47 is the button text area
  widgetFontSize = widgetFontSize * font_factor * ( 1 + linuxMode * .2 );
  buttonFontSize = buttonFontSize * font_factor;

  // Initialize object instances
  wndX    = 250 * retina_scaling;
  wndY    = wndX;
  wndPad  = 30 * retina_scaling;
  
  window1.gen_window(wndPad, wndPad - yOffset, wndX, wndY, "This window can be used to control the waveshaping.\n\nSquashed tanh\n  Saturates signal quickly and reduces amplitude.\nSquashed fast tanh\n  Fast approximation to the squashed tanh.\nSine\n  Sine-based distortion (FM-like sound).\nTanh\n  Tanh-based saturator\nSpline\n  Spline based distortion. LMB drags nodes. RMB adds/deletes nodes.\n\nNote: Negative input level is shown under the X axis and output level along Y axis.");
  window2.gen_window(2*wndPad+wndX, wndPad - yOffset, wndX, wndY, "This window can be used to control the waveshaping.\n\nSquashed tanh\n  Saturates signal quickly and reduces amplitude.\nSquashed fast tanh\n  Fast approximation to the squashed tanh.\nSine\n  Sine-based distortion (FM-like sound).\nTanh\n  Tanh-based saturator\nSpline\n  Spline based distortion. LMB drags nodes. RMB adds/deletes nodes.\n\n\nNote: Positive input level is shown under the X axis and output level along Y axis.");
  window3.gen_dynamics(3*wndPad+2*wndX, wndPad - yOffset, wndX, wndY, "This window shows input/output RMS and the dynamical variable.\n\nThe dynamical variable is shown in yellow and its source can be set here as well.\n\nSource options are:\nDriven RMS - Dynamical variable is driven by post-gain input RMS.\nMIDI - Dynamical variable is triggered by MIDI (note velocity is ignored).\nMIDI Velocity - Dynamical variable is triggered by MIDI (note velocity is used).\nPre-Gain RMS - Dynamical variable is driven by pre-gain input RMS.\nSidechain - Dynamical variable is driven by input channel 3 and 4.\nModwheel - Dynamical variable is set via Modwheel.\nDepending on the usage mode, different options become available in the DYNAMICS\nwindow. Hover over elements in the DYNAMICS window for more information.\n\nLMB + Drag - Zoom.\nLMB + Drag threshold - Change threshold.\nRMB + Drag - Change threshold." );
  
  copyright_h = .8*sliderHeight;
  copyRight.selectionButton(1.5*wndPad+wndX - .25*wndPad, wndPad + .15*wndY - .5*copyright_h - yOffset, .5*wndPad, copyright_h, ">",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Copy spline curve to right");
  copyLeft.selectionButton(1.5*wndPad+wndX - .25*wndPad,  wndPad + .85*wndY - .5*copyright_h - yOffset, .5*wndPad, copyright_h, "<",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Copy spline curve to left");
  
  spectrumIn.setWindowLocation(wndPad, 2.4*wndPad + wndY - yOffset, 2*wndX + wndPad, wndY * .9);
  !spectrumIn.hint ? spectrumIn.hint = "Spectrum\n\nCurve shows spectrum post filtering. Filled area shows\nspectrum pre-filtering. When pitch tracking is enabled for\na filter, a vertical line indicates the detected pitch. For\nsome filters, vertical lines are drawn at relevant frequencies.\nIn such cases, matching them up with spectral peaks is\nbeneficial for producing pleasant sounds.\n\nLMB + Drag - Change noise floor\nScrollwheel - Change smoothing\n";
  spectrumOut.setWindowLocation(wndPad, 2.4*wndPad + wndY - yOffset, 2*wndX + wndPad, wndY * .9);
  filterA_gfx.setWindowLocation(wndPad, 2.4*wndPad + wndY - yOffset, 2*wndX + wndPad, wndY * .9);
  filterB_gfx.setWindowLocation(wndPad, 2.4*wndPad + wndY - yOffset, 2*wndX + wndPad, wndY * .9);  
  
  hy    = 15*retina_scaling;
  bw    = 35*retina_scaling;
  bh    = 10*retina_scaling;
  specY = 2.4*wndPad + wndY - yOffset + 5;
  //x+5, y+4, bw, bh
  
  showSpectrumInButton.selectionButton(wndPad+5, specY, bw, bh, "In",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Show incoming spectrum");
  showSpectrumOutButton.selectionButton(wndPad+5, 2.4*wndPad + wndY - yOffset + hy + 5, bw, bh, "Out",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Show outgoing spectrum");
  showFiltersButton.selectionButton(wndPad+5, 2.4*wndPad + wndY - yOffset + 2*hy + 5, bw, bh, "Filter",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Show filter spectra");
  
  gonioIn.setWindowLocation(3*wndPad+2*wndX, 2.4*wndPad + wndY - yOffset, wndX, wndY * .9);
  gonioOut.setWindowLocation(3*wndPad+2*wndX, 2.4*wndPad + wndY - yOffset, wndX, wndY * .9);  
  
  envX = 3*wndPad+2*wndX;
  envX = wndPad;
  block_analyzers == 0 ? (
    envY = 2.4*wndPad + 2*wndY - yOffset; 
  ) : (
    envY = specY;
  );
  envW = wndX*2+wndPad;
  envH = wndY * .35;
  envWindow1.initEnvelope(envX, envY, envW, envH, env_buf1, env_buf_shapes1, 6, "ENVELOPE 1", env1_widget_r, env1_widget_g, env1_widget_b, env1_widget_a );

  envY = envY + .440*wndY;
  envWindow2.initEnvelope(envX, envY, envW, envH, env_buf2, env_buf_shapes2, 6, "ENVELOPE 2", env2_widget_r, env2_widget_g, env2_widget_b, env2_widget_a);
  
  wR = widgetcolor_r;
  wG = widgetcolor_g;
  wB = widgetcolor_b;
  wA = widgetcolor_a;
  
  buttonHeight  = 12 * retina_scaling;
  buttonWidth   = 70 * retina_scaling;
  buttonPad     = 6 * retina_scaling; 
  
  masterPanelX  = 4*wndPad+3*wndX;
  masterPanelY  = (30 + 5) * retina_scaling - yOffset;
  sliderWidth   = 234 * retina_scaling;
  sliderHeight  = 20 * retina_scaling;
  sliderPad     = 5 * retina_scaling;
  masterPanelH  = sliderHeight*4+6*sliderPad;
  
  toggleWidth   = .15 * sliderWidth; // .2
  baseRight     = sliderWidth - .8*toggleWidth; // .82
  toggleOffset  = .12 * sliderWidth; // .185
  postTextLoc = masterPanel.groupWidget(masterPanelX, masterPanelY, sliderWidth, masterPanelH, "MASTER", wR, wG, wB, wA );
  lfoGainButton.selectionButton(masterPanelX + baseRight, masterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "LFO",  lfobutton_color_r, lfobutton_color_g, lfobutton_color_b, lfobutton_color_a, "Enable dynamic filter manipulation.\n\nWhen activated, the gain responds to changes in the LFO.");
  lfoGainButton.hoverType = 1;
  dynamicGainButton.selectionButton(masterPanelX + baseRight - toggleOffset, masterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "DYN",  dynbutton_color_r, dynbutton_color_g, dynbutton_color_b, dynbutton_color_a, "Enable dynamic gain manipulation.\n\nWhen activated, the gain responds to changes in the dynamic\nvariable (shown with the yellow curve). This value changes based\non the settings set in the dynamics panel. It is either modulated\nby an attack/decay mechanism based on thresholding the input RMS\nvalue, or directly set to some function of the RMS value (RMS mode).");
  dynamicGainButton.hoverType = 2;
  env1GainButton.selectionButton(masterPanelX + baseRight - 3*toggleOffset, masterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN1",  env1button_color_r, env1button_color_g, env1button_color_b, env1button_color_a, "Enable Envelope 1 for gain manipulation.");
  env1GainButton.hoverType = 3;
  env2GainButton.selectionButton(masterPanelX + baseRight - 2*toggleOffset, masterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN2",  env2button_color_r, env2button_color_g, env2button_color_b, env2button_color_a, "Enable Envelope 2 for gain manipulation.");
  env2GainButton.hoverType = 4;
  agcButton.selectionButton(postTextLoc + .015 * sliderWidth, masterPanelY-buttonHeight, .14*sliderWidth-2*sliderPad, buttonHeight, "AGC",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Automatic Gain Control (BETA)\n\nAdjusts the level between post-filter and post-gain in order\nto keep the RMS ratio between post-filter and post-drive fixed.\n\nThis setting is meant to protect your ears when tweaking filters,\nnot to be used in final production as it affects dynamics.\n\n\nClicking this button with the outer mouse button transfers the \ngain correction estimated by AGC to the Post-Gain slider and\ndisables AGC.");
  force_mono.selectionButton(postTextLoc + .015 * sliderWidth + .13*sliderWidth-1*sliderPad, masterPanelY-buttonHeight, .1*sliderWidth-2*sliderPad, buttonHeight, "M",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Force mono\n\nSums left and right output. Use this every now\nand then to spot any phase issues in the bass.\n");
  globalbypass.selectionButton(postTextLoc + .015 * sliderWidth + .22*sliderWidth-2*sliderPad, masterPanelY-buttonHeight, .1*sliderWidth-2*sliderPad, buttonHeight, "B",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Bypass plugin.\n");
  legacySliders.selectionButton(postTextLoc + .015 * sliderWidth + .31*sliderWidth-3*sliderPad, masterPanelY-buttonHeight, .1*sliderWidth-2*sliderPad, buttonHeight, "L",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Use legacy slider mapping.\n\nLegacy slider mapping has less resolution for lower frequencies\n");

  inGain.sliderWidget(masterPanelX+sliderPad, masterPanelY+sliderPad, .78*sliderWidth-2*sliderPad, sliderHeight, "Pre-Gain / Drive", wR, wG, wB, wA, 40, -40, 40, 0, " dB", 0, "Input gain\n(Post upsampling, pre-effect)");
  outGain.sliderWidget(masterPanelX+sliderPad, masterPanelY+2*sliderPad+sliderHeight, .78*sliderWidth-2*sliderPad, sliderHeight, "Post-Gain", wR, wG, wB, wA, 40, -40, 40, 0, " dB", 0, "Output gain");
  overSampling.sliderWidget(masterPanelX+sliderPad, masterPanelY+3*sliderPad+2*sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Oversampling", wR, wG, wB, wA, 0, 1, 8, 1, "x", 1, "Oversampling factor\nOversampling reduces aliasing that occurs when distorting heavily\nand is required for the stability of a few filters.\nUse FIR version if phase is important (stabby sounds).\n");
  keyAmount.sliderWidget(masterPanelX+sliderPad, masterPanelY+4*sliderPad+3*sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Keyfollow amount", wR, wG, wB, wA, 0, 0, 2, 1, "x", 0, "Keyfollow amount.\n\nDetermines how strongly the filters follow\nthe last note played when KEY toggles are activated.\n");
  linkButton.selectionButton(masterPanelX+sliderPad + .745*sliderWidth, masterPanelY+sliderPad+1, .028*sliderWidth, sliderHeight+3*sliderPad+2, "",  .3, .4, .8, .3, "Link");

  inClip.selectionButton(masterPanelX+sliderPad+ + .8*sliderWidth, 3+masterPanelY+.75*sliderPad, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Clip",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Toggle input clipping");
  outClip.selectionButton(masterPanelX+sliderPad + .8*sliderWidth, 3+masterPanelY+1.75*sliderPad+sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Clip",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Toggle output clipping");
  firButton.selectionButton(masterPanelX+sliderPad + .8*sliderWidth, 3+masterPanelY+2.75*sliderPad+2*sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "FIR",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable FIR up/downsampling\n(preserves phase but expensive)");
  polarityButton.selectionButton(masterPanelX+sliderPad + .8*sliderWidth, 3+masterPanelY+3.75*sliderPad+3*sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Invert polarity");

  filterPanelX = masterPanelX;
  filterPanelY = masterPanelY + masterPanelH + sliderHeight - .5*sliderPad;
  filterPanelH = sliderHeight*4+6*sliderPad;
  postTextLoc = filterPanel.groupWidget(filterPanelX, filterPanelY, sliderWidth, filterPanelH, "FILTER", wR, wG, wB, wA );  
  pitchFollow1.selectionButton(filterPanelX + baseRight - 5*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "PIT",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable pitch following for this filter (BETA).\n\nWhen activated, the filter follows the dominant incoming frequency.");
  pitchFollow1.hoverType = 5;
  keyFollow1.selectionButton(filterPanelX + baseRight - 4*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "KEY",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable note following for this filter.\n\nWhen activated, the filter follows the note pitch\nof the last note sent to it over MIDI.");
  env1FilterButton.selectionButton(filterPanelX + baseRight - 3*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN1",  env1button_color_r, env1button_color_g, env1button_color_b, env1button_color_a, "Enable Envelope 1 for filter manipulation.\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  env1FilterButton.hoverType = 3;
  env2FilterButton.selectionButton(filterPanelX + baseRight - 2*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN2",  env2button_color_r, env2button_color_g, env2button_color_b, env2button_color_a, "Enable Envelope 2 for filter manipulation.\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  env2FilterButton.hoverType = 4;
  dynamicFilterButton.selectionButton(filterPanelX + baseRight - toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "DYN",  dynbutton_color_r, dynbutton_color_g, dynbutton_color_b, dynbutton_color_a, "Enable dynamic filter manipulation.\n\nWhen activated, the filter responds to changes in the dynamic\nvariable (shown with the yellow curve). This value changes based\non the settings set in the dynamics panel. It is either modulated\nby an attack/decay mechanism based on thresholding the input RMS\nvalue, or directly set to some function of the RMS value (RMS mode).\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  dynamicFilterButton.hoverType = 2;
  lfoFilterButton.selectionButton(filterPanelX + baseRight, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "LFO", lfobutton_color_r, lfobutton_color_g, lfobutton_color_b, lfobutton_color_a, "Enable dynamic filter manipulation.\n\nWhen activated, the filter responds to changes in the LFO.\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  lfoFilterButton.hoverType = 1;
  filterSelect.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nFilters, 0, 0, 4, "Filter selection.\nNon-linear (NL) filters are more expensive and benefit more from oversampling.\nTheir character comes out when driven (increase the pre-gain without enabling clipping).\nZero Delay Feedback (ZDF) filters behave better with rapid modulation.\nAll filters are IIR filters, meaning they do not preserve linear phase.\n\nWARNING: Not all filters are stable under rapid modulation!\nRemember to read the filter description to avoid being hit by instability.\nInstability manifests itself as there suddenly being a spike and then no sound." );
  inertia.selectionButton(filterPanelX+sliderPad + .8 * sliderWidth, filterPanelY+sliderPad*2+sliderHeight*1.05, .2*sliderWidth-2*sliderPad, .95*sliderHeight, "Inertia",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Toggle cutoff and resonance inertia");
  modeSelect.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad*2+sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nModes, 1, 0, 1, "Filter mode selection.\nStereo - Default mode. Process left and right independently.\nMono double - Interleave samples and process.\nM1/S2 - Process mid regularly, feed side samples to filter twice.\nM2/S1 - Feed mid to filter twice, process side regularly.\nOnly side - Only filter the side channel.\nOnly mid - Only filter the mid channel.\nStereo Boost - Filter both, but pre-amplify side channel.\nStereoize - M/S processing. Side is boosted and computed with a delayed right channel for extra width.\nSubtle Stereo - M/S processing. Side is computed with a slightly delayed right channel for extra width.\nInverted - Signal is run through the filter, but filtered signal is subtracted from original and then distorted." );
  cutoffSlider.sliderWidget(filterPanelX+sliderPad, filterPanelY+3.5*sliderPad+2*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Cutoff", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Filter cutoff.\nLMB sets filter cutoff.\nRMB sets range for modulation.\nFor more info on modulation, hover over the Filter button in the dynamics panel.\n\nNote: When LFO and dynamics are both active, the modulation range is twice what is diplayed.\nNote: Hold Shift and/or Ctrl while dragging for smaller adjustments.\nNote: Use mouse wheel for precision adjustments.\nNote: Use shift + Mousewheel for precision adjustments of mod range.");
  resonanceSlider.sliderWidget(filterPanelX+sliderPad, filterPanelY+4.5*sliderPad+3*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Resonance", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Filter resonance.\nLMB sets filter cutoff.\nRMB sets range for modulation.\nFor more info on modulation, hover over the Filter button in the dynamics panel.\n\nNote: When LFO and dynamics are both active, the modulation range is twice what is diplayed.\nNote: Hold Shift and/or Ctrl while dragging for smaller adjustments.\nNote: Use mouse wheel for precision adjustments.\nNote: Use shift + Mousewheel for precision adjustments of mod range.");
  bypassFilter1.selectionButton(postTextLoc + .015 * sliderWidth, filterPanelY-buttonHeight, .1*sliderWidth-2*sliderPad, buttonHeight, "B",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Bypass filter.");
  env1FilterButton.modes = 2;
  env2FilterButton.modes = 2;
  dynamicFilterButton.modes = 2;
  lfoFilterButton.modes = 2;
  
  filterPanelX = masterPanelX;
  filterPanelY = filterPanelY + filterPanelH + sliderHeight - .5*sliderPad;  
  filterPanelH = sliderHeight*3+5*sliderPad;
  postTextLoc = filterPanel2.groupWidget(filterPanelX, filterPanelY, sliderWidth, filterPanelH, "FILTER", wR, wG, wB, wA );
  pitchFollow2.selectionButton(filterPanelX + baseRight - 5*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "PIT",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable pitch following for this filter (BETA).\n\nWhen activated, the filter follows the dominant incoming frequency.");
  pitchFollow2.hoverType = 5;
  keyFollow2.selectionButton(filterPanelX + baseRight - 4*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "KEY",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable note following for this filter.\n\nWhen activated, the filter follows the note pitch\nof the last note sent to it over MIDI.");
  env1Filter2Button.selectionButton(filterPanelX + baseRight - 3*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN1",  env1button_color_r, env1button_color_g, env1button_color_b, env1button_color_a, "Enable Envelope 1 for filter manipulation.\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  env1Filter2Button.hoverType = 3;
  env2Filter2Button.selectionButton(filterPanelX + baseRight - 2*toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN2",  env2button_color_r, env2button_color_g, env2button_color_b, env2button_color_a, "Enable Envelope 2 for filter manipulation.\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  env2Filter2Button.hoverType = 4;
  dynamicFilterButton2.selectionButton(filterPanelX +  baseRight - toggleOffset, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "DYN",  dynbutton_color_r, dynbutton_color_g, dynbutton_color_b, dynbutton_color_a, "Enable dynamic filter manipulation.\n\nWhen activated, the filter responds to changes in the dynamic\nvariable (shown with the yellow curve). This value changes based\non the settings set in the dynamics panel. It is either modulated\nby an attack/decay mechanism based on thresholding the input RMS\nvalue, or directly set to some function of the RMS value (RMS mode).\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  dynamicFilterButton2.hoverType = 2;
  lfoFilterButton2.selectionButton(filterPanelX + baseRight, filterPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "LFO", lfobutton_color_r, lfobutton_color_g, lfobutton_color_b, lfobutton_color_a, "Enable dynamic filter manipulation.\n\nWhen activated, the filter responds to changes in the LFO.\n\nLMB - Activate / Deactivate\nRMB - Select modulation of cutoff, resonance or both.\n");
  lfoFilterButton2.hoverType = 1;
  filterSelect2.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nFilters, 0, 0, 4, "Filter selection.\nNon-linear (NL) filters are more expensive and benefit more from oversampling.\nTheir character comes out when driven (increase the pre-gain without enabling clipping).\nZero Delay Feedback (ZDF) filters behave better with rapid modulation.\nAll filters are IIR filters, meaning they do not preserve linear phase.\n\nWARNING: Not all filters are stable under rapid modulation!\nRemember to read the filter description to avoid being hit by instability.\nInstability manifests itself as there suddenly being a spike and then no sound." );
  cutoffSlider2.sliderWidget(filterPanelX+sliderPad, filterPanelY+2.5*sliderPad+1*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Cutoff", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Filter cutoff.\nLMB sets filter cutoff.\nRMB sets range for modulation.\nFor more info on modulation, hover over the Filter button in the dynamics panel.\n\nNote: When LFO and dynamics are both active, the modulation range is twice what is diplayed.\nNote: Hold Shift and/or Ctrl while dragging for smaller adjustments.\nNote: Use mouse wheel for precision adjustments.\nNote: Use shift + Mousewheel for precision adjustments of mod range.");
  resonanceSlider2.sliderWidget(filterPanelX+sliderPad, filterPanelY+3.5*sliderPad+2*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Resonance", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Filter resonance.\nLMB sets filter cutoff.\nRMB sets range for modulation.\nFor more info on modulation, hover over the Filter button in the dynamics panel.\n\nNote: When LFO and dynamics are both active, the modulation range is twice what is diplayed.\nNote: Hold Shift and/or Ctrl while dragging for smaller adjustments.\nNote: Use mouse wheel for precision adjustments.\nNote: Use shift + Mousewheel for precision adjustments of mod range.");  
  bypassFilter2.selectionButton(postTextLoc + .015 * sliderWidth, filterPanelY-buttonHeight, .1*sliderWidth-2*sliderPad, buttonHeight, "B",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Bypass filter.");  
  env1Filter2Button.modes = 2;
  env2Filter2Button.modes = 2;
  dynamicFilterButton2.modes = 2;
  lfoFilterButton2.modes = 2;
  
  routingPanelX = masterPanelX;
  routingPanelY = filterPanelY + filterPanelH + sliderHeight - .5*sliderPad;
  routingPanelH = buttonHeight+sliderHeight*2+sliderPad;
  postTextLoc = routingPanel.groupWidget(routingPanelX, routingPanelY, sliderWidth, routingPanelH, "ROUTING", wR, wG, wB, wA );
  modeSelect2.combobox(routingPanelX+sliderPad, routingPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nModes2, 3, 0, 1, "Filter routing mode.\n\nSerial Dual Dist - Both filters are in series. Both with waveshaper enabled.\nSerial - Both filters are placed in series. The second filter does not use the waveshaper.\nParallel Dual Dist - Both filters are in series. Both filters have the waveshaper enabled.\nParallel - Both filters are in series. The second filter does not use the waveshaper.\nMorph Dual Dist - Both filters are linked in parallel. The Morph slider can be used to interpolate between A and B.\nMorph Dist - Both filters are linked in parallel. The Morph slider can be used to interpolate between A and B. B does not use the waveshaper.\n\n\nNote: Using morph routing means you can only use a maximum of 7 nodes for the spline waveshaper" );
  morphSlider.sliderWidget(routingPanelX+sliderPad, routingPanelY+sliderPad*2+sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Morph", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Routing control (depends on current function).");
  env1Morph.selectionButton(routingPanelX + baseRight - 3*toggleOffset, routingPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN1",  env1button_color_r, env1button_color_g, env1button_color_b, env1button_color_a, "Enable Envelope 1 for morph manipulation.");
  env1Morph.hoverType = 3;
  env2Morph.selectionButton(routingPanelX + baseRight - 2*toggleOffset, routingPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN2",  env2button_color_r, env2button_color_g, env2button_color_b, env2button_color_a, "Enable Envelope 2 for morph manipulation.");
  env2Morph.hoverType = 4;
  dynamicMorph.selectionButton(routingPanelX + baseRight - toggleOffset, routingPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "DYN",  dynbutton_color_r, dynbutton_color_g, dynbutton_color_b, dynbutton_color_a, "Enable dynamic manipulation.\n\nWhen activated, the controls in this tab can respond to changes in the dynamic\nvariable (shown with the yellow curve). This value changes based\non the settings set in the dynamics panel. It is either modulated\nby an attack/decay mechanism based on thresholding the input RMS\nvalue, or directly set to some function of the RMS value (RMS mode).");
  dynamicMorph.hoverType = 2;
  lfoMorph.selectionButton(routingPanelX + baseRight, routingPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "LFO",  lfobutton_color_r, lfobutton_color_g, lfobutton_color_b, lfobutton_color_a, "Enable dynamic manipulation.\n\nWhen activated, the controls in this tab can respond to changes in the LFO.");
  lfoMorph.hoverType = 1;
  
  dynamicsPanelX = masterPanelX;
  dynamicsPanelY = routingPanelY + routingPanelH + sliderHeight - .5*sliderPad;
  dynamicsPanelH = buttonHeight+sliderHeight*4+7*sliderPad;
  dynamicsPanel.groupWidget(dynamicsPanelX, dynamicsPanelY, sliderWidth, dynamicsPanelH, "DYNAMICS", dynamics_widget_r, dynamics_widget_g, dynamics_widget_b, dynamics_widget_a );
  dynamicWaveShapingButton.selectionButton(dynamicsPanelX+buttonPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "Shaper",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable dynamic waveshaper activation.\n\nWhen activated, the waveshaper responds to changes in the dynamic\nvariable (shown with the yellow curve). Based on the dynamic variable,\nthe waveshaper interpolates between no waveshaping and the curve set\nby the user. This can be used to simulate compressors for instance.\n\nThe dynamic variable changes based on the settings set in the dynamics\npanel. It is either modulated by an attack/decay mechanism based on\nthresholding the input RMS value or directly set to some function of\nthe RMS value (RMS mode).\n");
  lookaheadButton.selectionButton(dynamicsPanelX+sliderPad+buttonWidth+buttonPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "LookAhead",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Prevent lag in RMS estimate.\n\nNote that enabling lookahead increases the\npdc_delay of the plugin and is therefore not\nrecommended for live recording.");
  dynButton.selectionButton(dynamicsPanelX+sliderPad+2*buttonWidth+2*buttonPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "RMS Mode",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Use threshold or modulate directly by RMS.\n\nThe dynamic variable (shown with the yellow curve) changes based\non one of two mechanisms. Either it changes based on an attack/decay\nmechanism based on thresholding the input RMS value (RMS mode off),\nor it is directly set (without transient) to a function of the RMS \nvalue (RMS mode on).");
  threshSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+3*sliderPad+buttonHeight, sliderWidth-2*sliderPad, sliderHeight, "Threshold", wR, wG, wB, wA, 0, 0, 1, 1, " V", 0, "Threshold value.\nWhen input RMS exceeds this value, the dynamic variable begins to accumulate.\n");
  mulWidth = .06 * sliderWidth;
  mulPad = 4 * retina_scaling;
  attackSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, sliderWidth-2*sliderPad - 2*mulWidth-2*mulPad, sliderHeight, "Attack", wR, wG, wB, wA, 0, 0, 50, 0, "", 0, "Attack\nHow long does the dynamic variable take to change\nto its maximal value once over the threshold.");
  atk_x4_1.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-mulWidth, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x8",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 8");
  atk_x4_2.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 8");
  decaySlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, sliderWidth-2*sliderPad - 2*mulWidth-2*mulPad, sliderHeight, "Decay", wR, wG, wB, wA, 0, 0, 50, 0, "", 0, "Decay\nHow long does the dynamic variable take to\ndecay when below the threshold.");
  decay_x4_1.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-mulWidth, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x8",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 8");
  decay_x4_2.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 4");
  rmsSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, sliderWidth-2*sliderPad - 2*mulWidth-2*mulPad, sliderHeight, "RMS time", wR, wG, wB, wA, 0, 0.02, 40, 0, "", 0, "RMS time\nSets over how much time is the RMS computed");
  rms_x4_1.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-mulWidth, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x8",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 8");
  rms_x4_2.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 4");
  
  lfoPanelX = masterPanelX;
  lfoPanelY = dynamicsPanelY + dynamicsPanelH + sliderHeight - .5*sliderPad;
  lfoPanelH = buttonHeight+sliderHeight*3+2.5*sliderPad;
  buttonHeight = 12 * retina_scaling;
  lfoPanel.groupWidget(lfoPanelX, lfoPanelY, sliderWidth, lfoPanelH, "LFO", lfo_widget_r, lfo_widget_g, lfo_widget_b, lfo_widget_a );
  lfoSelect.combobox(lfoPanelX+sliderPad, lfoPanelY+sliderPad, .62*sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nLFO, 2, 1, 1, "Select LFO type" );
  modulatorDisplay.create_mod_window(lfoPanelX+.62*sliderWidth, lfoPanelY+sliderPad, .2*sliderWidth - sliderPad, sliderHeight, wR, wG, wB, wA);

  smoothsize = 0.03*sliderWidth;
  lfoSmoothButton.selectionButton(lfoPanelX+.62*sliderWidth+.2*sliderWidth-sliderPad-smoothsize, lfoPanelY+sliderPad+1, smoothsize, smoothsize, "",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Smoothen LFO.");
  lfoResetButton.selectionButton(lfoPanelX+sliderPad+.8*sliderWidth, lfoPanelY+sliderPad, .2*sliderWidth-2*sliderPad, sliderHeight, "MIDI",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Reset LFO phase on incoming MIDI note.");
  modulationFactor.sliderWidget(lfoPanelX+sliderPad, lfoPanelY+3.5*sliderPad+2*sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Modulation Range", wR, wG, wB, wA, 1, 0, 4, 1, "", 0, "Modulation range");
  lfoFrequency.sliderWidget(lfoPanelX+sliderPad, lfoPanelY+2.5*sliderPad+sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Rate", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "LFO rate");
  tempoLFOButton.selectionButton(lfoPanelX+sliderPad + .8*sliderWidth, lfoPanelY+2.5*sliderPad+sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Tempo",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Synchronize to tempo");
  centeredLFOButton.selectionButton(lfoPanelX+sliderPad + .8*sliderWidth, lfoPanelY+3.5*sliderPad+2*sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Center",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Centered");
  env1LFO.selectionButton(lfoPanelX + baseRight - 2*toggleOffset, lfoPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN1", env1button_color_r, env1button_color_g, env1button_color_b, env1button_color_a, "Enable Envelope 1 for LFO manipulation.");
  env1LFO.hoverType = 3;
  env2LFO.selectionButton(lfoPanelX + baseRight - 1*toggleOffset, lfoPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN2", env2button_color_r, env2button_color_g, env2button_color_b, env2button_color_a, "Enable Envelope 2 for LFO manipulation.");
  env2LFO.hoverType = 4;
  dynamicLFOButton.selectionButton(lfoPanelX + baseRight, lfoPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "DYN", dynbutton_color_r, dynbutton_color_g, dynbutton_color_b, dynbutton_color_a, "Enable dynamic LFO manipulation.\n\nWhen activated, the gain responds to changes in the dynamic variable.");  
  dynamicLFOButton.hoverType = 2;
  
  fbPanelX = masterPanelX;
  fbPanelY = lfoPanelY + lfoPanelH + sliderHeight - .5*sliderPad;
  fbPanelH = buttonHeight+sliderHeight*2;
  postTextLoc = feedbackPanel.groupWidget(fbPanelX, fbPanelY, sliderWidth, buttonHeight+sliderHeight*2+1*sliderPad, "Feedback", wR, wG, wB, wA );
  feedbackActive.selectionButton(postTextLoc + .015 * sliderWidth, fbPanelY-buttonHeight, .1*sliderWidth-2*sliderPad, buttonHeight, "A",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Enable global feedback.\n\nBe careful. While the total feedback amount is limited,\nthe sounds produced can be quite horrible.\n");
  env1FB.selectionButton(fbPanelX + baseRight - 3*toggleOffset, fbPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN1",  env1button_color_r, env1button_color_g, env1button_color_b, env1button_color_a, "Enable Envelope 1 for feedback manipulation.");
  env1FB.hoverType = 3;
  env2FB.selectionButton(fbPanelX + baseRight - 2*toggleOffset, fbPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "EN2",  env2button_color_r, env2button_color_g, env2button_color_b, env2button_color_a, "Enable Envelope 2 for feedback manipulation.");  
  env2FB.hoverType = 4;
  dynamicFeedback.selectionButton(fbPanelX + baseRight - toggleOffset, fbPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "DYN",  dynbutton_color_r, dynbutton_color_g, dynbutton_color_b, dynbutton_color_a, "Enable dynamic feedback manipulation.\n\nWhen activated, the feedback responds to changes in the dynamic\nvariable (shown with the yellow curve). This value changes based\non the settings set in the dynamics panel. It is either modulated\nby an attack/decay mechanism based on thresholding the input RMS\nvalue, or directly set to some function of the RMS value (RMS mode).");
  dynamicFeedback.hoverType = 2;
  lfoFeedback.selectionButton(fbPanelX + baseRight, fbPanelY-buttonHeight, toggleWidth-2*sliderPad, buttonHeight, "LFO", lfobutton_color_r, lfobutton_color_g, lfobutton_color_b, lfobutton_color_a, "Enable dynamic feedback manipulation.\n\nWhen activated, the feedback responds to changes in the LFO.");
  lfoFeedback.hoverType = 1;
  feedbackAmount.sliderWidget(fbPanelX+sliderPad, fbPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, "Feedback amount", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Feedback amount");
  feedbackDelay.sliderWidget(fbPanelX+sliderPad, fbPanelY+2*sliderPad+sliderHeight, sliderWidth-2*sliderPad- 3*mulWidth-3*mulPad, sliderHeight, "Feedback delay", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Feedback delay");
  feedbackDelay_x8_1.selectionButton(fbPanelX-sliderPad+sliderWidth-mulWidth, fbPanelY+2*sliderPad+sliderHeight, mulWidth, sliderHeight-4, "x16",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 16");
  feedbackDelay_x8_2.selectionButton(fbPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, fbPanelY+2*sliderPad+sliderHeight, mulWidth, sliderHeight-4, "x8",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 8"); 
  feedbackDelay_x8_3.selectionButton(fbPanelX-sliderPad+sliderWidth-3*mulWidth-2*mulPad, fbPanelY+2*sliderPad+sliderHeight, mulWidth, sliderHeight-4, "x6",  selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Multiply value by 6");
  
  finalSize = fbPanelY + fbPanelH + sliderHeight - .5*sliderPad + yOffset;
  
  env1GainButton.style = 2;
  env2GainButton.style = 2;
  env1GainButton.style = 2;
  env2GainButton.style = 2;
  env1FilterButton.style = 2;
  env2FilterButton.style = 2;
  env1Filter2Button.style = 2;
  env2Filter2Button.style = 2;
  env1Morph.style = 2;
  env2Morph.style = 2;
  env1LFO.style = 2;
  env2LFO.style = 2;
  env1FB.style = 2;
  env2FB.style = 2;
  feedbackActive.style = 2;
  
  dynamicGainButton.style = 2;
  lfoGainButton.style = 2;
  dynamicFilterButton.style = 2;
  lfoFilterButton.style = 2;
  dynamicFilterButton2.style = 2;
  lfoFilterButton2.style = 2;
  keyFollow1.style = 2;
  keyFollow2.style = 2;
  pitchFollow1.style = 2;
  pitchFollow2.style = 2;
  dynamicFeedback.style = 2;
  lfoFeedback.style = 2;
  bypassFilter1.style = 2;
  bypassFilter2.style = 2;
  agcButton.style = 2;
  force_mono.style = 2;
  globalbypass.style = 2;
  legacySliders.style = 2;
  dynamicMorph.style = 2;
  lfoMorph.style = 2;
  dynamicLFOButton.style = 2;
  
  scrollbar = gfx_h < finalSize;
);

function rescaleToFit()
(
  !rescale_factor ? rescale_factor = 1;
  rescale_factor != 1 ? rescale_factor = 1 : rescale_factor *= gfx_h / finalSize;
    
  setupGUI();
);

// Initialize the splines
initGUI();

function distort(s)
  global(window1.evalDistAudio, window2.evalDistAudio, rc_filter.evalRC2)
  local(os)
  global(slider55, slider56, dynval, distortionDynamics)
  ( 
    ( slider56 == 0 ) ? (
      os = s; 
      s = ( s > 0 ) ? s = window1.evalDistAudio(s) : ( s = -window2.evalDistAudio(-s); );
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 1 ) ? ( 
      os = s;
      s = tanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 2 ) ? (
      os = s;
      s = fasttanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 4 ) ? (
      os = s;
      s = sin(2*$pi*s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 5 ) ? (
      os = s;
      s = actual_tanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    );

    s
  );
  
function distortderiv(s)
  global(window1.evalDiff, window2.evalDiff, rc_filter.evalRC2)
  local(th)
  global(slider56, dynval)
  (
    ( slider56 == 0 ) ? (
      s = ( s > 0 ) ? s = window1.evalDiff(s) : ( s = -window2.evalDiff(-s); );
    ) : ( slider56 == 1 ) ? (
      th = tanh(s);
      s = 1.0 - th*th;
    ) : ( slider56 == 2 ) ? (
      th = fasttanh(s);
      s = 1.0 - th*th;
    );
    (1.0-dynval) + dynval * s
  );  

//---------------------------
// Filter usage section
//--------------------------- 
function evalRC(input)
  instance(len, v0, v1, a1, c)
  local(output, tmp)
  global(srate)
  (
    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    tmp = v1;

    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    output = (tmp+v1)*0.5;
  );

function eval303(input)
  local(y0, s0, s)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4
            b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  global()
  (
    s = (z0*wc3 + z1*a20 + z2*c2 + z3*c3) * b; // *b was missing in prev
    y4 = (g*input + s)/(1 + g*k);
    
    y0 = max(-1,min(1,(input - k*y4)));
    //y0 = fasttanh((distort(input) - k*y4));
 
    y1 = b * ( y0*b0 + z0*a0 + z1*a1 + z2*a2 + z3*a3 );     // #OK
    y2 = b * (y0*b10 + z0*a10 + z1*a11 + z2*a12 + z3*a13);  // #OK
    y3 = b * (y0*b20 + z0*a20 + z1*a21 + z2*a22 + z3*a23);  //
    y4 = g*y0 + s;
    
    z0 += 4*wc*(y0 - y1   + y2);
    z1 += 2*wc*(y1 - 2*y2 + y3);
    z2 += 2*wc*(y2 - 2*y3 + y4);
    z3 += 2*wc*(y3 - 2*y4);
    
    A*y4;
  );

function evalmoog(input)
  local(x)
  global()
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    // Process input
    x = input - r*y4;
    
    // Four cascaded onepole filters (bilinear transform)
    y1= x*p +  oldx*p - k*y1;
    y2=y1*p + oldy1*p - k*y2;
    y3=y2*p + oldy2*p - k*y3;
    y4=y3*p + oldy3*p - k*y4;
    
    // Clipper band limited sigmoid
    y4-=(y4*y4*y4)/6.;
    oldx = x; oldy1 = y1; oldy2 = y2; oldy3 = y3;
    
    y4;
  );

  //filter_karlsen
function evalkarlsen(b_v, dist)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  ( 
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    dist ? b_v = distort(b_v);
    b_v     = min(max(b_v, 0),1);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = b_aflt4;
  );
 
  //filter_karlsen
function evalkarlsen_sat(b_v, dist)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    // for nice low sat, or sharper type low deemphasis saturation, one can use a onepole shelf before the filter.
    b_lfcut = .001;
    b_lf    = b_lf + ((-b_lf + b_v) * b_lfcut); // b_lfcut 0..1
    b_lfhp  = b_v - b_lf;
    b_v     = b_lf + (b_lf1hp * ((b_lfgain*0.5)+1)); 
  
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    dist ? b_v = distort(b_v);
    b_v     = min(max(b_v, 0),1);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = 4*b_aflt4;
  );
  
function evaldualfilt(sample, dist)
  local(out, fbs, dd)
  global(distort)
  instance(fb, f, d0, d1)
  (
    dd = d0 - d1;
    dist ? dd = distort(dd);
    fbs = fb * .5*(dd + (d0-d1) + 0.15 * out );
    fbs = max(-2, min(2, fbs));
    d0  = d0 + f * (sample - d0 + fbs );
    d1  = d1 + f * ( d0 - d1 );
    dd = d1;
    dist ? dd = distort(dd);
    out = dd*0.9 + d1*0.1;
  );
  
function evaldualfiltHP(sample, dist)
  local(out, hp, bp, fbs, dd)
  global(distort)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    dd  = bp;
    dist ? dd = distort(dd);
    fbs = fb * .5*(dd + (d0-d1) + 0.15 * out );
    fbs = max(-2, min(2, fbs));
    d0  = d0 + f * ( hp + fbs );
    d1  = d1 + f * ( d0 - d1 );
    dd  = hp;
    dist ? dd  = distort(dd);
    out = dd*0.9 + hp*0.51;
  );
  
function evaldualfiltBP(sample, dist)
  local(out, hp, bp, fbs, dd)
  global(distor)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    dd  = bp;
    dist ? dd = distort(dd);
    fbs = fb * (.6*dd + .4*(d0-d1) + 0.15 * out );
    fbs = max(-2, min(2, fbs));
    d0  = d0 + f * ( hp + fbs );
    d1  = d1 + f * ( d0 - d1 );
    dd  = bp;
    dist ? dd = distort(dd);
    
    out = dd*.7 + bp*0.3 + 0.05*hp + 0.05*d1;
  );
  
function evalfancymoog(y0)
  local(S0, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3                    
        )
  global()
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, S1)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      /*WS0 = distort(S0);
      gJ0 = g*distortderiv(S0);

      WS1 = distort(S1);
      gJ1 = g*distortderiv(S1);
      
      WS2 = distort(S2);
      gJ2 = g*distortderiv(S2);
      
      WS3 = distort(S3);
      gJ3 = g*distortderiv(S3);
      
      WS4 = distort(S4);
      gJ4 = g*distortderiv(S4);*/
      WS0 = actual_tanh(S0);
      gJ0 = g*(1-WS0*WS0);
      
      WS1 = actual_tanh(S1);
      gJ1 = g*(1-WS1*WS1);
      
      WS2 = actual_tanh(S2);
      gJ2 = g*(1-WS2*WS2);
      
      WS3 = actual_tanh(S3);
      gJ3 = g*(1-WS3*WS3);
      
      WS4 = actual_tanh(S4);
      gJ4 = g*(1-WS4*WS4);
       
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );

      // Jacobian subexpressions
      t2 = gJ2*gJ3;
      t3 = gJ2*gJ4;
      t4 = gJ3*gJ4;
      t5 = gJ2*gJ3*gJ4;
      t6 = gJ1*gJ2;
      t7 = gJ1*gJ3;
      t8 = gJ1*gJ4;
      t9 = gJ1*gJ2*gJ3;
      t10 = gJ1*gJ2*gJ4;
      t11 = gJ1*gJ3*gJ4;
      t12 = gJ1*gJ2*gJ3*gJ4;
      t13 = gJ0*gJ1*gJ2*gJ3*k;
      t14 = gJ1+gJ2+gJ3+gJ4+t2+t3+t4+t5+t6+t7+t8+t9+t10+t11+t12+t13+1.0; 
      t15 = 1.0/t14;
      t16 = gJ2+1.0;
      t17 = gJ3+1.0;
      t18 = gJ1+1.0;
      
      // Jacobian
      A0_0_0 = t15*(gJ2+gJ3+gJ4+t2+t3+t4+t5+1.0);
      A0_0_1 = -gJ0*gJ2*gJ3*k*t15;
      A0_0_2 = -gJ0*gJ3*k*t15*t16;
      A0_0_3 = -gJ0*k*t15*t16*t17;
      A0_1_0 = t15*(gJ1+t7+t8+t11);
      A0_1_1 = t15*(gJ1+gJ3+gJ4+t4+t7+t8+t11+1.0);
      A0_1_2 = -gJ0*gJ1*gJ3*k*t15;
      A0_1_3 = -gJ0*gJ1*k*t15*t17;
      A0_2_0 = t15*(t6+t10);
      A0_2_1 = t15*(gJ2+t3+t6+t10);
      A0_2_2 = t15*(gJ1+gJ2+gJ4+t3+t6+t8+t10+1.0);
      A0_2_3 = -gJ0*gJ1*gJ2*k*t15;
      A0_3_0 = gJ1*gJ2*gJ3*t15;
      A0_3_1 = gJ2*gJ3*t15*t18;
      A0_3_2 = gJ3*t15*t16*t18;
      A0_3_3 = t15*t16*t17*t18;
      
      // Newton Raphson update
      //y1 = y1 - ( A0_0_0 * F1 + A0_1_0 * F2 + A0_2_0 * F3 + A0_3_0 * F4 );
      //y2 = y2 - ( A0_0_1 * F1 + A0_1_1 * F2 + A0_2_1 * F3 + A0_3_1 * F4 );
      //y3 = y3 - ( A0_0_2 * F1 + A0_1_2 * F2 + A0_2_2 * F3 + A0_3_2 * F4 );
      //y4 = y4 - ( A0_0_3 * F1 + A0_1_3 * F2 + A0_2_3 * F3 + A0_3_3 * F4 );
      y1 = y1 - ( A0_0_0 * F1 + A0_0_1 * F2 + A0_0_2 * F3 + A0_0_3 * F4 );
      y2 = y2 - ( A0_1_0 * F1 + A0_1_1 * F2 + A0_1_2 * F3 + A0_1_3 * F4 );
      y3 = y3 - ( A0_2_0 * F1 + A0_2_1 * F2 + A0_2_2 * F3 + A0_2_3 * F4 );
      y4 = y4 - ( A0_3_0 * F1 + A0_3_1 * F2 + A0_3_2 * F3 + A0_3_3 * F4 );
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalfancymoog_noJac(y0)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4)
  global()
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      WS0 = actual_tanh(S0);
      WS1 = actual_tanh(S1);
      WS2 = actual_tanh(S2);
      WS3 = actual_tanh(S3);
      WS4 = actual_tanh(S4);
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );
     
      // Newton Raphson update (assuming derivatives 0)
      y1 = y1 - F1;
      y2 = y2 - F1 - F2;
      y3 = y3 - F3;
      y4 = y4 - F4;
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalvowel(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;
    
    d2yC = d1yC;
    d1yC = outC;
    
    out  = amp1 * outA + amp2 * outB + amp3 * outC;
  );
  
function evalsai0(sample, dist)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC, dd)
  global()
  (
    dist ? sample = distort(sample);
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;

    d2yC = d1yC;
    d1yC = outC - .01 * ( outA - outB );
    
    dd   = outC-outB;
    dist ? dd = distort(dd);
    
    out  = outA-.6*dd;
    out = 0.4*out;
  );  
  
function evalmodulator(sample, dist)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp, d2x2, d1x2
   )
  local(out, dS, outA, outB, modo, dd1, dd2)
  global()
  (
    // Modulator LP
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB; 
    d2yB = d1yB;
    d1yB = outB;
    d2x = d1x;
    d1x = sample;
    
    modo = sample * outB;
    outA = Ab0 * modo + Ab1 * d1x2 + Ab2 * d2x2 - Aa1 * d1yA - Aa2 * d2yA;    
    d2yA = d1yA;
    d1yA = outA;    
    d2x2 = d1x2;
    d1x2 = modo;
    
    dd1  = sample+amp*outA;
    dist ? dd1 = distort(dd1);
    dd2  = outB * dd1*2;
    dist ? dd2 = distort(dd2);
    
    out  = dd2;
  );
  
function evalrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local(out)
  global()
  (
    out = b0 * sample + b1 * d1x + b2 * d2x - a1 * d1y - a2 * d2y;
    
    d2x = d1x;
    d1x = sample;
    
    d2y = d1y;
    d1y = out;
    out;
  );

function evalphaserOTA(sample, jnk)
  global()
  local(w)
  instance(C1, C2, dw, dx, sq)
  (
    sample = sample - sq * jnk;
    w = dw + C1 * ( C2 * ( sample + dx + dw ) ); // removed distort here (was causing problems in a lot of cases)
    dx = sample;
    dw = w;
    
    w + sample
  );
    
function evalphaserFET(sample)
  global()
  local(w, u, I_ds, out)
  instance(C1, C2, dw, IDSSdivVpSq, thresh)
  (
    u = sample - dw;
    
    I_ds = ( u < thresh ) ? (
      IDSSdivVpSq * 2 * thresh * u - u*u;
    ):(
      IDSSdivVpSq * thresh * thresh * u;
    );
    
    w = dw + C1 * ( C2 * u + I_ds );
    w = min(3, max(-3, w));
    
    out = sample - w - dw;
    dw = w;
    
    out
  );

// One-pole zero-delay LP filter
function zdf(G, x)
  global()
  local()
  instance(tpt, y)
  (
    y = G*x + tpt.s;
    tpt.TPT_step(G, x-y);
  );

function eval_MS20lin(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    y  = a0 * x + a1 * s1 + a2 * s2;
    ky = k*y;
    onepole1.zdf(g, x - ky);
    onepole2.zdf(g, onepole1.y + ky);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20linBP(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    y  = -a0 * x + a1 * (s1 + x) + a2 * s2;
    ky = k*y;
    onepole1.zdf(g, -x - ky);
    onepole2.zdf(g, onepole1.y + ky + x);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20linHP(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    y  = a1 * (s1 - x) + x + s2;
    ky = k*y;
    onepole1.zdf(g, - ky);
    onepole2.zdf(g, onepole1.y + ky - x);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );    
  
/* Older version. No longer used. */  
function eval_MS20(x, dist)
  global()
  local(ky, y, fy, fyprime, distky, ddistky)
  instance(s1, s2, G, Gsq, Gsqk, Gk, k, onepole1, onepole2)
  (
    //fyprime = 1.0 - d/dy(Gsq*x*k*distort(y)) - d/dy(G*k*distort(y));
    //x = distort(x);

    loop(3,
      ky = k*y;
      dist ? distky = distort(ky) : distky = ky;
      dist ? ddistky = distortderiv(ky) : ddistky = ky;
      fy = y - Gsq*x + Gsq*distky - G * S1 - G*distky - S2;
      fyprime = 1.0 + Gsq*ddistky - G*ddistky;
      y = y - fy/fyprime;
    );
    
    //y = (Gsq*x + G*S1 + S2)/(1+Gsqk-Gk);
    
    ky = k*y;
    onepole1.zdf(g, x - distky);
    onepole2.zdf(g, onepole1.y + distky);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20_nonlin(x)
  global()
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      gky2    = k*y2;
      dgky2   = 1 - ( abs(gky2) > 1 );  // Note that the chain ruled k part is already in the eqs (hk)
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
  );  
  
function eval_MS20_nonlin_FM(x)
  global()
  local(mag, hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs, f)
  (
    mag   = f*5;
      
    gkd2  = k * sin(mag*d2); // g(k*d2)
    gkd2  = mag * k * cos(mag*d2);
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*sin(mag*y2); //k*y2;
      dgky2   = mag * k * cos(mag*y2);
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    y2
  );    
  
function eval_MS20_nonlin_mod(x)
  global()
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2-2*k*(y2*y2-y2*y2*y2)-.1*k*y1;
      dgky2   = 1 - ( abs(gky2) > 1 );   // Note that the chain ruled k part is already in the eqs (hk)
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    y2
  );
  
function eval_MS20_nonlinBP(x)
  global()
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
     
    atanterm1 = atan(d1 +  x + gkd2);
    atanterm2 = atan(d1 - d2 + x + gkd2);
    hk    = h * k;
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2;
      dgky2   = 1 - ( abs(gky2) > 1 );   // Note that the chain ruled k part is already in the eqs (hk)
      
      gky2    = max(-1,min(1,gky2));
      
      sig1    = y1 + x + gky2;
      sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig1));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig2));
           
      sfunsq  = sig1*sig1;
      sub3    = (2*(sfunsq + 1));
      sub3i   = 1/sub3;
      
      sub4sq  = sig2*sig2;
      sub5    = 1 / (2*(sub4sq + 1));
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1 - (hk*dgky2 - h)*sub5;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    y2
  );  
  
function eval_MS20_nonlinHP(x)
  global()
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2px, gky2px, dgky2px, sub1sq, sub1i sub4sq, sub4i, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2px  = k*(d2 + x);    // g(k*(d2 + x))
    gkd2px  = max(-1,min(1,gkd2px));
    hk      = h * k;
    
    atanterm1 = atan(d1 + gkd2px);
    atanterm2 = atan(d1 - d2 - x + gkd2px);
    
    loop(5,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      
      gky2px  = k*(x + y2);   // g(k*(x + y2))

      // Clipper (g(y))
      gky2px  = max(-1,min(1,gky2px));
      
      // Derivative
      dgky2px = 1 - ( abs(gky2px) > 1 );   // Note that the chain ruled k part is already in the eqs (hk)
      
      sig1    = y1 + gky2px;
      sig2    = x + y2 - sig1;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig1));
      f2      = y2 - d2 - hh*(atanterm2 - atan(sig2));
      
      sub1sq  = sig1*sig1;
      sub1i   = 1/(2*(sub1sq + 1));
      sub4sq  = sig2*sig2;
      sub4i   = 1/(2*(sub4sq + 1));
      
      a       = h*sub1i + 1;
      b       = hk*dgky2px*sub1i;
      c       = -h*sub4i;
      d       = 1 - (hk*dgky2px - h)*sub4i;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    y2+x
  );    

// Checked for effect of tanh vs true_tanh
function eval_ssm_nonlin_cheap(Ui)
  global()
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distk2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm, term
        )
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    term        = D0 + D1; term = term + term*term*term;
    distd0d1    = term / ( 1 + abs(term) );
    
    term        = D1 + D2; term = term + term*term*term;
    distd1d2    = term / ( 1 + abs(term) );
    
    term        = D2 + D3; term = term + term*term*term;
    distd2d3    = term / ( 1 + abs(term) );
    
    term        = K2 * D3; term = term + term*term*term;
    distk2d3    = term / ( 1 + abs(term) );
    
    term        = (D0 + Di - distk2d3); term = term + term*term*term;
    distd0difb  = term / ( 1 + abs(term) );
    
    loop(3,
      term = U0 + U1; term = term + term*term*term;
      distu0u1    = term / ( 1 + abs(term) );
      term = U1 + U2; term = term + term*term*term;
      distu1u2    = term / ( 1 + abs(term) );
      term = U2 + U3; term = term + term*term*term;
      distu2u3    = term / ( 1 + abs(term) );
      term = K2 * U3; term = term + term*term*term;
      fbterm      = term / ( 1 + abs(term) );
      term        = U0 + Ui - fbterm; term = term + term*term*term;
      distu0uifb  = term / ( 1 + abs(term) );
    
      ddistu0uifb = 1 - distu0uifb*distu0uifb;
      ddistu0u1   = 1 - distu0u1*distu0u1;
      ddistu1u2   = 1 - distu1u2*distu1u2;
      ddistu2u3   = 1 - distu2u3*distu2u3;
      dfbterm     = 1 - fbterm*fbterm;
    
      f0 = -D0 + U0 + hhitau * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );


function eval_ssm_nonlin(Ui)
  global()
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm)
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    distd0d1    = actual_tanh(D0 + D1);
    distd1d2    = actual_tanh(D1 + D2);
    distd2d3    = actual_tanh(D2 + D3);
    distd0difb  = actual_tanh(D0 + Di - actual_tanh(K2*D3));
    
    loop(3,
      distu0u1    = actual_tanh(U0 + U1);
      distu1u2    = actual_tanh(U1 + U2);
      distu2u3    = actual_tanh(U2 + U3);
      fbterm      = actual_tanh(K2 * U3);
      distu0uifb  = actual_tanh(U0 + Ui - fbterm);
    
      ddistu0uifb = 1 - distu0uifb*distu0uifb;
      ddistu0u1   = 1 - distu0u1*distu0u1;
      ddistu1u2   = 1 - distu1u2*distu1u2;
      ddistu2u3   = 1 - distu2u3*distu2u3;
      dfbterm     = 1 - fbterm*fbterm;
    
      f0 = -D0 + U0 + hhitau * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );

function ftanh2(x)
  global()
  local(sgn, ax)
  (
    sgn = sign(x);
    ax = abs(x);
//    sgn*(-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*ax)*ax)*ax)/(.2464845986383725+(.060934719706049+(.1086202599228572+.02874707922475963*ax)*ax)*ax)
    sgn*(-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*ax)*ax)*ax)/(.2464845986383725+(.0609347197060491+(.1086202599228572+.02874707922475963*ax)*ax)*ax)
  );

function cmosFun(x)
  global()
  local(absterm, signterm, taa, tab, tasc)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;
  
    absterm = abs(x); signterm = sign(x);
    
    tasc * (1-tanh( tab + taa*absterm )) * signterm;
  );

function cmosDeriv(fun)
  global()
  local(absterm, signterm, taa, tab, tasc, taadsc, taatasc)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;
    taadsc  = taa/tasc;
    taatasc = taa*tasc;
    
    (taadsc*fun*fun - taatasc)
  );
  
function cmosFun2(x)
  global()
  local(absterm, signterm, taa, tab, tasc, t)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;

    absterm = abs(x); signterm = sign(x);
    
    t = tasc * x - tasc * (1-tanh( tab + taa*absterm ))*signterm;
  );

function cmosDeriv2(fun)
  global()
  local(absterm, signterm, taa, tab, tasc, taadsc, taatasc)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;
    taadsc  = taa/tasc;
    taatasc = taa*tasc;
    
    tasc - (taadsc*fun*fun - taatasc)
  );  
  
function eval_broken_nonlin_LP(x)
  global(slider54, srate)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    // taa = 7.5*1.5 = 11.25
    // tab = -8
    // tasc = 4.8/7.5 = 0.6
    // Empirical cmos func tasc  * ( 1.0 - tanh(taa*x+tab) )
  
    gkd2  = cmosFun(k*d2); // g(k*d2)
    hk    = h*k;
    
    atanterm1 = cmosFun(d1 -  x + gkd2);
    atanterm2 = cmosFun(d1 - d2 + gkd2);
    
    // BP
    //atanterm1 = cmosFun(d1 +  x + gkd2);
    //atanterm2 = cmosFun(d1 - d2 + x + gkd2);
    
    loop(3,
      gky2    = cmosFun(k*y2);
      dgky2   = cmosDeriv(gky2);
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x  + gky2;
      
      // BP
      //sig1    = y1 + x + gky2;
      //sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + cmosFun(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + cmosFun(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
  );
  
/* This filter is no longer used. Too unstable */  
function eval_broken_nonlin_BP(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = cmosFun(k*d2); // g(k*d2)
    gkd2  = min(3,max(-3,gkd2)); 
     
    atanterm1 = cmosFun(d1 +  x + gkd2);
    atanterm2 = cmosFun(d1 - d2 + x + gkd2);
    hk    = h * k;
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = min(3,max(-3,cmosFun(k*y2)));
      dgky2   = cmosDeriv(gky2);
      
      sig1    = y1 + x + gky2;
      sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + cmosFun(sig1));
      f2      = y2 - d2 - hh*(atanterm2 + cmosFun(sig2));
           
      sfunsq  = sig1*sig1;
      sub3    = (2*(sfunsq + 1));
      sub3i   = 1/sub3;
      
      sub4sq  = sig2*sig2;
      sub5    = 1 / (2*(sub4sq + 1));
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1 - (hk*dgky2 - h)*sub5;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    y2
  );    
  
function eval_wasp_nonlin2(Ui)
  global(slider54, srate)
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm, fb1,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm)
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    // taa = 7.5*1.5 = 11.25
    // tab = -8
    // tasc = 4.8/7.5 = 0.6
    // Empirical cmos func tasc  * ( 1.0 - tanh(taa*x+tab) )
  
    distd0d1    = cmosFun2(D0 + D1);
    distd1d2    = cmosFun2(D1 + D2);
    distd2d3    = cmosFun2(D2 + D3);   
    fb1         = cmosFun2(K2 * D3);
    distd0difb  = cmosFun2(D0 + Di - fb1);
     
    // We desire: a*sc*(tanh(a*|x| + b)**2 - 1)*sign(x)*dabs(x)/dx
    // a dist term squared will be tasc^2 * tanh(tab + taa*abs(x))^2
    // This is one tasc too many, but one taa too little. sign(x)*dabs(x)/dx cancel out (sort of).
    
    loop(3,
      distu0u1    = cmosFun2(U0+U1);
      distu1u2    = cmosFun2(U1+U2);
      distu2u3    = cmosFun2(U2+U3);
      fbterm      = cmosFun2(K2 * U3);
      distu0uifb  = cmosFun2(U0+Ui-fbterm);
        
      ddistu0uifb = cmosDeriv2(distu0uifb);
      ddistu0u1   = cmosDeriv2(distu0u1);
      ddistu1u2   = cmosDeriv2(distu1u2);
      ddistu2u3   = cmosDeriv2(distu2u3);
      dfbterm     = cmosDeriv2(fbterm);
    
      f0 = -D0 + U0 + hhitau * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );
  
// Checked for effect of tanh vs true_tanh
function eval_cem_nonlin(Ui)
  global(slider54, srate)
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm, f0h, ad, bc)
  instance(hh, itau, K2, hhitau, hhitau2, itau2, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout, res, ifdbk)
  (
    ifdbk       = 2*res;
    /*distd0d1    = tanh(D0 + D1);
    distd1d2    = (D1 + D2);
    distd2d3    = (D2 + D3);
    fbterm      = tanh(K2 * D3 - Di * ifdbk);
    distd0difb  = fasttanh(D0 + Di - fbterm);*/
    distd0d1    = tanh(D0 + D1);
    distd1d2    = (D1 + D2);
    distd2d3    = (D2 + D3);
    fbterm      = tanh(K2 * D3 - Di * ifdbk);
    distd0difb  = tanh(D0 + Di - fbterm);
    
    loop(3,
      // All of these had tanh
      /*distu0u1    = fasttanh(U0 + U1);
      distu1u2    = (U1 + U2);
      distu2u3    = (U2 + U3);
      fbterm      = tanh(K2 * U3 - Ui * ifdbk);
      distu0uifb  = fasttanh(U0 + Ui - fbterm);*/
      distu0u1    = tanh(U0 + U1);
      distu1u2    = (U1 + U2);
      distu2u3    = (U2 + U3);
      fbterm      = tanh(K2 * U3 - Ui * ifdbk);
      distu0uifb  = tanh(U0 + Ui - fbterm);
      
      // The factor 16 is to correct for the fact that tanh actually computes 0.25 tanh(4*x).
      // This leads to a derivative given by 1-tanh(4*x)^2, but given that we have stored a term that 
      // has this 0.25, we have to add this factor 4 back and square it.
      ddistu0uifb = 1 - 16*distu0uifb*distu0uifb;
      ddistu0u1   = 1 - 16*distu0u1*distu0u1;
      ddistu1u2   = 1;// - 16*distu1u2*distu1u2;
      ddistu2u3   = 1;// - 16*distu2u3*distu2u3;
      dfbterm     = 1 - 16*fbterm*fbterm;
    
      f0 = -D0 + U0 + hhitau  * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau  * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau  * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau2 * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;           
      g = hhitau2*ddistu2u3;
      h = g + 1;
      f0h = f0*h;
      ad = a*d;
      bc = b*c;
      
      idet = 1.0/(ad*f*h - bc*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0h)*idet;
      U1 = U1 - (a*f*f1*h  + bc*f*f3  - bc*f2*g  - c*f*f0h)*idet;
      U2 = U2 - (ad*f2*h   - a*e*f1*h - bc*e*f3  + c*e*f0h)*idet;
      U3 = U3 - (ad*f*f3   - ad*f2*g  + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );
//  instance(hh, itau, itau2, K2, hhitau, hhitau2, f, rate, Kout)  
  
function eval_ssm_lin(Ui)
  global(slider54, srate)
  local(x3, x4, x5, x8, x9, x10, x12, x16, x17, x18, x19, x20, x21, x22)
  instance(x0, x1, x15, x2, x6, x7, x11, x13, x14, x16, Di, D0, D1, D2, D3, U0, U1, U2, U3, K2)
  (
    x3      = D0*x0;
    x4      = D1*x0;
    x5      = -D1 + x3 + x4;
    x8      = D2*x0;
    x9      = D3*x0;
    x10     = -D3 + x8 + x9;
    x12     = -D2 + x4 + x8;
    x16     = -x3;
    x17     = Di*x0;
    x18     = Ui*x0;
    x19     = K2*x9;
    x20     = -x4;
    x21     = -D0 + x17 + x18 - x19 + x3;
    x22     = -x8;
    
    U0 = x2*(-K2*x10*x11 + x12*x14 + x15*(D0 + x16 - x17 - x18 + x19) - x5*x7);
    U1 = x2*(x10*x14 + x11*x21 - x12*x7 + x15*(D1 + x16 + x20));
    U2 = x2*(-x10*x7 + x11*x5 - x13*x21 + x15*(D2 + x20 + x22));
    U3 = x2*(x11*x12 - x13*x5 + x15*(D3 + x22 - x9) + x21*x6);
    
    D0      = U0;
    D1      = U1;
    D2      = U2;
    D3      = U3;
    Di      = Ui;
    
    U3
  );
  
function eval_cem_lin(Ui)
  global(slider54, srate)
  local(x7, x8, x9, x16, x17, x18, x20, x24, x25, x26, x29, iG)
  instance(K2, res, x0, x1, x2, x3, x4, x5, x6, x11, x12, x13, x14, x15, x19, x27, x22, x23, x28, hh2, hh3
    D0, D1, D2, D3, U0, U1, U2, U3, Di)
  (
    iG      = 2*res;
  
    x7      = D0*x3;
    x8      = D1*x3;
    x9      = -D1 + x7 + x8;
    x16     = D2*x1;
    x17     = D3*x1;
    x18     = -D3 + x16 + x17;
    x20     = D2*x3 - D2 + x8;
    x24     = Di*x3;
    x25     = Ui*x3;
    x26     = -D0 - D3*x19 + iG*x24 + iG*x25 + x24 + x25 + x7;
    x29     = x12*x26;

    U0      = x6*(K2*x20*x23 - x14*x9 - x15*x18*x19 - x26*x27);
    U1      = x6*(x13*x18*x22 - x14*x20 + x26*x28 - x27*x9);
    U2      = x6*(-x0*hh3*x18 - x2*hh2*x29 - x20*x27 + x28*x9);
    U3      = x6*(x1*x15*x20 + x11*x29 - x23*x9 + x5*(D3 - x16 - x17));
    
    D0      = U0;
    D1      = U1;
    D2      = U2;
    D3      = U3;
    Di      = Ui;
    
    U3
  );
  
function pwm_eval(sample)
   instance(len, ilen, c, out, spunk, gain)
   local(s)
   global()
   (
      sample = 8*sample;
      out = this.filter_SVF.eval_linearSVF_LP(abs(sample) < (len-1)*ilen);
      s = len-1;
      loop(ilen-2,
        s -= 1;
        this.filter_SVF.eval_linearSVF_LP(abs(sample) < s*ilen);      
      );
      
      out
   );
   
function pwm_eval_BP(sample)
   instance(len, ilen, c, out, spunk, gain)
   local(s)
   global()
   (
      sample = 8*sample;
      out = this.filter_SVF.eval_linearSVF_BP(abs(sample) < (len-1)*ilen);
      s = len-1;
      loop(ilen-2,
        s -= 1;
        this.filter_SVF.eval_linearSVF_BP(abs(sample) < s*ilen);
      );
      
      out
   );  
   
function bit_eval(sample)
  instance(depth, idepth, res)
  local(s, bass)
  global(testo)
  (  
    res > 0.01 ? 
    (
      bass = this.filter_SVF.eval_linearSVF_LP(sample);
      sample = sample - bass;
    );
    sample = floor( sample * depth + 0.00000002 ) * idepth;
    res > 0.01 ? sample += bass;
    
    sample
  );
  
function muck_eval(sample)
  instance(f, res)
  local(s, bass)
  global()
  (
    bass = this.filter_SVF.eval_linearSVF_LP(sample);
    sample = sample - bass;
    bass = bass * (1+.1*res*rand()*rand()*rand());
    sample = sample + bass;
    
    sample
  );  
  
function evalvowelSVF(sample)
  instance( c, svf1, svf2, svf3, svf4, svf5, svf6, amp1, amp2, amp3 )
  local(outA, outB, outC)
  global()
  (
    outA = this.svf1.eval_linearSVF_peak(sample);
    outB = this.svf2.eval_linearSVF_BP(sample);
    outC = this.svf3.eval_linearSVF_BP(sample);
    
    outA = this.svf4.eval_linearSVF_BP(outA);
    outB = this.svf5.eval_linearSVF_BP(outB);
    outC = this.svf6.eval_linearSVF_BP(outC);
    
    amp1 * outA + amp2 * outB + amp3 * outC;
  );      
        
function evalvowelSVF2(sample)
  instance( c, svf1, svf2, svf3, svf4, svf5, svf6, amp1, amp2, amp3 )
  local(outA, outB, outC)
  global()
  (
    outA = this.svf1.eval_linearSVF_peak(sample);
    outB = this.svf2.eval_linearSVF_BP(sample);
    outC = this.svf3.eval_linearSVF_BP(sample);
    
    outA = this.svf4.eval_linearSVF_LP(outA);
    outB = this.svf5.eval_linearSVF_LP(outB);
    outC = this.svf6.eval_linearSVF_LP(outC);
    
    amp1 * outA + amp2 * outB + amp3 * outC;
  );      
    
function modulon_eval(sample)
  local(mterm)
  global(srate, slider54)
  instance(dt, t, svf, c)
  (
    t = t + dt;
    mterm = ( sin(1.5*t)+sin(.5*t) );
    sample = tanh( sample - tanh( sample*( .5 * mterm ) ) );    
    c = this.svf.eval_linearSVF_LP(sample);
  );    
  
function modulatrix_eval(sample)
  local(mterm)
  global(srate, slider54)
  instance(dt, t, svf, c, reso)
  (
    t = t + dt;
    mterm = ( sin(1.5*t)+sin(.125*t)+2*sin(.5*t) );
    sample = tanh( sample - tanh( sample*( .5 * mterm ) ) );
    
    sample = sample - 1.7*reso*sample * sin(.9999*t);    
    c = this.svf.eval_linearSVF_LP(sample);
  );      
  
function octaver_eval(sample)
  local()
  global(srate, slider54, israte)
  instance(lpsample, flipflopState, flipflopState2, h1, cnt, bal1, bal2, f_est, sidx)
  (
    sidx += 1;
    lpsample = this.svf3.eval_linearSVF_LP( this.svf4.eval_linearSVF_HP( sample ) );
    (lpsample > 0 && h1 < 0 && sidx > 100) ? (
      cnt += 1;
      flipflopState = -flipflopState;
      flipflopState2 = -flipflopState2;
      f_est = .7 * f_est + .3 * ( slider54 / sidx );
      sidx = 0;
      
      /*
      f_est = .005;
      this.svf.init_linearSVF_direct( f_est, 0.2 );
      this.svf2.init_linearSVF_direct( .5*f_est, 0.2 );
      */
    );
    
    cnt > 1 ?
    (
      flipflopState2 = -flipflopState2;
      cnt = 0;
    );
    
    h1 = lpsample;
    
    //sample+this.svf.eval_linearSVF_LP( 2*(sample * flipflopState * (1-bal) + bal * sample * flipflopState2) )
    bal1 * sample + 2*(1-bal1) * ( (1-bal2)*this.svf.eval_linearSVF_LP( sample*flipflopState ) + bal2*this.svf2.eval_linearSVF_LP( sample*flipflopState2 ) );
// lpsample
  );    
  
function octaverUp_eval(sample)
  local(o1, o2)
  global()
  instance(bal1, bal2)
  (    
    //bal1 * sample + 2*(1-bal1) * ( (1-bal2)*this.svf.eval_linearSVF_LP( sample*flipflopState ) + bal2*this.svf2.eval_linearSVF_LP( sample*flipflopState2 ) );
    o1 = 2*abs(sample)-0.5;
    o1 = this.svf1.eval_linearSVF_HP( o1 );
    
    o2 = 2*abs(o1)-0.5;
    o2 = this.svf2.eval_linearSVF_HP( o2 );    
    
    bal1 * sample + (1-bal1) * ( o1 * (1-bal2) + o2 * bal2 )
  );
    
function metallic_eval(sample)
  local()
  instance(t, dt, f, res, sh, sh2, sh3, sh4)
  global()
  (
    t = t + dt;
    //sample = sample * sin(t+3*sh-8*sh4) +  .8*sin(.0001*res*sample*t);
    sample = sample * sin(t+3*sh-8*sh4) + .8*sin(60*res*sample);
    sh4 = sh3;
    sh3 = sh2;
    sh2 = sh;
    sh = sample;  
    
    .25*sample
  );    
    
function frazzle_eval(sample)
  local(rm, o1, o2, ls)
  global()
  instance(t, f, dt, bal2)
  (
    t = t + dt;
    
    ls = this.svf1.eval_linearSVF_LP(sample);
 
    o1 = sin(t)*ls;
    o2 = sin(1000*dt*ls) * (sample*(1-bal2) - o1*bal2);
    
    o2
  );    
    
function eval_wasplin(Ui)
  global()
  local()
  instance(U0, U1, Di, D0, D1, x0, x1, x2, x3, i1)
  (
    U0 = (-D0*x2 - D0*x3 + D0 - 4*D1*x0 - Di*x1 - Ui*x1)*i1;
    U1 = (4*D0*x0 + D1*x2 - D1*x3 + D1 - Di*x3 - Ui*x3)*i1;
    
    D0 = U0;
    D1 = U1;
    Di = Ui;
        
    -U1;
  );
      
function f_g(s)
  local()
  global(slider8)
  instance()
  (
    ( slider8 == 0 ) ? max(-1,min(1,s)) : abs(s) > 1 ? s - .75*sign(s)*(abs(s)-1) : s;
  );
  
function f_dg(s)
  local()
  global(slider8)
  instance()
  (
    ( slider8 == 0 ) ? 1 - 1 * (abs(s)>1) : abs(s) > 1 ? .25 : 1;
  );
      
function eval_MS20_nonlin_tanh(x)
  global()
  local(gd2k, ky2, gky2, dgky2,
    f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
  instance(i, y1, y2, d1, d2, h, hh, k, obs)
  (
    gd2k = f_g(d2*k);
    tanhterm1 = actual_tanh((-d1 + x - gd2k));
    tanhterm2 = actual_tanh((d1 - d2 + gd2k));
    
    loop(4,
      ky2 = k*y2;
      gky2 = f_g(ky2);
      dgky2 = f_dg(ky2);
      
      sig1 = x - y1 - gky2;
      thsig1 = actual_tanh(sig1);
      thsig1sq = thsig1 * thsig1;
      
      sig2 = y1 - y2 + gky2;
      thsig2 = actual_tanh(sig2);
      thsig2sq = thsig2 * thsig2;
      hhthsig1sqm1 = hh*(thsig1sq - 1);
      hhthsig2sqm1 = hh*(thsig2sq - 1);
      
      f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
      f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
      a = -hhthsig1sqm1 + 1;
      b = -k*hhthsig1sqm1*dgky2;
      c = hhthsig2sqm1;
      d = (k*dgky2 - 1)*hhthsig2sqm1 + 1;
      
      norm = 1 / ( a*d - b*c );
      y1 = y1 - ( d*f1 - b*f2 ) * norm;
      y2 = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
  ); 


function eval_MS20_nonlinBP_tanh(x)
  global()
  local(gd2k, ky2, gky2, dgky2,
      f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
  instance(i, y1, y2, d1, d2, h, hh, k, obs)
  (
    gd2k = f_g(d2*k);
    tanhterm1 = actual_tanh(-d1 - x - gd2k);
    tanhterm2 = actual_tanh(d1 - d2 + x + gd2k);
    
    loop(4, 
      ky2 = k*y2;
      gky2 = f_g(ky2);
      dgky2 = f_dg(ky2);
      
      sig1 = -x - y1 - gky2;
      thsig1 = actual_tanh(sig1);
      thsig1sq = thsig1 * thsig1;
      
      sig2 = x + y1 - y2 + gky2;
      thsig2 = actual_tanh(sig2);
      thsig2sq = thsig2 * thsig2;
      
      hhthsig1sqm1 = hh*(thsig1sq - 1);
      hhthsig2sqm1 = hh*(thsig2sq - 1);
      
      f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
      f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
      a = 1 - hhthsig1sqm1;
      b = -k*hhthsig1sqm1*dgky2;
      c = hhthsig2sqm1;
      d = (k*dgky2 - 1)*hhthsig2sqm1 + 1;
      
      norm = 1 / ( a*d - b*c );
      y1 = y1 - ( d*f1 - b*f2 ) * norm;
      y2 = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
  ); 

function eval_MS20_nonlinHP_tanh(x)
  global()
  local(gkd2px, kxpy2, gkxpy2, dgky2px,
    f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
  instance(i, y1, y2, d1, d2, h, hh, k, obs)
  (
  gkd2px = f_g(k*(d2 + x));
  tanhterm1 = actual_tanh(-d1 - gkd2px);
  tanhterm2 = actual_tanh(d1 - d2 - x + gkd2px);
  
  loop(4,
    kxpy2 = k*(x + y2);
    gkxpy2 = f_g(kxpy2);
    dgky2px = f_dg(kxpy2);
  
    sig1 = -y1 - gkxpy2;
    thsig1 = actual_tanh(sig1);
    thsig2sq = thsig2 * thsig2;
  
    sig2 = -x + y1 - y2 + gkxpy2;
    thsig2 = actual_tanh(sig2);
    thsig2sq = thsig2 * thsig2;
  
    hhthsig1sqm1 = (thsig1sq - 1);
    hhthsig2sqm1 = (thsig2sq - 1);
  
    f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
    f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
    a = -hhthsig1sqm1 + 1;
    b = -k*hhthsig1sqm1*dgky2px;
    c = hhthsig2sqm1;
    d = (k*dgky2px - 1)*hhthsig2sqm1 + 1;
    
    norm = 1 / ( a*d - b*c );
    y1 = y1 - ( d*f1 - b*f2 ) * norm;
    y2 = y2 - ( a*f2 - c*f1 ) * norm;
  );
    
  d1 = y1;
  d2 = y2;
  
  y2+x
);     
      
function bufferFun(sample, delay1, delay2)
  global()
  local(h)
  instance()
  (
    h = 5;
  );

function specialGraphics()
  local(specialValue)
  global(showFilterFFT)
  instance()
  ( 
    showFilterFFT = 1;
    specialValue = 0;
  
    ( this.filtertype == 31 ) ?
    (
      showFilterFFT = 0;
    ) : ( this.filtertype == 66 || this.filtertype == 72 ) ? 
    (
      specialValue = this.modulon.f;
    ) : ( this.filtertype == 73 ) ? 
    (
      specialValue = this.modulon.f;
    ) : ( this.filtertype == 76 || this.filtertype == 77 || this.filtertype == 78 || this.filtertype == 60 || this.filtertype == 61 || this.filtertype == 62 || this.filtertype == 67 || this.filtertype == 68 || this.filtertype == 74 || this.filtertype == 75 || this.filtertype == 82 || this.filtertype == 83 ) ?
    (
      showFilterFFT = 0;
    ) : ( this.filtertype == 70 ) ?
    (
      specialValue = this.frazzle.dtref;
    ) : ( this.filtertype == 69 ) ? 
    (
      showFilterFFT = 0;
      specialValue = .125*this.metallic.dtref;
    );
    
    specialValue
  );

  //global(window1.evalDist, window2.evalDist, filter_303.eval303)
function process(sample, dist)
  local(
            /* Initialized immediately, hence no instance history */
            os, os1, os2, ys1, flt, reso, lp, diff, vib_delay, vibratoSinTerm, bp
        )
  global(pregain, clipInput, clipOutput
        /* This block is part of the cruft that is filter 16 and 17 :( */
        filter_delay1,              filter_delay2,
        filter_delay3,              filter_delay4,
        filter_delay5,              filter_delay6,
        filter_delay7,              filter_delay8,
        filter_delay1.readBuffer,   filter_delay2.readBuffer, 
        filter_delay1.updateBuffer, filter_delay2.updateBuffer
        filter_delay3.readBuffer,   filter_delay4.readBuffer, 
        filter_delay3.updateBuffer, filter_delay4.updateBuffer
        filter_delay5.readBuffer,   filter_delay6.readBuffer, 
        filter_delay5.updateBuffer, filter_delay6.updateBuffer
        filter_delay7.readBuffer,   filter_delay8.readBuffer, 
        filter_delay7.updateBuffer, filter_delay8.updateBuffer
        
        hist1, hist2, hist3, hist4
  )
  instance()
  (
    sample+=0.00000001; // DeNorm fix

    // Optional clipping
    ( clipInput ) ? sample = min(1,max(-1,sample));
    
    ( this.filtertype == 0 ) ? (
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 1 ) ? (
      sample = this.rc_filter.evalRC(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 2 ) ? (
      dist ? sample = distort(sample);
      sample = this.filter_303.eval303(sample);
    ) : ( this.filtertype == 3 ) ? (
      dist ? sample = distort(sample);
      sample = this.filter_vowel.evalvowel(sample);
    ) : ( this.filtertype == 4 ) ? (
      sample = this.filter_karlsen.evalkarlsen(sample, dist);
    ) : ( this.filtertype == 5 ) ? (
      sample = this.filter_karlsen_sat.evalkarlsen_sat(sample, dist);
    ) : ( this.filtertype == 6 ) ? (
      sample = this.filter_dualfilt.evaldualfilt(sample, dist);
    ) : ( this.filtertype == 7 ) ? (
      sample = this.filter_dualfiltHP.evaldualfiltHP(sample, dist);
    ) : ( this.filtertype == 8 ) ? (
      sample = this.filter_dualfiltBP.evaldualfiltBP(sample, dist);
    ) : ( this.filtertype == 9 ) ? (
      sample = (1/pregain) * this.filter_fancymoog.evalfancymoog(-40*sample)/40;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 10 ) ? (
      sample = (1/pregain) * this.filter_fancymoog.evalfancymoog_noJac(-40*sample)/40;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 11 ) ? (
      sample = this.filter_notch.evalrbj(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 12 ) ? (
      sample = this.filter_sai0.evalsai0(-sample, dist);
    ) : ( this.filtertype == 13 ) ? (
      sample = this.filter_modulator.evalmodulator(sample, dist);
    ) : ( this.filtertype == 14 ) ? (
      /* Have a closer look at jnk here. Behaviour modified. */
      os = sample;
      sample = this.filter_phaser.evalphaserOTA(sample, this.jnk);
      sample = this.filter_phaser2.evalphaserOTA(sample, 0);
      sample = this.filter_phaser3.evalphaserOTA(sample, 0);
      sample = this.filter_phaser4.evalphaserOTA(sample, 0);
      this.jnk = sample;
      sample = (os + sample)*.5;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 15 ) ? (
      os = sample;
      sample = this.filter_phaser.evalphaserFET(sample);
      sample = this.filter_phaser2.evalphaserFET(sample);
      sample = this.filter_phaser3.evalphaserFET(sample);
      sample = this.filter_phaser4.evalphaserFET(sample);
      sample = (os + sample)*.5;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 16 ) ? (
      !(this.isGFX) ? (
        !(this.isFilt2) ? ( 
          os1 = filter_delay1.readBuffer();
          os2 = filter_delay2.readBuffer();
          ys1 = sample - .2 * distort(os1-os2);
          filter_delay1.updateBuffer(sample);
          filter_delay2.updateBuffer(ys1-sample);
        ) : (
          os1 = filter_delay3.readBuffer();
          os2 = filter_delay4.readBuffer();
          ys1 = sample - .2 * distort(os1-os2);
          filter_delay3.updateBuffer(sample);
          filter_delay4.updateBuffer(ys1-sample);
        )
      ) : (
        !(this.isFilt2) ? ( 
          os1 = filter_delay5.readBuffer();
          os2 = filter_delay6.readBuffer();
          ys1 = sample - .2 * (os1-os2);
          filter_delay5.updateBuffer(sample);
          filter_delay6.updateBuffer(ys1-sample);
        ) : (
          os1 = filter_delay7.readBuffer();
          os2 = filter_delay8.readBuffer();
          ys1 = sample - .2 * (os1-os2);
          filter_delay7.updateBuffer(sample);
          filter_delay8.updateBuffer(ys1-sample);
        )
      );
      sample = ys1 + os2;
    ) : ( this.filtertype == 17 ) ? (
      !(this.isGFX) ? (
        !(this.isFilt2) ? ( 
          os1 = filter_delay1.readBuffer();
          os2 = filter_delay2.readBuffer();
          hist1 = 0.001 * abs(sample) + 0.999 * abs(hist1);
          filter_delay1.updateBuffer(sample);
          filter_delay2.updateBuffer(sample);
          sample = tanh(5*hist1*sample + distort(sample-os1));
        ) : (
          os1 = filter_delay3.readBuffer();
          os2 = filter_delay4.readBuffer();
          hist2 = 0.001 * abs(sample) + 0.999 * abs(hist2);
          filter_delay3.updateBuffer(sample);
          filter_delay4.updateBuffer(sample);
          sample = tanh(5*hist2*sample + distort(sample-os1));
        )
      ) : (
        !(this.isFilt2) ? ( 
          os1 = filter_delay5.readBuffer();
          os2 = filter_delay6.readBuffer();
          hist3 = 0.001 * abs(sample) + 0.999 * abs(hist3);
          filter_delay5.updateBuffer(sample);
          filter_delay6.updateBuffer(sample);
          sample = tanh(5*hist3*sample + (sample-os1));
        ) : (
          os1 = filter_delay7.readBuffer();
          os2 = filter_delay8.readBuffer();
          hist4 = 0.001 * abs(sample) + 0.999 * abs(hist4);
          filter_delay7.updateBuffer(sample);
          filter_delay8.updateBuffer(sample);
          sample = tanh(5*hist4*sample + (sample-os1));
        )
      );    
      
    ) : ( this.filtertype == 18 ) ? (
      dist ? sample = distort(sample);
      sample = this.filter_ms20lin.eval_MS20lin(sample);
    ) : ( this.filtertype == 19 ) ? (
      dist ? sample = distort(sample);
      sample = this.filter_ms20lin.eval_MS20linBP(sample);
    ) : ( this.filtertype == 20 ) ? (
      dist ? sample = distort(sample);
      sample = this.filter_ms20lin.eval_MS20linHP(sample);            
    ) : ( this.filtertype == 21 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlin(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 22 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinBP(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 23 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinHP(sample);  
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 24 ) ? (
      sample += 0.8 * this.filter_phaser.evalphaserFET(this.filter_delay.getBuffer());
      flt = this.filter_ms20.eval_MS20_nonlin(sample);
      dist ? flt = distort(flt);
      flt = this.filter_phaser2.evalphaserFET(flt);  
      os = flt-.7*sample;
      dist ? os = distort(os);      
      this.filter_delay.updateBuffer(os);
      sample = this.filter_ms20.eval_MS20_nonlin(sample+flt);
      dist ? sample = distort(sample);
      sample = this.filter_ms20.eval_MS20_nonlin(sample+flt);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 25 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlin_mod(sample); 
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 26 ) ? (
      sample = this.filter_ssm.eval_ssm_nonlin(sample);   
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 27 ) ? (
      sample = this.filter_ssm.eval_ssm_nonlin_cheap(sample);   
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 28 ) ? (
      sample = this.filter_cem.eval_cem_nonlin(sample);   
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 29 ) ? (
      sample = this.filter_ssm_lin.eval_ssm_lin(sample);   
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 30 ) ? (
      sample = this.filter_cem_lin.eval_cem_lin(sample);   
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 31 ) ? (
      sample = ( 1 - this.filter_sine.res ) * sample + this.filter_sine.res * sin(sample * this.filter_sine.freq);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 32 ) ? (
      os = this.filter_ms20.eval_MS20_nonlin_FM(sample);
      dist ? os = distort(os);
      sample = ( 1 - this.filter_sine.res ) * sample + this.filter_sine.res * os;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 33 ) ? (
      os = .7 + .3* sin(.5*sample * this.filter_sine.freq);
      this.filter_ms20.init_MS20_nonlin(os*this.filter_sine.fraw, this.filter_sine.res);
      sample = this.filter_ms20.eval_MS20_nonlin(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 34 ) ? ( 
      sample = this.filter_broken.eval_broken_nonlin_LP(sample);   
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 35 ) ? (
      //sample = this.filter_wasp2.eval_wasp_nonlin2(sample);   
      sample = this.filter_wasp.eval_wasp_nonlin_extrareso(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 36 ) ? (
      sample = this.filter_wasp_lin.eval_wasplin(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 37 ) ? (
      sample = this.filter_wasp.eval_wasp_nonlin(sample);
      dist ? sample = distort(sample);  
    ) : ( this.filtertype == 38 ) ? (
      sample = this.filter_wasp.eval_wasp_nonlin_BP(sample);
      dist ? sample = distort(sample);   
    ) : ( this.filtertype == 39 ) ? (
      sample = this.filter_SVF.eval_linearSVF_LP(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 40 ) ? (
      sample = this.filter_SVF.eval_linearSVF_BP(sample);
      dist ? sample = distort(sample);            
    ) : ( this.filtertype == 41 ) ? (
      sample = this.filter_SVF.eval_linearSVF_HP(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 42 ) ? (
      sample = this.filter_SVF.eval_linearSVF_notch(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 43 ) ? (
      sample = this.filter_SVF.eval_linearSVF_peak(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 44 ) ? (
      sample = this.filter_wasp.eval_wasp_nonlin(sample);
      dist ? sample = distort(sample); 
    ) : ( this.filtertype == 45 ) ? (
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      os = 5*(reso-lp);
      dist ? os = distort(os);
      sample = lp + .2*os;
    ) : ( this.filtertype == 46 ) ? (
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      diff = 10*(reso-lp);
      this.resoint = .5*tanh(this.resoint + tanh(diff));
      sample = lp + this.resoint;
      dist ? sample = distort(sample);      
    ) : ( this.filtertype == 47 ) ? (
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      diff = tanh(10*(reso-lp));
      diff = this.filter_SVF2.eval_linearSVF_LP( sample+diff );
      diff = this.filter_SVF2.eval_linearSVF_LP( diff );                
      sample = (lp + diff)*.7;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 48 ) ? (
      dist ? sample = distort(sample);
      os = this.filter_delay.readBuffer();
      this.filter_delay.updateBuffer(sample);
      sample = (this.chan > 0) ? (sample + os) : (sample + os - 2 * this.stereoize * os);
      
    ) : ( this.filtertype == 49 ) ? (  
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      diff = tanh(3*(reso-lp));
      sample = lp;
      os = this.filter_delay.readBuffer();
      this.filter_delay.updateBuffer(diff);
      sample = sample+(diff+os);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 50 ) ? (  
      reso = this.filter_SVF.eval_linearSVF_BP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_BP( sample );
      diff = reso-lp;
      sample = lp;
      
      os = this.filter_delay.readBuffer();
      this.filter_delay.updateBuffer(diff);
      
      sample = sample+(diff+os);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 51 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlin_tanh(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 52 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinBP_tanh(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 53 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinHP_tanh(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 54 ) ? (
      sample = this.weeping.weeping_eval(sample);
      dist ? sample = 4*distort(.25*sample);
    ) : ( this.filtertype == 55 ) ? (
      sample = this.pwm.pwm_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 56 ) ? (
      sample = this.pwm.pwm_eval_BP(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 57 ) ? (
      sample = this.bit.bit_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 58 ) ? (
      sample = this.muck.muck_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 59 ) ? (
      sample = this.weeping.weeping_eval(sample);
      dist ? sample = 4*distort(.25*sample);
    ) : ( this.filtertype == 60 ) ? (
      sample = this.wah.dlop_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 61 ) ? (
      sample = this.wah.dlop_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 62 ) ? (
      sample = this.wah.dlop_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 63 ) ? (
      dist ? sample = distort(sample);
      sample = this.vowel_svf.evalvowelSVF(sample);
    ) : ( this.filterType == 64 ) ? (
      sample = sample + tanh( -(this.vowel_svf.evalvowelSVF2(sample) + sample) + this.xxos );
      this.xxos = sample;
      dist ? sample = distort(sample);
    ) : ( this.filterType == 65 ) ? (
      sample = this.kot.kot_eval(sample);
      dist ? sample = distort(sample);      
    ) : ( this.filterType == 66 ) ? (
      sample = this.modulon.modulon_eval(sample);
      dist ? sample = distort(sample);      
    ) : ( this.filterType == 67 ) ? (
      sample = this.octaver.octaver_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 68 ) ? (
      sample = this.octaverUp.octaverUp_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 69 ) ? (
      sample = this.metallic.metallic_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 70 ) ? (
      sample = this.frazzle.frazzle_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 71 ) ? (
      sample = this.phone.phone_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 72 ) ? (
      sample = this.modulon.modulon_eval(sample);
      dist ? sample = distort(sample);      
    ) : ( this.filterType == 73 ) ? (
      sample = this.modulon.modulatrix_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 74 ) ? (
      this.vibrato.t += this.vibrato.dt;
      this.filter_delay.updateBuffer(sample);
      this.vibrato.smoothreso = this.vibrato.smoothreso * .999 + this.vibrato.reso * .001;
      
      vib_delay = this.vibrato.ovs * 800 * this.vibrato.smoothreso * (1+sin(this.vibrato.t));
      this.filter_delay.setOffset(vib_delay+5);
      sample = this.filter_delay.readBufferFrac(vib_delay-floor(vib_delay));

      dist ? sample = distort(sample);
    ) : ( this.filterType == 75 ) ? (
      this.vibrato.t += this.vibrato.dt;
      this.filter_delay.updateBuffer(sample);
      this.vibrato.smoothreso = this.vibrato.smoothreso * .999 + this.vibrato.reso * .001;
      
      vibratoSinTerm = sin(this.vibrato.t);
      vib_delay = this.vibrato.ovs * 500 * this.vibrato.smoothreso * (1+(1-2*this.vibrato.isR)*vibratoSinTerm);
      this.filter_delay.setOffset(vib_delay+5);
      sample = this.filter_delay.readBufferFrac(vib_delay-floor(vib_delay));
      sample = .6*sample + .4*sample * (1-(1-2*this.vibrato.isR)*vibratoSinTerm);

      dist ? sample = distort(sample);
    ) : ( this.filterType == 76 ) ? (
      sample = sample + this.folder.dc_scum;
      sample = actual_tanh(this.folder.folder_eval(sample));
      dist ? sample = distort(sample);
    ) : ( this.filterType == 77 ) ? (
      sample = sample + this.folder1.dc_scum;
      sample = this.folder1.folder_eval(sample);
      sample = this.folder2.folder_eval(sample);
      sample = this.folder3.folder_eval(sample);
      sample = actual_tanh(this.folder4.folder_eval(sample));
      dist ? sample = distort(sample);
    ) : ( this.filterType == 78 ) ? (
      sample = sample + this.serge1.dc_scum;
      
      sample = this.serge1.serge_eval(sample*2^(this.serge1.gain*5));
      sample = this.serge2.serge_eval(sample);
      sample = this.serge3.serge_eval(sample);
      sample = this.serge4.serge_eval(sample);
      sample = this.serge5.serge_eval(sample);
      sample = actual_tanh(4*this.serge6.serge_eval(sample));
      dist ? sample = distort(sample);
    ) : ( this.filterType == 79 ) ? (
      dist ? sample = distort(sample);
      sample = this.diffuser.diffuser_eval(sample);
    ) : ( this.filterType == 80 ) ? (
      dist ? sample = distort(sample);
      sample = this.space.space_eval(sample);
    ) : ( this.filterType == 81 ) ? (
      dist ? sample = distort(sample);
      sample = this.worp.worp_eval(sample);
    ) : ( this.filterType == 82 ) ? (
      sample = this.crunch.crunch_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 83 ) ? (
      sample = this.athena.athena_eval(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 84 ) ? (
      bp = this.filter_SVF.eval_linearSVF_BP( sample*sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );      
      sample = lp + tanh(20*bp);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 85 ) ? (
      bp = this.filter_SVF.eval_linearSVF_BP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );      
      sample = lp + tanh(10*bp);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 86 ) ? (
      bp = this.filter_SVF.eval_linearSVF_BP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample-8*bp*bp );
      sample = lp;
      dist ? sample = distort(sample);
    ) : ( this.filterType == 87 ) ? (
      bp = this.filter_SVF.eval_linearSVF_BP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample - 15*sample*bp );
      sample = lp;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 88 || this.filterType == 89 ) ? (
      bp = 0;
      bp += this.f1.eval_linearSVF_BP(sample);
      bp += this.f2.eval_linearSVF_BP(sample);
      bp += this.f3.eval_linearSVF_BP(sample);
      bp += this.f4.eval_linearSVF_BP(sample);
      bp += this.f5.eval_linearSVF_BP(sample);
      bp += this.f6.eval_linearSVF_BP(sample);
      bp += this.f7.eval_linearSVF_BP(sample);
      bp += this.f8.eval_linearSVF_BP(sample);
      bp += this.f9.eval_linearSVF_BP(sample);
      bp += this.f10.eval_linearSVF_BP(sample);
      sample = bp * this.amp;
      dist ? sample = distort(sample);
    ) : ( this.filtertype == 90 ) ? (
      bp = 0;
      bp += this.f1.eval_linearSVF_BP(sample);
      bp += this.f2.eval_linearSVF_BP(sample);
      bp += this.f3.eval_linearSVF_BP(sample);
      bp += this.f4.eval_linearSVF_BP(sample);
      bp += this.f5.eval_linearSVF_BP(sample);
      bp += this.f6.eval_linearSVF_BP(sample);
      bp += this.f7.eval_linearSVF_BP(sample);
      bp += this.f8.eval_linearSVF_BP(sample);
      bp += this.f9.eval_linearSVF_BP(sample);
      bp += this.f10.eval_linearSVF_BP(sample);
      bp += this.f11.eval_linearSVF_BP(sample);
      bp += this.f12.eval_linearSVF_BP(sample);
      bp += this.f13.eval_linearSVF_BP(sample);
      bp += this.f14.eval_linearSVF_BP(sample);
      bp += this.f15.eval_linearSVF_BP(sample);
      bp += this.f16.eval_linearSVF_BP(sample);
      bp += this.f17.eval_linearSVF_BP(sample);
      bp += this.f18.eval_linearSVF_BP(sample);
      bp += this.f19.eval_linearSVF_BP(sample);
      bp += this.f20.eval_linearSVF_BP(sample);
      sample = bp * this.amp;
      dist ? sample = distort(sample);
    ) : ( this.filterType == 91 ) ? (
      // The new moogs :)
      this.newMoog.eval_newMoog(sample);
      sample = this.newMoog.newMoog_LP(sample);
      dist ? sample = distort(sample);
    )  : ( this.filterType == 92 ) ? (
      // The new moogs :)
      this.newMoog.eval_newMoog(sample);
      sample = this.newMoog.newMoog_BP(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 93 ) ? (
      // The new moogs :)
      this.newMoog.eval_newMoog(sample);
      sample = this.newMoog.newMoog_HP(sample);
      dist ? sample = distort(sample);
    ) : ( this.filterType == 94 ) ? (
      // The new moogs :)
      this.newMoog.eval_newMoog(sample);
      sample = this.newMoog.newMoog_Notch(sample);
      dist ? sample = distort(sample);
    );
    
    sample;
  );

function processSamples()
  (
    sl_in = ssl;
    sr_in = ssr;
  
    //( slider47 > 0 ) ? 
    //(
      ( slider35 & 4 == 4 ) ? (
        ssl = distort(ssl);
        ssr = distort(ssr);
      ) : ( slider46 == 0 ) ?
      (
        ssl = L.process(ssl, 1);
        ssr = R.process(ssr, 1);
      ) : ( slider46 == 1 ) ?
      (
        ssl = L.process(ssl, 1);
        ssr = L.process(ssr, 1);
      ) : ( slider46 == 2 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side, 1);
        side = L.process(side, 1);
        mid  = R.process(mid, 1);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 3 ) ?
      ( 
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side, 1);
        mid  = R.process(mid, 1);
        mid  = R.process(mid, 1);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 4 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side, 1);
        mid  = mid;
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 5 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        mid  = R.process(mid, 1);
        side = side;
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 6 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        mid  = R.process(mid, 1);
        side = L.process(1.5*side, 1);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 7 ) ?
      (
        side = .5 * ( ssl - d4ssr );
        mid  = .5 * ( ssl + ssr );
        mid  = R.process(mid, 1);
        side = L.process(4*side, 1);
        
        d4ssr = d3ssr;
        d3ssr = d2ssr;
        d2ssr = dssr;
        dssr = ssr;        
        
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 8 ) ?
      (
        side = .5 * ( ssl - d2ssr );
        mid  = .5 * ( ssl + ssr );
        
        mid  = R.process(mid, 1);
        side = L.process(side, 1);
        
        d3ssr = d2ssr;
        d2ssr = dssr;
        dssr = ssr;        
        
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 9 ) ?
      (
        ssl = distort(ssl-L.process(ssl, 0));
        ssr = distort(ssr-R.process(ssr, 0));
      );
    //);
    
    (slider40 > 0)? (
      ( slider35 & 8 == 8 ) ? (
        ssl = ssl;
      ) :
      ( secondFilterMode == 0 ) ? (
        // Serial dual dist
        ssl = L2.process(ssl, 1);
        ssr = R2.process(ssr, 1);
      ) : ( secondFilterMode == 1 ) ? (
        // Serial single dist
        ssl = L2.process(ssl, 0);
        ssr = R2.process(ssr, 0);
      ) : ( secondFilterMode == 2 ) ? (
        // Parallel dual dist
        ssl = .5*ssl + .5*L2.process(sl_in, 1);
        ssr = .5*ssr + .5*R2.process(sr_in, 1);
      ) : ( secondFilterMode == 3 ) ? (
        // Parallel single dist
        ssl = .5*ssl + .5*L2.process(sl_in, 0);
        ssr = .5*ssr + .5*R2.process(sr_in, 0);
      ) : ( secondFilterMode == 4 ) ? (
        // Parallel dual dist
        morphModVal              = 0;
        cnt                      = 0;
        slider35 & 1024          ? (morphModVal += filteredDynval; cnt += 1;);
        env1Morph.active         ? (morphModVal += envelopeValue1; cnt += 1;);
        env2Morph.active         ? (morphModVal += envelopeValue2; cnt += 1;);
        cnt > 1                  ? morphModVal /= cnt;
        slider35 & 2048          ? morphModVal += modulator.scaled_modvalue;
        morphSliderValue = min(1, max(0, slider18 + slider34 * morphModVal));
        
        ssl = (1-morphSliderValue)*ssl + morphSliderValue*L2.process(sl_in, 1);
        ssr = (1-morphSliderValue)*ssr + morphSliderValue*R2.process(sr_in, 1);
      ) : ( secondFilterMode == 5 ) ? (
        // Parallel single dist
        morphModVal              = 0;
        cnt                      = 0;
        slider35 & 1024          ? (morphModVal += filteredDynval; cnt += 1;);
        env1Morph.active         ? (morphModVal += envelopeValue1; cnt += 1;);
        env2Morph.active         ? (morphModVal += envelopeValue2; cnt += 1;);
        cnt > 1                  ? morphModVal /= cnt;
        slider35 & 2048          ? morphModVal += modulator.scaled_modvalue;
        morphSliderValue = min(1, max(0, slider18 + slider34 * morphModVal));
        
        ssl = (1-morphSliderValue)*ssl + morphSliderValue*L2.process(sl_in, 0);
        ssr = (1-morphSliderValue)*ssr + morphSliderValue*R2.process(sr_in, 0);
      );
    );
  );

//ext_nodenorm    = 1; 
gfx_clear       = -1;
updateSliders();

// Quick hacky fix until I can refactor this.
// The UI is now initialized before it is ever opened. The reason is that the
// maximum and minimum for the dynamic variable are stored in the slider, and the
// actual mod range is taken from the widget. This is a bit of a design fail.
setupGUI();
UI_Loaded = 0;

@slider
updateSliders();
updateActiveFilters(1);

@block     
  agc_corr == 0 ? agc_corr = 1;
  israte = 1/srate;
  
  blockRef = 44100/512;
  blockFactor = min(blockSize * israte * blockRef, 1);
  
  updateLegacyStatus();
  cTempo            = tempo; 
  blockSize         = samplesblock;
  secondFilterMode  = floor(slider50*.5);

  envWindow1.updateEnvRate();
  envWindow2.updateEnvRate();
  
  env1Active = env1GainButton.active || env1FilterButton.active || env1Filter2Button.active || env1FB.active || env1Morph.active || env1LFO.active;
  env2Active = env2GainButton.active || env2FilterButton.active || env2Filter2Button.active || env2FB.active || env2Morph.active || env2LFO.active;

  function inertiaSmoothing(newval)
    instance(prev, val, boost)
    global(blockFactor)
    local(error, diff)
    (    
      error   = (val - newval);
      diff    = val - prev;
      prev    = val;
      boost   = min(1, max(0, 15*abs(diff)-.1));
      //val     = val - .3 * error - .7 * error * boost;
      val     = val - ( .3 + .7*boost ) * error * blockFactor;
    );

  ( followPitch1 || followPitch2 ) ? (
    pitchFFT.calcIncrementalFFT();
    currentPeakHzEstimate = pitchFFT.mxpos/fftSize * srate;  
    pitchTrackingMod1 = getPitchMod(slider47, currentPeakHzEstimate/64, slider48);
    pitchTrackingMod2 = getPitchMod(slider40, currentPeakHzEstimate/64, slider41);
    pitchLerp1.prepLerp(-1, pitch_buffer1, inertia_pitch1.inertiaSmoothing( pitchTrackingMod1 ), 1);
    pitchLerp2.prepLerp(-1, pitch_buffer2, inertia_pitch2.inertiaSmoothing( pitchTrackingMod2 ), 1);
  ) : pitchFFT.mxpos = 0;

  // Sample accurate lerp
  slider55 & 4 ?
  (
    resoLerp.prepLerp(49, reso_mem, inertia_s49.inertiaSmoothing( slider49 ), 1);
    cutoffLerp.prepLerp(48, cutoff_mem, inertia_s48.inertiaSmoothing( slider48 ), 1);
    resoLerp2.prepLerp(42, reso_mem2, inertia_s42.inertiaSmoothing( slider42 ), 1);
    cutoffLerp2.prepLerp(41, cutoff_mem2, inertia_s41.inertiaSmoothing( slider41 ), 1);
  ) :
  (
    resoLerp.prepLerp(49, reso_mem, slider49, interpReso);
    cutoffLerp.prepLerp(48, cutoff_mem, slider48, interpCutoff);
    resoLerp2.prepLerp(42, reso_mem2, slider42, interpReso2);
    cutoffLerp2.prepLerp(41, cutoff_mem2, slider41, interpCutoff2);
  );
   
  // Check if the filter or filter mode changed
  flushIt = ( slider46 != currentMode ) || ( slider47 != currentFilter ) || ( slider40 != currentFilter2 );
  ( flushIt == 1 ) ? (
    currentMode     = slider46;
    currentFilter   = slider47;
    currentFilter2  = slider40;
    lfoModValLast   = -1;
    resetActiveFilters();
    updateSliders();
    updateActiveFilters(1);
    resetActiveFilters();
  ) : ( forceUpdate==1 ) ? (
    forceUpdate = 0;
    lfoModValLast = -1;
    updateSliders();
    updateActiveFilters(1);
  );
  
 ( pdcDelay != lastpdcDelay ) ?
  (
    lastpdcDelay = pdcDelay;
    pdc_bot_ch=0; 
    pdc_top_ch=2;
    pdc_delay = pdcDelay;
  );
  
  dynTargetMode = ( slider45 > 9 && slider45 < 12 ) ? 1 : 0;
  
  //handlesMIDI = (slider38&1) || ((slider45 > 1) && (slider45 < 6)) || followKey1 || followKey2;
  notePtr = note_mem;
  while (midirecv(offset,msg1,msg2,msg3)) (
      noteOn = msg1>$x8F&&msg1<$xA0 && msg3!=0;
      noteOff = (msg1>$x7F&&msg1<$x90) || (msg1>$x89&&msg1<$xA0 && msg3==0);
      mwCC = (msg1>$xAF&&msg1<$xC0);
      
      noteOn ? (
      notePtr[] = offset;
      notePtr += 1;
      notePtr[] = msg3;
      notePtr += 1;
      notePtr[] = msg2;
      notePtr += 1;
    ) : ( noteOff ) ? (
      notePtr[] = offset;
      notePtr += 1;
      notePtr[] = -1;
      notePtr += 1;
    ) : ( mwCC ) ? (
      ( slider45 > 9 && slider45 < 11 ) ? (
        notePtr[] = offset;
        notePtr += 1;
        notePtr[] = -2;
        notePtr += 1;
        notePtr[] = msg2;
        notePtr += 1;
        notePtr[] = msg3;
        notePtr += 1;
      );
    );
    
    midisend(offset,msg1,msg2,msg3); // passthrough MIDI events
  );
  notePtr[]       = -1337;    // Signal end of note buffer
  notePtr         = note_mem;
  curSample       = 0;        // Current sample in block
  notes_remain    = 1;        // End of the note buffer?
  note_next       = notePtr[];  
 
  c_feedbackEnabled = slider35 & 32;
  c_feedbackEnabled ? (
    c_feedbackDynamic = slider35 & 64;
    c_feedbackLFO     = slider35 & 128;
    c_feedbackMul1    = slider35 & 256;
    c_feedbackMul2    = slider35 & 512;
    c_feedbackMul3    = slider35 & 8192;
  ); 
 
 clipInput = slider55 & 1;
 clipOutput = slider55 & 2;
 
 ( slider45 == 0 || slider45 == 6 || slider45 == 8 ) ? (
   dynamic_variable_mode = 1;
 ) : ( slider45 == 1 || slider45 == 7 || slider45 == 9 ) ? (
   dynamic_variable_mode = 2;
 ) : ( slider45 == 2 || slider45 == 4 ) ? (
   dynamic_variable_mode = 3;
 ) : ( slider45 == 3 || slider45 == 5 ) ? (
   dynamic_variable_mode = 4;
 );
 
 ( slider45 == 8 || slider45 == 9 ) ? (
   listenChan = 1; // Side chain
 ) : ( slider45 > 5 ) ? (
   listenChan = 2; // Pregain RMS
 ) : (
   listenChan = 3; // Normal RMS
 );
 
 FIR_upsampling  = slider50 & 1;
 modulatorSmoothingFactor = slider35 & 16 == 16 ? 0.996 : 0;
 
 delta_T = 1/srate;
 
@sample
  sl        = spl0 * pregain;
  sr        = spl1 * pregain;
  
  globalTime = globalTime + delta_T;
  
  //( followPitch1 || followPitch2 ) ? (
  pitchFFT.feedSampleLP(sl+sr);
  //);
  
  block_analyzers == 0 ? (
    spectrumIn.feedSample(sl+sr);
    gonioIn.feedGonio(sl, sr);
  );
  modulator.updateModulator(modulatorSmoothingFactor);
  
  // Does this plugin respond to MIDI signals?
  // Take notes from the stack until we hit the end marker -1
  (notes_remain) ? (
    while( note_next == curSample ) (
      currentSkip = skipFactor + 1; // Make sure we update filter coeffs at such an important moment
      currentSkip2 = skipFactor + 1; // Make sure we update filter coeffs at such an important moment
      notePtr += 1;
      (notePtr[] > 0) ? ( // note-on
        modulator.reset = 1;
        LFO_was_reset = 1;
        notesOn = notesOn + 1;
        lastVel_cur = notePtr[]/127;
        lastVel = ( (slider45 == 4) || (slider45 == 5) ) ? lastVel_cur : 1;
        (slider45 == 2 || slider45 == 4) ? ( tDynamic = 0; dynval = 0; );
        
        envWindow1.resetEnvelope(lastVel_cur, 0);
        envWindow2.resetEnvelope(lastVel_cur, 0);
        
        notePtr += 1;
        lastNote = notePtr[];
        
        approxNoteFrequencyFilter1 = getTuning(slider47, lastNote, slider48);
        approxNoteFrequencyFilter2 = getTuning(slider40, lastNote, slider41);        
      ) : (notePtr[] == -1) ? ( // note-off
        notesOn = notesOn - 1;
        notesOn = max(0, notesOn);
      ) : (notePtr[] == -2) ? ( // CC
        notePtr += 1;
        // msg3
        cur_cc = notePtr[];
        
        notePtr += 1;
        // msg2
        cur_cc == 1 ? (
          cc_target = notePtr[]/128;
        )
      );
      notePtr += 1;
      
      // Avoid constantly dereferencing by picking up the next one
      note_next = notePtr[];
      notes_remain = note_next != -1337;
    );
  );
  
  // Are we following a target with the dynamic variable?
  dynTargetMode ? (
    ( cc_target > dynval ) ?
    (
      dynval = min( cc_target, dynval+dyn_atk_time );
    ) : ( cctarget < dynval ) ? (
      dynval = max( cc_target, dynval-dyn_atk_time );
    );
    dynval = dynval + dyn_atk * ( cc_target - dynval );
  );
  
  envelopeValue1 = env1Active ? envWindow1.evaluateEnvelope(notesOn) : 0;
  envelopeValue2 = env2Active ? envWindow2.evaluateEnvelope(notesOn) : 0;
  
  notePtrAtEnd=note_next;
  // Dynamics
  // Optional input clipping
  // Note that this input clipping is just for the dynamics and that the real clipping
  // is done on the oversampled samples to avoid aliasing issues.
  ( clipInput ) ?
  ( 
    sbl = min(1,max(-1,sl));
    sbr = min(1,max(-1,sr));
  ) : (
    sbl = sl;
    sbr = sr;
  );
  
  ( listenChan == 1 ) ? (
    inV = inVol.updateBuffer( RMS1.updateRMS(spl2, spl3) );
  ) : ( listenChan == 2 ) ? (
    inV = inVol.updateBuffer( RMS1.updateRMS(spl0, spl1) );
  ) : (
    inV = inVol.updateBuffer( RMS1.updateRMS(sbl, sbr) );
  );

  // Calculation of the dynamic variable  
  ( dynamic_variable_mode == 1 ) ?
  (
    // Regular threshold mode
    ( inV > dyn_thresh ) ? (
      dynval = dynval + dyn_atk;
      dynval = min(1, dynval);
    ) : (
      dynval = dynval - dyn_decay * dynval;
    );
  ) : ( dynamic_variable_mode == 2 ) ? (
    // Direct RMS based mode
    dynval = min(1, (abs(inV)/dyn_thresh)^dyn_atk);
    dynval = (1 - dyn_decay) * dynval + dyn_decay * (1-dynval);
  ) : ( dynamic_variable_mode == 3 ) ? (
    // Fixed envelope that plays on note on
    tDynamic = tDynamic + 1;
    (tDynamic < dyn_atk_time) ? (
      dynval = dynval + dyn_atk * lastVel;
    ) : ( tDynamic > dyn_hold_end ) ? (
      dynval = dynval - dyn_decay * dynval;
    ) : dynval = lastVel;
    dynval = min(1, dynval);
  ) : ( dynamic_variable_mode == 4 ) ? (
    // Note mode (Legato)
    ( notesOn > 0 ) ? (
      dynval = dynval + dyn_atk * ( 1-dyn_thresh ) + 3*dyn_thresh * dyn_atk*(1-dynval);
      currentVel = currentVel == 0 ? lastVel : currentVel;
      dynval = min(currentVel, dynval);
    ) : (
      currentVel = 0;
      dynval = dynval - dyn_decay * dynval;
    );
  );
    
  dynBuf.updateBuffer(filteredDynval);
  
  // Update active filter only if cutoff changed
  updateActiveFilters(0);
  
  lfoModVal                 = 0;
  cnt                       = 0;
  slider35 & 4096           ? ( lfoModVal += filteredDynval; cnt += 1; );
  env1LFO.active            ? ( lfoModVal += envelopeValue1; cnt += 1; );
  env2LFO.active            ? ( lfoModVal += envelopeValue2; cnt += 1; );
  cnt > 1                   ? lfoModVal /= cnt;
  
  (lfoModVal != lfoModValLast) ? (
    modulator.updateModRate(max(0,min(1,slider37 + mod_LFO_rate * lfoModVal)));
    modulator.updateScale(max(0,min(4,slider39 + mod_LFO_amount * lfoModVal)));
    lfoModValLast = lfoModVal;
  );
  
  ( lookAhead ) ?
  (
    oldl = preBufferL.getBuffer();
    oldr = preBufferR.getBuffer();
    oldreset = preBufferMod.getBuffer();
    preBufferL.updateBuffer( sl );
    preBufferR.updateBuffer( sr );
    preBufferMod.updateBuffer( modulator.reset );
    sl = oldl;
    sr = oldr;
    modulator.reset = oldreset;
  );
  
  alpha = .9999;
  movavgLN = max(alpha*movavgLN, -sl);
  movavgLP = max(alpha*movavgLP,  sl);
  movavgRN = max(alpha*movavgRN, -sr);
  movavgRP = max(alpha*movavgRP,  sr);
  
  // FEEDBACK
  c_feedbackEnabled ? (  
    fbModVal                 = 0;
    cnt                      = 0;
    c_feedbackDynamic        ? ( fbModVal += filteredDynval; cnt += 1; );
    env1FB.active            ? ( fbModVal += envelopeValue1; cnt += 1; );
    env2FB.active            ? ( fbModVal += envelopeValue2; cnt += 1; );
    cnt > 1                  ? fbModVal /= cnt;
    c_feedbackLFO            ? fbModVal += modulator.scaled_modvalue;
        
    newFbDelay  = min(1, max(0, slider16 + slider32 * fbModVal));
    newFbAmnt   = min(1, max(0, slider15 + slider31 * fbModVal));
    
    newFbDelay = .003125 * srate * (pow(2, newFbDelay)-1) + 1;
    c_feedbackMul1 ? newFbDelay *= 16;
    c_feedbackMul2 ? newFbDelay *= 8;
    c_feedbackMul3 ? newFbDelay *= 6;
    
    smoothedFbDelay = smoothedFbDelay * .999 + newFbDelay * .001;
    flNewFbDelay = floor(smoothedFbDelay);
    fracFbDelay = smoothedFbDelay-flNewFbDelay;
    
    fb_bufferL.setOffset(flNewFbDelay+1);
    fb_bufferR.setOffset(flNewFbDelay+1);

    sl = 1.25*actual_tanh(.8*(sl + newFbAmnt * fb_bufferL.readBufferFrac(fracFbDelay)));
    sr = 1.25*actual_tanh(.8*(sr + newFbAmnt * fb_bufferR.readBufferFrac(fracFbDelay)));
  );

  ( slider54 < 1.5 ) ? (
    // Without oversampling
    ssl = sl;
    ssr = sr;
    processSamples();
    sl = ssl;
    sr = ssr;
  ) : ( 
    q = 0;
    // N>1 oversampling
    sli = sl;
    sri = sr;
    
    ( FIR_upsampling == 1 ) ? (
      sincFilterL.advanceSinc(sli);
      sincFilterR.advanceSinc(sri);
      loop( slider54,
        ssl = sincFilterL.getSubSample();
        ssr = sincFilterR.getSubSample();
       
        processSamples();
        
        sincDownL.advanceHist(ssl);
        sincDownR.advanceHist(ssr);  
      );
      
      sl = sincDownL.sincDownSample();
      sr = sincDownR.sincDownSample();
    ) /* : ( FIR_upsampling == 2 ) ? ( 
      upsampleL.updateUpHist(slider54, sli);
      upsampleR.updateUpHist(slider54, sri);
      
      f = 0;
      loop(slider54,
        f += 1;
        ssl = slider54*upsampleL.upSample(slider54);
        ssr = slider54*upsampleR.upSample(slider54);
      
        processSamples();
        downL.updateDownHist(slider54, ssl);
        downR.updateDownHist(slider54, ssr);
        
        ( f == 1 ) ? (
          sl = downL.downSample(slider54);
          sr = downR.downSample(slider54);
        );
      );
    )*/ : (
      loop( slider54,
        ssl = filterL.inputFilter(sli);
        ssr = filterR.inputFilter(sri);
        processSamples();
        
        (q += 1)==1 ? (
          sl = filterL.outputFilter(ssl);
          sr = filterR.outputFilter(ssr);
        ) : (
          filterL.outputFilter(ssl);
          filterR.outputFilter(ssr);
        );
      );
    );
  );
  
  // FEEDBACK
  c_feedbackEnabled ? (
    fb_bufferL.updateBuffer(sl);
    fb_bufferR.updateBuffer(sr);
  );
  
  // DC correction
  otm1=0.999*otm1 + sl - itm1;
  itm1=sl;
  sl=otm1;
  otm2=0.999*otm2 + sr - itm2;
  itm2=sr;
  sr=otm2;
   
  movavgOLN = max(alpha*movavgOLN, -sl);
  movavgOLP = max(alpha*movavgOLP,  sl);
  movavgORN = max(alpha*movavgORN, -sr);
  movavgORP = max(alpha*movavgORP,  sr);
  
  postResetWaitSamples == 0 ? 
  (
    ( agcControl == 1 || agcOverride > 0 ) ?
    (
      alpha       = 0.9999;
      agccur      = max(spl0*spl0, spl1*spl1);
      
      ( abs(agccur) > 0.0001 ) ? (      
        agcsumpre   = agcsumpre * alpha + agccur * (1-alpha);
        agcsumpost  = agcsumpost * alpha + max(sl*sl, sr*sr) * (1-alpha);
        agcpre      = sqrt(agcsumpre);
        agcpost     = sqrt(agcsumpost)*agc_corr;
      
        // Automatic Gain Control
        // Decrease fast, increase slower (don't want wobble) with hysteresis
        // Direct dynamic solution with PID controller was attempted but ended up oscillating too much.
        ( agcpost > agcpre ) ? (
          // Higher
          ( agcpost > 10*agcpre ) ? (
            agc_corr = agc_corr * .99;
          ) : ( agcpost > 3.5*agcpre ) ? (
            agc_corr = agc_corr * .999;
          ) : ( agcpost > 1.4*agcpre ) ? (
            agc_corr = agc_corr * .99999;
          ) : agc_corr = agc_corr * .999999;
        ) : (
          // Lower
          ( agcpost < .2*agcpre ) ? (
            agc_corr = agc_corr * 1.001;
          ) : ( agcpost < .71*agcpre ) ? (
            agc_corr = agc_corr * 1.00001;
          ) : agc_corr = agc_corr * 1.000001;
        );
      );
      
      sl *= agc_corr;
      sr *= agc_corr;
      
      agcOverride > 0 ? (
        agcOverride -= .000003;
        agcOverride <= 0 ?
        (
          agcControl == 0 ? (
            slider53 = 6 * log(agc_corr) / log(2);
            slider_automate( slider53 ); 
            agc_corr = 1;
            forceUpdate = 1;
          );
        )
      );
      
      // Mitigate peaks
      // If after correction we are more than 2x higher than input, saturate the remnant with a smooth cap
      sl = capIt( sl, agcpre );
      sr = capIt( sr, agcpre );
    );
    
    out0 = sl * postgain;
    out1 = sr * postgain;
  ) : (
    out0 = 0;
    out1 = 0;
    postResetWaitSamples -= 1;
  );

  !global_bypass ? (
  
    polarityButton.active ? (
      out0 = -out0;
      out1 = -out1;
    );
  
    spl0 = out0;
    spl1 = out1;

    // Optional output clipping
    ( clipOutput ) ? 
    ( 
      spl0 = min(1,max(-1,spl0));
      spl1 = min(1,max(-1,spl1));
    );

    force_mono_output ? (
      spl1 = spl0 = .5*(spl0+spl1);
    );
  );

  block_analyzers == 0 ? (
    spectrumOut.feedSample(spl0 + spl1);
    gonioOut.feedGonio(spl0, spl1);
  );
  
  // Scope
  outVol.updateBuffer( RMS2.updateRMS(spl0, spl1) );
  
  curSample += 1;

@gfx 1135 785
  importNodes( window1.spline.xloc_gfx, window2.spline.xloc_gfx, window1.spline.yloc_gfx, window2.spline.yloc_gfx, 1 );
  window1.sort_spline(1);
  window2.sort_spline(1);
  window1.update_spline(1);
  window2.update_spline(1);

  ( activeTheme != currentTheme ) ? (
    activeTheme = currentTheme;
    initTheme(currentTheme);
  );

  function angle_line(x, y, d1, d2, angle)
  local(ca, cb)
  (
    sx = sin(angle);
    cx = cos(angle);
    gfx_line( x + d1 * cx, y + d1 * sx, x + d2 * cx, y + d2 * sx );
  );

  function recordPreset()
  (
    cSli = 1;
    loop(63,
      slider_automate(slider(cSli));
      cSli += 1;
    );
  );

  // Very basic Box Mueller. Can be done more efficiently, but who cares.
  function clampedGauss(mean, sd, lb, ub)
  local(val, iter)
  global()
  instance()
  (
    val = -1; iter = 0;
    while( ( val < lb ) || ( val > ub ) && ( iter < 50 ) )
    (
      val = sd*sqrt(-2*log(rand()))*cos(2*$pi*rand())+mean;
      iter += 1;
    );
    
    min(ub, max(lb, val));
  );

 function randomizeFilters()
  (
    agcOverride = 1;
    agc_corr = 1;
    slider53 = 0;
  
    // Filter2
    slider40 = floor(rand(nFilters));
    while(danger_list[slider40] == 1)
    (
      slider40 = floor(rand(nFilters));
    );
    slider41 = clampedGauss(.2, 1/3, 0, 0.97);    // Cutoff
    slider42 = clampedGauss(.2, 1/3, 0, 0.9);     // Resonance
    slider43 = rand(2)-1;                         // Cutoff mod
    slider44 = rand(2)*.7-1;                      // Resonance mod
    
    // Filter 1
    slider47 = floor(rand(nFilters));
    while(danger_list[slider47] == 1)
    (
      slider47 = floor(rand(nFilters));
    );
    slider48 = clampedGauss(.2, 1/3, 0, 0.97);
    slider49 = clampedGauss(.2, 1/3, 0, 0.9);
    slider62 = rand(2)-1;
    slider63 = rand(2)*.7-1;
    
    // Filter 1 mode
    slider46 = floor(rand(6));
    
    // Second filter routing
    slider50 = floor(rand(3));
    
    slider46 == 1 ? slider46 = 0; // Don't use mono double, too buggy!
    slider46 == 2 ? slider46 = 7; // Don't use M1/S2, too buggy!
    slider46 == 3 ? slider46 = 7; // Don't use M2/S1, too buggy!
    
    forceUpdate = 1;
  );

  function randomize()
  (
    agcOverride = 1;
    agc_corr = 1;
    //slider53 = 0;
    
    // SPLINE
    slider1 = 2+floor(rand(7));
    slider2 = 2+floor(rand(7));
    slider4 = rand(1);
    slider5 = rand(1);
    slider6 = rand(1);
    slider7 = rand(1);
    slider8 = rand(1);
    slider9 = rand(1);
    slider10 = rand(1);
    slider11 = rand(1);
    slider12 = rand(1);
    slider13 = rand(1);
    slider14 = rand(1);
    slider15 = rand(1);
    slider16 = rand(1);
    slider18 = rand(1);
    slider19 = rand(1);
    slider20 = rand(1);
    slider21 = rand(1);
    slider22 = rand(1);
    slider23 = rand(1);
    slider24 = rand(1);
    slider25 = rand(1);
    slider26 = rand(1);
    slider27 = rand(1);
    slider28 = rand(1);
    slider29 = rand(1);
    slider30 = rand(1);
    slider31 = rand(1);
    slider32 = rand(1);
    slider34 = rand(1);
    
    // Randomize
    env1GainButton.active = rand() > 0.5;
    env2GainButton.active = rand() > 0.5;
    env1FilterButton.active = rand() > 0.5;
    env2FilterButton.active = rand() > 0.5;
    env1Filter2Button.active = rand() > 0.5;
    env2Filter2Button.active = rand() > 0.5;
    env1Morph.active = rand() > 0.5;
    env2Morph.active = rand() > 0.5;
    env1LFO.active = rand() > 0.5;
    env2LFO.active = rand() > 0.5;
    env1FB.active = rand() > 0.5;
    env2FB.active = rand() > 0.5;
    
    envWindow1.randomEnvelopeCurve();
    envWindow2.randomEnvelopeCurve();    
    
    // Second filter routing
    slider50 = floor(rand(3));
    
    // Enabled toggles
    slider58 = floor(rand(4095));
    
    // x4 x8 etc
    slider57 = floor(rand(63));
    
    // Waveshaper type
    slider56 = floor(rand(5));
    
    // Keyfollow
    slider33 = rand(1) + 1;
    
    // Pre-Gain Mod%
    slider51 = rand(1)*0.1; 
    
    // Lookahead on
    slider35 = 3 + 16384;
    
    // LFO type
    slider36 = floor(rand(nLFO));    
    
    // LFO flags
    slider38 = floor(rand(7));
    
    // LFO freq
    slider37 = rand(1);
    
    // Mod range
    slider39 = rand(4);
    
    randomizeFilters();
    
    // Integration time
    slider64 = rand(40);
    
    // Attack/Decay/Thresh
    slider59 = rand(1);
    slider60 = rand(50);
    slider61 = rand(50);
    
    // Gains
    //slider52 = rand(25)-10;
    //slider53 = rand(25)-10;
    
    // Clipping options
    slider55 = floor(rand(7));
    
    // MIDI mode
    slider45 = floor(rand(5));
    
    forceUpdate = 1;
  );
  
  function swapSlider(idx1, idx2)
  (
    t = slider(idx1);
    slider(idx1) = slider(idx2);
    slider(idx2) = t;
  );

  function swapFilters()
  (
    swapSlider(40, 47);
    swapSlider(41, 48);
    swapSlider(42, 49);
    swapSlider(43, 62);
    swapSlider(44, 63);
    
    forceUpdate = 1;
  );  
  
  function randomizeWaveshaper()
  (
    agcOverride = 1;
    agc_corr = 1;
    slider53 = 0;
  
    // SPLINE
    slider1 = 2+floor(rand(7));
    slider2 = 2+floor(rand(7));
    slider4 = rand(1);
    slider5 = rand(1);
    slider6 = rand(1);
    slider7 = rand(1);
    slider8 = rand(1);
    slider9 = rand(1);
    slider10 = rand(1);
    slider11 = rand(1);
    slider12 = rand(1);
    slider13 = rand(1);
    slider14 = rand(1);
    slider15 = rand(1);
    slider16 = rand(1);
    slider18 = rand(1);
    slider19 = rand(1);
    slider20 = rand(1);
    slider21 = rand(1);
    slider22 = rand(1);
    slider23 = rand(1);
    slider24 = rand(1);
    slider25 = rand(1);
    slider26 = rand(1);
    slider27 = rand(1);
    slider28 = rand(1);
    slider29 = rand(1);
    slider30 = rand(1);
    slider31 = rand(1);
    slider32 = rand(1);
    slider34 = rand(1);
    
    forceUpdate = 1;
  );
  
  function randomizeLFO()
  (
    // LFO type
    slider36 = floor(rand(nLFO));
    
    // LFO freq
    slider37 = rand(1);
    
    // LFO flags
    slider38 = floor(rand(7));
    
    // Mod range
    slider39 = rand(4);
    
    forceUpdate = 1;
  );
  
  function processScrollBar()
      global(retina_scaling, yOffset, finalSize, mouse_x, mouse_y, mouse_cap, gfx_w, gfx_h)
      instance(lasty, grabbed, lastcap)
      local(scrollWidth, scrollPad, scrollX, scrollHeight, scrollHeight, blockY, blockH) 
      (
        scrollWidth = 10* retina_scaling;
        scrollPad = 10 * retina_scaling;
        scrollHeight = gfx_h - 2 * scrollpad;
        gfx_set(0.2, 0.2, 0.3, 1.0);
        gfx_rect(gfx_w - scrollWidth - scrollPad, scrollPad, scrollWidth, scrollHeight);
        scrollPad = scrollPad + 2*retina_scaling;
        scrollHeight = scrollHeight - 4*retina_scaling;
        scrollWidth = scrollWidth - 4*retina_scaling;
        scrollX = gfx_w - scrollWidth - scrollPad;
        
        gfx_set(0.4, 0.4, 0.6, 1.0);
        blockY = scrollPad + scrollHeight * yOffset / finalSize;
        blockH = scrollHeight * gfx_h / finalSize;
        gfx_rect(scrollX, blockY, scrollWidth, blockH );
        
        ( grabbed && (mouse_cap & 1 > 0) ) ?
        (
          yOffset = yOffset + (mouse_y - lasty) * (finalSize/gfx_h);
          lasty = mouse_y;
        ) : ( 
          grabbed = 0;
        );
        
        // Clicked?
        ( (mouse_cap & 1 > 0) && (lastcap & 1 == 0) ) ?
        ( 
          // On the scrollbar?
          (mouse_x > scrollX && mouse_x < (scrollX+scrollWidth) ) ? (
            ( mouse_y > scrollPad && mouse_y < (gfx_h-scrollPad) ) ? (
              ( mouse_y < blockY ) ?
              (
                yOffset = 0;
              ) : ( mouse_y > (blockY + blockH) ) ?
              (
                yOffset = finalSize - gfx_h;
              ) : ( 
                grabbed = 1;
                lasty = mouse_y;
              );
            )
          );
        );

        lastcap = mouse_cap;        
        yOffset = max(0, min(yOffset, finalSize-gfx_h) )
      );

  function draw_logo(x, y, size)
  global(gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, retina_scaling, plugname, fontface,
          logo_color_r, logo_color_g, logo_color_b )
  local(t1, t2, t3, a, ang1, ang2, dif, range)
  (
    gfx_set(logo_color_r, logo_color_g, logo_color_b,.9);
    gfx_circle( x, y, size*.2 );
    t1 = .4*size;
    t2 = .6*size;
    t3 = .7*size;
    
    a = 5*time_precise();
    ang1 = a; ang2 = ang1 + .5*$pi; range = (1/12)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    
    gfx_set(logo_color_r, logo_color_g, logo_color_b,1);
    a = 8*time_precise();
    t1 = .5*size;
    t2 = size;
    t3 = 1.3*size;
    ang1 = (1/3)*$pi + a; ang2 = ang1 + .5*$pi; range = (1/12)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_line( x + t2 * cos(ang1-range), y + t2 * sin(ang1-range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_line( x + t2 * cos(ang1+range), y + t2 * sin(ang1+range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_arc(x, y, t2, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_line( x + t2 * cos(ang1-range), y + t2 * sin(ang1-range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_line( x + t2 * cos(ang1+range), y + t2 * sin(ang1+range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_arc(x, y, t2, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_line( x + t2 * cos(ang1-range), y + t2 * sin(ang1-range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_line( x + t2 * cos(ang1+range), y + t2 * sin(ang1+range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_arc(x, y, t2, ang2 - range, ang2 + range );
    
    gfx_set(logo_color_r, logo_color_g, logo_color_b,.5);
    a = -1*time_precise();
    ang2 = a + .5*$pi; range = (3/12)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );    

    t3 = 1.5*size;
    gfx_set(logo_color_r, logo_color_g, logo_color_b,.7);
    a = -1*time_precise();
    ang2 = a + .5*$pi; range = (3/12)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    
    gfx_setfont(2, fontface, 10*retina_scaling);
    gfx_measurestr( "FILTHER", t1, t2 );
    gfx_x = x + 18*retina_scaling;
    gfx_y = y - .5*t2;
    gfx_a = .3 + .5 * sin(a);
    gfx_printf(plugname)
  );

  UI_Loaded == 0 ? (
    updateSliders(1);
    updateActiveFilters(1);
  );

  /* UI_Loaded == 0 ? */ SetupGUI();

  lastChar = gfx_getchar();
  visible = gfx_getchar(65536) & 4 > 0;
  updating == 0 ? (
    gfx_clear = -1;
    updating = 1;
    
    block_analyzers == 0 ? draw_logo(18*retina_scaling, 18*retina_scaling - yOffset, 9*retina_scaling);
    
    // Clear screen first
    hudStyle ? (
      gfx_setimgdim(2, gfx_w, gfx_h);
      gfx_dest = 2;
    );
    
    gfx_r=bg_color_r;
    gfx_g=bg_color_g;
    gfx_b=bg_color_b;
    gfx_a=bg_color_a;
    gfx_x=gfx_y=0;
    gfx_rectto(gfx_w,gfx_h);
  
    fx    = 3*wndPad+2*wndX;
    block_analyzers == 0 ? (
      fy  = wndPad*2.2 + wndY*2 + 3*retina_scaling - yOffset;
    ) : (
      fy  = specY;
    );
    hh    = wndY * .35;
    fy2   = fy + hh + .1 * wndY;
    wx    = wndX;
    
    gfx_set(filter_description_bg_r, filter_description_bg_g, filter_description_bg_b, filter_description_bg_a);
    gfx_rect(fx, fy,  wx, hh);
    gfx_rect(fx, fy2, wx, hh);
    filterDescription(slider47, fx, wx, fy);
    filterDescription(slider40, fx, wx, fy2);  
    
    window3.draw_back();
    window3.inLight.active ? (
      gfx_set( rms_in_r, rms_in_g, rms_in_b, rms_in_a );
      window3.draw_buffer(inVol.scopeptr, inVol.scopebuffer, inVol.scopebuffermax, 0, filled_input);
    );
    window3.outLight.active ? (
      gfx_set( rms_out_r, rms_out_g, rms_out_b, rms_out_a );
      window3.draw_buffer(outVol.scopeptr, outVol.scopebuffer, outVol.scopebuffermax, 0, 0);  
    );
    window3.dynLight.active ? (
      gfx_set( dyn_color_r, dyn_color_g, dyn_color_b, dyn_color_a );  
      window3.draw_buffer(dynBuf.scopeptr, dynBuf.scopebuffer, dynBuf.scopebuffermax, 1, 0); 
    );  
      
    retina_scaling > 1 ? gfx_setfont(3, fontface, 10*retina_scaling) : gfx_setfont(0);
    window3.draw_dynamics(dyn_thresh);
    
    retina_scaling > 1 ? gfx_setfont(3, fontface, 10*retina_scaling) : gfx_setfont(0);
    //window3.draw_text("Dynamics", .025, .025);
    
    // Display spectra
    block_analyzers == 0 ? (
      spectrumIn.drawGrid();
      
      !hideSpectrumIn ? spectrumIn.drawFFT(1, 1, 1);
      !hideSpectrumOut ? spectrumOut.drawFFT(0, 1, 1);    
      spectrumIn.fftWindow_processMouse(mouse_x, mouse_y, mouse_cap);
      spectrumIn.floorLevel = 25 + dnoisefloor_freq;
      spectrumOut.floorLevel = 25 + dnoisefloor_freq;
      impulse_magnitude = .01;

      // Draw filter A
      !hideSpectrumFilters ? (
        (!bypassFilter1.active && slider47 > 0) ? 
        ( 
          L_gfx.resetActiveFilter( slider47, 1 );
          L_gfx.filtertype = slider47;
          peakLocation = L_gfx.specialGraphics();
          
          updateF1gfx     = showFilterFFT && ((lastF1Mode != slider46) || (lastOversamplingF1 != slider54) || (lastDrawnF1Freq != filterFreq) || (lastDrawnF1Reso != filterReso) || (lastDrawnF1Filt != slider47));
          updateF1gfx ? (
            L_gfx.updateActiveFilter(slider47, filterFreq, filterReso, 0, 0, 1);
            lastDrawnF1Freq     = filterFreq;
            lastDrawnF1Reso     = filterReso;
            lastDrawnF1Filt     = slider47;
            lastOversamplingF1  = slider54;
            lastF1Mode          = slider46;

            filterA_gfx.impulse();
            (slider46 == 1 || slider46 == 2 || slider46 == 3) ?
            (
              // Dual mode
              filterA_gfx.feedSample(L_gfx.process(L_gfx.process(impulse_magnitude, 0), 0));
            ) : ( slider46 == 9 ) ? (
              // Inversion mode
              filterA_gfx.feedSample(1-L_gfx.process(impulse_magnitude, 0));
            ) : (
              filterA_gfx.feedSample(L_gfx.process(impulse_magnitude, 0));
            );
            loop(fftSize-1,
              (slider46 == 1 || slider46 == 2 || slider46 == 3) ?
              (
                // Dual mode
                filterA_gfx.feedSample(L_gfx.process(L_gfx.process(0, 0), 0));
              ) : ( slider46 == 9 ) ? (
                // Inversion mode
                filterA_gfx.feedSample(1-L_gfx.process(0, 0));
              ) : (
                filterA_gfx.feedSample(L_gfx.process(0, 0));
              );
            );
          );
          filterA_gfx.slope = 0;
          filterA_gfx.floorLevel = 30;
          filterA_gfx.setToFFTLoc();
          peakLocation > 0 ? filterA_gfx.drawLineFFT( peakLocation, 0 );
          showFilterFFT ? filterA_gfx.drawFFT(2, max(1, slider54), 1.0 / impulse_magnitude);
        );
        
        // Draw filter B
        (!bypassFilter2.active && slider40 > 0) ? 
        ( 
          L2_gfx.resetActiveFilter( slider40, 1 );
          L2_gfx.filtertype = slider40;
          peakLocation = L2_gfx.specialGraphics();
          
          updateF2gfx     = showFilterFFT && ((lastOversamplingF2 != slider54) || (lastDrawnF2Freq != filterFreq2) || (lastDrawnF2Reso != filterReso2) || (lastDrawnF2Filt != slider40));
          updateF2gfx ? (
            L2_gfx.updateActiveFilter(slider40, filterFreq2, filterReso2, 0, 1, 1);
            lastDrawnF2Freq     = filterFreq2;
            lastDrawnF2Reso     = filterReso2;
            lastDrawnF2Filt     = slider40;    
            lastOversamplingF2  = slider54;
          
            filterB_gfx.impulse();
            filterB_gfx.feedSample(L2_gfx.process(impulse_magnitude, 0));      
            loop(fftSize-1,
              filterB_gfx.feedSample(L2_gfx.process(0, 0));
            );
            filterB_gfx.slope = 0;
            filterB_gfx.floorLevel = 30;
            filterB_gfx.setToFFTLoc();
          );
          peakLocation > 0 ? filterB_gfx.drawLineFFT( peakLocation, 1 );
          showFilterFFT ? filterB_gfx.drawFFT(3, max(1, slider54), 1.0 / impulse_magnitude);
        );
      );
      
      //spectrumIn.xlabel("Frequency");
      gfx_setfont(1);
      spectrumIn.ylabel("Level");
      
      gonioIn.drawGonioWindow();
      gonioIn.drawGonioMeter(0);
      gonioOut.drawGonioMeter(1);
      gonioIn.drawGonioTop();
      gonioOut.gonio_processMouse(mouse_x, mouse_y, mouse_cap);      
    );
    
    envWindow1.drawEnvelopeWindow();
    envWindow2.drawEnvelopeWindow();
    envWindow1.processMouse();
    envWindow2.processMouse();
    
    window3.xlabel("Time");    
    window3.ylabel("RMS / Level");
    window1.draw_window(movAvgLN, movAvgRN, movavgOLN, movavgORN);
    window2.draw_window(movAvgLP, movAvgRP, movavgOLP, movavgORP);
    gfx_measurestr("Negative", ws, h);
    window1.draw_text("Negative", .985-ws/window1.w, .025);
    window1.xlabel("In Voltage (-)");
    window1.ylabel("Out Voltage (-)");
    gfx_measurestr("Positive", ws, h);
    window2.draw_text("Positive", .985-ws/window2.w, .025);
    window2.xlabel("In Voltage (+)");
    window2.ylabel("Out Voltage (+)");
  
    slider56 == 0 ? (
      copyRight.selectionButton_draw();
      copyLeft.selectionButton_draw();  
    );
    
    masterPanel.groupWidget_draw();
    filterPanel.groupWidget_draw();
    filterPanel2.groupWidget_draw();
    routingPanel.groupWidget_draw();
    dynamicsPanel.groupWidget_draw();
    lfoPanel.groupWidget_draw();
    feedbackPanel.groupWidget_draw();
    
    inGain.sliderWidget_draw();
    inClip.selectionButton_draw();
    linkButton.selectionButton_linkbutton();
    outGain.sliderWidget_draw();
    outClip.selectionButton_draw();
    inertia.selectionButton_draw();
    firButton.selectionButton_draw();
    polarityButton.selectionButton_draw();
    overSampling.sliderWidget_draw();
    tempoLFOButton.selectionButton_draw();
    centeredLFOButton.selectionButton_draw();
    keyAmount.sliderWidget_draw();    
    
    lfoFrequency.sliderWidget_draw();
    modulationFactor.sliderWidget_draw();
    
    keyFollow1.selectionButton_draw();
    keyFollow2.selectionButton_draw();
    pitchFollow1.selectionButton_draw();
    pitchFollow2.selectionButton_draw();
    dynamicFilterButton.selectionButton_draw();
    dynamicFilterButton2.selectionButton_draw();
    bypassFilter1.selectionButton_draw();
    bypassFilter2.selectionButton_draw();
    feedbackActive.selectionButton_draw();
    
    agcButton.active ? (
      agcButton.r = selectionbutton_color_r + (globalTime - floor(globalTime)>.5);
      agcButton.g = selectionbutton_color_g;
      agcButton.b = selectionbutton_color_b;
      agcButton.a = selectionbutton_color_a;
    ) : (
      agcButton.r = selectionbutton_color_r;
      agcButton.g = selectionbutton_color_g;
      agcButton.b = selectionbutton_color_b;
      agcButton.a = selectionbutton_color_a;
    );
    agcButton.selectionButton_draw();
    
    force_mono.selectionButton_draw();
    globalbypass.selectionButton_draw();
    legacySliders.selectionButton_draw();
    dynamicFeedback.selectionButton_draw();
    lfoFeedback.selectionButton_draw();
    dynamicMorph.selectionButton_draw();
    lfoMorph.selectionButton_draw();
    
    block_analyzers == 0 ? (
      showSpectrumInButton.selectionButton_draw();
      showSpectrumOutButton.selectionButton_draw();
      showFiltersButton.selectionButton_draw();
    );
    
    lfoFilterButton.selectionButton_draw();
    lfoFilterButton2.selectionButton_draw();
    dynamicGainButton.selectionButton_draw();
    lfoGainButton.selectionButton_draw();
    dynamicLFOButton.selectionButton_draw();
    
    env1GainButton.selectionButton_draw();
    env2GainButton.selectionButton_draw();
    env1GainButton.selectionButton_draw();
    env2GainButton.selectionButton_draw();
    env1FilterButton.selectionButton_draw();
    env2FilterButton.selectionButton_draw();
    env1Filter2Button.selectionButton_draw();
    env2Filter2Button.selectionButton_draw();
    env1Morph.selectionButton_draw();
    env2Morph.selectionButton_draw();
    env1LFO.selectionButton_draw();
    env2LFO.selectionButton_draw();
    env1FB.selectionButton_draw();
    env2FB.selectionButton_draw();
    
    dynamicWaveShapingButton.selectionButton_draw();
    lookaheadButton.selectionButton_draw();
    dynButton.selectionButton_draw();
    lfoResetButton.selectionButton_draw();
    lfoSmoothButton.selectionButton_draw();
    
    feedbackAmount.sliderWidget_draw();
    feedbackDelay.sliderWidget_draw();
    
    atk_x4_1.selectionButton_draw();
    atk_x4_2.selectionButton_draw();
    decay_x4_1.selectionButton_draw();
    decay_x4_2.selectionButton_draw();
    rms_x4_1.selectionButton_draw();
    rms_x4_2.selectionButton_draw();
    
    feedbackDelay_x8_1.selectionButton_draw();
    feedbackDelay_x8_2.selectionButton_draw();
    feedbackDelay_x8_3.selectionButton_draw();
    
    modulatorDisplay.draw_modulator();
    
    threshSlider.sliderWidget_draw();
    attackSlider.sliderWidget_draw();
    decaySlider.sliderWidget_draw();
    rmsSlider.sliderWidget_draw();
    
    /* These flags determine whether these values have an animated slider and mod range on top or not */
    inGain.hasFilterDynamics             = dynamicGainButton.active || env1GainButton.active || env2GainButton.active;
    inGain.dynval                        = gainModVal;
    inGain.hasModulatorDynamics          = lfoGainButton.active;
    outGain.hasFilterDynamics            = dynamicGainButton.active || env1GainButton.active || env2GainButton.active;
    outGain.dynval                       = gainModVal;
    outGain.hasModulatorDynamics         = lfoGainButton.active;
    
    cutoffSlider.hasFilterDynamics       = dynamicFilterButton.active || env1FilterButton.active || env2FilterButton.active;
    cutoffSlider.hasModulatorDynamics    = F1_lfo_cutoff;
    cutoffSlider.dynval                  = filter1ModValCutoff;
    resonanceSlider.hasFilterDynamics    = dynamicFilterButton.active || env1FilterButton.active || env2FilterButton.active;
    resonanceSlider.hasModulatorDynamics = F1_lfo_reso;
    resonanceSlider.dynval               = filter1ModValReso;
    
    cutoffSlider2.hasFilterDynamics      = dynamicFilterButton2.active || env1Filter2Button.active || env2Filter2Button.active;
    cutoffSlider2.hasModulatorDynamics   = F2_lfo_cutoff;
    cutoffSlider2.dynval                 = filter2ModValCutoff;
    resonanceSlider2.hasFilterDynamics   = dynamicFilterButton2.active || env1Filter2Button.active || env2Filter2Button.active;
    resonanceSlider2.hasModulatorDynamics= F2_lfo_reso;
    resonanceSlider2.dynval              = filter2ModValReso;
    
    feedbackAmount.hasFilterDynamics     = dynamicFeedback.active || env1FB.active || env2FB.active;
    feedbackAmount.hasModulatorDynamics  = lfoFeedback.active;
    feedbackAmount.dynval                = fbModVal;
    feedbackDelay.hasFilterDynamics      = dynamicFeedback.active || env1FB.active || env2FB.active;
    feedbackDelay.hasModulatorDynamics   = lfoFeedback.active;
    feedbackDelay.dynval                 = fbModVal;
    
    morphSlider.hasFilterDynamics        = dynamicMorph.active || env1Morph.active || env2Morph.active;
    morphSlider.dynval                   = morphModVal;
    morphSlider.hasModulatorDynamics     = lfoMorph.active;
    
    lfoFrequency.hasFilterDynamics       = dynamicLFOButton.active || env1LFO.active || env2LFO.active;
    lfoFrequency.dynval                  = lfoModVal;
    modulationFactor.hasFilterDynamics   = dynamicLFOButton.active || env1LFO.active || env2LFO.active;
    modulationFactor.dynval              = lfoModVal;
    
    /* Code to disable envelopes in legacy presets */
    ( envelopesPresent == 0 ) ?
    (
      envelopesPresent          = 1;
      env1GainButton.active     = 0;
      env2GainButton.active     = 0;
      env1FilterButton.active   = 0;
      env2FilterButton.active   = 0;
      env1Filter2Button.active  = 0;
      env2Filter2Button.active  = 0;
      env1Morph.active          = 0;
      env2Morph.active          = 0;
      env1LFO.active            = 0;
      env2LFO.active            = 0;
      env1FB.active             = 0;
      env2FB.active             = 0;
    );
    
    (slider35 & 32) ? (
      feedbackAmount.disabled = 0;
      feedbackDelay.disabled  = 0;
    ) : (
      feedbackAmount.disabled = 1;
      feedbackDelay.disabled  = 1;
    );

    (slider35 & 4) ? (
      cutoffSlider.disabled     = 1;
      resonanceSlider.disabled  = 1;
      filterSelect.disabled     = 1;
      modeSelect.disabled       = 1;
    ) : (
      cutoffSlider.disabled     = 0;
      resonanceSlider.disabled  = 0;
      filterSelect.disabled     = 0;
      modeSelect.disabled       = 0;
    );
    
    (slider35 & 8) ? (
      filterSelect2.disabled    = 1;
      cutoffSlider2.disabled    = 1;
      resonanceSlider2.disabled = 1;
    ) : (
      filterSelect2.disabled    = 0;
      cutoffSlider2.disabled    = 0;
      resonanceSlider2.disabled = 0;
    );

    /* Display appropriate Hertzage for the cutoff sliders */
    hz = getHz(slider47, cutoffSlider.sliderWidget_getValue());
    cutoffSlider.overridevalue = hz;
    cutoffSlider.overrideunit = "Hz";
    cutoffSlider.sliderWidget_draw();
    resonanceSlider.sliderWidget_draw();    
    
    hz = getHz(slider40, cutoffSlider2.sliderWidget_getValue());
    cutoffSlider2.overridevalue = hz;
    cutoffSlider2.overrideunit = "Hz";
    cutoffSlider2.sliderWidget_draw();
    resonanceSlider2.sliderWidget_draw();
    
    morphSlider.disabled = !(secondFilterMode == 4 || secondFilterMode == 5);
    morphSlider.sliderWidget_draw();
    
    lfoFrequency.overridevalue = modulator.modrate;
    (slider38&2) == 0 ? (
      lfoFrequency.overridevalue = ((1+2*slider37)^4 - 1);
      lfoFrequency.overrideunit = "Hz";
    ) : (
      lfoFrequency.overridevalue = -1000;
      lfoFrequency.overrideunit = tempoLabel;
    );
     
    // Combobox should be the last to draw
    lfoSelect.combobox_draw();  
    modeSelect.combobox_draw();
    modeSelect2.combobox_draw();
    filterSelect.combobox_draw();
    filterSelect2.combobox_draw();
    
    lfoSelect.combobox_draw_top();  
    modeSelect.combobox_draw_top();
    modeSelect2.combobox_draw_top();
    filterSelect.combobox_draw_top();
    filterSelect2.combobox_draw_top();    
    
    (filterSelect.hasfocus == 0) ? (
      ( modeSelect.hasFocus == 0 && modeSelect2.hasFocus == 0 ) ? (
        ( filterSelect2.hasFocus == 0 ) ? (
          ( lfoSelect.hasFocus == 0 ) ? (
            change = inGain.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( 
              slider_automate( slider51=inGain.sliderWidget_getValue2_nn(); ); 
              preChange = slider52;
              slider_automate( slider52=inGain.sliderWidget_getValue(); ); 
              linkButton.active == 1 ? slider_automate( slider53=slider53 - (slider52 - preChange); ); 
              forceUpdate = 1; ) :
            change == 2 ? ( 
              slider_automate( slider52=inGain.sliderWidget_getValue(); );
              slider_automate( slider51=inGain.sliderWidget_getValue2_nn(); );
              forceUpdate = 1;
            );
            
            change = outGain.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? (
              slider_automate( slider17=outGain.sliderWidget_getValue2_nn(); ); 
              preChange = slider53;
              slider_automate( slider53=outGain.sliderWidget_getValue(); );
              linkButton.active == 1 ? slider_automate( slider52=slider52 - (slider53 - preChange); ); 
              forceUpdate = 1; ) :
            change == 2 ? (
              preChange = slider53;
              slider_automate( slider53=outGain.sliderWidget_getValue(); );
              linkButton.active == 1 ? slider_automate( slider52=slider52 - (slider53 - preChange); ); 
              forceUpdate = 1;
              slider_automate( slider35=slider35-(slider35&2)+2 ); /* Signal that we did this and it wasn't an old preset */
              slider_automate( slider17=outGain.sliderWidget_getValue2_nn(); );
            );
            
            slider56 == 0 ? (
              copyRight.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? (
                copyRight.active = 0;
                
                slider_automate(
                  slider2 = slider1;
                  slider3 = slider19;
                  slider4 = slider20;
                  slider5 = slider21;
                  slider6 = slider22;
                  slider7 = slider23;
                  slider8 = slider24;
                  slider9 = slider25;
                  slider10 = slider26;
                  slider11 = slider27;
                  slider12 = slider28;
                  slider13 = slider29;
                  slider14 = slider30;
                  slider15 = slider31;
                  slider16 = slider32;
                  slider18 = slider34;
                );
                
                forceUpdate = 1;
              );
              
              copyLeft.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? (
                copyLeft.active = 0;
                
                slider_automate(
                  slider1 = slider2;
                  slider19 = slider3;
                  slider20 = slider4;
                  slider21 = slider5;
                  slider22 = slider6;
                  slider23 = slider7;
                  slider24 = slider8;
                  slider25 = slider9;
                  slider26 = slider10;
                  slider27 = slider11;
                  slider28 = slider12;
                  slider29 = slider13;
                  slider30 = slider14;
                  slider31 = slider15;
                  slider32 = slider16;
                  slider34 = slider18;
                );
                
                forceUpdate = 1;
              );
            );
            
            change = cutoffSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider62=cutoffSlider.sliderWidget_getValue2_nn(); ); slider_automate( slider48=cutoffSlider.sliderWidget_getValue(); ); interpCutoff = 1; forceUpdate = 1; ) : ( interpCutoff = 0 );
            change == 2 ? ( slider_automate( slider48=cutoffSlider.sliderWidget_getValue(); ); slider_automate( slider62=cutoffSlider.sliderWidget_getValue2_nn(); ); interpCutoff = 1; forceUpdate = 1; ) : ( interpCutoff = 0 );
            
            change = resonanceSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider63=resonanceSlider.sliderWidget_getValue2_nn() ); slider_automate( slider49=resonanceSlider.sliderWidget_getValue(); ); interpReso = 1; forceUpdate = 1; ) : ( interpReso = 0 );
            change == 2 ? ( slider_automate( slider49=resonanceSlider.sliderWidget_getValue(); ); slider_automate( slider63=resonanceSlider.sliderWidget_getValue2_nn() ); interpReso = 1; forceUpdate = 1; ) : ( interpReso = 0 );
            
            change = cutoffSlider2.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider43=cutoffSlider2.sliderWidget_getValue2_nn(); ); slider_automate( slider41=cutoffSlider2.sliderWidget_getValue(); ); interpCutoff2 = 1; forceUpdate = 1; ) : ( interpCutoff2 = 0 );
            change == 2 ? ( slider_automate( slider41=cutoffSlider2.sliderWidget_getValue(); ); slider_automate( slider43=cutoffSlider2.sliderWidget_getValue2_nn(); ); interpCutoff2 = 1; forceUpdate = 1; ) : ( interpCutoff2 = 0 );
            
            change = resonanceSlider2.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider44=resonanceSlider2.sliderWidget_getValue2_nn() ); slider_automate( slider42=resonanceSlider2.sliderWidget_getValue(); ); interpReso2 = 1; forceUpdate = 1; ) : ( interpReso2 = 0 );
            change == 2 ? ( slider_automate( slider42=resonanceSlider2.sliderWidget_getValue(); ); slider_automate( slider44=resonanceSlider2.sliderWidget_getValue2_nn() ); interpReso2 = 1; forceUpdate = 1; ) : ( interpReso2 = 0 );            

            change = feedbackAmount.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider31=feedbackAmount.sliderWidget_getValue2_nn(); ); slider_automate( slider15=feedbackAmount.sliderWidget_getValue(); ); forceUpdate = 1; );
            change == 2 ? ( slider_automate( slider15=feedbackAmount.sliderWidget_getValue(); ); slider_automate( slider31=feedbackAmount.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );

            change = feedbackDelay.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider32=feedbackDelay.sliderWidget_getValue2_nn(); ); slider_automate( slider16=feedbackDelay.sliderWidget_getValue(); ); forceUpdate = 1; );
            change == 2 ? ( slider_automate( slider16=feedbackDelay.sliderWidget_getValue(); ); slider_automate( slider32=feedbackDelay.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );

            change = morphSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
            change == 1 ? ( slider_automate( slider34=morphSlider.sliderWidget_getValue2_nn(); ); slider_automate( slider18=morphSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
            change == 2 ? ( slider_automate( slider18=morphSlider.sliderWidget_getValue(); ); slider_automate( slider34=morphSlider.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );

            overSampling.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider54=overSampling.sliderWidget_getValue(); ); forceUpdate = 1; );
          
            keyAmount.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)        ? ( slider_automate( slider33=keyAmount.sliderWidget_getValue(); ); forceUpdate = 1; );
          
            threshSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider59=threshSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
            attackSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider60=attackSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
            decaySlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)      ? ( slider_automate( slider61=decaySlider.sliderWidget_getValue(); ); forceUpdate = 1; );
            rmsSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)        ? ( slider_automate( slider64=rmsSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
            
            linkButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            
            inClip.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            outClip.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            inertia.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            newClipMode = inClip.active + 2 * outClip.active + 4 * inertia.active;
            ( slider55 != newClipMode ) ? ( slider_automate( slider55=newClipMode; ); forceUpdate = 1; );
            
            firButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            ( slider50 & 1 != firButton.active ) ? ( slider_automate( slider50=slider50 - (slider50&1) + firButton.active; ); forceUpdate = 1; );
            
            polarityButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            
            atk_x4_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            atk_x4_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            decay_x4_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            decay_x4_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            rms_x4_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            rms_x4_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);                
            newMultiplierMode = atk_x4_1.active + 2*atk_x4_2.active + 4 * decay_x4_1.active + 8 * decay_x4_2.active + 16 * rms_x4_1.active + 32 * rms_x4_2.active;
            ( slider57 != newMultiplierMode ) ? ( slider_automate( slider57=newMultiplierMode; ); forceUpdate = 1; );
                      
            change = agcButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            ( change == 1 ) ? ( 
              agcControl = agcButton.active;
            ) : ( change == 2 ) ? (
              slider53 = slider53 + 6 * log(agc_corr) / log(2);
              slider_automate( slider53 ); 
              agcControl = agcButton.active = 0;
              agc_corr = 1;
              forceUpdate = 1;
            );
            
            force_mono.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? force_mono_output = force_mono.active;
            globalbypass.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? global_bypass = globalbypass.active;
             
            dynButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider45 = dynButton.active + (slider45 & 2) + ( slider45 & 4 ) + ( slider45 & 8 ); ); forceUpdate = 1; );
            lfoResetButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);            
            tempoLFOButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            centeredLFOButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
            newLFOMode = lfoResetButton.active + 2*tempoLFOButton.active + 4 * centeredLFOButton.active;
            ( slider38 != newLFOMode ) ? ( slider_automate( slider38=newLFOMode ); forceUpdate = 1; );
            
            lfoFrequency.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( 
              slider_automate( slider37=lfoFrequency.sliderWidget_getValue(); ); 
              mod_LFO_rate = lfoFrequency.sliderWidget_getValue2_nn();
              forceUpdate = 1; 
            );
            modulationFactor.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap) ? ( 
              slider_automate( slider39=modulationFactor.sliderWidget_getValue(); ); 
              mod_LFO_amount = modulationFactor.sliderWidget_getValue2_nn();
              forceUpdate = 1;
            );
            
            showSpectrumInButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap )  ? hideSpectrumIn      = 1 - showSpectrumInButton.active;
            showSpectrumOutButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap ) ? hideSpectrumOut     = 1 - showSpectrumOutButton.active;
            showFiltersButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap )     ? hideSpectrumFilters = 1 - showFiltersButton.active;
            
            // Something changed w.r.t. dynamics
            env1GainButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env2GainButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env1FilterButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env2FilterButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env1Filter2Button.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env2Filter2Button.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env1Morph.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env2Morph.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env1LFO.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env2LFO.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env1FB.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            env2FB.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( forceUpdate = 1; );
            
            lookAheadButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)     ? ( slider_automate( slider35=(slider35 - (slider35&1))+lookAheadButton.active; ); forceUpdate = 1; );
            bypassFilter1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)       ? ( slider_automate( slider35=(slider35 - (slider35&4))+4*bypassFilter1.active; ); forceUpdate = 1; );
            bypassFilter2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)       ? ( slider_automate( slider35=(slider35 - (slider35&8))+8*bypassFilter2.active; ); forceUpdate = 1; );
            lfoSmoothButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)     ? ( slider_automate( slider35=(slider35 - (slider35&16))+16*lfoSmoothButton.active; ); forceUpdate = 1; );
            feedbackActive.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)      ? ( slider_automate( slider35=(slider35 - (slider35&32))+32*feedbackActive.active; ); forceUpdate = 1; );
            dynamicFeedback.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)     ? ( slider_automate( slider35=(slider35 - (slider35&64))+64*dynamicFeedback.active; ); forceUpdate = 1; );
            lfoFeedback.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)         ? ( slider_automate( slider35=(slider35 - (slider35&128))+128*lfoFeedback.active; ); forceUpdate = 1; );            
            feedbackDelay_x8_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)  ? ( slider_automate( slider35=(slider35 - (slider35&256))+256*feedbackDelay_x8_1.active; ); forceUpdate = 1; );
            feedbackDelay_x8_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)  ? ( slider_automate( slider35=(slider35 - (slider35&512))+512*feedbackDelay_x8_2.active; ); forceUpdate = 1; );
            feedbackDelay_x8_3.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)  ? ( slider_automate( slider35=(slider35 - (slider35&8192))+8192*feedbackDelay_x8_3.active; ); forceUpdate = 1; );
            dynamicMorph.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)        ? ( slider_automate( slider35=(slider35 - (slider35&1024))+1024*dynamicMorph.active; ); forceUpdate = 1; );
            lfoMorph.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)            ? ( slider_automate( slider35=(slider35 - (slider35&2048))+2048*lfoMorph.active; ); forceUpdate = 1; );            
            dynamicLFOButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)    ? ( slider_automate( slider35=(slider35 - (slider35&4096))+4096*dynamicLFOButton.active; ); forceUpdate = 1; );
            legacySliders.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)       ? ( slider_automate( slider35=(slider35 - (slider35&16384))+16384*(1-legacySliders.active); ); forceUpdate = 1; );
            
            dynamicFilterButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) || 
            dynamicFilterButton2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) || 
            lfoFilterButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) || 
            lfoFilterButton2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) || 
            dynamicWaveShapingButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ||
            dynamicGainButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ||
            lfoGainButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ||
            keyFollow1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap ) ||
            keyFollow2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap ) || 
            pitchFollow1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap ) ||
            pitchFollow2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap ) ? (
              updateDynamicsSlider = 1;
            );
            
            updateDynamicsSlider ? (
              slider58 = 2 * dynamicWaveShapingButton.active + 4 * dynamicFilterButton.active +
                         8 * lfoFilterButton.active + 16 * dynamicFilterButton2.active +
                         32 * lfoFilterButton2.active + 64 * dynamicGainButton.active + 
                         128 * lfoGainButton.active + 256 * keyFollow1.active + 
                         512 * keyFollow2.active + 1024 * pitchFollow1.active + 
                         2048 * pitchFollow2.active;
              slider_automate(slider58);
              forceUpdate = 1;
              updateDynamicsSlider = 0;
            );
            
            window1.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap, last_mouse_cap);
            window2.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap, last_mouse_cap);
            dyn_thresh = window3.processMouseDynamics(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap, dyn_thresh);
          );
        );
      );
    );
  
    ( modeSelect2.hasFocus == 0 && filterSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 && filterSelect2.hasFocus == 0 ) ?
      modeSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider46=modeSelect.curitem; ); );
  
    ( modeSelect.hasFocus == 0 && filterSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 && filterSelect2.hasFocus == 0 ) ?
      modeSelect2.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider50=((slider50&1) + modeSelect2.curitem*2); );  forceUpdate = 1; );
  
    ( modeSelect2.hasFocus == 0 && modeSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 && filterSelect2.hasFocus == 0 ) ?
      filterSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider47=filterSelect.combobox_getCurItem(); ); forceUpdate = 1; );
  
    ( modeSelect2.hasFocus == 0 && modeSelect.hasFocus == 0 && filterSelect.hasFocus == 0 && filterSelect2.hasFocus == 0 ) ?
      lfoSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider36=lfoSelect.curitem; ); forceUpdate = 1; );
  
    ( modeSelect2.hasFocus == 0 && modeSelect.hasFocus == 0 && filterSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 ) ?
      filterSelect2.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider40=filterSelect2.combobox_getCurItem(); ); forceUpdate = 1; );
  
    lx = mouse_x;
    ly = mouse_y;
    
    ( refreshDynMode != slider45 ) ?
    (
      ( slider45 == 10 || slider45 == 11 ) ?
      (
        threshSlider.setLabel("Lin Smoothing");
        attackSlider.setLabel("Exp Smoothing");
        decaySlider.setLabel("");
        dynButton.setLabel("");
        
        dynButton.hint = "Unavailable in modwheel mode.";
        threshSlider.hint = "Zero order smoothing\n\nSmoothing is best tweaked by setting both to maximum\ninitially and then dialing in as much as needed from both.\nExponential responds faster, but in some cases linear may\nsound more natural.\n";
        attackSlider.hint = "Exponential smoothing\n\nSmoothing is best tweaked by setting both to maximum\ninitially and then dialing in as much as needed from both.\nExponential responds faster, but in some cases linear may\nsound more natural.\n";
        decaySlider.hint  = "Unavailable in modwheel mode.";
      ) : ( slider45 == 0 || slider45 == 6 || slider45 == 8 ) ?
      (
        threshSlider.setLabel("Threshold");
        attackSlider.setLabel("Attack");
        decaySlider.setLabel("Decay");
        dynButton.setLabel("RMS Mode");

        dynButton.hint = "Use threshold or modulate directly by RMS.\n\nThe dynamic variable (shown with the yellow curve) changes based\non one of two mechanisms. Either it changes based on an attack/decay\nmechanism based on thresholding the input RMS value (RMS mode off),\nor it is directly set (without transient) to a function of the RMS \nvalue (RMS mode on).";
        threshSlider.hint = "Threshold value.\nWhen input RMS exceeds this value,\nthe dynamic variable begins to accumulate.\n";
        attackSlider.hint = "Attack\nHow long does the dynamic variable take to change\nto its maximal value once over the threshold..";
        decaySlider.hint  = "Decay\nHow long does the dynamic variable take to\ndecay when below the threshold";        
      ) : ( slider45 == 1 || slider45 == 7 || slider45 == 9 ) ?
      (
        threshSlider.setLabel("Maximum");
        attackSlider.setLabel("Curve / Attack");
        decaySlider.setLabel("Inversion");
        dynButton.setLabel("RMS Mode");
        
        dynButton.hint = "Use threshold or modulate directly by RMS.\n\nThe dynamic variable (shown with the yellow curve) changes based\non one of two mechanisms. Either it changes based on an attack/decay\nmechanism based on thresholding the input RMS value (RMS mode off),\nor it is directly set (without transient) to a function of the RMS \nvalue (RMS mode on).";
        threshSlider.hint = "Maximum\nAt which RMS signal value should\nthe dynamic modulation be 1.\n";
        attackSlider.hint = "Curve\nSets how steep the non-linearity between\nRMS value and dynamic variable is.";
        decaySlider.hint  = "Inversion\nChange polarity. 25 results in no dynamic modulation."; 
      ) : ( slider45 == 2 || slider45 == 4 ) ?
      (
        threshSlider.setLabel("Hold");
        attackSlider.setLabel("Attack");
        decaySlider.setLabel("Decay");
        dynButton.setLabel("Legato");
        
        dynButton.hint = "Play fixed envelope and restart envelope\nupon each MIDI note or play legato style.";
        threshSlider.hint = "Shape.\nShape of the envelope (0.5 = linear).\n";
        attackSlider.hint = "Attack\nHow long does the dynamic variable take to change\nto its maximal value once over the threshold..";
        decaySlider.hint  = "Decay\nHow long does the dynamic variable take to\ndecay when below the threshold"; 
      ) : ( slider45 == 3 || slider45 == 5 ) ?
      (
        threshSlider.setLabel("Shape");
        attackSlider.setLabel("Attack");
        decaySlider.setLabel("Decay");
        dynButton.setLabel("Legato");
        
        dynButton.hint = "Play fixed envelope and restart envelope\nupon each MIDI note or play legato style.";
        threshSlider.hint = "Shape.\nShape of the envelope (0.5 = linear).\n";
        attackSlider.hint = "Attack\nHow long does the dynamic variable take to change\nto its maximal value once over the threshold..";
        decaySlider.hint  = "Decay\nHow long does the dynamic variable take to\ndecay when below the threshold"; 
      );

      forceUpdate = 1;
      refreshDynMode = slider45;
    );
    
    ( LFO_was_reset == 1 ) ? 
    ( 
      lfoResetButton.highlightNow();
      LFO_was_reset = 0;
    );
    
    decaySlider.disabled = 0;
    ( slider45 == 10 || slider45 == 11 ) ?
    (
      threshSlider.overridevalue = (1/dyn_atk_time) / srate;
      threshSlider.overrideunit = " s";
      attackSlider.overridevalue = (log(2)/dyn_atk) / srate;
      attackSlider.overrideunit = " s";
      decaySlider.overridevalue = 0;
      decaySlider.disabled = 1;
      decaySlider.overrideunit = " ";
    ) : ( slider45 == 0 || slider45 == 6 || slider45 == 8 ) ?
    (
      threshSlider.overridevalue = 0;
      threshSlider.unit = " V";
      attackSlider.overridevalue = dyn_atk_time / srate;
      attackSlider.overrideunit = "s";
      decaySlider.overridevalue = dyn_decay_time / srate;
      decaySlider.overrideunit = "s";
    ) : ( slider45 == 1 || slider45 == 7 || slider45 == 9 ) ? 
    (
      threshSlider.overridevalue = 0;
      threshSlider.unit = " V";
      attackSlider.overridevalue = 0;
      decaySlider.overridevalue = 0;
    ) : ( slider45 == 2 || slider45 == 4 ) ?
    (
      threshSlider.overridevalue = dyn_hold_time / srate;
      threshSlider.overrideunit = "s";
      attackSlider.overridevalue = dyn_atk_time / srate;
      attackSlider.overrideunit = "s";
      decaySlider.overridevalue = 2*dyn_decay_time / srate;
      decaySlider.overrideunit = "s";
    ) : ( slider45 == 3 || slider45 == 5 ) ?
    (
      threshSlider.overridevalue = 0;
      threshSlider.unit = "-";
      attackSlider.overridevalue = dyn_atk_time / srate;
      attackSlider.overrideunit = "s";
      decaySlider.overridevalue = 2*dyn_decay_time / srate;
      decaySlider.overrideunit = "s";
    );
    
    globalTime = time_precise();
    delta_time = globalTime - lastGlobalTime;
    
    rts = 35*retina_scaling;
    ( (mouse_cap & 1) ) ?
    (
      (lastLMB == 0) && (mouse_x < rts) && (mouse_y < rts) ? (
        tc = time_precise();
        lastLMB = 1;
      
        ( (tc-lastLogoClick) < .2 ) ? (
          extraScale = (extraScale == 0) ? .2 : 0;
          SetupGUI();
        ) : lastLogoClick = tc;
      )
    ) : ( lastLMB = 0; );
    
    lastGlobalTime = globalTime;
    
    hideToolTips == 0 ? (
      drawHint_draw();
      
      spectrumIn.highlighted      = 0;
      window3.highlighted         = 0;
      dynamicsPanel.highlighted   = 0;
      lfoPanel.highlighted        = 0;
      envWindow1.highlighted      = 0;
      envWindow2.highlighted      = 0;

      mux = max(0, min(6*hinttime-2, 1));
      hover == 1 ? lfoPanel.highlighted = mux;
      hover == 2 ? (dynamicsPanel.highlighted = mux; window3.highlighted = mux );
      hover == 3 ? envWindow1.highlighted = mux;
      hover == 4 ? envWindow2.highlighted = mux;
      hover == 5 ? spectrumIn.highlighted = mux;
    );
    
    helpOpen == 1 ? 
    (
      gfx_set( 0, 0, 0, .95 );
      helpx = 75 * retina_scaling;
      helpy = 25 * retina_scaling;
      gfx_rect( .5*helpx, helpy, 500, 500 );
      gfx_x = 10;
      gfx_y = 2*helpy;
      
      gfx_setfont(4, fontface, 15*retina_scaling);
      gfx_set( .7, .7, .9, .8 ); gfx_x = helpx; 
      gfx_printf( "F1 - Help" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( ". - Switch theme" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "L - Different font (linux compatibility mode)" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "T - Hide tooltips and highlighting" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + R - Randomize everything" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + S - Swap filter 1 and 2" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + F - Randomize filters" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "Shift + W - Randomize waveshaper" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "Shift + L - Randomize LFO" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + Q - Rescale UI to fit window" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + P - Emit settings" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + G - Graphics Light (do not render spectrum and goniometer)" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + H - Switch to HUD style" ); gfx_x = helpx; gfx_y += helpy;
      gfx_printf( "SHIFT + M - Force mono output" ); gfx_x = helpx; gfx_y += helpy;      
      gfx_printf( "F12 - MIDI Reset (if a note got stuck)" ); gfx_x = helpx; gfx_y += helpy;
    );
    
    // 
    ( lastChar == 26161 ) ? helpOpen = 1 - helpOpen;
    ( lastChar == 82 && ((mouse_cap & 8)>0) ) ? randomize();
    ( lastChar == 83 && ((mouse_cap & 8)>0) ) ? swapFilters();
    ( lastChar == 70 && ((mouse_cap & 8)>0) ) ? randomizeFilters();
    ( lastChar == 87 && ((mouse_cap & 8)>0) ) ? randomizeWaveshaper();
    ( lastChar == 77 && ((mouse_cap & 8)>0) ) ? ( force_mono_output = 1 - force_mono_output; forceUpdate = 1; );
    ( lastChar == 76 && ((mouse_cap & 8)>0) ) ? randomizeLFO();
    ( lastChar == 80 && ((mouse_cap & 8)>0) ) ? recordPreset();
    ( lastChar == 71 && ((mouse_cap & 8)>0) ) ? block_analyzers = 1-block_analyzers;
    ( lastChar == 6697266 ) ? notesOn = 0;                                            // F12
    ( lastChar == 72 && ((mouse_cap & 8)>0) ) ? hudStyle = 1 - hudStyle;              // F3
    ( lastChar == 81 && ((mouse_cap & 8)>0) ) ? rescaleToFit();
    ( lastChar == 46 ) ? ( currentTheme += 1; currentTheme > maxTheme ? currentTheme = 0; );
    ( lastChar == 116 ) ? hideToolTips = 1 - hideToolTips; // T
    ( lastChar == 108 ) ? ( linuxMode = 1 - linuxMode; setupGUI(); ); // L
    
    last_mouse_cap = mouse_cap;
    
    ( scrollbar == 1 ) ? 
    (
     // yOffset = 100 * retina_scaling;
      yOffset = scroller.processScrollbar();
    );
    
    hudStyle ? (
      lighten = .4;
      gfx_dest = -1;
      gfx_x = gfx_y=0;
      gfx_blit(2, 1, 0);
      
      gfx_dest = 2;
      gfx_mode = 1;
      gfx_x = gfx_y = 0; gfx_blurto(gfx_w, gfx_h);
      gfx_x = gfx_y = 0; gfx_blurto(gfx_w, gfx_h);
      gfx_muladdrect(0, 0, gfx_w, gfx_h, lighten, lighten, lighten, 1.0);
      gfx_dest = -1;
      gfx_x = gfx_y = 0;
      gfx_blit(2, 1, 0);
    );   
    
    updating = 0;
    mouse_wheel = 0;
  );
  
  
  
