import reajs_compatibility.jsfx-inc
noindex: truedesc:Saike Reflectosaurus (beta) [ReaJS-Compatibility]
tags: multi-tap delay plugin
version: 0.102
author: Joep Vanlier
changelog: Reserve more memory for pitch shifter (old reajs compatibility)
license: MIT
about:
  # A flexible delay plugin for setting up complex delays and reverbs.
  [Screenshot](https://raw.githubusercontent.com/JoepVanlier/JSFX/master/Reflectosaurus_Manual/Overview.png)
  ### Manual
  A full manual can be found here: [manual](https://github.com/JoepVanlier/JSFX/raw/master/Reflectosaurus_Manual/Reflectosaurus_Manual.pdf)
  ### Demos
  You can find demos of the plugin [here](https://www.youtube.com/watch?v=47L9bysgIiA) and [here](https://www.youtube.com/watch?v=pUu3h21yARY).
  ### Features:
  - Up to 10 node delay.
  - Positive, negative and allpass delay.
  - Delay filtering (LPF w/ resonance, HPF).
  - Various delay saturation algorithms.
  - Delay sends.
  - Two reverberation algorithms (FFT-based and allpass).
  - Delay time pitch tracking based on MIDI input.
  - Granular resynthesis.
  - Pitch shifting.
  - Side chain compressing the delays.
  - A decent selection of presets.

options:maxmem=12000000
options:no_meter
import Reflectosaurus_grainlib.jsfx-inc
import Reflectosaurus_widgets.jsfx-inc
import Reflectosaurus_compressor.jsfx-inc
import Reflectosaurus_pitchlib.jsfx-inc
import Reflectosaurus_midilib.jsfx-inc
import Reflectosaurus_buffers.jsfx-inc
import Reflectosaurus_allpassverb.jsfx-inc

slider1:drywet=1.0<0,1,.001>-Dry/Wet
slider2:SyncMode=0<0,1,6{Off,Fourth,Third,Fifth,Eight,Sixth,Tonal>-Mode
slider3:Snap=0<0,1,1{Off,On}>-Snap
slider4:LP=1<0,1,.00001>-Global LP Cutoff
slider5:HP=0<0,1,.00001>-Global HP Cutoff
slider6:LPRES=0<0,1,.00001>-Global LP Resonance

slider7:dummy=0<0,1,1>-Dummy
slider8:dummy=0<0,1,1>-Dummy
slider9:dummy=0<0,1,1>-Dummy

slider10:X1=0.09<0,1,.000000001>-X1
slider11:Y1=0.6<0,1,.000000001>-Y1
slider12:X2=0.18<0,1,.000000001>-X2
slider13:Y2=0.6<0,1,.000000001>-Y2
slider14:X3=0.27<0,1,.000000001>-X3
slider15:Y3=0.6<0,1,.000000001>-Y3
slider16:X4=0.36<0,1,.000000001>-X4
slider17:Y4=0.6<0,1,.000000001>-Y4
slider18:X5=0.45<0,1,.000000001>-X5
slider19:Y5=0.6<0,1,.000000001>-Y5
slider20:X6=0.55<0,1,.000000001>-X6
slider21:Y6=0.6<0,1,.000000001>-Y6
slider22:X7=0.63<0,1,.000000001>-X7
slider23:Y7=0.6<0,1,.000000001>-Y7
slider24:X8=0.73<0,1,.000000001>-X8
slider25:Y8=0.6<0,1,.000000001>-Y8
slider26:X9=0.82<0,1,.000000001>-X9
slider27:Y9=0.6<0,1,.000000001>-Y9
slider28:X10=.91<0,1,.000000001>-X10
slider29:Y10=0.6<0,1,.000000001>-Y10
slider30:X11=1.0<0,1,.000000001>-X11
slider31:Y11=0.6<0,1,.000000001>-Y11

slider32:FB1=0<0,1,.00000001>-Feedback 1
slider33:FB2=0<0,1,.00000001>-Feedback 2
slider34:FB3=0<0,1,.00000001>-Feedback 3
slider35:FB4=0<0,1,.00000001>-Feedback 4
slider36:FB5=0<0,1,.00000001>-Feedback 5
slider37:FB6=0<0,1,.00000001>-Feedback 6
slider38:FB7=0<0,1,.00000001>-Feedback 7
slider39:FB8=0<0,1,.00000001>-Feedback 8
slider40:FB9=0<0,1,.00000001>-Feedback 9
slider41:FB10=0<0,1,.00000001>-Feedback 10
slider42:FB11=0<0,1,.00000001>-Feedback 11
slider43:shine_slider=0<0,1,.0000001>-shine
slider44:Pan1=0.5<0,1,.00000001>-Pan 1
slider45:Pan2=0.5<0,1,.00000001>-Pan 2
slider46:Pan3=0.5<0,1,.00000001>-Pan 3
slider47:Pan4=0.5<0,1,.00000001>-Pan 4
slider48:Pan5=0.5<0,1,.00000001>-Pan 5
slider49:Pan6=0.5<0,1,.00000001>-Pan 6
slider50:Pan7=0.5<0,1,.00000001>-Pan 7
slider51:Pan8=0.5<0,1,.00000001>-Pan 8
slider52:Pan9=0.5<0,1,.00000001>-Pan 9
slider53:Pan10=0.5<0,1,.00000001>-Pan 10
slider54:Pan11=0.5<0,1,.00000001>-Pan 11
slider55:dummy=0<0,1,1>-Dummy
slider56:dummy=0<0,1,1>-Dummy
slider57:dummy=0<0,1,1>-Dummy
slider58:dummy=0<0,1,1>-Dummy
slider59:dummy=0<0,1,1>-Dummy
slider60:dummy=0<0,1,1>-Dummy
slider61:note_response_time=0<0,100,.001>-Glide time
slider62:force_enabled=0<0,1,1>-Force Enabled (overrides automute)

slider63:Inertia=50<0,500,.001>-Inertia
slider64:WetGain=0<-32,32,.001>-Gain

@init
nShapers = 11;
allow_updates = 1;
gfx_ext_retina = 1;
quickSwitch = 1;
UPDATE_INTERVAL = 4;

  function init_lpg_time_constants()
  local(lpg_attack, lpg_decay)
  global(lpg_k_atk, lpg_k_decay, srate, lpg_srate_norm, lpg_update_rate)
    (
      lpg_attack = 9.22;
      lpg_decay = 110.666667;
      lpg_k_atk = 1000 / lpg_attack / srate;
      lpg_k_decay = 1000 / lpg_decay / srate;
      lpg_srate_norm = 2.0 / srate;
      lpg_update_rate = 8;
    );

  /* Very flat 6-pole butterworth made of cascade of cytomics' SVF */
  function init_HP6(freq)
    global(srate)
    local(res)
    instance(g, a1_1, a1_2, a1_3, a2_1, a2_2, a2_3, k1, k2, k3)
    (
      g = tan( $pi * freq );
      
      k1  = 1.93185165257814; // sqrt(2+sqrt(3))
      a1_1 = 1/(1+g*(g+k1));
      
      k2 = 1.41421356474619; // sqrt(2)
      a1_2 = 1/(1+g*(g+k2));
      
      k3 = 0.517638090205042; // sqrt(2-sqrt(3))
      a1_3 = 1/(1+g*(g+k3));
      
      a2_1 = g*a1_1;
      a2_2 = g*a1_2;
      a2_3 = g*a1_3;
    );

  function eval_HP6(v0)
    global()
    local(v1, v2, hp)
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq,
             g, a1_1, a1_2, a1_3, a2_1, a2_2, a2_3, k1, k2, k3)
    (
      v1 = a1_1 * ic1eq + a2_1*(v0-ic2eq);
      v2 = ic2eq + g*v1;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;
      hp    = v0 - k1*v1 - v2;
      
      v1 = a1_2 * ic3eq + a2_2*(hp-ic4eq);
      v2 = ic4eq + g*v1;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      hp    = hp - k2*v1 - v2;
      
      v1 = a1_3 * ic5eq + a2_3*(hp-ic6eq);
      v2 = ic6eq + g*v1;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;
      
      hp    = hp - k3*v1 - v2;
    );  
 
function updateGlobalFeedback()
  global(globalFeedbackAttn, globalFeedback)
  local()
  (
    globalFeedback = 10^(-36.0*globalFeedbackAttn/20);
  );
  
function log2(x)
local()
global()
(
  log(x)/log(2)
);

function roundToNote(x)
global()
local(c)
(
  c = 12 * log2(x/440);
  c = 440 * 2 ^ (floor(c) / 12)
);

  
function xToTime(x)
global(mintime, maxtime, xmin, xmax, srate, SyncMode)
local()
(
  SyncMode > 0 && ( syncMode < 6 ) ? (
    maxTime * x + minTime;
  ) : (
    minTime * 2^((log2(maxTime)-log2(minTime))*x);
  );
);


function timeToX(dtime)
  global(mintime, maxtime, SyncMode, freeNodes)
  local(v)
  (
    v = SyncMode && ( syncMode < 6 ) ? (
      (dTime - minTime) / maxTime;
    ) : (
      (log2(dTime) - log2(minTime)) / (log2(maxTime) - log2(minTime));
    );
    
    !freeNodes ? clamp(v, 0, 1) : v;
  );

// Input for this function is half divided by the dtime (the frequency)
function toNote(note_frequency)
global(tester)
local(c, st, N)
(
  //c = 12 * log(x*512/440) / log(2);
  c = 12 * log2(note_frequency/440);
  
  c -= floor(c/12)*12;
  N = floor(c+.001);
  c -= N;
  st = 104;
  abs(c) > .009999 ? (
    N == 0 ? ( sprintf(st, "%s %.2f", "A", c)
    ) : ( N == 1 ) ? ( sprintf(st, "%s %.2f", "A#", c)
    ) : ( N == 2 ) ? ( sprintf(st, "%s %.2f", "B", c)
    ) : ( N == 3 ) ? ( sprintf(st, "%s %.2f", "C", c)
    ) : ( N == 4 ) ? ( sprintf(st, "%s %.2f", "C#", c)
    ) : ( N == 5 ) ? ( sprintf(st, "%s %.2f", "D", c)
    ) : ( N == 6 ) ? ( sprintf(st, "%s %.2f", "D#", c)
    ) : ( N == 7 ) ? ( sprintf(st, "%s %.2f", "E", c)
    ) : ( N == 8 ) ? ( sprintf(st, "%s %.2f", "F", c)
    ) : ( N == 9 ) ? ( sprintf(st, "%s %.2f", "F#", c)
    ) : ( N == 10 ) ? ( sprintf(st, "%s %.2f", "G", c)
    ) : ( N == 11 ) ? ( sprintf(st, "%s %.2f", "G#", c)
    )
  ) : (
    N == 0 ? ( sprintf(st, "A")
    ) : ( N == 1 ) ? ( sprintf(st, "A#")
    ) : ( N == 2 ) ? ( sprintf(st, "B")
    ) : ( N == 3 ) ? ( sprintf(st, "C")
    ) : ( N == 4 ) ? ( sprintf(st, "C#")
    ) : ( N == 5 ) ? ( sprintf(st, "D")
    ) : ( N == 6 ) ? ( sprintf(st, "D#")
    ) : ( N == 7 ) ? ( sprintf(st, "E")
    ) : ( N == 8 ) ? ( sprintf(st, "F")
    ) : ( N == 9 ) ? ( sprintf(st, "F#")
    ) : ( N == 10 ) ? ( sprintf(st, "G")
    ) : ( N == 11 ) ? ( sprintf(st, "G#")
    )
  );
);

function updateRange()
(
  SyncMode && (SyncMode < 6) ? (
    SyncMode > 3 ? (
      maxTime = 8*60/tempo;
      minTime = 0;
    ) : (
      maxTime = 16*60/tempo;
      minTime = 0;
    );
  ) : (
    (SyncMode == 0) ? (
      //minTime = 4/100;
      maxTime = 4;
      minTime = maxTime / 1024;
    ) : (
      minTime = 2/440;
      maxTime = 2/(440/32);
    );
  );
);
updateRange();

  function tanh(x)
  local()
  global()
  instance()
  (
    (2/(1+exp(-2*x)))-1.0
  );  
  
function smoothSaturator(x)
local(cterm, indep,
      p0, p1, p2, p3, p4, p5, p6, p7)
global()
(
    p0 = -0.43497619473852767;
    p1 = -0.5460978062661744;
    p2 = -0.9288977638330088;
    p3 = -1.8931725230583496;
    p4 = -1.901829522587536;
    p5 = -0.7951494375999134;
    p6 = -0.35701520925330404;
    
    indep = p2 + p3*x + p6*x*x;
    cterm = indep < 0 ? 1 : cterm > $pi ? -1 : cos(indep);
    p4 * tanh(p0 + p1*x) + p5 * cterm
);
   
/***************************/
/* Reverb section          */
/***************************/  
function initWindow(_window_mem, windowtype, fftSize)
  global()
  instance(pwr, window_mem)
  local(i, dwindowpos, windowpos, windowSize)
  (
    windowSize = fftSize*.5;
    window_mem = _window_mem;
    windowpos = 0;
    dwindowpos = $pi*2/windowSize;
    i = 0; pwr = 0;
    loop(fftSize/2+1,
       pwr += (window_mem[i] = (
         windowtype==0 ? ( 0.5 - cos(windowpos)*0.5 ) :
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
      
    i = 0;
    loop(fftSize*.5+1, 
      window_mem[i] = sqrt(window_mem[i]);
      i+=1; 
    );
  );  
   
function windowBlock()
  instance(window_mem, fft_mem, fftSize)
  local(fftPtr, windowPtr)
  global()
  (
    /* Window */
    windowPtr = window_mem;
    fftPtr = fft_mem;

    loop(fftSize,
      fftPtr[] *= windowPtr[];
      fftPtr += 1;
      fftPtr[] *= windowPtr[];
      fftPtr += 1;
      windowPtr += 1;
    );
  );

 function processBlockVerb(outputPtr)
    instance(fft_mem, fftSize, nSamples, mag_mem, phase_mem, offset, 
             dampFactor, sharedBuffer, outputBufStart, outputBufEnd, shine, ice, ice_panned)
    local(ifftSize, fwd, bwd, chnk1, idamp,
          r1, r2, i1, i2, re1, im1, re2, im2, x1, x2, x1sq, x2sq, sqlen, isqlen, ang1, ang2,
          cMag, cPhase, outPtr, fftPtr, fftPtr2, magPtr, magPtr2, phasePtr, 
          i, last, new,
          g_rand1, g_rand2, g_rand3, g_rand4, tmp)
    global(mode)
    (
      this.windowBlock();
       
      // FFT this block
      ifftSize = 1/fftSize;
      fft(fft_mem, fftSize);
      fft_permute(fft_mem, fftSize);
  
      magPtr      = mag_mem;
      re1         = fft_mem[] + fft_mem[];
      re2         = fft_mem[1] + fft_mem[1];
      magPtr[]    = re1; magPtr += 1;
      magPtr[]    = re2; magPtr += 1;
      
      // Decompose into magnitude and phase
      fwd       = 2;
      bwd       = fftSize;
      loop(fftSize/2 - 1,
        bwd = 2*fftSize - fwd;
        r1  = fft_mem[fwd];
        i1  = fft_mem[fwd + 1];
        r2  = fft_mem[bwd];
        i2  = fft_mem[bwd + 1];
        
        re1 = r1 + r2;
        im1 = i1 - i2;
        re2 = i1 + i2;
        im2 = r2 - r1;
        
        magPtr[]    = sqrt(re1*re1 + im1*im1); magPtr += 1;
        magPtr[]    = sqrt(re2*re2 + im2*im2); magPtr += 1;
        fwd += 2;
      );      
      
      shine ? (
        i = 0;
        idamp = shine * (1.0 - dampFactor);
        loop(fftSize/2 - 1,
          i2 = 2*i;
          sharedBuffer[i2]      += idamp*sharedBuffer[i];
          sharedBuffer[i2 + 1]  += idamp*sharedBuffer[i + 1];
          i += 2;
        );
      );
      
      ice ? (
        g_rand1 = 2*(1 + floor(rand() * 2));
        g_rand2 = 0.01 * fftSize + rand() * fftSize/2;
        g_rand4 = g_rand3 = 100 * rand() * (1.0-dampFactor) * ice;
        
        ice_panned ? (
          tmp = rand();
          g_rand3 = g_rand3 * sqrt(1.0-tmp);
          g_rand4 = g_rand4 * sqrt(tmp);      
        );
        
        i = 0;
        tmp = 0;
        loop(fftSize/2,
          i2 = g_rand1*i;
          i2 < fftSize ? (
            sharedBuffer[i2]      = sharedBuffer[i2] + g_rand3*sharedBuffer[2*i] * tmp;
            sharedBuffer[i2 + 1]  = sharedBuffer[i2 + 1] + g_rand4*sharedBuffer[2*i + 1] * tmp;
            tmp         = g_rand2 - i;
            tmp         = -50 * tmp * tmp;
            tmp         = exp(tmp / fftSize);
          );
          i += 1;
        );
      );
      
      /////////////////////////////
      // Perform processing here //
      /////////////////////////////
      fftPtr = sharedBuffer;
      magPtr = mag_mem;
      
      loop( fftSize - 1,
        mode == 1 ? (
          fftPtr[] = fftPtr[]*dampFactor + magPtr[];
        ) : (
          fftPtr[] = max(fftPtr[]*dampFactor, magPtr[]);
        );
        fftPtr += 1;
        magPtr += 1;
      );      
      
      // Add basic verb from magnitude
      fftPtr = sharedBuffer;
      magPtr = mag_mem;
      loop( fftSize - 1,
        magPtr[] = fftPtr[];
        fftPtr += 1;
        magPtr += 1;
      );

      /////////////////////////////
      // End processing here     //
      /////////////////////////////
      
      /* Fix issue with peak near nyquist */
      fwd = 0;
      loop(35,
        mag_mem[fwd] = 0;
        mag_mem[fftSize-fwd] = 0;
        fwd += 1;
      );
      
      /* TO DO: Investigate why this peak beyond the end of the buffer affects the FFT */
      fwd = 0;
      loop(4,
        fft_mem[fftSize-fwd] = 0;
        fft_mem[fftSize+fwd] = 0;
        fwd += 1;
      );
      
      // Spectra at this point are interleaved                
      // At this point magPtr contains interleaved magnitude  
      // Phase contains interleaved phases                   
      //      fft_mem[0] = 0;
      //      fft_mem[1] = mag_mem[1] * cos(phase_mem[1]);
       
      fwd = 0;
      bwd = fftSize;
      magPtr = mag_mem;
      phasePtr = phase_mem;
      ifftSize = .5*ifftSize; /* Normalizing constant */
      
      bwd = 2*fftSize;
      loop(fftSize/2 - 1,
        //bwd = 2*fftSize - fwd;
          
        // Spectrum 1
        cMag        = ifftSize*magPtr[];
          
        // Generate random phase angle uniform on the circle without sin/cos (von Neumann1951)
        // Note that technically for accurate uniformity, we should check whether x1sq+x2sq >= 1 and
        // reject the sample if it is, but this is omitted. This leads to a slight bias in the angles 
        // as this will be violated with a probability of 1-(pi/4).
        x1 = 2*rand()-1;
        x2 = 2*rand()-1;
        x1sq = x1*x1;
        x2sq = x2*x2;
        sqlen = x1sq + x2sq;
          
        isqlen = 1.0 / sqlen;
        ang1 = (x1sq - x2sq) * isqlen;
        re1 = cMag * ang1; // Real
        ang2 = (2.0 * x1 * x2) * isqlen;
        im1 = cMag * ang2; // Imaginary   
        
        magPtr += 1;
          
        // Spectrum 2
        cMag        = ifftSize*magPtr[];
          
        x1 = 2*rand()-1;
        x2 = 2*rand()-1;
        x1sq = x1*x1;
        x2sq = x2*x2;
        sqlen = x1sq + x2sq;
            
        isqlen = 1 / sqlen;
        ang1 = (x1sq - x2sq) * isqlen;
        re2 = cMag * ang1; // Real
        ang2 = (2 * x1 * x2) * isqlen;
        im2 = cMag * ang2; // Imaginary
          
        magPtr += 1;
        
        // Multiplex it back into the complex spectrum before backtrafo
        fft_mem[fwd]      = re1 - im2;  // Real 1
        fft_mem[bwd]      = re1 + im2;  // Real 2
        
        fft_mem[fwd + 1]  = re2 + im1;  // Imag 1
        fft_mem[bwd + 1]  = re2 - im1;  // Imag 2
          
        fwd += 2;
        bwd -= 2;
      );
      
      fft_ipermute(fft_mem, fftSize);
      ifft(fft_mem, fftSize);
      
      this.windowBlock();
      
      outPtr = outputPtr + offset;
      fftPtr = fft_mem;
      loop(nSamples,
        ( outPtr > outputBufEnd ) ? outPtr = outputBufStart;
      
        outPtr[] += fftPtr[]; outPtr += 1; fftPtr += 1;
        outPtr[] += fftPtr[]; outPtr += 1; fftPtr += 1;        
      );
    );

/* One overlapping chunk of the convolution */
function updateVerb(verbOutputPtr, left, right)
  instance(fft_mem, fft_end, ptr)
  local()
  global()
  (
    (ptr >= fft_end) ? (
      this.processBlockVerb(verbOutputPtr);
      ptr = fft_mem;
      //memset(ptr, 0, 65536);
    );
      
    ptr[]  = left;    ptr += 1;
    ptr[]  = right;   ptr += 1;
  );
    
function initFFTBuffer(_fft_mem, _nSamples, _fftSize, _mag_mem, _phase_mem)
  instance(fft_mem, ptr, fft_end, fftSize, nSamples, mag_mem, phase_mem)
  local()
  global()
  (
    fft_mem   = _fft_mem;
    nSamples  = _nSamples;
    fft_end   = _fft_mem + _nSamples;
    ptr       = _fft_mem;
    fftSize   = _fftSize;
    mag_mem   = _mag_mem;
    phase_mem = _phase_mem;
  );    
    
function initializeVerb(bufferPos)
  local(fftSize, nSamples, windowType,
        bufMem, magMem, phaseMem, bufMem2, magMem2, phaseMem2, windowMem, sharedBuffer,
        bufferDist )
  global()
  instance(verbBuf, verbBuf2, verbOutputPtr, verbOutputBufStart, verbOutputBufEnd)
  (
    bufferDist  = 65536;
    
    verbOutputBufStart = bufferPos;
    verbOutputBufEnd   = bufferPos + bufferDist - 4;
    
    bufMem         = bufferPos + 1*bufferDist;
    magMem         = bufferPos + 2*bufferDist;
    phaseMem       = bufferPos + 3*bufferDist;
    windowMem      = bufferPos + 4*bufferDist;
    
    bufMem2        = bufferPos + 5*bufferDist;
    magMem2        = bufferPos + 6*bufferDist;
    phaseMem2      = bufferPos + 7*bufferDist;
    
    /* Temporary buffer */
    sharedBuffer   = bufferPos + 8*bufferDist;
  
    fftSize     = 2048*8*2;
    nSamples    = 1024*8*2;
    windowType  = 0;

    verbBuf.initFFTBuffer(bufMem, nSamples, fftSize, magMem, phaseMem);  
    verbBuf.initWindow(windowMem, windowType, nSamples);
    verbBuf2.initFFTBuffer(bufMem2, nSamples, fftSize, magMem2, phaseMem2); 
    verbBuf2.initWindow(windowMem, windowType, nSamples);
    
    verbOutputBufStart      = verbOutputBufStart;
    verbOutputBufEnd        = verbOutputBufEnd;
    verbBuf.sharedBuffer    = sharedBuffer;
    verbBuf2.sharedBuffer   = sharedBuffer;
    verbBuf.outputBufStart  = verbOutputBufStart;
    verbBuf2.outputBufStart = verbOutputBufStart;
    verbBuf.outputBufEnd    = verbOutputBufEnd;
    verbBuf2.outputBufEnd   = verbOutputBufEnd;
    
    verbOutputPtr = verbOutputBufStart;
    
    verbBuf2.ptr += nSamples/2;
    
    bufferPos + 9*bufferDist
  );

function processVerb(inL, inR)
  global()
  local()
  instance(verbBuf, verbBuf2, outL, outR, verbOutputPtr, verbOutputBufStart, verbOutputBufEnd, damp, mode, shine, ice, ice_panned)
  (  
    verbBuf.dampFactor = damp;
    verbBuf2.dampFactor = damp;
    verbBuf.mode = mode;
    verbBuf2.mode = mode;
    verbBuf.shine = shine;
    verbBuf2.shine = shine;
    verbBuf.ice = ice;
    verbBuf.ice_panned = ice_panned;
    verbBuf2.ice = ice;
    verbBuf2.ice_panned = ice_panned;
    
    verbBuf.updateVerb(verbOutputPtr, inL, inR);
    verbBuf2.updateVerb(verbOutputPtr, inL, inR);
    verbOutputPtr > verbOutputBufEnd ? verbOutputPtr = verbOutputBufStart;
    outL = verbOutputPtr[]; verbOutputPtr[] = 0; verbOutputPtr += 1; 
    outR = verbOutputPtr[]; verbOutputPtr[] = 0; verbOutputPtr += 1;
  );
  
/***************************/
/* End of reverb section   */
/***************************/  
  
function f_trafo(freq)
  local()
  global()
  instance()
  (
    exp( (1-freq) * log(20/22050) ) * $pi;
  );
  
function f_trafo_hz(freq)
  local()
  global(srate)
  instance()
  (
    .5 * exp( (1-freq) * log(20/22050) ) * srate;
  );

function init_linearSVF(freq, res)
  global()
  local(f0, ct, st, div)
  instance(ic1eq, ic2eq, k, a1, a2, a3, resonance_scaling)
  (
    f0 = 0.5 * f_trafo(freq);
    k = 2 - 2*res;
    
    ct = cos(f0);
    st = sin(f0);
    div = 1.0 / (1.0 + k * st * ct);
    a1 = ct * ct * div;
    a2 = st * ct * div;
    a3 = st * st * div;
    
    resonance_scaling = k/(2-(1-.25*k*k));
  );
  
function init_linearSVF_direct(freq, res)
  global()
  local(g)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    g = tan(.5 * $pi * freq);
    k = 2 - 2*res;
    
    a1 = 1/(1+g*(g+k));
    a2 = g*a1;
    a3 = g*a2;
  ); 

function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );
  
function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3, resonance_scaling)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2 * resonance_scaling
  );  
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );  
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );

  // Tilt filters used for the saturator's warmth  parameter
  function init_tilt(freq, res, A)
    global()
    local(g, k)
    instance(ic1eq, ic2eq, A, a1, a2, a3, m0, m1, m2)
    (
      g = tan(.5 * $pi * freq) / sqrt(A);
      k = 2 - 2*res;
      
      a1 = 1/(1+g*(g+k));
      a2 = g*a1;
      a3 = g*a2;
      
      m0 = 1;
      m1 = k*(A-1);
      m2 = (A*A - 1);
    );

  function eval_tilt(v0)
    global()
    local(v1, v2, v3)
    instance(ic1eq, ic2eq, a1, a2, a3, m0, m1, m2)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3*v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;    
      
      (v0 + m1 * v1 + m2 * v2)
    );

function octaver_reset()
  local()
  global()
  instance(flipflopState)
  (
    flipflopState = 1;
    this.svf.reset_linearSVF();
    this.svf2.reset_linearSVF();
    this.svf3.reset_linearSVF();
    this.svf4.reset_linearSVF();
  );
    
function octaver_eval(sample)
  local(out)
  global()
  instance(lpsample, flipflopState, pflipflopState, h1, cnt, bal1, f_est, sidx)
  (
    sidx += 1;
    lpsample = this.svf3.eval_linearSVF_LP( this.svf4.eval_linearSVF_HP( sample ) );
    (lpsample > 0 && h1 < 0 && sidx > 25) ? (
      cnt += 1;
      flipflopState = -flipflopState;
      f_est = .7 * f_est + .3 * ( 1.0 / sidx );
      sidx = 0;
    );
    
    cnt > 1 ?
    (
      cnt = 0;
    );
    
    h1 = lpsample;
    out = (1-bal1) * sample*pflipflopState;
    pflipflopState = .98*pflipflopstate + .02*flipflopState;
    
    out
  );

function lpg_func(lpg, input_gain)
  global()
  local(t)
  instance()
  (
    t = (0.573144 + 20.2149 * lpg*lpg*lpg*lpg) * input_gain;
    0.185304 * (1.0 - exp(- t*t)) - 0.00307613
  );

function lpg_eval(l, r)
  global(lpg_srate_norm, lpg_k_atk, lpg_k_decay, lpg_update_rate, samples)
  local(l_cur, r_cur, gate_left, gate_right)
  instance(state_l, state_r, lOut, rOut, lpg_level,
           l_gate_filt.init_linearSVF_direct, r_gate_filt.init_linearSVF_direct,
           l_gate_filt.eval_linearSVF_LP, r_gate_filt.eval_linearSVF_LP)
  (
    l_cur = abs(l);
    r_cur = abs(r);
  
    state_l += state_l < l_cur ? lpg_k_atk * (l_cur - state_l) : lpg_k_decay * (l_cur - state_l);
    state_r += state_r < r_cur ? lpg_k_atk * (r_cur - state_r) : lpg_k_decay * (r_cur - state_r);

    (samples % lpg_update_rate == 0) ? (
      gate_left = min(lpg_func(lpg_level, state_l), 1.0);
      gate_right = min(lpg_func(lpg_level, state_r), 1.0);
      
      gate_left = max(50, 44100 * gate_left) * lpg_srate_norm;
      gate_right = max(50, 44100 * gate_right) * lpg_srate_norm;
    
      this.l_gate_filt.init_linearSVF_direct(gate_left, 0);
      this.r_gate_filt.init_linearSVF_direct(gate_right, 0);
      this.l_gate_filt.resonance_scaling = 1.0;
      this.r_gate_filt.resonance_scaling = 1.0;
    );
    
    lOut = this.l_gate_filt.eval_linearSVF_LP(l);
    rOut = this.r_gate_filt.eval_linearSVF_LP(r);
  );

function octaver_init(filterfreq)
  local(f_est)
  global()
  instance(bal1)
  (
    bal1 = filterFreq;
    
    f_est = .005;
    this.svf.init_linearSVF_direct( f_est, 0 );
    this.svf2.init_linearSVF_direct( .5*f_est, 0 );
    this.svf3.init_linearSVF( .0005, 0 );
    this.svf4.init_linearSVF( .01, 0 );
  );

function lpg_init(level)
  global()
  local(attack, decay)
  instance(lpg_level)
  (
    lpg_level = level;
  );

// INTERPOLATOR SECTION
 function smooth_parameter(target)
  instance(s, coeff)
  global()
  local(y, v)
  (
    v = coeff*(target - s);
    y = v + s;
    s = y + v;
    y
  );
  
  function initialize_smoother(cutoff)
  instance(coeff, idx, s)
  global(srate)
  local(g)
  ( 
    s = slider(idx);
    g = tan($pi*cutoff/srate);
    coeff = g/(1+g);  
  );

  function interpolator_init(slider_idx)
  instance(next_val, idx)
  local()
  global()
  (
    next_val = slider(slider_idx);
    idx = slider_idx;
  );

  function interpolator_block()
  instance(delta, next_changepoint_t, next_val, idx)
  local(next_changepoint_y)
  global(samplesblock)
  (
    next_changepoint_t = slider_next_chg(idx, next_changepoint_y);
    next_changepoint_t > 0 ? 
    (
      next_val = slider(idx);
    ) : (
      next_changepoint_y = slider(idx);
      next_changepoint_t = samplesblock;
    );
    
    delta = (next_changepoint_y - next_val) / next_changepoint_t;
  );
  
  function interpolate()
  instance(delta, next_changepoint_t, next_val, idx, coeff)
  local(current_value, next_changepoint_y)
  global(current_sample)
  (
    current_value = next_val;
    current_sample == next_changepoint_t ? 
    (
      delta = 0;
      next_changepoint_t = slider_next_chg(idx, next_changepoint_y);
      delta = next_changepoint_t > current_sample ? (next_changepoint_y - current_value) / (next_changepoint_t-current_sample) : 0;
    );
    
    next_val = current_value + delta;
    
    coeff > 0 ? this.smooth_parameter(current_value) : current_value
  );
  
  function initialize_interpolators()
  (
    lp_interpolator.interpolator_init(4);
    hp_interpolator.interpolator_init(5);
    lpres_interpolator.interpolator_init(6);
    gain_interpolator.interpolator_init(64);
 
    (last_inertia != inertia) ? (
      last_inertia = inertia;
      inertia_cutoff = 1000.0/inertia;
      lp_interpolator.initialize_smoother(inertia_cutoff);
      hp_interpolator.initialize_smoother(inertia_cutoff);
      lpres_interpolator.initialize_smoother(inertia_cutoff);
      gain_interpolator.initialize_smoother(inertia_cutoff);
      change += 1;
    );
  );
  
  initialize_interpolators();
  
function yToVol(y)
  global(minvol, maxvol)
  local()
  (
    // Same as 10^(-30*dB/20)
    exp(-1.5*y*log(10)) 
  );  
  
  function flutter()
  local()
  global(srate, update_alpha, inv_update_alpha, samples)
  instance(flutter, cFlutter, flutterLpf)
  (
    cFlutter = update_alpha * flutter + inv_update_alpha * cFlutter;
    cFlutter * srate * flutterLpf.eval_linearSVF_BP(rand()-0.5) / 100;
  );
  
  function updateNode()
  local(newdtime, current_dtime, dTimeOffset)
  global(HQ, srate, MAX_MOVE, globalFeedback, update_alpha, inv_update_alpha, pitchMod, freeNodes)
  instance(hq_active, fbc, diff, buffer, tx, x, y, dtime, ctime, timeOffset, activevol, Gain, invol, invollast, oldvol, vol, pan, panlast, lPanTerm, rPanTerm, lpl, hpl, lpr, hpr, lpf, hpf, llpf, lhpf, fb, fbcoeff, xlast, ylast, fblast, olddtime, mute, solo, flutter,
           lfo, lfoAdvanceStep, lfoDepthFactor, lfoTime, lpfResonance, llreso, lpfActive, lflutter, fbslast, feedbackSign, pitch, pitchTracking,
           isReverb, xSmoothed, lastfb)
  (
    y > 1 ? y = 1;
    !freeNodes ? ( x > 1 ? x = 1; );
    y < 0 ? y = 0;
    x < 0 ? x = 0;
    
    ( !mute || solo ) ? (
      ctime = dtime;
      pitchTracking && pitchmod ? ctime *= pitchMod;
      newdtime = update_alpha * (srate * ctime + timeOffset) + inv_update_alpha * olddtime;
      
      (lfo > 0) ? ( lfoTime += lfoAdvanceStep;
        lfoTime += lfoAdvanceStep;
        dTimeOffset = sin(lfoTime) * lfoDepthFactor;
        diff = 1;
      ) : diff = olddtime - newdtime;
    
      isReverb ? (
        xSmoothed == 0 ? xSmoothed = x;
        xSmoothed = update_alpha * x + inv_update_alpha * xSmoothed;
        (abs(xSmoothed - x) > .00001) || (abs(fb - lastfb) > .00001) ? (
          this.allpassverbInit(xSmoothed, fb, .5);
          lastfb = fb;
        );
      ) : (
        ( abs( diff ) > .0000001 || ( invollast == 99999 ) || flutter || lflutter || (HQ != hq_active) ) ? (
          hq_active = HQ;
          current_dtime = newdtime;
          flutter ? current_dtime += this.flutter();
          buffer.setOffset(max(current_dtime + dTimeOffset, 4), HQ );
          lflutter = flutter;
        );
      );
      olddtime = newdtime;
      
      activevol = update_alpha * vol + inv_update_alpha * oldvol;
      oldvol = activevol;
      fbc = fb * globalFeedback;
    
      ( y != ylast ) ? ( vol = yToVol(y);  ylast = y; );
      ( Gain != invollast ) ? ( invol = Gain<1 ? yToVol(Gain) : 0; invollast = Gain; );
      ( (fbc != fblast) || (feedbackSign != fbslast) ) ? ( 
        fbcoeff = .95*exp( -4.0 * ( 1.0 - fbc ) );
        fblast = fbc;
        fbslast = feedbackSign;
        feedbackSign ? fbcoeff = - fbcoeff;
      );
      ( pan != panlast ) ? ( lPanTerm = cos($pi*pan/2); rPanTerm = sin($pi*pan/2); panlast = pan; );
    
      lpfActive = lpf < 1.0 || lpfResonance > 0.0;
      ( lpfActive && (lpf != llpf || lpfResonance != llreso) ) ? ( lpl.init_linearSVF(lpf, .99*lpfResonance); lpr.init_linearSVF(lpf, .99*lpfResonance); llpf = lpf; llreso = lpfResonance; );
      ( hpf > 0.0 && hpf != lhpf) ? ( hpl.init_linearSVF(hpf, 0); hpr.init_linearSVF(hpf, 0); lhpf = hpf; );
    );
  );
  
POSITION_LOC = 10;
FB_LOC = 32;
PAN_LOC = 44;
function updateFromSlider()
  local()
  global(slider, shine_slider, POSITION_LOC, FB_LOC, PAN_LOC)
  instance(y, dtime, fb, me, pan, shine)
  (
    dtime = xToTime( slider(POSITION_LOC + (me-1)*2) );
    y = slider(POSITION_LOC + (me-1)*2 + 1);
    fb = slider(FB_LOC + (me-1));
    pan = slider(PAN_LOC + (me-1));
    shine = shine_slider;
  );
  
function updateToSlider()
  local(xl)
  global(slider, POSITION_LOC, FB_LOC, PAN_LOC, allow_updates)
  instance(y, dtime, me, fb, pan)
  (
    allow_updates > 2 ? (
      xl = POSITION_LOC + (me-1)*2;
      slider(xl) = timeToX(dtime);
      xl += 1;
      slider(xl) = y;
      slider(FB_LOC + (me-1)) = fb;
      slider(PAN_LOC + (me-1)) = pan;
    );
  );
  
function updateToSliderNonScaled()
  local(xl)
  global(slider, POSITION_LOC, FB_LOC, PAN_LOC, allow_updates)
  instance(y, dtime, me, fb, pan)
  (
    xl = POSITION_LOC + (me-1)*2 + 1;
    slider(xl) = y;
    slider(FB_LOC + (me-1)) = fb;
    slider(PAN_LOC + (me-1)) = pan;
  );
  
function updateToSliderRec()
  local(xl, newtime)
  global(slider, POSITION_LOC, FB_LOC, PAN_LOC, allow_updates)
  instance(y, dtime, me, fb, pan)
  (
    allow_updates > 2 ? (
      xl = POSITION_LOC + (me-1)*2;
      newtime = timeToX(dtime);
      slider(xl) != newtime ? (
        slider_automate(slider(xl) = newtime);
      );
      xl += 1;
      slider(xl) != y ? (
        slider_automate(slider(xl) = y);
      );
      xl = FB_LOC + (me-1);
      slider(xl) != fb ? (
        slider(xl) = fb;
        slider_automate(slider(xl) = fb);
      );
      xl = PAN_LOC + (me-1);
      slider(xl) != pan ? (
        slider(xl) = pan;
        slider_automate(slider(xl) = pan);
      );
    );
  );

function updateNodeBlock()
  local(omega_tilt)
  global(srate, UPDATE_INTERVAL, pitchMod)
  instance(dtime, recv, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11, saturationGain, ceiling, invCeiling, warmth, lWarmth
  l_tilt, r_tilt, l_itilt, r_itilt, tilt_gain, inverse_tilt_gain, slew_target, degrade, invdegrade,
  octaver, rectify, lfo, lfoDepth, lfoFrequency, lfoDepthFactor, lfoAdvanceStep, pitch, shifter, shift_pitch, timeOffset)
  (
    recv = fromNode1 || fromNode2 || fromNode3 || fromNode4 || fromNode5 || fromNode6 || fromNode7 || fromNode8 || fromNode9 || fromNode10 || fromNode11;

    timeOffset = 0;
    lfoAdvanceStep = 2.0 * lfoFrequency * $pi * UPDATE_INTERVAL / srate;
    lfoDepthFactor = lfoDepth * 0.002 * srate; // 0.002 since the sample buffer is packed two samples at a time

    ceiling     = exp(.11512925464970228420089957273422 * saturationGain); //log(10)/20 = .11512925464970228420089957273422;
    invCeiling = 1.0 / ceiling;

    rectify == 6 ? (
      this.octaver.octaver_init(1-saturationGain/36);   
    ) : ( rectify == 9 ) ? (
      ceiling = (saturationGain / 9 - 2) * 2 * $pi * 440 / (pitchMod * srate);
    ) : ( rectify == 7 ) ? (
      slew_target = 1.0 - exp(-0.04797052277070928508370815530592 * saturationGain); // 15 * log(10)/20 / 36
    ) : ( rectify == 8 ) ? (
      degrade = 2 + 2^(.44444444*(36.0-saturationGain));
      invdegrade = 1.0/degrade;
    ) : ( rectify == 10 ) ? (
      this.lpg.lpg_init(saturationGain/36);
    );
    
    pitch ? (
      shifter.setPitchShifterSpeed(2*((2^(shift_pitch))-1.0));
    );
    pitch == 1 ? timeOffset -= 1035; /* Approximate latency comp for the shifter */
    
    warmth != lwarmth ? (
      tilt_gain = 10^(12*warmth / 20);
      inverse_tilt_gain = 1.0 / tilt_gain;
      omega_tilt = 3200 / srate;
      l_tilt.init_tilt(omega_tilt, 0, tilt_gain);
      r_tilt.init_tilt(omega_tilt, 0, tilt_gain);
      l_itilt.init_tilt(omega_tilt, 0, inverse_tilt_gain);
      r_itilt.init_tilt(omega_tilt, 0, inverse_tilt_gain);
      lwarmth = warmth;
    );
    
    //timeOffset = max(-srate * dtime + 7, timeOffset);
    timeOffset < - srate * dtime ? timeOffset = 0;
 );

function getReceives()
  local()
  global( node1.lastL, node2.lastL, node3.lastL, node4.lastL, node5.lastL, node6.lastL, node7.lastL, node8.lastL, node9.lastL, node10.lastL, node11.lastL, 
          node1.lastR, node2.lastR, node3.lastR, node4.lastR, node5.lastR, node6.lastR, node7.lastR, node8.lastR, node9.lastR, node10.lastR, node11.lastR,
          sendSaturation )
  instance(recv, lIn, rIn, 
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11,
           me)
  (
    recv ? (
      ( me == 1 )    ? ( fromNode1 *= 0 )
      : ( me == 2 )  ? ( fromNode2 *= 0 )
      : ( me == 3 )  ? ( fromNode3 *= 0 )
      : ( me == 4 )  ? ( fromNode4 *= 0 )
      : ( me == 5 )  ? ( fromNode5 *= 0 )
      : ( me == 6 )  ? ( fromNode6 *= 0 )
      : ( me == 7 )  ? ( fromNode7 *= 0 )
      : ( me == 8 )  ? ( fromNode8 *= 0 )
      : ( me == 9 )  ? ( fromNode9 *= 0 )
      : ( me == 10 ) ? ( fromNode10 *= 0 )
      : ( me == 11 ) ? ( fromNode11 *= 0 );
      
      fromNode1 ? (
        lIn = lIn + fromNode1 * node1.lastL;
        rIn = rIn + fromNode1 * node1.lastR;
      );
      
      fromNode2 ? (
        lIn = lIn + fromNode2 * node2.lastL;
        rIn = rIn + fromNode2 * node2.lastR;
      );
        
      fromNode3 ? (
        lIn = lIn + fromNode3 * node3.lastL;
        rIn = rIn + fromNode3 * node3.lastR;
      );
        
      fromNode4 ? (
        lIn = lIn + fromNode4 * node4.lastL;
        rIn = rIn + fromNode4 * node4.lastR;
      );
      
      fromNode5 ? (
        lIn = lIn + fromNode5 * node5.lastL;
        rIn = rIn + fromNode5 * node5.lastR;
      );
      
      fromNode6 ? (
        lIn = lIn + fromNode6 * node6.lastL;
        rIn = rIn + fromNode6 * node6.lastR;
      );
      
      fromNode7 ? (
        lIn = lIn + fromNode7 * node7.lastL;
        rIn = rIn + fromNode7 * node7.lastR;
      );
      
      fromNode8 ? (
        lIn = lIn + fromNode8 * node8.lastL;
        rIn = rIn + fromNode8 * node8.lastR;
      );
      
      fromNode9 ? (
        lIn = lIn + fromNode9 * node9.lastL;
        rIn = rIn + fromNode9 * node9.lastR;
      );
      
      fromNode10 ? (
        lIn = lIn + fromNode10 * node10.lastL;
        rIn = rIn + fromNode10 * node10.lastR;
      );
      
      fromNode11 ? (
        lIn = lIn + fromNode11 * node11.lastL;
        rIn = rIn + fromNode11 * node11.lastR;
      );
    );
    
    sendSaturation ? (
      lIn = tanh(lIn);
      rIn = tanh(rIn);
    );
  );

eps = 0.0000000001;
function rectify(in)
  instance(last, diff, F0last)
  local(out, F0n)
  global(eps)
  (
    F0n = .5*in*in*sign(in);
    diff = in - last;
  
    ( diff > eps ) ? (
      out = ( F0n - F0last ) / diff;
    ) : (
      out = abs(.5*(in+last));
    );
    
    last = in;
    F0last = F0n;
    
    out
  );
  
  /* Simple monopole */
  function fixdc(x)
  local()
  global()
  instance(DC_fixed, prev)
  (
    DC_fixed=0.995*DC_fixed + x - prev;
    prev=x;
  
    DC_fixed
  );  
  
slew_factor = .999 * slew_factor + .001 * (0.00075*srate*slew_target);  
  
function slew_buffer(x, slew_factor)
local(diff)
global()
instance(lx)
(
  diff = tanh(slew_factor*(x - lx))/slew_factor;
  lx = lx + diff;
  lx
);

function processWaveshapers(l, r)
instance(warmth, tilt_gain, ceiling, invCeiling, rectify,
         l_itilt, r_itilt, l_tilt, r_tilt, tilt_gain, inverse_tilt_gain, slew_target,
         shaped_r, lx, slew_target, slew_factor, l_slew, r_slew, degrade, invdegrade)
global(srate, samples)
local(factor, t)
(
    // De-emphasize before shaper for warmth
    warmth != 0 ? (
      l=l_itilt.eval_tilt(l)*tilt_gain;
      r=r_itilt.eval_tilt(r)*tilt_gain;
    );
              
    rectify == 1 ? (
      // Higher quality anti-aliasing rectification
      // decided against this for performance reasons
      //l = this.rectl.rectify(l);
      //r = this.rectr.rectify(r);
      l = abs(l);
      r = abs(r);
          
      l = this.dcfl.fixdc(l);
      r = this.dcfr.fixdc(r);
    ) : ( rectify == 2 ) ?
    (
      l = tanh(ceiling*l)*invCeiling;
      r = tanh(ceiling*r)*invCeiling;
    ) : ( rectify == 3 ) ? 
    (
      l = .5*l*ceiling;
      r = .5*r*ceiling;
      ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
      ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      l = l * invCeiling;
      r = r * invCeiling;
    ) : ( rectify == 4 ) ?
    (
      l = smoothSaturator(ceiling*l)*invCeiling;
      r = smoothSaturator(ceiling*r)*invCeiling;
      l = this.dcfl.fixdc(l);
      r = this.dcfr.fixdc(r);
    ) : ( rectify == 5 ) ? (
      /* Crossover distortion */
      l = l * ceiling;
      r = r * ceiling;
      ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
      ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
          
      factor = -15.09587456;
          
      t = l*l;
      l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-exp(factor*t));
      t = r*r;
      r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-exp(factor*t));
      l = l * invCeiling;
      r = r * invCeiling;
    ) : ( rectify == 6 ) ? (
      t = this.octaver.octaver_eval(l+r);
      l = this.octaver.bal1 * l + t*.5;
      r = this.octaver.bal1 * r + t*.5;
    ) : ( rectify == 7 ) ? (
      slew_target > 0 ? (
        slew_factor = .999 * slew_factor + .001 * (0.00075*srate*slew_target);
        l = l_slew.slew_buffer(l, slew_factor);
        r = r_slew.slew_buffer(r, slew_factor);
      );
    ) : ( rectify == 8 ) ? (
      l = floor(degrade * l + .5) * invdegrade;
      r = floor(degrade * r + .5) * invdegrade;
    ) : ( rectify == 9 ) ? (
      t = ceiling * samples;
      l = l * sin(t);
      r = r * sin(t);
    ) : ( rectify == 10 ) ? (
      this.lpg.lpg_eval(l, r);
      l = this.lpg.lOut;
      r = this.lpg.rOut;
    );
        
    // Re-emphasize after shaper for warmth
    warmth != 0 ? (
      l=l_tilt.eval_tilt(l)*inverse_tilt_gain;
      r=r_tilt.eval_tilt(r)*inverse_tilt_gain;
    );
    
    shaped_r = r;
    l
  );

function process(l_in, r_in)
  local(tmp, lr, ll, t, l, r)
  global(lOut, rOut, srate, dc_correction)
  instance(dcfl, dcfr, rectl, rectr, invol, lIn, rIn, buffer, activevol, fbcoeff, lpl, lpr, hpl, hpr, lpf, hpf, pan, level, lPanTerm, rPanTerm, mute, solo, play, lastL, lastR, warmth,
           pingpong, rectify, left_sat, right_sat, modifier, ceiling, invCeiling, midSide,
           granulator, grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread, grainReverse, grainSizeVar,
           shaper, shaped_r, hq_active, lpfActive, pitch, shifter, allpass, isReverb,
           dc_yl, dc_xl, dc_yr, dc_xr)
  (
    ( !mute || solo ) ? (
      lIn = l_in * invol;
      rIn = r_in * invol;

      this.getReceives();
       
      midSide ? (
        t = lIn;
        lIn = (lIn + rIn) * .5;
        rIn = (t - rIn) * .5;
      );
    
      grain == 1 ? (
        granulator.granulator_update((grainLength/1000)*srate, grainJitter, grainOverlap, grainSpeed, grainSpeedSpread, grainPanSpread, grainReverse, grainSizeVar, buffer.readptr, buffer.scopebuffer, buffer.scopebuffermax, buffer.scopeptr);
        buffer.readptr += 2;
        buffer.readptr > buffer.scopebuffermax ? buffer.readptr = buffer.scopebuffer;
        l = granulator.L;
        r = granulator.R;
      ) : ( isReverb == 0 ) ? (
        hq_active ? buffer.readBuffer2_HQ() : buffer.readBuffer2();
        
        l = buffer.outL;
        r = buffer.outR;
      ) : (
        l = lIn;
        r = rIn;
      );
      
      (pitch == 1) ? (
        shifter.pitchShifterUpdate(l, r);
        l = shifter.outL;
        r = shifter.outR;
      );
      
      lpfActive ? ( l = lpl.eval_linearSVF_LP( l ); r = lpr.eval_linearSVF_LP( r ); );
      hpf > 0.0 ? ( l = hpl.eval_linearSVF_HP( l ); r = hpr.eval_linearSVF_HP( r ); );
  
      lastL = l * lPanTerm;
      lastR = r * rPanTerm;

      rectify ? (
        // Note: I tried to make l, r part of this instance and call with this.processWaveshapers,
        // but this seemed to cause memory errors. JSFX bug maybe?
        l = this.processWaveshapers(l, r);
        r = shaped_r;
      );
  
      // Entering the delay here
      isReverb ? (
        this.evaluateAllpassVerb(l, r);
        l = activevol*play*this.verbLeft*lPanTerm;
        r = activevol*play*this.verbRight*rPanTerm;
      ) : (
        pingpong ? (
          buffer.updateBuffer2(fbcoeff*r + lIn*lPanTerm, fbcoeff*l + rIn*rPanTerm);
          
          allpass ? (
            l = activevol*(l - fbcoeff*(fbcoeff*l + lIn))*play;
            r = activevol*(r - fbcoeff*(fbcoeff*r + rIn))*play;
          ) : (
            l = activevol*l*play;
            r = activevol*r*play;
          );
        ) : (
          buffer.updateBuffer2(fbcoeff*l + lIn, fbcoeff*r + rIn);
          
          allpass ? (
            l = activevol*(l - fbcoeff*(fbcoeff*l + lIn))*lPanTerm*play;
            r = activevol*(r - fbcoeff*(fbcoeff*r + rIn))*rPanTerm*play;
          ) : (
            l = activevol*l*lPanTerm*play;
            r = activevol*r*rPanTerm*play;        
          );
        );
      );

      grain == 2 ? (
        granulator.granulator_update((grainLength/1000)*srate, grainJitter, grainOverlap, grainSpeed, grainSpeedSpread, grainPanSpread, grainReverse, grainSizeVar, buffer.readptr, buffer.scopebuffer, buffer.scopebuffermax, buffer.scopeptr);
        pingpong ? (
          l = activevol*granulator.L*play;
          r = activevol*granulator.R*play;
        ) : (
          l = activevol*granulator.L*lPanTerm*play;
          r = activevol*granulator.R*rPanTerm*play;
        );
      );
      
      (pitch == 2) ? (
        shifter.pitchShifterUpdate(l, r);
        l = shifter.outL;
        r = shifter.outR;
      );
      
      midSide ? (
        t = l;
        l = l + r;
        r = t - r;
      );
      
      // DC blocker
      dc_correction ? (
        dc_yl = l - dc_xl + 0.998 * dc_yl;
        dc_xl = l;
        
        dc_yr = r - dc_xr + 0.998 * dc_yr;
        dc_xr = r;
        
        l = dc_yl;
        r = dc_yr;
      );
      
      lOut += l;
      rOut += r;
    );
    
    level = .5*(abs(l)+abs(r))*play;
  );

function processVerbNode(l_in, r_in)
  local(l, r)
  global(lOut, rOut)
  instance(verb, lIn, rIn, buffer, invol, vol, activevol, fbcoeff, lpl, lpr, hpl, hpr, lpf, hpf, pan, level, ice, ice_panned,
  lPanTerm, rPanTerm, mute, solo, play, lastL, lastR, shine, pingpong, rectify, shaped_r, lpfActive, pitch, shifter)
  (
    ( !mute || solo ) ? (
      lIn = l_in * invol;
      rIn = r_in * invol;
    
      this.getReceives();
      
      pitch ? (
        shifter.pitchShifterUpdate(lIn, rIn);
        lIn = shifter.outL;
        rIn = shifter.outR;
      );
      
      verb.damp = fbcoeff;
      verb.shine = shine;
      verb.mode = 1.0-pingpong;
      verb.ice = ice;
      verb.ice_panned = ice_panned;
      verb.processVerb(lIn, rIn);
      
      l = verb.outL;
      r = verb.outR;
      
      lpfActive ? ( l = lpl.eval_linearSVF_LP( l ); r = lpr.eval_linearSVF_LP( r ); );
      hpf > 0.0 ? ( l = hpl.eval_linearSVF_HP( l ); r = hpr.eval_linearSVF_HP( r ); );
      
      lastL = l * lPanTerm;
      lastR = r * rPanTerm;
      
      rectify ? (
        // Note: I tried to make l, r part of this instance and call with this.processWaveshapers,
        // but this seemed to cause memory errors. JSFX bug maybe?
        l = this.processWaveshapers(l, r);
        r = shaped_r;
      );
    
      l = activevol*l*lPanTerm*play;
      r = activevol*r*rPanTerm*play;
      
      lOut += l;
      rOut += r;
    );
    
    level = .5*(abs(l)+abs(r))*play;
  );

function resetNode(_dtime, _y)
instance(granulator, grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread,
         flutterLpf, octaver, octaver, lfoTime,lastfb, xSmoothed,
         buffer, mute,
         panlast, fblast, llpf, lhpf, lastL, lastR,
         dtime, y, fb, vol, invollast, pan, hpf, lpf,
         active, rectify,
         lpl, lpr, hpl, hpr)
local()
global(srate)
(
    panlast = -9999;
    fblast = -9999;
    llpf = -9999;
    lhpf = -9999;
    invollast = 99999;     
    lfoTime = 0;
    
    lastL = 0;
    lastR = 0;
    lastfb = -1;
    xSmoothed = 0;
    
    octaver.octaver_reset();
    
    /* Cleanly reset the nodes */
    buffer.resetBuffer();
    lpl.reset_linearSVF();
    hpl.reset_linearSVF();
    lpr.reset_linearSVF();
    hpr.reset_linearSVF();
    flutterLpf.init_linearSVF_direct(8/srate, 0.999); /* Note that flutter gets updated every fourth sample, cutoff ~2 Hz */
    flutterLpf.reset_linearSVF();
    granulator.granulator_init();
    
    !dtime && !y ? ( dtime = _dtime; y = _y; fb = 0.8; vol = 1.0; pan = 0.5; hpf = 0.0; lpf = 1.0; active = 1; mute = 0; rectify=0; );
    !grainLength ? ( grain = 0; grainLength = 60; grainJitter = .15; grainOverlap = .66; grainSpeed = 1; grainPanSpread = .5; grainSpeedSpread = .05; );
);

function randomizeNode(snap)
instance(granulator, grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainSizeVar, grainReverse, grainPanSpread, grainSpeedSpread,
         flutterLpf, octaver, lfoTime,lastfb, xSmoothed,
         buffer, mute,
         panlast, fblast, llpf, lhpf, lastL, lastR,
         dtime, y, fb, vol, invollast, pan, hpf, lpf, pingpong, midside,, lpfresonance,
         active, rectify,
         lpl, lpr, hpl, hpr,
         hidden,
         fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11,
         allpass, isreverb, pitchTracking, ice, ice_panned, shine, warmth, saturationGain, gain)
local(linkprob, x, csync)
global(nShapers, shine_slider, SyncMode, gridDensity)
(
  x = rand();
  Snap ? (
    ( SyncMode == 0 ) ? (
      csync = 10;
    ) : ( SyncMode == 1 ) ? (
      csync = 16;
    ) : ( SyncMode == 2 ) ? (
      csync = 12;
    ) : ( SyncMode == 3 ) ? (
      csync = 20;
    ) : ( SyncMode == 4 ) ? (
      csync = 16;
    ) : ( SyncMode == 5 ) ? (
      csync = 12;
    ) : ( syncMode == 6 ) ? (
      csync = 12 * 5;
    );
    csync *= 1 + gridDensity;
    x = floor(x*csync+.5)/csync;
  );
  dtime = xToTime(x);
  
  y = rand();
  fb = rand()^2;
  mute = rand() < .25;
  hidden = 0;
  
  /* Granular synthesis settings */
  grain = rand() < .25;
  grainLength = 300 * rand()^2;
  grainJitter = 10 * rand()^2;
  grainSpeed = 1;
  rand() < .25 ? grainSpeed = 2^(floor(rand() * 8) - 4);
  grainPanSpread = rand();
  grainSizeVar = rand();
  grainOverlap = rand() ^ 3;
  grainPanSpread = rand();
  grainSpeedSpread = .25 * rand()^5;
  grainReverse = rand();
  
  hpf = rand() < 0.5 ? rand()*rand() : 0;
  lpf = rand() < 0.5 ? hpf + (1.0 - hpf) * rand() * rand() : 1;

  pan = rand();
  pingpong = rand() < 0.75;
  midside = rand() < 0.8;
  lpfresonance = 0.9 * rand()^3;
  
  linkprob = rand()^4;
  
  mute ? (
    fromNode1 = fromNode2 = fromNode3 = fromNode4 = fromNode5 = fromNode6 = fromNode7 = fromNode8 = fromNode9 = fromNode10 = fromNode11 = 0;
  ) : (
    fromNode1 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode2 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode3 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode4 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode5 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode6 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode7 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode8 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode9 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode10 = rand() < linkprob ? rand()*2 - 1 : 0;
    fromNode11 = rand() < linkprob ? rand()*2 - 1 : 0;
  );
  
  rectify = rand() < 0.15 ? floor(rand() * nShapers) : 0;
  
  allpass = rand() < 0.15;
  isreverb = rand() < 0.15;
  pitchTracking = rand() < 0.1;
  
  ice = rand() < 0.25 ? rand() : 0;
  ice_panned = rand() < 0.5;
  shine_slider = shine = rand() < 0.2 ? rand() : 0;
  
  warmth = rand() ^ 4;
  saturationGain = 36 * rand() ^ 4;
  gain = 1 - rand()*rand();
);

function randomize()
(
  randomized = 1;
  snapRandom = rand() < 0.25;
  
  node1.randomizeNode(snapRandom);
  node2.randomizeNode(snapRandom);
  node3.randomizeNode(snapRandom);
  node4.randomizeNode(snapRandom);
  node5.randomizeNode(snapRandom);
  node6.randomizeNode(snapRandom);
  node7.randomizeNode(snapRandom);
  node8.randomizeNode(snapRandom);
  node9.randomizeNode(snapRandom);
  node10.randomizeNode(snapRandom);
  node11.randomizeNode(snapRandom);
);

function initNode(_memloc, _dtime, _y, idx, off, pitchbuffer_location, fftmem1, fftmem2)
  local(transition_region, shifterBufferSize)
  instance(mute, buffer, memloc, me, shifter)
  global(bufsize, srate)
  (
    me = idx;
    memloc = _memloc;
    buffer.initBuffer(memloc, memloc+bufsize-4);
    
    transition_region = 1024;
    shifterBufferSize = 4 * transition_region;
    shifter.pitchShifter(1, pitchbuffer_location, shifterBufferSize, fftmem1, fftmem2, transition_region, 1);

    this.resetNode(_dtime, _y);
  );

function initFFTNode(loc)
  instance(verb, lpf, hpf, fb)
  local()
  global()
  (
    /* Initialize reverb buffers */
    verb.mode = 1;
    verb.initializeVerb(loc)
  );

function randomizeGrain()
  local()
  global()
  instance(grain, grainLength, grainOverlap, grainPitch, grainJitter, grainSpeedSpread)
  (
    grain = rand() > 0.5;
    grainLength = rand() * 260 + 40;
    grainOverlap = rand();
    grainJitter = rand() * 10;
    grainPitch = 2^(4*rand()-2);
    grainSpeedSpread = .25 * rand();    
  );

function serializeNode()
  local()
  global(readread, SyncMode, quickSwitch, shine_slider)
  instance( x, y, active,
            dtime, temposync, fb, lpf, hpf, lpfResonance, widen, sat, pan, variance, pingpong, rectify, Gain, saturationGain, midside,
            mute, solo, play, shine, warmth, flutter, lfo, lfoDepth, lfoFrequency, feedbackSign,
            fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11,
            grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread, grainReverse, grainSizeVar,
            ice, ice_panned, shift_pitch, pitch, pitchTracking, allpass, isReverb, hidden )
  (
    ( file_avail(0) < 0 ) ? (
      this.updateFromSlider();
    );
  
    file_var( 0, active );
    file_var( 0, dtime );
    file_var( 0, y );
    file_var( 0, temposync );
    file_var( 0, fb );
    file_var( 0, lpf );
    file_var( 0, hpf );
    file_var( 0, widen );
    file_var( 0, sat );
    file_var( 0, pan );
    file_var( 0, mute );
    file_var( 0, solo );
    file_var( 0, play );
    
    file_var( 0, fromNode1 );
    file_var( 0, fromNode2 );
    file_var( 0, fromNode3 );
    file_var( 0, fromNode4 );
    file_var( 0, fromNode5 );
    file_var( 0, fromNode6 );
    file_var( 0, fromNode7 );
    file_var( 0, fromNode8 );
    file_var( 0, fromNode9 );
    file_var( 0, fromNode10 );
    file_var( 0, fromNode11 );
    
    file_var( 0, pingpong );
    file_var( 0, rectify );
    file_var( 0, Gain );
    
    file_var( 0, grain );
    file_var( 0, grainLength );
    file_var( 0, grainJitter );
    file_var( 0, grainOverlap );
    file_var( 0, grainSpeed );
    file_var( 0, grainPanSpread );
    file_var( 0, grainSpeedSpread );
    
    file_var( 0, saturationGain );    
    file_var( 0, midside );
    file_var( 0, shine );
    shine_slider = shine;
    file_var( 0, warmth );
    file_var( 0, flutter );
    
    file_var( 0, lfo );
    file_var( 0, lfoDepth );
    file_var( 0, lfoFrequency );
    file_var( 0, lpfResonance );
    file_var( 0, feedbackSign );
    file_var( 0, grainReverse );
    file_var( 0, grainSizeVar );
    file_var( 0, ice );
    file_var( 0, ice_panned );
    file_var( 0, shift_pitch );
    file_var( 0, pitch );
    file_var( 0, pitchTracking );
    file_var( 0, allpass );
    file_var( 0, isReverb );
    file_var( 0, hidden );
    
    /* Memory to expand into when features are added */
    memset(0, 0, 55);
    file_mem(0, 0, 55); /* Reduce this by one when you want to add features */
  );
  
connectorSize = 16;

function drawConnector( xmin, ymin, w, h, xl, yl, nx, ny, idx, fromLevel )
  local(dmx, dmy, diffx, diffy, len, mx, my, nx, ny, ytri1, ytri2, ytri3, xtri1, xtri2, xtri3, xl2, yl2, ang,
        connector_r, connector_g, connector_b, larc, scalingfactor, csize)
  global(connectorSize, mouse_x, mouse_y, render_time, scaling)
  instance(overConnector)
  (
    scalingfactor = 1 + scaling;
    cSize = scalingfactor * connectorSize;
    xl2 = xmin + w*nx;
    yl2 = ymin + h*ny;
    mx  = (.4*xl+.6*xl2);
    my  = (.4*yl+.6*yl2);
    gfx_set(.5,.4,.7,.8);
    gfx_line(xl, yl, xl2, yl2, 1);
    gfx_set(.5,.4,.7,.6+.4*sin(14*render_time));
    gfx_line(xl, yl+1, xl2, yl2+1, 1);
    
    gfx_set(0,0,0,1);
    gfx_circle(mx, my, cSize-.5, 0, 1);
    gfx_circle(mx, my, cSize, 0, 0);
    gfx_circle(mx, my, cSize+.5, 0, 1);
    gfx_circle(mx, my, cSize-2.5, 0, 1);
    gfx_circle(mx, my, cSize-3.5, 0, 1);
    gfx_circle(mx, my, cSize+2.5, 0, 1);
    gfx_circle(mx, my, cSize+3.5, 0, 1);
    gfx_circle(mx, my, cSize+4.5, 0, 1);
    
    connector_r = .6;
    connector_g = .6;
    connector_b = .8;
    
    gfx_set(connector_r, connector_g, connector_b,.9+.1*sin(14*render_time));
    gfx_circle(mx, my, cSize-.5, 0, 1);
    gfx_circle(mx, my, cSize, 0, 0);
    gfx_circle(mx, my, cSize+.5, 0, 1);
    
    ang = 2*abs(fromLevel)*$pi - $pi;
    larc = cSize + 1;
    loop(ceil(3 * scalingfactor),
      gfx_arc(mx, my, larc, -$pi, ang, 1);
      larc += .5;
    );
    
    diffx = xl - xl2;
    diffy = yl - yl2;
    len   = sqrt( diffx * diffx + diffy * diffy );
    nx    = 10 * scalingfactor * diffx / len;
    ny    = 10 * scalingfactor * diffy / len;
    
    xtri1 = mx - .6*nx + ny;
    ytri1 = my - .6*ny - nx;
    xtri2 = mx - .6*nx - ny;
    ytri2 = my - .6*ny + nx;
    xtri3 = mx + 1.2*nx;
    ytri3 = my + 1.2*ny;
    
    dmx = mx - mouse_x;
    dmy = my - mouse_y;
    ( dmx * dmx + dmy * dmy ) < (cSize*cSize) ? overConnector = idx;

    gfx_set(connector_r, connector_g, connector_b,.5);
    gfx_triangle( xtri1-1, ytri1, xtri2-1, ytri2, xtri3-1, ytri3 );
    gfx_triangle( xtri1+1, ytri1, xtri2+1, ytri2, xtri3+1, ytri3 );
    gfx_triangle( xtri1, ytri1-1, xtri2, ytri2-1, xtri3, ytri3-1 );
    gfx_triangle( xtri1, ytri1+1, xtri2, ytri2+1, xtri3, ytri3+1 );

    gfx_set(connector_r, connector_g, connector_b,1.0);
    gfx_triangle( xtri1, ytri1, xtri2, ytri2, xtri3, ytri3 );
    

    fromLevel > 0 ? (
      gfx_set(0, 0, 0, 1);
      gfx_line(mx - 4, my, mx + 4, my, 1);
      gfx_line(mx, my - 4, mx, my + 4, 1);
      gfx_set(0, 0, 0, .5);
      gfx_line(mx - 4, my+1, mx + 4, my+1, 1);
      gfx_line(mx - 4, my-1, mx + 4, my-1, 1);
      
      gfx_line(mx + 1, my-4, mx + 1, my+4, 1);
      gfx_line(mx - 1, my-4, mx - 1, my+4, 1);
    ) : (
      gfx_set(0, 0, 0, 1);
      gfx_line(mx - 4, my, mx + 4, my, 1);
      gfx_set(0, 0, 0, .5);
      gfx_line(mx - 4, my+1, mx + 4, my+1, 1);
      gfx_line(mx - 4, my-1, mx + 4, my-1, 1);
    );
  );

function drawConnections(xmin, ymin, w, h)
  global( node1.x, node2.x, node3.x, node4.x, node5.x, node6.x, node7.x, node8.x, node9.x, node10.x, node11.x, 
          node1.y, node2.y, node3.y, node4.y, node5.y, node6.y, node7.y, node8.y, node9.y, node10.y, node11.y )
  instance(overConnector, x, y, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11)
  local(xl, yl)
  (
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
    
    overConnector = 0;
    fromNode1  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node1.x,  node1.y,  1,  fromNode1 );
    fromNode2  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node2.x,  node2.y,  2,  fromNode2 );
    fromNode3  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node3.x,  node3.y,  3,  fromNode3 );
    fromNode4  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node4.x,  node4.y,  4,  fromNode4 );
    fromNode5  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node5.x,  node5.y,  5,  fromNode5 );
    fromNode6  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node6.x,  node6.y,  6,  fromNode6 );
    fromNode7  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node7.x,  node7.y,  7,  fromNode7 );
    fromNode8  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node8.x,  node8.y,  8,  fromNode8 );
    fromNode9  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node9.x,  node9.y,  9,  fromNode9 );
    fromNode10 ? this.drawConnector( xmin, ymin, w, h, xl, yl, node10.x, node10.y, 10, fromNode10 );
    fromNode11 ? this.drawConnector( xmin, ymin, w, h, xl, yl, node11.x, node11.y, 11, fromNode11 );
    
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
  );

function draw(xmin, ymin, w, h, verb)
  local(adv, alpha, xl, yl, tf, logLevel, panSize, silent, radius, rectS, cr, cg, cb, fb, anim, scalefactor, tmp, xc, yc, xll, yll)
  global(gfx_a, gfx_x, gfx_y, render_time, scaling)
  instance(x, y, r, fbcoeff, lpf, hpf, dtime, level, pan, selected, play, mute, solo, pingpong, rectify, gain, grain, outer, mouse_over, allpass, isReverb, pitch, hidden, lasthidden)
  (
    !hidden && (!lasthidden) ? (
      scalefactor = 1+scaling;
      silent = max(0,1-play);
      r = 4 * scalefactor;
      alpha = 1.0;
      tf = 100*dtime;
      radius = .13*log(1.0+200*abs(fbcoeff));
      
      adv = min(0.99, radius);
      xl = floor(xmin + x*w);
      yl = floor(ymin + y*h);
      
      outer = 8+4.15*ceil(log(.2)/log(radius)) * scalefactor;    
      
      isReverb ? (
        gfx_set(1,1,1,.6);
        rectS = 1.95*outer;
        gfx_line(xl-rectS, yl+.707*rectS-.1*rectS, xl+rectS, yl+.707*rectS-.1*rectS);
        gfx_line(xl, yl-rectS-.1*rectS, xl-rectS, yl+.707*rectS-.1*rectS);
        gfx_line(xl, yl-rectS-.1*rectS, xl+rectS, yl+.707*rectS-.1*rectS);
        
        gfx_set(1,1,1,.2);
        gfx_line(xl-rectS, yl+.707*rectS-.1*rectS, xl, yl-.1*rectS);
        gfx_line(xl, yl-rectS-.1*rectS, xl, yl-.1*rectS);
        gfx_line(xl, yl-.1*rectS, xl+rectS, yl+.707*rectS-.1*rectS);
      );
          
      
      rectify ? (
        rectS = outer-3;
        gfx_set(1, 1, 1,.1);
        rectS += 13;
        gfx_rect(xl-rectS, yl-rectS, 2*rectS+2, 2*rectS+2);
      );
      
      grain ? (
        gfx_set(1.6,0.2,1,1);
        
        rectS = 0;
        loop(30,
          gfx_circle(xl+2*outer*cos(time_precise()*rectS), yl+2*outer*sin(time_precise()*rectS), 2);
          rectS += $pi/60;
        );
      );
      
      cr = .8;
      cg = .8;
      cb = .9;
      
      panSize = 7 * (1+scaling);
      gfx_set(cr*.5,cg*.5,cb*.5,.8 - .7*silent);
      gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize+2, 1);
      gfx_set(cr,cg,cb,1 - .7*silent);
      gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize, 1);    
      
      pingpong ? (
        gfx_set(cr*.2,cg*.2,cb*.2,.8 - .7*silent);
        gfx_circle(xl-outer*cos($pi*(1-pan)), yl-outer*sin($pi*(1-pan)), panSize+2, 1);
        gfx_set(cr,cg,cb,.4 - .7*silent);
        gfx_circle(xl-outer*cos($pi*(1-pan)), yl-outer*sin($pi*(1-pan)), panSize, 1);    
      );
      
      gfx_set(0,0,.3,.95);
      gfx_circle(xl, yl, outer, 1, 1);    
      
      gfx_set(0.2,0.25,0.1,.4);
      gfx_circle(xl, yl, outer, 0, 0);
      gfx_circle(xl, yl, outer+.5, 1, 0);
      gfx_circle(xl, yl, outer+1, 0, 1);
      
      verb ? (
        gfx_set(1,1,1,.2);
        rectS = 1.1*outer;
        panSize = 1.8*outer;
        gfx_line(xl-rectS, yl-rectS, xl+rectS, yl-rectS);
        gfx_line(xl-rectS, yl+rectS, xl+rectS, yl+rectS);
        gfx_line(xl-rectS, yl-rectS, xl-rectS, yl+rectS);
        gfx_line(xl+rectS, yl-rectS, xl+rectS, yl+rectS);
      
        gfx_line(xl-rectS, yl-rectS, xl-panSize, yl-panSize);
        gfx_line(xl+rectS, yl+rectS, xl+panSize, yl+panSize);
        gfx_line(xl-rectS, yl+rectS, xl-panSize, yl+panSize);
        gfx_line(xl+rectS, yl-rectS, xl+panSize, yl-panSize);
        
        gfx_set(1,1,1,.6);
        rectS = panSize;
        gfx_line(xl-rectS, yl-rectS, xl+rectS, yl-rectS);
        gfx_line(xl-rectS, yl+rectS, xl+rectS, yl+rectS);
        gfx_line(xl-rectS, yl-rectS, xl-rectS, yl+rectS);
        gfx_line(xl+rectS, yl-rectS, xl+rectS, yl+rectS);
      );
      
      mute ? (
        gfx_set(0.7,0,.1,.95);
        tmp = outer + 1*(1+scaling);
        loop(5 * (1+scaling),
          gfx_circle(xl, yl, tmp, 0, 1);
          tmp += .5;
        );
      );
      
      selected ? (
        gfx_set(0.45,0.4,.7,1);
        gfx_circle(xl, yl, outer, 0, 0);
        gfx_circle(xl, yl, outer+.5, 1, 0);
        gfx_circle(xl, yl, outer+1, 0, 1);
    
        anim = 3*render_time-floor(3*render_time);
        rectS = (1.1+.35*anim)*outer;
        loop(2 * (1+scaling),
            
          gfx_set(.4, .3, .8, .7-.7*anim);
          gfx_line(xl-rectS, yl-rectS, xl+rectS, yl-rectS);
          gfx_line(xl-rectS, yl+rectS, xl+rectS, yl+rectS);
          gfx_line(xl-rectS, yl-rectS, xl-rectS, yl+rectS);
          gfx_line(xl+rectS, yl-rectS, xl+rectS, yl+rectS);
          rectS += 1;
        );
      ) : ( mouse_over == 1 ) ? (
        anim = .5 + .5 * sin(render_time*8);
        gfx_set(0.45,0.4,.7,.1 + .5*anim);
        gfx_circle(xl, yl, outer, 0, 0);
        gfx_circle(xl, yl, outer+.5, 1, 0);
        gfx_circle(xl, yl, outer+1, 0, 1);
      );
      
      solo ? (
        gfx_set(0,1,.3,.95);
        tmp = outer + 1*(1+scaling);
        loop(5 * (1+scaling),
          gfx_circle(xl, yl, tmp, 0, 1);
          tmp += .5;
        );
      );    
      
      gfx_set(cr, cg, cb, 1);
      
      gfx_a = alpha;
      tmp = floor(r-.5);
      loop(4 * (1+scaling),  
        gfx_arc(xl, yl, tmp, - $pi, 2*(1-gain)*$pi - $pi, 1);
        tmp += .5;
        gfx_a *= .8;
      );
      
      r += 4*scalefactor;
      alpha *= adv;
      while(
        gfx_a = alpha;
        gfx_circle(xl, yl, r, 0, 0);
        gfx_a = .5*alpha;
        gfx_circle(xl, yl, r+1, 0, 1);
        gfx_circle(xl, yl, r-1, 0, 1);
        
        r += 4*scalefactor;
        alpha *= adv;
        alpha>.2
      );
      
      gfx_a = 1;
      
      r -= 5*scaling;
      hpf < lpf ? (
        loop(5*scalefactor,
          gfx_arc(xl, yl, r, 2*lpf*$pi - $pi, 2*hpf*$pi - $pi, 1);
          r += .5;
        );
      );
      
      logLevel = log(4000*level-2)*scalefactor;
      silent ? logLevel = 0;
      
      fbcoeff < 0 ? (
        xc = xl + r;
        yc = yl - r;
        gfx_line(xc - 4, yc, xc + 4, yc, 1);
        gfx_line(xc - 4, yc+1, xc + 4, yc+1, 1);
        gfx_line(xc - 4, yc-1, xc + 4, yc-1, 1);
      );
      
      allpass ? (
        xc = xl - r;
        yc = yl - r;
        //gfx_printf("A");
        gfx_line(xc - 4, yc, xc, yc-4, 1);
        gfx_line(xc - 4, yc+1, xc, yc-3, 1);
        gfx_line(xc - 4, yc-1, xc, yc-5, 1);
        gfx_line(xc, yc-4, xc+4, yc, 1);
        gfx_line(xc, yc-3, xc+4, yc+1, 1);
        gfx_line(xc, yc-5, xc+4, yc-1, 1);
      );
      
      
      pitch ? (
        xll = xc = xl - r - 6;
        yc = yl + r;
        yl = yll = 0;
        tmp = sin(4*render_time);
        tmp = .6 * (1 + tmp*tmp*tmp*tmp);
        loop(10,
          xc += 1;
          yl += tmp;
          gfx_line(xll, yc + 4*sin(yll), xc, yc + 4*sin(yl));
          gfx_line(xll, yc + 4*sin(yll)+1, xc, yc + 4*sin(yl)+1);
          xll = xc;
          yll = yl;
        );
      );
      
      gfx_set(1, 1, 1, .03);
      gfx_circle(xl, yl, logLevel*5, 1, 1);
      
      gfx_set(1, 1, 1, .03);
      gfx_circle(xl, yl, logLevel*6, 1, 1);
      
      gfx_set(1, 1, 1, .03);
      gfx_circle(xl, yl, logLevel*8, 1, 1);    
      
      silent ? (
        gfx_set(0.0,0,.0,.7);
        tmp = outer + 1+scaling;
        gfx_circle(xl, yl, tmp, 1, 1);
      );
      
      r = r*r;
    );
    lasthidden = hidden;
  );

function clamp(x, lb, ub)
  local()
  global()
  instance()
  (
    max(lb,min(ub,x))
  );

function select(xmin, ymin, w, h, xselectmin, xselectmax, yselectmin, yselectmax)
  local(xl, yl)
  global()
  instance(x, y, dtime, selected)
  (
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
        
    selected = ( xl > xselectmin ) && ( xl < xselectmax ) && ( yl > yselectmin ) && ( yl < yselectmax ) ? 1 : 0;
  );

function mouse_over(mousex, mousey, xmin, ymin, w, h)
  local(x1, y1, dx, dy)
  instance(dtime, x, y, outer, mouse_over)
  (
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
    
    dx = mousex - xl;
    dy = mousey - yl;
    
    /* Yeah! We're in range! */
    mouse_over = ( (dx*dx + dy*dy) < (outer*outer) ) ? 1 : 0
);


function amIChosen()
  local()
  global(mouse_cap)
  instance(selected)
  (
    (mouse_cap & 4) == 0 ? (
      selected = ( selected == 2 ) ? 1 : 0;
    ) : (
      selected == 2 ? selected = 1;
    );
  );

function tryNodeConnect(xmin, ymin, w, h, from, mousex, mousey)
  local(xl, yl, dx, dy)
  instance(dtime, x, y, fbcoeff,
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11, outer)
  global()
  (
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
    
    dx = mousex - xl;
    dy = mousey - yl;
    
    /* Yeah! We're in range. hook us up! */
    ( (dx*dx + dy*dy) < (outer*outer) ) ? (
      ((from == 1)  && (fromNode1  == 0)) ? fromNode1 = fbcoeff;
      ((from == 2)  && (fromNode2  == 0)) ? fromNode2 = fbcoeff;
      ((from == 3)  && (fromNode3  == 0)) ? fromNode3 = fbcoeff;
      ((from == 4)  && (fromNode4  == 0)) ? fromNode4 = fbcoeff;
      ((from == 5)  && (fromNode5  == 0)) ? fromNode5 = fbcoeff;
      ((from == 6)  && (fromNode6  == 0)) ? fromNode6 = fbcoeff;
      ((from == 7)  && (fromNode7  == 0)) ? fromNode7 = fbcoeff;
      ((from == 8)  && (fromNode8  == 0)) ? fromNode8 = fbcoeff;
      ((from == 9)  && (fromNode9  == 0)) ? fromNode9 = fbcoeff;
      ((from == 10) && (fromNode10 == 0)) ? fromNode10 = fbcoeff;
      ((from == 11) && (fromNode11 == 0)) ? fromNode11 = .5;
    );
  );

function overNode(xmin, ymin, w, h, mousex, mousey, mousecap)
  local(dx, dy, dist, xl, yl)
  global(nodeCap, gfx_x, gfx_y, gfx_w, gfx_h)
  instance(overConnector, x, y, r, dtime, lastleft, left, lastright, right, lx, ly, selected, over)
  (
    left  = mousecap & 1;
    right = mousecap & 2;
    x = timeToX(dtime);
    
    xl = xmin + x*w;
    yl = ymin + y*h;
    dx = mousex - xl;
    dy = mousey - yl;
    
    dist = dx * dx + dy * dy;
    over = dist < r;
    
    ( left ) ? (
      ( (nodeCap == 0) && (lastleft == 0) && (lastright == 0) ) ? (
        ( over ) ? (
          nodeCap = 1;
            
          /* If this one is not selected, signal that all others have to be deselected */
          !selected ? (
            selected = 2;
            nodeCap = -nodeCap;
          ) : (
            (mousecap & 4) == 4 ? selected = 0;
          );
        );
      );
    ) : ( right ) ? (
      ( (nodeCap == 0) && (lastright == 0) && (lastleft == 0) ) ? (
        ( over ) ? (
          nodeCap = 2;
           
          /* If this one is not selected, signal that all others have to be deselected */
          !selected ? (
            selected = 2;
            nodeCap = -nodeCap;
          );
        );
      );
    ) : ( 
      nodeCap = 0;
    );
  );
  
function overSignalCable(mousecap)
  local()
  global(nodeCap)
  instance(overConnector, lastleft, left, lastright, right, selected)
  (
    left  = mousecap & 1;
    right = mousecap & 2;
    
    ( left ) ? (
      ( (nodeCap == 0) && (lastleft == 0) && (lastright == 0) ) ? (
        ( overConnector ) ? (
          nodeCap = -10-overConnector;
          selected = 2;
        );
      );
    ) : ( right ) ? (
      ( (nodeCap == 0) && (lastright == 0) && (lastleft == 0) ) ? (
        ( overConnector ) ? (
          nodeCap = -10-overConnector;
          selected = 2;
        );
      );
    ) : ( 
      nodeCap = 0;
    );
  lastleft = left;
  lastright = right;
);

function nodeProcessMouse(xmin, ymin, w, h, mousex, mousey, mousecap, currentCap, lx, ly, dbl)
  local(left, right, dist, shift, ctrl, alt, from, chy, xl, yl, moved, csync)
  global(SyncMode, Snap, nodeCap, tester,
          node1.tryNodeConnect,
          node2.tryNodeConnect,
          node3.tryNodeConnect,
          node4.tryNodeConnect,
          node5.tryNodeConnect,
          node6.tryNodeConnect,
          node7.tryNodeConnect,
          node8.tryNodeConnect,
          node9.tryNodeConnect, 
          node10.tryNodeConnect,
          node11.tryNodeConnect,
          gridDensity, scaling )
  instance(x, y, r, dtime, fb, lpf, hpf, pan, selected, lcap,
           lastleft, lastSignalClick,
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11, Connecting, me)
  (
    shift = mousecap & 8;
    ctrl  = mousecap & 4;
    alt   = mousecap & 16;
    left  = mousecap & 1;
    right = mousecap & 2;    
    
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
    moved = 0;
    
    left ? (
      ( currentCap > 10 && selected ) ? (
        (lcap == 0 && (abs(time_precise() - lastSignalClick) < .25)) ? (
          // Check for double click
          currentCap == 11 ? fromNode1 = -fromNode1;
          currentCap == 12 ? fromNode2 = -fromNode2;
          currentCap == 13 ? fromNode3 = -fromNode3;
          currentCap == 14 ? fromNode4 = -fromNode4;
          currentCap == 15 ? fromNode5 = -fromNode5;
          currentCap == 16 ? fromNode6 = -fromNode6;
          currentCap == 17 ? fromNode7 = -fromNode7;
          currentCap == 18 ? fromNode8 = -fromNode8;
          currentCap == 19 ? fromNode9 = -fromNode9;
          currentCap == 20 ? fromNode10 = -fromNode10;
          currentCap == 21 ? fromNode11 = -fromNode11;
          lastSignalClick = 1000;
        ) : (
          // It wasn't a doubleclick
          lastSignalClick = time_precise();
          chy = (ly-mousey)/h;
          currentCap == 11 ? fromNode1  = sign(fromNode1) * clamp( abs(fromNode1) + chy, 0.001, .999 );
          currentCap == 12 ? fromNode2  = sign(fromNode2) * clamp( abs(fromNode2) + chy, 0.001, .999 );
          currentCap == 13 ? fromNode3  = sign(fromNode3) * clamp( abs(fromNode3) + chy, 0.001, .999 );
          currentCap == 14 ? fromNode4  = sign(fromNode4) * clamp( abs(fromNode4) + chy, 0.001, .999 );
          currentCap == 15 ? fromNode5  = sign(fromNode5) * clamp( abs(fromNode5) + chy, 0.001, .999 );
          currentCap == 16 ? fromNode6  = sign(fromNode6) * clamp( abs(fromNode6) + chy, 0.001, .999 );
          currentCap == 17 ? fromNode7  = sign(fromNode7) * clamp( abs(fromNode7) + chy, 0.001, .999 );
          currentCap == 18 ? fromNode8  = sign(fromNode8) * clamp( abs(fromNode8) + chy, 0.001, .999 );
          currentCap == 19 ? fromNode9  = sign(fromNode9) * clamp( abs(fromNode9) + chy, 0.001, .999 );
          currentCap == 20 ? fromNode10 = sign(fromNode10) * clamp( abs(fromNode10) + chy, 0.001, .999 );
          currentCap == 21 ? fromNode11 = sign(fromNode11) * clamp( abs(fromNode11) + chy, 0.001, .999 );
        );
      ) : ( currentCap == 1 && selected ) ? (
        moved = 1;
        ( shift ) ? (
          ( alt ) ? (
            gfx_set( 1, 1, 1, 1 );
            gfx_line(xl, yl, mousex, mousey);
            gfx_line(xl, yl+1, mousex, mousey+1);
            gfx_line(xl, yl-1, mousex, mousey-1);
            gfx_line(xl+1, yl, mousex+1, mousey+1);
            gfx_line(xl-1, yl, mousex-1, mousey-1);
            Connecting = 1;
          ) : ( ctrl ) ? (
            hpf = clamp( hpf - (mousey-ly)/h, 0, lpf );
          ) : (
            lpf = clamp( lpf - (mousey-ly)/h, hpf, 1 );
          );
        ) : (
          ( alt ) ? (
            dbl ? ( 
              pan = 0.5;
            ) : (
              pan = clamp( pan - (mousey-ly)/h, 0, 1);
            );
          ) : (
            x += (mousex-lx)/w;
            y += (mousey-ly)/h;
          );
        );
      );
    ) : ( right ) ? (
      ( currentCap > 10 && selected ) ? (
        currentCap == 11 ? fromNode1  = 0;
        currentCap == 12 ? fromNode2  = 0;
        currentCap == 13 ? fromNode3  = 0;
        currentCap == 14 ? fromNode4  = 0;
        currentCap == 15 ? fromNode5  = 0;
        currentCap == 16 ? fromNode6  = 0;
        currentCap == 17 ? fromNode7  = 0;
        currentCap == 18 ? fromNode8  = 0;
        currentCap == 19 ? fromNode9  = 0;
        currentCap == 20 ? fromNode10 = 0;
        currentCap == 21 ? fromNode11 = 0;
      ) : ( currentCap == 2 && selected ) ? (
        fb = fb - (mousey-ly)/w;
        fb = clamp(fb, 0, .999);
        moved = 1;
      );
    );
    
    lastleft = left;
    
    ( ( currentCap == 0 ) && ( lcap > 0 ) ) ? (
      Snap ? (
        ( SyncMode == 0 ) ? (
          csync = 10;
        ) : ( SyncMode == 1 ) ? (
          csync = 16;
        ) : ( SyncMode == 2 ) ? (
          csync = 12;
        ) : ( SyncMode == 3 ) ? (
          csync = 20;
        ) : ( SyncMode == 4 ) ? (
          csync = 16;
        ) : ( SyncMode == 5 ) ? (
          csync = 12;
        ) : ( syncMode == 6 ) ? (
          csync = 12 * 5;
        );
        csync *= 1 + gridDensity;
        x = floor(x*csync+.5)/csync;
        tester = x;
      );
      
      Connecting ? (
        node1.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node2.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node3.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node4.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node5.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node6.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node7.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node8.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node9.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node10.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node11.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
      );
      
      Connecting = 0;
    );
    
    dtime = xToTime(x);
    
    moved ? (
      this.updateToSliderRec();
    );
    
    selected ? (
      lcap = currentCap;
    ) : (
      lcap = 0;
    );
  );

function Init()
  (
    /* Nuke it all */
    memset(0,0,12000000);

    // MEMORY LAYOUT
    bufSize = 65536*8;
    minvol = 0.05;
    maxvol = 1;
    
    dTap1  = 1*bufSize;
    dTap2  = 2*bufSize;
    dTap3  = 3*bufSize;
    dTap4  = 4*bufSize;
    dTap5  = 5*bufSize;
    dTap6  = 6*bufSize;
    dTap7  = 7*bufSize;
    dTap8  = 8*bufSize;
    dTap9  = 9*bufSize;
    dTap10 = 10*bufSize;
    
    freemem = node11.initFFTNode(11*bufSize);
    freemem = node1.initializeAllpassBuffers(freemem);
    freemem = node2.initializeAllpassBuffers(freemem);
    freemem = node3.initializeAllpassBuffers(freemem);
    freemem = node4.initializeAllpassBuffers(freemem);
    freemem = node5.initializeAllpassBuffers(freemem);
    freemem = node6.initializeAllpassBuffers(freemem);
    freemem = node7.initializeAllpassBuffers(freemem);
    freemem = node8.initializeAllpassBuffers(freemem);
    freemem = node9.initializeAllpassBuffers(freemem);
    freemem = node10.initializeAllpassBuffers(freemem);
 
    pitchBlockSize = 4*4096; /* We have 64 blocks of this */
    freemem = (fftmem1 = freemem) + pitchBlockSize;
    freemem = (fftmem2 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation1 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation2 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation3 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation4 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation5 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation6 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation7 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation8 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation9 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation10 = freemem) + pitchBlockSize;
    freemem = (pitchBufferLocation11 = freemem) + pitchBlockSize;
    freemem = (midimem = freemem) + 4*pitchBlockSize;
    freemem = (globalPitchBuffer = freemem) + pitchBlockSize;
    midi.initializeMIDI(midimem, 0, 1);
 
    transition_region = 1024;
    shifterBufferSize = 4 * transition_region;
    shifter.pitchShifter(1, globalPitchBuffer, shifterBufferSize, fftmem1, fftmem2, transition_region, 1);
 
    BUF_SIZE = 64000;
    freemem = (height = freemem) + BUF_SIZE;
    freemem = (velocity_x = freemem) + BUF_SIZE;
    freemem = (velocity_y = freemem) + BUF_SIZE;
    freemem = (height_gradient_x = freemem) + BUF_SIZE;
    freemem = (height_gradient_y = freemem) + BUF_SIZE;
    freemem = (velocity_prediction_x = freemem) + BUF_SIZE;
    freemem = (velocity_prediction_y = freemem) + BUF_SIZE;
    
    maxTime == 0 ? maxTime = 4;
    
    /* Initialize or reset the nodes */
    node1.initNode(dTap1,   xToTime(0.5),  0.1, 1,  0, pitchBufferLocation1, fftmem1, fftmem2);
    node2.initNode(dTap2,   xToTime(0.1),  1.0, 2,  0, pitchBufferLocation2, fftmem1, fftmem2);
    node3.initNode(dTap3,   xToTime(0.2),  1.0, 3,  0, pitchBufferLocation3, fftmem1, fftmem2);
    node4.initNode(dTap4,   xToTime(0.3),  1.0, 4,  0, pitchBufferLocation4, fftmem1, fftmem2);
    node5.initNode(dTap5,   xToTime(0.4),  1.0, 5,  0, pitchBufferLocation5, fftmem1, fftmem2);
    node6.initNode(dTap6,   xToTime(0.5),  1.0, 6,  1, pitchBufferLocation6, fftmem1, fftmem2);
    node7.initNode(dTap7,   xToTime(0.6),  1.0, 7,  1, pitchBufferLocation7, fftmem1, fftmem2);
    node8.initNode(dTap8,   xToTime(0.7),  1.0, 8,  1, pitchBufferLocation8, fftmem1, fftmem2);
    node9.initNode(dTap9,   xToTime(0.8),  1.0, 9,  1, pitchBufferLocation9, fftmem1, fftmem2);
    node10.initNode(dTap10, xToTime(0.9),  1.0, 10, 1, pitchBufferLocation10, fftmem1, fftmem2);
    node11.initNode(dTap10, xToTime(0.9),   .5, 11, 1, pitchBufferLocation11, fftmem1, fftmem2);    
    
    updateGlobalFeedback();
    startFade.fadeIn(50);
  );
  
function updateFromSliderAll()
(
  node1.updateFromSlider();
  node2.updateFromSlider();
  node3.updateFromSlider();
  node4.updateFromSlider();
  node5.updateFromSlider();
  node6.updateFromSlider();
  node7.updateFromSlider();
  node8.updateFromSlider();
  node9.updateFromSlider();
  node10.updateFromSlider();
  node11.updateFromSlider();
);

function updateToSliderAll()
(
  node1.updateToSlider();
  node2.updateToSlider();
  node3.updateToSlider();
  node4.updateToSlider();
  node5.updateToSlider();
  node6.updateToSlider();
  node7.updateToSlider();
  node8.updateToSlider();
  node9.updateToSlider();
  node10.updateToSlider();
  node11.updateToSlider();
);

function updateToSliderNonScaledAll()
(
  node1.updateToSliderNonScaled();
  node2.updateToSliderNonScaled();
  node3.updateToSliderNonScaled();
  node4.updateToSliderNonScaled();
  node5.updateToSliderNonScaled();
  node6.updateToSliderNonScaled();
  node7.updateToSliderNonScaled();
  node8.updateToSliderNonScaled();
  node9.updateToSliderNonScaled();
  node10.updateToSliderNonScaled();
  node11.updateToSliderNonScaled();
);

Init();

function rescaleToTempo(ratio)
(
  !node1.pitchTracking ? node1.dtime = node1.dtime * ratio;
  !node2.pitchTracking ? node2.dtime = node2.dtime * ratio;
  !node3.pitchTracking ? node3.dtime = node3.dtime * ratio;
  !node4.pitchTracking ? node4.dtime = node4.dtime * ratio;
  !node5.pitchTracking ? node5.dtime = node5.dtime * ratio;
  !node6.pitchTracking ? node6.dtime = node6.dtime * ratio;
  !node7.pitchTracking ? node7.dtime = node7.dtime * ratio;
  !node8.pitchTracking ? node8.dtime = node8.dtime * ratio;
  !node9.pitchTracking ? node9.dtime = node9.dtime * ratio;
  !node10.pitchTracking ? node10.dtime = node10.dtime * ratio;
  !node11.pitchTracking ? node11.dtime = node11.dtime * ratio;
);

dc0.init_HP6(19/srate);
dc1.init_HP6(19/srate);
init_lpg_time_constants();

@serialize
writing = file_avail(0) < 0;
allow_updates = 0;
file_var(0, maxTime);
file_var(0, minTime);

node1.serializeNode();
node2.serializeNode();
node3.serializeNode();
node4.serializeNode();
node5.serializeNode();
node6.serializeNode();
node7.serializeNode();
node8.serializeNode();
node9.serializeNode();
node10.serializeNode();
node11.serializeNode();

file_var(0, HQ);
file_var(0, current_tempo);

csync = SyncMode;
file_var(0, SyncMode);
file_var(0, dc_correction);
file_var(0, globalFeedbackAttn);
file_var(0, sendSaturation);
file_var(0, duckingActive);
file_var(0, duckingAttack);
file_var(0, duckingRelease);
file_var(0, duckingThreshold);
file_var(0, duckingRatio);
file_var(0, duckingKnee);
file_var(0, pdcToggle);
file_var(0, shift_pitch);
file_var(0, pitch);
file_var(0, freeNodes);

// Some extra padding to make sure that future variables start at zero.
memset(0,0,100);
file_mem(0,0,100);
allow_updates = 1;

updateToSliderNonScaledAll();

@slider
updateFromSliderAll();

@block
midi.processMIDIBlock();
init_lpg_time_constants();

// Tempo is only valid once playing has started.
play_state > 0 ? has_played = 1;

allow_updates > 2 && has_played ? (
  (tempo != current_tempo) ? (  
    SyncMode > 0 ? (
      (current_tempo > 0) && (tempo > 0) ? (
        rescaleToTempo(current_tempo / tempo);
        current_tempo = tempo;
        updateToSliderAll();
      );
      current_tempo = tempo;
    );
    
    quickSwitch = 1;
    updateToSliderAll();
  );
);
allow_updates ? allow_updates += 1;

pitch && compensate_pdc ? (
  pdc_bot_ch=0;
  pdc_top_ch=2;
  pdc_delay=1035;
);

ducker.setCompressorOptions(duckingThreshold, duckingRatio, duckingAttack, duckingRelease, duckingKnee, 1, 120, 15, 400);

gain_interpolator.interpolator_block();
lp_interpolator.interpolator_block();
hp_interpolator.interpolator_block();
lpres_interpolator.interpolator_block();

// Interpolation speed for the time and gain. This creates that more tapey effect.
// We want the user to be able to disable this temporarily if they just want a sudden
// transition.
(quickSwitch > 0) ? (
  (quickSwitch == 1) ? (
    quickSwitch = 2;
    update_alpha = 1000 / ((1+note_response_time)*srate/UPDATE_INTERVAL);
    inv_update_alpha = 1 - update_alpha;
  ) : ( quickSwitch == 2 ) ? (
    quickSwitch = 0;
    update_alpha = log(2) / (0.28881132523331055*srate/UPDATE_INTERVAL);
    inv_update_alpha = 1.0 - update_alpha;
  );
);

!node1.mute  ? node1.play  = 1 : node1.play  = 0;
!node2.mute  ? node2.play  = 1 : node2.play  = 0;
!node3.mute  ? node3.play  = 1 : node3.play  = 0;
!node4.mute  ? node4.play  = 1 : node4.play  = 0;
!node5.mute  ? node5.play  = 1 : node5.play  = 0;
!node6.mute  ? node6.play  = 1 : node6.play  = 0;
!node7.mute  ? node7.play  = 1 : node7.play  = 0;
!node8.mute  ? node8.play  = 1 : node8.play  = 0;
!node9.mute  ? node9.play  = 1 : node9.play  = 0;
!node10.mute ? node10.play = 1 : node10.play = 0;
!node11.mute ? node11.play = 1 : node11.play = 0;

( node1.solo || node2.solo || node3.solo || node4.solo || node5.solo || node6.solo || node7.solo || node8.solo || node9.solo || node10.solo || node11.solo ) ? 
( node1.play = node2.play = node3.play = node4.play = node5.play = node6.play = node7.play = node8.play = node9.play = node10.play = node11.play = 0 );

node1.solo  ? node1.play  = 1;
node2.solo  ? node2.play  = 1;
node3.solo  ? node3.play  = 1;
node4.solo  ? node4.play  = 1;
node5.solo  ? node5.play  = 1;
node6.solo  ? node6.play  = 1;
node7.solo  ? node7.play  = 1;
node8.solo  ? node8.play  = 1;
node9.solo  ? node9.play  = 1;
node10.solo ? node10.play = 1;
node11.solo ? node11.play = 1;

node1.updateNodeBlock();
node2.updateNodeBlock();
node3.updateNodeBlock();
node4.updateNodeBlock();
node5.updateNodeBlock();
node6.updateNodeBlock();
node7.updateNodeBlock();
node8.updateNodeBlock();
node9.updateNodeBlock();
node10.updateNodeBlock();
node11.updateNodeBlock();

updateGlobalFeedback();

israte = 1.0 / srate;

@sample
midi.processMIDISample() ? (
  pitchMod = 2^(-(midi.lastNote - 69)/12);
  quickSwitch = 1;
);

samples += 1;

gainFactor = exp(.11512925464970228420089957273422*gain_interpolator.interpolate());
updateRange();

cPos += 50*israte;
lOut = 0;
rOut = 0;

samples % UPDATE_INTERVAL == 0 ? (
  node1.updateNode();
  node2.updateNode();
  node3.updateNode();
  node4.updateNode();
  node5.updateNode();
  node6.updateNode();
  node7.updateNode();
  node8.updateNode();
  node9.updateNode();
  node10.updateNode();
  node11.updateNode();
);

silent_thresh = 0.000001;
inGainEstimate = max(.99999 * inGainEstimate, max(spl0, spl1));

// Don't incur the CPU hit if we're not playing, geez.
(inGainEstimate + outGainEstimate + force_enabled) > silent_thresh ? (
  fade = startFade.evaluateFade();
  l = spl0 * fade;
  r = spl1 * fade;
  
  // This thing hates DC, so let's make sure it doesn't get in.
  dc_correction ? (
    l = dc0.eval_HP6(l);
    r = dc1.eval_HP6(r);
  );
  
  node1.process(l, r);
  node2.process(l, r);
  node3.process(l, r);
  node4.process(l, r);
  node5.process(l, r);
  node6.process(l, r);
  node7.process(l, r);
  node8.process(l, r);
  node9.process(l, r);
  node10.process(l, r);
  node11.processVerbNode(l, r);
  
  lp_cutoff = lp_interpolator.interpolate();
  hp_cutoff = hp_interpolator.interpolate();
  lp_res = lpres_interpolator.interpolate();
  (abs(lp_cutoff - llpf) > .00000001) || (abs(lp_res - lres) > .00000001) ? ( lpl.init_linearSVF(lp_cutoff, .99*LPRES); lpr.init_linearSVF(lp_cutoff, .99*LPRES); llpf = lp_cutoff; lres = lp_res; );
  (abs(hp_cutoff - lhpf) > .00000001) ? ( hpl.init_linearSVF(hp_cutoff, 0); hpr.init_linearSVF(hp_cutoff, 0); lhpf = hp_cutoff; );
  lp_cutoff < .99999 || lpres > 0 ? (
    lOut = lpl.eval_linearSVF_LP(lOut);
    rOut = lpr.eval_linearSVF_LP(rOut);
  );
  hp_cutoff > .00001 ? (
    lOut = hpl.eval_linearSVF_HP(lOut);
    rOut = hpr.eval_linearSVF_HP(rOut);
  );
  
  // Update the compressor and duck the delay signal if active
  duckingActive ? (
    duckerGain = ducker.compressor(l, r);
    lOut *= duckerGain;
    rOut *= duckerGain;
  );
  
  pitch ? (
    shifter.setPitchShifterSpeed(2*((2^(shift_pitch))-1.0));
    shifter.pitchShifterUpdate(lOut, rOut);
    lOut = shifter.outL;
    rOut = shifter.outR;
  );
  
  spl0 = l * (1-drywet) + lOut * drywet * gainFactor;
  spl1 = r * (1-drywet) + rOut * drywet * gainFactor;
);

outGainEstimate = max(.99999 * outGainEstimate, max(spl0, spl1));

@gfx 1400 850
scaling = gfx_ext_retina == 2 ? 1 : 0;
scaling = min(scaling, (max(850,gfx_w) - 1343)/1343);
render_time = render_time + 1/60;
lastchar = gfx_getchar();

function line_to_sim(xmin, ymin, w, h, xs, Ny, x1, y1, x2, y2, intensity)
global(w1x, w1y, height)
local(c1x, c1y, c2x, c2y, len, steps, dx, dy, xc, yc)
(
  c1x = floor((xmin + x1*w - w1x) / xs);
  c1y = floor((ymin + y1*h - w1y) / xs);
  c2x = floor((xmin + x2*w - w1x) / xs);
  c2y = floor((xmin + y2*h - w1y) / xs); 
  dx = c2x - c1x;
  dy = c2y - c1y;
  
  len = sqrt(dx * dx + dy * dy);
  steps = len / (.25*xs);
  dx /= steps;
  dy /= steps;
  xc = c1x;
  yc = c1y;
  loop(steps,
    height[floor(xc) * Ny + floor(yc)] += intensity;
    
    xc += dx;
    yc += dy;
  );
);

function draw_to_sim(xmin, ymin, w, h, xs, Ny)
local(cx, cy, intensity)
global(gfx_a, gfx_x, gfx_y, height, w1x, w1y, gainFactor,
       /*node1.x, node2.x, node3.x, node4.x, node5.x, node6.x, node7.x, node8.x, node9.x, node10.x, node11.x, 
       node1.y, node2.y, node3.y, node4.y, node5.y, node6.y, node7.y, node8.y, node9.y, node10.y, node11.y,
       node1.level, node2.level, node3.level, node4.level, node5.level, node6.level, node7.level, node8.level, node9.level, node10.level, node11.level*/)
instance(x, y, level,
  /*fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11*/)
(     
  //radius = fbcoeff/(1+.15*verb);
  //adv = min(0.99, radius);
  cx = floor((xmin + x*w - w1x) / xs);
  cy = floor((ymin + y*h - w1y) / xs);
  
  intensity = 50*level*gainFactor;
  height[cx * Ny + cy] += intensity;
  cx = cx + 1;
  height[cx * Ny + cy] += intensity;
  cx = cx - 2;
  height[cx * Ny + cy] += intensity;  
  
  /*fromNode1 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node1.x, node1.y, node1.level * fromNode1 );
  fromNode2 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node2.x, node2.y, node2.level * fromNode2 );
  fromNode3 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node3.x, node3.y, node3.level * fromNode3 );
  fromNode4 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node4.x, node4.y, node4.level * fromNode4 );
  fromNode5 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node5.x, node5.y, node5.level * fromNode5 );
  fromNode6 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node6.x, node6.y, node6.level * fromNode6 );
  fromNode7 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node7.x, node7.y, node7.level * fromNode7 );
  fromNode8 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node8.x, node8.y, node8.level * fromNode8 );
  fromNode9 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node9.x, node9.y, node9.level * fromNode9 );
  fromNode10 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node10.x, node10.y, node10.level * fromNode10);
  fromNode11 ? line_to_sim(xmin, ymin, w, h, xs, Ny, this.x, this.y, node11.x, node11.y, node11.level * fromNode11 );*/
);

function simulation(sim_w, sim_h, xs)
(
  (last_sim_w != sim_w || last_sim_h != sim_h) ? (
    last_sim_w = sim_w;
    last_sim_h = sim_h;
    
    memset(height, 0, BUF_SIZE);
    memset(velocity_x, 0, BUF_SIZE);
    memset(velocity_y, 0, BUF_SIZE);
    memset(height_gradient_x, 0, BUF_SIZE);
    memset(height_gradient_y, 0, BUF_SIZE);
    memset(velocity_prediction_x, 0, BUF_SIZE);
    memset(velocity_prediction_y, 0, BUF_SIZE);
  );

  Nx = sim_w/xs + 1;
  Ny = sim_h/xs + 1;
 
  colorscheme == 1 ? (
    c1r = 17/256;
    c1g = 11/256;
    c1b = 34/256;
  
    c2r = 175/256;
    c2g = 121/256;
    c2b = 274/256;
  ) : (
    c1r = 31/256;
    c1g = 21/256;
    c1b = 50/256;
     
    c2r = 180/256;
    c2g = 93/256;
    c2b = 103/256;
  );
  
  dtg = 9.81*0.1;
  dth = .4*0.1;
  
  /*(mouse_cap & 1 && !capped) > 0 ? (  
    (mouse_x < sim_w) && (mouse_y < sim_h) && (mouse_x > 0) && (mouse_y > 0) ? (
      dt = time_precise() - last_time;
      vx = (mouse_x - last_mouse_x) / dt;
      vy = (mouse_y - last_mouse_y) / dt;
      cx = floor(mouse_x / xs);
      cy = floor(mouse_y / xs);
      height[cx * Ny + cy] += 3;
    );
  );*/
  
  node1.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node2.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node3.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node4.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node5.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node6.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node7.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node8.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node9.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node10.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node11.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  
  xl = floor(xmin + x*w);
  yl = floor(ymin + y*h);
  
  /*cx = (Nx-4) * rand() + 2;
  cy = (Ny-4) * rand() + 2;
  height[cx * Ny + cy] = 8*(rand()>.65)*(.5+rand());*/
  
  cx = 0;
  loop(Nx-1,
    cy = 0;
    loop(Ny-1,
      h = height[cx * Ny + cy];
      dHx = h - height[(cx-1) * Ny + cy];
      dHy = h - height[cx * Ny + cy-1];
    
      velocity_prediction_x[cx * Ny + cy] = velocity_x[cx * Ny + cy] - dtg * dHx;
      velocity_prediction_y[cx * Ny + cy] = velocity_y[cx * Ny + cy] - dtg * dHy;
      cy += 1;
    );
    cx += 1;
  );
  
  cx = 0;
  loop(Ny,
    velocity_prediction_x[0 + cy] = 0;
    velocity_prediction_x[(Nx-1) * Ny + cy] = 0;
    cy += 1;
  );
  
  cy = 0;
  loop(Nx,
    velocity_prediction_y[cx * Ny + 0] = 0;
    velocity_prediction_y[cx * Ny + (Ny-1)] = 0;
    cx += 1;
  );
  
  cx = 0;
  tx = w1x;
  loop(Nx-1,
    cy = 0;
    ty = w1y + xs;
    loop(Ny-1,
      dUx = velocity_prediction_x[(cx+1) * Ny + cy] - velocity_prediction_x[cx * Ny + cy];
      dUy = velocity_prediction_y[cx * Ny + cy + 1] - velocity_prediction_y[cx * Ny + cy];
    
      h = height[cx * Ny + cy];
      height[cx * Ny + cy] = h - dth * (dUx + dUy) - .005*h;
      cy += 1;
      lvl = h>1?1:h;
      
      cx > 0 ? (
        gfx_set(c1r * (1-lvl) + c2r * lvl, 
                c1g * (1-lvl) + c2g * lvl,
                c1b * (1.0-lvl) + c2b * lvl,
                1.0);
        gfx_rect(tx, ty, xs-1, xs-1);
        gfx_a = .8;
        gfx_rect(tx, ty, xs, xs);
        ty += xs;
      );
    );
    cx += 1;
    tx += xs;
  );
  
  cx = 0;
  loop(Nx-1,
    cy = 0;
    loop(Ny-1,
      h = height[cx * Ny + cy];
      dHx = h - height[(cx-1) * Ny + cy];
      dHy = h - height[cx * Ny + cy-1];
    
      velocity_x[cx * Ny + cy] = velocity_x[cx * Ny + cy] - dtg * dHx;
      velocity_y[cx * Ny + cy] = velocity_y[cx * Ny + cy] - dtg * dHy;
      cy += 1;
    );
    cx += 1;
  );
);

font_color_r = .7;
font_color_g = .6;
font_color_b = .8;
font_color_a = 1;
line_color_r = .3;
line_color_g = 0;
line_color_b = 1;
line_color_a = .7;
knob_font_color_r = .4+.1;
knob_font_color_g = .3+.1;
knob_font_color_b = .6+.1;
knob_font_color_a = 1;
backface_color_r = .2;
backface_color_g = .1;
backface_color_b = .3;
edge_r = .15;
edge_g = .1;
edge_b = .3;
edge_a = 1.0;

label_r = .15 + .2;
label_g = .1 + .2;
label_b = .3 + .2;

FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", 16 * (1+scaling));

BAND_FONT = 5;
gfx_setfont(BAND_FONT, "Arial", 16 * (1+scaling));

KNOB_FONT = 6;
gfx_setfont(KNOB_FONT, "Arial", 14 * (1+scaling));

KNOB_FONT2 = 7;
test=(13 * (1+scaling));
gfx_setfont(KNOB_FONT2, "Arial", 13 * (1+scaling));

HINT_FONT = 8;
gfx_setfont(HINT_FONT, "Arial", 13 * (1+scaling));

TOGGLE_FONT = 9;
gfx_setfont(TOGGLE_FONT, "Arial", 16 * (1+scaling));

function drawWindow(x, y, w, h)
  local(dx, dy, Nx, Ny, pw, ph, xValue, yLevel, dyL, dxL, i, ct)
  global(gfx_x, gfx_y, FONT_GRID, SyncMode,
          font_color_r, font_color_g, font_color_b, font_color_a, 
          line_color_r, line_color_g, line_color_b, line_color_a,
          gridDensity)
  instance()
  (
    SyncMode == 0 ? (
      Nx = 10;
      Ny = 10;
    ) : ( SyncMode == 1 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 2 ) ? (
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 3 ) ? (
      Nx = 5*4;
      Ny = 10;
    ) : ( SyncMode == 4 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 5 ) ? ( 
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 6 ) ? (
      Nx = 12 * 5;
      Ny = 10;
    );
    Nx *= (1+gridDensity);
    Ny *= (1+gridDensity);
    
    dx = w/Nx;
    dy = h/Ny;
    dyL = 1/Ny;
    dxL = 1/Nx;
    gfx_y = y;
    
    gfx_measurestr("8888", pw, ph);
    gfx_setfont( FONT_GRID );
    yLevel = 1-dyL;
    loop(Ny,
      gfx_set(0, 0, 0, .7);
      gfx_line(x, gfx_y-1, x+w, gfx_y-1);
      gfx_line(x, gfx_y, x+w, gfx_y);
      gfx_line(x, gfx_y+1, x+w, gfx_y+1);
      gfx_set(0, 0, 0, .2);
      gfx_line(x, gfx_y+1, x+w-pw, gfx_y+1);
      
      gfx_x = x+w + 10;
      gfx_y -= .5*ph;
      
      gfx_y += dy + .5*ph;
      yLevel -= dyL;
    );
    
    gfx_x = x;
    gfx_y = h;
    i = 1;
    xValue = 0;
    loop(Nx+1,
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x-1, y, gfx_x-1, y+h);
      gfx_line(gfx_x, y, gfx_x, y+h);
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x+1, y, gfx_x+1, y+h);
      
      (syncMode == 6 && (i%12) == 1 && i > 0 && i < Nx+1) ? (
        gfx_set(.8, 0, .3, .7);
        gfx_line(gfx_x, y + 5, gfx_x, y+h);        
      );
            
      gfx_x = x + dx * i;
      xValue += dxL;
      i += 1;
    );
  );

function drawWindowText(x, y, w, h)
  local(dx, dy, Nx, Ny, pw, ph, xValue, yLevel, dyL, dxL, i, ct)
  global(gfx_x, gfx_y, FONT_GRID, SyncMode,
          font_color_r, font_color_g, font_color_b, font_color_a, 
          line_color_r, line_color_g, line_color_b, line_color_a,
          scaling)
  instance()
  (
    SyncMode == 0 ? (
      Nx = 10;
      Ny = 10;
    ) : ( SyncMode == 1 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 2 ) ? (
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 3 ) ? (
      Nx = 5*4;
      Ny = 10;
    ) : ( SyncMode == 4 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 5 ) ? ( 
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 6 ) ? (
      Nx = 12 * 5;
      Ny = 10;
    );
    dx = w/Nx;
    dy = h/Ny;
    dyL = 1/Ny;
    dxL = 1/Nx;
    gfx_y = y;
    
    gfx_measurestr("8888", pw, ph);
    gfx_setfont( FONT_GRID );
    yLevel = 1;
    loop(Ny,
      gfx_x = x+w + 10;
      gfx_y -= .5*ph;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      gfx_printf("%d dB", 20*log10(yToVol(1-yLevel)) );
      
      gfx_y += dy + .5*ph;
      yLevel -= dyL;
    );
    
    gfx_x = x;
    gfx_y = y + h + 5 * (1+scaling);// + .5*dy;
    i = 1;
    xValue = 0;
    
//    syncMode == 6

    gfx_x = x;
    gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
    syncMode == 6 ? (
      loop(Nx,
        gfx_x += .2*pw;
        (i%12) == 1 ? ( gfx_printf("A")
        ) : (i%12) == 0 ? ( gfx_x -= 2; gfx_printf("A#")
        ) : (i%12) == 11 ? ( gfx_printf("B")
        ) : (i%12) == 10 ? ( gfx_printf("C")
        ) : (i%12) == 9 ? ( gfx_x -= 2; gfx_printf("C#")
        ) : (i%12) == 8 ? ( gfx_printf("D")
        ) : (i%12) == 7 ? ( gfx_x -= 2; gfx_printf("D#")
        ) : (i%12) == 6 ? ( gfx_printf("E")
        ) : (i%12) == 5 ? ( gfx_printf("F")
        ) : (i%12) == 4 ? ( gfx_x -= 2; gfx_printf("F#")
        ) : (i%12) == 3 ? ( gfx_printf("G")
        ) : (i%12) == 2 ? ( gfx_x -= 2; gfx_printf("G#") );
        gfx_x = x + dx * i;
        i += 1;
      );
    ) : (
      loop(Nx+1,
        //gfx_x = x + .1*pw;
        ct = 1000*xToTime(xValue);
        gfx_x += .2*pw;
        syncMode == 0 ? (
          ( abs(ct - floor(ct+.5)) < .1 ) ? gfx_printf("%d ms", floor(.5*ct+.5)) : gfx_printf("%.1f ms", .5*ct);
        ) : (
          syncMode == 1 ? (
            (floor(i/2) != i/2) ? gfx_printf("%d/%d", (i-1)/2, 8/2);
          ) : ( syncMode == 2 ) ? (
            (floor(i/2) != i/2) ? gfx_printf("%d/%d", (i-1)/2, 6/2);
          ) : ( syncMode == 3 ) ? (
            (floor(i/2) != i/2) ? gfx_printf("%d/%d", (i-1)/2, 10/2);
          ) : ( syncMode == 4 ) ? (
            (floor(i/2) != i/2) ? gfx_printf("%d/%d", (i-1)/2, 16/2);
          ) : ( syncMode == 5 ) ? (
            (floor(i/2) != i/2) ? gfx_printf("%d/%d", (i-1)/2, 12/2);
          );
        );
        
        gfx_x = x + dx * i;
        xValue += dxL;
        i += 1;
      );
    );
    
  );

gfx_set(0,0,0,1);
gfx_rect(0, 0, gfx_w, gfx_h);

ymin = 0;
ymax = gfx_h;
xmin = 0;
xmax = gfx_w;

w1x = 10 * (1+scaling);
w1y = 30 * (1+scaling);
w1w = (1-0.062*(1+scaling))*gfx_w;
w1h = gfx_h - 1.5 * w1y - 1.95 * control_offset;
control_offset = 58 * (1 + scaling);

bg_color_r = 1.1;
bg_color_g = 0.3;
bg_color_b = 0.3;
bg_color_a = 0.8;

//grads.drawGradients(w1w, w1h, w1h, 0);

simulation(w1w, w1h, 5*(1+max(0,scaling)));

gfx_setfont(8, Arial, 80 * (1+ scaling));
gfx_measurestr("Delay Time → ", tw, th);
gfx_x = w1w - tw;
gfx_y = w1h - th;
gfx_set(0, 0, 0, .4);
gfx_printf("Delay Time →");

drawWindow(w1x, w1y, w1w, w1h);

node1.drawConnections(w1x, w1y, w1w, w1h);
node2.drawConnections(w1x, w1y, w1w, w1h);
node3.drawConnections(w1x, w1y, w1w, w1h);
node4.drawConnections(w1x, w1y, w1w, w1h);
node5.drawConnections(w1x, w1y, w1w, w1h);
node6.drawConnections(w1x, w1y, w1w, w1h);
node7.drawConnections(w1x, w1y, w1w, w1h);
node8.drawConnections(w1x, w1y, w1w, w1h);
node9.drawConnections(w1x, w1y, w1w, w1h);
node10.drawConnections(w1x, w1y, w1w, w1h);
node11.drawConnections(w1x, w1y, w1w, w1h);

node1.draw(w1x, w1y, w1w, w1h, 0);
node2.draw(w1x, w1y, w1w, w1h, 0);
node3.draw(w1x, w1y, w1w, w1h, 0);
node4.draw(w1x, w1y, w1w, w1h, 0);
node5.draw(w1x, w1y, w1w, w1h, 0);
node6.draw(w1x, w1y, w1w, w1h, 0);
node7.draw(w1x, w1y, w1w, w1h, 0);
node8.draw(w1x, w1y, w1w, w1h, 0);
node9.draw(w1x, w1y, w1w, w1h, 0);
node10.draw(w1x, w1y, w1w, w1h, 0);
node11.draw(w1x, w1y, w1w, w1h, 1);

gfx_set(0,0,0,1);
gfx_rect(0, w1y+w1h+1, gfx_w, gfx_h-w1h);

drawWindowText(w1x, w1y, w1w, w1h);

function killNode()
instance(mute, hidden, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11)
(
  fromNode1 = fromNode2 = fromNode3 = fromNode4 = fromNode5 = fromNode6 = fromNode7 = fromNode8 = fromNode9 = fromNode10 = fromNode11 = 0.0;
  mute = 1;
  hidden = 1;
);

lastchar == 6579564 ? (
  node1.selected  ? ( node1.killNode();  node2.fromNode1  = node3.fromNode1  = node4.fromNode1  = node5.fromNode1  = node6.fromNode1  = node7.fromNode1  = node8.fromNode1  = node9.fromNode1  = node10.fromNode1  = node11.fromNode1  = 0; );
  node2.selected  ? ( node2.killNode();  node1.fromNode2  = node3.fromNode2  = node4.fromNode2  = node5.fromNode2  = node6.fromNode2  = node7.fromNode2  = node8.fromNode2  = node9.fromNode2  = node10.fromNode2  = node11.fromNode2  = 0; );
  node3.selected  ? ( node3.killNode();  node2.fromNode3  = node1.fromNode3  = node4.fromNode3  = node5.fromNode3  = node6.fromNode3  = node7.fromNode3  = node8.fromNode3  = node9.fromNode3  = node10.fromNode3  = node11.fromNode3  = 0; );
  node4.selected  ? ( node4.killNode();  node2.fromNode4  = node3.fromNode4  = node1.fromNode4  = node5.fromNode4  = node6.fromNode4  = node7.fromNode4  = node8.fromNode4  = node9.fromNode4  = node10.fromNode4  = node11.fromNode4  = 0; );
  node5.selected  ? ( node5.killNode();  node2.fromNode5  = node3.fromNode5  = node4.fromNode5  = node1.fromNode5  = node6.fromNode5  = node7.fromNode5  = node8.fromNode5  = node9.fromNode5  = node10.fromNode5  = node11.fromNode5  = 0; );
  node6.selected  ? ( node6.killNode();  node2.fromNode6  = node3.fromNode6  = node4.fromNode6  = node5.fromNode6  = node1.fromNode6  = node7.fromNode6  = node8.fromNode6  = node9.fromNode6  = node10.fromNode6  = node11.fromNode6  = 0; );
  node7.selected  ? ( node7.killNode();  node2.fromNode7  = node3.fromNode7  = node4.fromNode7  = node5.fromNode7  = node6.fromNode7  = node1.fromNode7  = node8.fromNode7  = node9.fromNode7  = node10.fromNode7  = node11.fromNode7  = 0; );
  node8.selected  ? ( node8.killNode();  node2.fromNode8  = node3.fromNode8  = node4.fromNode8  = node5.fromNode8  = node6.fromNode8  = node7.fromNode8  = node1.fromNode8  = node9.fromNode8  = node10.fromNode8  = node11.fromNode8  = 0; );
  node9.selected  ? ( node9.killNode();  node2.fromNode9  = node3.fromNode9  = node4.fromNode9  = node5.fromNode9  = node6.fromNode9  = node7.fromNode9  = node8.fromNode9  = node1.fromNode9  = node10.fromNode9  = node11.fromNode9  = 0; );
  node10.selected ? ( node10.killNode(); node2.fromNode10 = node3.fromNode10 = node4.fromNode10 = node5.fromNode10 = node6.fromNode10 = node7.fromNode10 = node8.fromNode10 = node9.fromNode10 = node1.fromNode10  = node11.fromNode10 = 0; );
);

function createNode()
instance(hidden, mute, x, y, dtime, y, grainLength)
local()
global(mouse_x, mouse_y, w1x, w1y, w1w, w1h)
(
  hidden = 0;
  dtime = y = grainLength = 0;
  this.resetNode(xToTime((mouse_x - w1x) / w1w), (mouse_y - w1y) / w1h);
);

lastleft = left;
lastright = right;
left = mouse_cap & 1;
right = mouse_cap & 2;

((left > 0) && (lastleft == 0)) ? leftTime = time_precise();
ddtime  = ( leftTime - lastLeftTime );
dblclick = ( (left > 0) && (lastleft == 0) && ( ( leftTime - lastLeftTime ) < .2 ) ) ? 1 : 0;
lastLeftTime = leftTime;

comboboxOpen == 0 ? (
  !lastleft ? multiSelect = 0;
  multiSelect == 0 ? (
     // These functions will fill global nodeCap with the capture mode that occurred
     // 1 - LMB, 2 - RMB
     node1.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node2.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node3.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node4.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node5.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node6.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node7.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node8.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node9.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
     node10.overNode(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap );
     node11.overNode(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap );
     
     node1.overSignalCable(mouse_cap);
     node2.overSignalCable(mouse_cap);
     node3.overSignalCable(mouse_cap);
     node4.overSignalCable(mouse_cap);
     node5.overSignalCable(mouse_cap);
     node6.overSignalCable(mouse_cap);
     node7.overSignalCable(mouse_cap);
     node8.overSignalCable(mouse_cap);
     node9.overSignalCable(mouse_cap);
     node10.overSignalCable(mouse_cap);
     node11.overSignalCable(mouse_cap);
      
     // An unselected one was selected. Deselect all others
     nodeCap < 0 ? (
      node1.amIChosen();
      node2.amIChosen();
      node3.amIChosen();
      node4.amIChosen();
      node5.amIChosen();
      node6.amIChosen();
      node7.amIChosen();
      node8.amIChosen();
      node9.amIChosen();
      node10.amIChosen();
      node11.amIChosen();
      nodeCap = abs(nodeCap);
     );
     
     node1.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node2.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node3.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node4.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node5.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node6.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node7.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node8.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node9.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node10.nodeProcessMouse(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
     node11.nodeProcessMouse(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
  
    lastMouseX = mouse_x;
    lastMouseY = mouse_y;
    
    !nodeCap ? (
      // No nodes manipulated => Do multi-select
      ( mouse_x > w1x ) && ( mouse_y > w1y ) && ( mouse_x < ( w1x + w1w ) ) && ( mouse_y < ( w1y + w1h ) ) ? (
        ( ( lastleft == 0 ) && ( left == 1 ) ) ? (
          multiSelect = 1;
          refx = mouse_x;
          refy = mouse_y;
        ) : ( ( lastright == 0 ) && ( right == 2 ) ) ? (
          // Any nodes free?
          (node1.hidden == 1) ? ( node1.createNode(); 
          ) : ( node2.hidden == 1 ) ? ( node2.createNode(); 
          ) : ( node3.hidden == 1 ) ? ( node3.createNode(); 
          ) : ( node4.hidden == 1 ) ? ( node4.createNode(); 
          ) : ( node5.hidden == 1 ) ? ( node5.createNode(); 
          ) : ( node6.hidden == 1 ) ? ( node6.createNode(); 
          ) : ( node7.hidden == 1 ) ? ( node7.createNode(); 
          ) : ( node8.hidden == 1 ) ? ( node8.createNode(); 
          ) : ( node9.hidden == 1 ) ? ( node9.createNode(); 
          ) : ( node10.hidden == 1 ) ? ( node10.createNode(); 
          ) : (
            tried_to_make_more_nodes_than_available = 1;
          );
        );
      );
    );
  ) : ( multiSelect == 1 ) ? (
    xmi = max(w1x-1, min(refx, mouse_x));
    xma = max(refx, mouse_x);
    ymi = max(w1y-1, min(refy, mouse_y));
    yma = max(refy, mouse_y);
    xma = min(xma, w1x + w1w + 1);
    yma = min(yma, w1y + w1h + 1);
    gfx_set(1, 1, 1, .4);
    gfx_rect(xmi, ymi, xma-xmi, yma-ymi);
    // Select nodes upon release
    !left ? (
      node1.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node2.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node3.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node4.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node5.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node6.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node7.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node8.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node9.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node10.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
      node11.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    );
  );
);

  function printRight(str)
  (
    gfx_set(0,0,0,1);
    gfx_measurestr(str, tx, ty);
    gfx_x = w1x+w1w-tx-16;
    gfx_printf(str);
    gfx_x = w1x+w1w-tx-17;
    gfx_printf(str);
    gfx_y = gfx_y + 1;
    gfx_x = w1x+w1w-tx-15;
    gfx_set(font_color_r,font_color_g,font_color_b,1);
    gfx_printf(str);
    gfx_y = gfx_y + ty;
  );

gfx_y = w1y + 10;
hideHints == 0 ? (
  printRight("RMB - Add node\n");
  printRight("Del - Remove selected nodes\n");
  printRight("RMB + Drag Node - Feedback\n");
  printRight("Shift - LPF\n");
  printRight("Ctrl + Shift - HPF\n");
  printRight("Shift + Alt - Add Send\n");
  printRight("LMBx2 on Send - Invert\n");
  printRight("Hold Alt + Drag Node - Panning\n");
  printRight("M - Mute\n");
  printRight("S - Solo\n");
  printRight("P - Ping pong\n");
  printRight("R - Rectify\n");
  printRight("I - Invert polarity\n");
  printRight("Wheel - Direct In Gain\n");
  printRight("G - Grain\n");
  printRight("A - Select all nodes\n");
  HQ ? (
    printRight("H - HQ resampling [ON]");
  ) : (
    printRight("H - HQ resampling [OFF]");
  );
  printRight("F1 - Toggle hints");
  printRight("K -  Reset delay lines");
);

// F1 - Hide hints
( lastchar == 26161 ) ? (
  hideHints = 1 - hideHints;
);

// K - reset delay lines
( lastchar == 107 ) ? (
  Init();
);


// Mute
( lastchar == 109 ) ? (
  node1.selected  ? node1.mute  = node1.mute  ? 0 : 1;
  node2.selected  ? node2.mute  = node2.mute  ? 0 : 1;
  node3.selected  ? node3.mute  = node3.mute  ? 0 : 1;
  node4.selected  ? node4.mute  = node4.mute  ? 0 : 1;
  node5.selected  ? node5.mute  = node5.mute  ? 0 : 1;
  node6.selected  ? node6.mute  = node6.mute  ? 0 : 1;
  node7.selected  ? node7.mute  = node7.mute  ? 0 : 1;
  node8.selected  ? node8.mute  = node8.mute  ? 0 : 1;
  node9.selected  ? node9.mute  = node9.mute  ? 0 : 1;
  node10.selected ? node10.mute = node10.mute ? 0 : 1;
  node11.selected ? node11.mute = node11.mute ? 0 : 1;
);

( lastchar == 104 ) ? (
  HQ = 1 - HQ;
);

// Grain
( lastchar == 103 ) ? (
  node1.selected  ? node1.grain  = node1.grain  ? 0 : 1;
  node2.selected  ? node2.grain  = node2.grain  ? 0 : 1;
  node3.selected  ? node3.grain  = node3.grain  ? 0 : 1;
  node4.selected  ? node4.grain  = node4.grain  ? 0 : 1;
  node5.selected  ? node5.grain  = node5.grain  ? 0 : 1;
  node6.selected  ? node6.grain  = node6.grain  ? 0 : 1;
  node7.selected  ? node7.grain  = node7.grain  ? 0 : 1;
  node8.selected  ? node8.grain  = node8.grain  ? 0 : 1;
  node9.selected  ? node9.grain  = node9.grain  ? 0 : 1;
  node10.selected ? node10.grain = node10.grain ? 0 : 1;
  //node11.selected ? node11.grain = node11.grain ? 0 : 1;
  init();
);

// Solo
( lastchar == 115 ) ? (
  node1.selected  ? node1.solo  = node1.solo  ? 0 : 1;
  node2.selected  ? node2.solo  = node2.solo  ? 0 : 1;
  node3.selected  ? node3.solo  = node3.solo  ? 0 : 1;
  node4.selected  ? node4.solo  = node4.solo  ? 0 : 1;
  node5.selected  ? node5.solo  = node5.solo  ? 0 : 1;
  node6.selected  ? node6.solo  = node6.solo  ? 0 : 1;
  node7.selected  ? node7.solo  = node7.solo  ? 0 : 1;
  node8.selected  ? node8.solo  = node8.solo  ? 0 : 1;
  node9.selected  ? node9.solo  = node9.solo  ? 0 : 1;
  node10.selected ? node10.solo = node10.solo ? 0 : 1;
  node11.selected ? node11.solo = node11.solo ? 0 : 1;
);

// Pingpong (P)
( lastchar == 112 ) ? (
  node1.selected  ? node1.pingpong  = node1.pingpong  ? 0 : 1;
  node2.selected  ? node2.pingpong  = node2.pingpong  ? 0 : 1;
  node3.selected  ? node3.pingpong  = node3.pingpong  ? 0 : 1;
  node4.selected  ? node4.pingpong  = node4.pingpong  ? 0 : 1;
  node5.selected  ? node5.pingpong  = node5.pingpong  ? 0 : 1;
  node6.selected  ? node6.pingpong  = node6.pingpong  ? 0 : 1;
  node7.selected  ? node7.pingpong  = node7.pingpong  ? 0 : 1;
  node8.selected  ? node8.pingpong  = node8.pingpong  ? 0 : 1;
  node9.selected  ? node9.pingpong  = node9.pingpong  ? 0 : 1;
  node10.selected ? node10.pingpong = node10.pingpong ? 0 : 1;
);

// Invert feedback polarity (I)
( lastchar == 105 ) ? (
  node1.selected  ? node1.feedbackSign = 1 - node1.feedbackSign;
  node2.selected  ? node2.feedbackSign = 1 - node2.feedbackSign;
  node3.selected  ? node3.feedbackSign = 1 - node3.feedbackSign;
  node4.selected  ? node4.feedbackSign = 1 - node4.feedbackSign;
  node5.selected  ? node5.feedbackSign = 1 - node5.feedbackSign;
  node6.selected  ? node6.feedbackSign = 1 - node6.feedbackSign;
  node7.selected  ? node7.feedbackSign = 1 - node7.feedbackSign;
  node8.selected  ? node8.feedbackSign = 1 - node8.feedbackSign;
  node9.selected  ? node9.feedbackSign = 1 - node9.feedbackSign;
  node10.selected  ? node10.feedbackSign = 1 - node10.feedbackSign;
);

// Rectify (R)
( lastchar == 114 ) ? (
  node1.selected  ? node1.rectify  = node1.rectify  ? 0 : 1;
  node2.selected  ? node2.rectify  = node2.rectify  ? 0 : 1;
  node3.selected  ? node3.rectify  = node3.rectify  ? 0 : 1;
  node4.selected  ? node4.rectify  = node4.rectify  ? 0 : 1;
  node5.selected  ? node5.rectify  = node5.rectify  ? 0 : 1;
  node6.selected  ? node6.rectify  = node6.rectify  ? 0 : 1;
  node7.selected  ? node7.rectify  = node7.rectify  ? 0 : 1;
  node8.selected  ? node8.rectify  = node8.rectify  ? 0 : 1;
  node9.selected  ? node9.rectify  = node9.rectify  ? 0 : 1;
  node10.selected ? node10.rectify = node10.rectify ? 0 : 1;
);

( lastchar == 97 ) ? (
  node1.selected = node2.selected = node3.selected = node4.selected = node5.selected = node6.selected = node7.selected = node8.selected = node9.selected = node10.selected = 1;
);

//gfx_x = 0;
//gfx_y= 0;
//(lastchar > 0) ? (
//  lc = lastchar;
//);
//gfx_printf("%d", lc);


// T - transform
function convertToNewFormat()
  instance(fbCoeff, y)
  local(curVol)
  global()
  (
    curVol = yToVol(y);
    y = (-2/3)*log(curVol * fbCoeff)/log(10);
  );
  
( lastchar == 116 ) ? (
  node1.convertToNewFormat();
  node2.convertToNewFormat();
  node3.convertToNewFormat();
  node4.convertToNewFormat();
  node5.convertToNewFormat();
  node6.convertToNewFormat();
  node7.convertToNewFormat();
  node8.convertToNewFormat();
  node9.convertToNewFormat();
  node10.convertToNewFormat();
  lastchar = 0;
);

( abs( mouse_wheel ) > 0 ) ? (
  shift = mouse_cap & 8;
  ctrl  = mouse_cap & 4;
  dy = - mouse_wheel * .001;
  
  shift ? ( dy /= 4 );
  ctrl ? ( dy /= 4 );
  
  node1.over   ? ( node1.gain  = clamp( node1.gain  + dy, 0, 1); mouse_wheel = 0; );
  node2.over   ? ( node2.gain  = clamp( node2.gain  + dy, 0, 1); mouse_wheel = 0; );
  node3.over   ? ( node3.gain  = clamp( node3.gain  + dy, 0, 1); mouse_wheel = 0; );
  node4.over   ? ( node4.gain  = clamp( node4.gain  + dy, 0, 1); mouse_wheel = 0; );
  node5.over   ? ( node5.gain  = clamp( node5.gain  + dy, 0, 1); mouse_wheel = 0; );
  node6.over   ? ( node6.gain  = clamp( node6.gain  + dy, 0, 1); mouse_wheel = 0; );
  node7.over   ? ( node7.gain  = clamp( node7.gain  + dy, 0, 1); mouse_wheel = 0; );
  node8.over   ? ( node8.gain  = clamp( node8.gain  + dy, 0, 1); mouse_wheel = 0; );
  node9.over   ? ( node9.gain  = clamp( node9.gain  + dy, 0, 1); mouse_wheel = 0; );
  node10.over  ? ( node10.gain = clamp( node10.gain + dy, 0, 1); mouse_wheel = 0; );
  node11.over  ? ( node11.gain = clamp( node11.gain + dy, 0, 1); mouse_wheel = 0; );
);

nSelected = node1.selected + node2.selected + node3.selected + node4.selected + node5.selected + node6.selected + node7.selected + node8.selected + node9.selected + node10.selected + node11.selected*1;

function drawPanel(str, x, y, w, h)
instance()
local()
global(BAND_FONT, label_r, label_g, label_b, edge_r, edge_g, edge_b, edge_a)
(
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  drawVertLabel(x, y, str, h, BAND_FONT, 3, label_r, label_g, label_b, 1.0, 1.0);
  
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  gfx_line(x, y, x, y+h);
  gfx_line(x, y, x+w, y);
  gfx_line(x+w, y, x+w, y+h);
  gfx_line(x, y+h, x+w, y+h);
);


function processVerbCtrls(cX, cY)
  instance(gain, vol, y, fb, pan, lpf, hpf, shine, ice, ice_panned, pitch, shift_pitch,
  inputGainKnob, outputGainKnob, feedbackKnob, panningKnob, lpfKnob, hpfKnob, shineKnob, pitchToggle, pitchKnob,
  resonanceKnob, lpfResonance, iceKnob, icePanToggle)
  local(gain_string, tmp)
  global(mouse_x, mouse_y, mouse_cap, scaling, knobSize, knobSpacing, panelY, panelHeight, panelPad, buttonSize,
  widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a)
  (
    gfx_setfont(4);
    
    drawPanel("BALANCE", cX - 1.75*knobSpacing, panelY - panelPad, 14*knobSpacing, panelHeight);
    
    inputGainKnob.active = 1;
    inputGainKnob.value = 1 - gain;
    inputGainKnob.drawKnob(cX, cY, knobSize, "In Gain", "Input gain", 0);
    inputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? gain = 1-inputGainKnob.value;
    
    cX += 3.5*knobSpacing;
    outputGainKnob.active = 1;
    outputGainKnob.value = 1 - y;
    outputGainKnob.drawKnob(cX, cY, knobSize, "Out Gain", "Input gain", 0);
    outputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      y = 1 - outputGainKnob.value;
      this.updateToSliderRec();
    );
    
    cX += 3.5*knobSpacing;
    panningKnob.active = 1;
    panningKnob.value = pan;
    panningKnob.drawKnob(cX, cY, knobSize, "[L] Panning [R]", "Panning", 0);
    panningKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? pan = panningKnob.value;    
    
    cX += 3.5*knobSpacing;
    
    pitchToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pitch > 0, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Toggle pitch shifting.");
    tmp = pitchToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    pitchKnob.active = pitch;
    pitchKnob.value = shift_pitch*0.5 + 0.5;
    tmp > 0 && pitch == 0 ? ( pitch = 1; );
    tmp == 0 && pitch > 0 ? ( pitch = 0; );
    
    pitchKnob.label = sprintf(gain_string, "%.2f st", 12*shift_pitch);
    pitchKnob.label = gain_string;
    pitchKnob.drawKnob(cX, cY, knobSize, "Pitch", "Pitch shift.", 0);
    pitchKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      shift_pitch = 2 * pitchKnob.value - 1.0;
      mouse_cap & 2 > 0 ? (
        shift_pitch = floor(12 * shift_pitch + .5)/12;
      );
    );
    
    cX += 5*knobSpacing;
    drawPanel("REVERB", cX - 1.75*knobSpacing, panelY - panelPad, 10.5*knobSpacing, panelHeight);
    
    feedbackKnob.active = 1;
    feedbackKnob.value = fb;
    feedbackKnob.drawKnob(cX, cY, knobSize, "Decay time", "Decay time\n\nLength of the reverb tail.", 0);
    feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? (
      fb = clamp(feedbackKnob.value,0,.999);
      this.updateToSliderRec();
    );
    
    cX += 3.5*knobSpacing;
    shineKnob.active = 1;
    shineKnob.value = shine;
    shineKnob.drawKnob(cX, cY, knobSize, "Shine", "Shine.\n\nMake copies of spectrum to higher octaves.\nCan be used to add extra brightness.", 0);
    shineKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.2) ? shine = shineKnob.value;    

    cX += 3.5*knobSpacing;
    iceKnob.active = 1;
    iceKnob.value = ice;
    iceKnob.drawKnob(cX, cY, knobSize, "Ice", "Ice.\n\nMake bandpassed copies of spectrum to higher octaves.\nSounds like little icicles.", 0);
    iceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.2) ? ice = iceKnob.value;  

    icePanToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, ice_panned, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Random pan of icicles.");
    ice_panned = icePanToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

    cX += 5*knobSpacing;
    
    drawPanel("FILTERS", cX - 1.75*knobSpacing, panelY - panelPad, 10.5*knobSpacing, panelHeight);
    hpfKnob.active = 1;
    hpfKnob.value = hpf;
    tmp = f_trafo_hz(hpf);
    gain_string = 100;
    tmp < 1000 ? (
      hpf == 0 ? (
        hpfKnob.label = sprintf(gain_string, "OFF", tmp);
      ) : (
        hpfKnob.label = sprintf(gain_string, "%d Hz", tmp);
      );
    ) : (
      hpfKnob.label = sprintf(gain_string, "%d kHz", tmp/1000);
    );
    hpfKnob.drawKnob(cX, cY, knobSize, "High pass", "High pass filter.", 0);
    hpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      hpf = hpfKnob.value;
      lpf < hpf ? (
        lpf = hpf;
      );
    );
    
    cX += 3.5*knobSpacing;
    lpfKnob.active = 1;
    lpfKnob.value = lpf;
    tmp = f_trafo_hz(lpf);
    tmp < 1000 ? (
      lpfKnob.label = sprintf(gain_string, "%d Hz", tmp);
    ) : (
      (lpf < 1.0 || lpfResonance > 0.0) ? (
        lpfKnob.label = sprintf(gain_string, "%d kHz", tmp/1000);
      ) : (
        lpfKnob.label = sprintf(gain_string, "OFF");
      );
    );
    lpfKnob.drawKnob(cX, cY, knobSize, "Low pass", "Low pass filter", 0);
    lpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      lpf = lpfKnob.value;
      lpf < hpf ? (
        hpf = lpf;
      );
    );
    
    cX += 3.5*knobSpacing;
    resonanceKnob.active = 1;
    resonanceKnob.value = lpfResonance;
    resonanceKnob.label = sprintf(gain_string, "%.2f", lpfResonance);
    resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Resonance.\n\nResonance control for LPF.", 0);
    resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? lpfResonance = resonanceKnob.value;   
    
    cX += 5*knobSpacing
  );

function reverbCtrls(cX, cY)
  instance(flutterKnob,
           allpass, allpassToggle,
           feedbackKnob, timeKnob, x, dtime, fb, flutter, 
           reverbToggle, isReverb)
  local(gain_string)
  global(widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a,
         mouse_x, mouse_y, mouse_cap,
         scaling, knobSize, buttonSize, knobSpacing, panelY, panelPad, panelHeight, freeNodes)
  (
    gain_string = 101;
    
    drawPanel("REVERB", cX - 1.75*knobSpacing, panelY - panelPad, 7*knobSpacing, panelHeight);
    
    timeKnob.active = 1;
    timeKnob.value = x;
    timeKnob.label = 0;
    timeKnob.drawKnob(cX, cY, knobSize, "Size", "Tweak reverb size.", 0);
    timeKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? (
      x = !freeNodes ? clamp(timeKnob.value,0,1) : timeKnob.value;
      dtime = xToTime(x);
      this.updateToSliderRec();
    );
    
    reverbToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, isReverb, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Feedback Delay.\n\nConvert this node to a feedback delay."); 
    isReverb = reverbToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    cX += 3.5*knobSpacing;
    feedbackKnob.active = 1;
    feedbackKnob.value = fb;
    feedbackKnob.label = sprintf(gain_string, "%.1f dB", 20*log10(.95*exp(-4.0*(1.0-fb))));
    feedbackKnob.drawKnob(cX, cY, knobSize, "Decay", "Feedback amount\n\nControls how quickly the reverb decays.", 0);
    feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? (
      fb = feedbackKnob.value;
      this.updateToSliderRec();
    );
    
    /*cX += 3.5*knobSpacing;
    flutterKnob.active = 1;
    flutterKnob.value = flutter;
    flutterKnob.drawKnob(cX, cY, knobSize, "Flutter", "Flutter.\n\nControls random variability in delay time.", 0);
    flutterKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? flutter = flutterKnob.value;*/
    
    cX += 5*knobSpacing;
  );

function delayCtrls(cX, cY)
  instance(feedbackSignToggle, pitchKnob, flutterKnob,
           pitchTracking, pitchTrackingToggle, allpass, allpassToggle,
           feedbackKnob, timeKnob, x, dtime, fb, flutter, feedbackSign, 
           reverbToggle, isReverb)
  local(gain_string)
  global(widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a,
         mouse_x, mouse_y, mouse_cap,
         scaling, knobSize, buttonSize, knobSpacing, panelY, panelPad, panelHeight, freeNodes)
  (
    gain_string = 101;
    
    drawPanel("DELAY", cX - 1.75*knobSpacing, panelY - panelPad, 10.5*knobSpacing, panelHeight);
    timeKnob.active = 1;
    timeKnob.value = x;
    
    // dtime is given in buffer samples / srate. Since we are dealing with stereo content and an
    // interleaved buffer, dtime is only half of the true delay.
    pitchTracking ? (
      timeKnob.label = sprintf(gain_string, "%s", toNote(.5/dtime));
    ) : (
      dtime < 499 ? (
        timeKnob.label = sprintf(gain_string, "%d ms", dtime * 500);
      ) : (
        timeKnob.label = sprintf(gain_string, "%d s", dtime * .5);      
      );
    );
    
    timeKnob.drawKnob(cX, cY, knobSize, "Delay Time", "Delay time\n\nControls the distance between each delay.", 0);
    timeKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? (
      x = !freeNodes ? clamp(timeKnob.value, 0, 1) : timeKnob.value;
      dtime = xToTime(x);
      
      mouse_cap & 2 > 0 ? (
        pitchTracking ? (
          dtime = 1.0/roundToNote(1.0/dtime);
        );
      );
      this.updateToSliderRec();
    );

    reverbToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, isReverb, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Allpass reverb.\n\nConvert this node to an allpass reverb."); 
    isReverb = reverbToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    pitchTrackingToggle.drawToggle(cX+1.25*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pitchTracking, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Pitch tracking\nScale delay by incoming midi note. Enabling this allows you to generate\nresonances that track notes being played. Note that this only works well for\nshort delays. Reference point is at A-4 (meaning input note A4 incurs no\nchange in the delay time.\n");
    pitchTracking = pitchTrackingToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    cX += 3.5*knobSpacing;
    feedbackKnob.active = 1;
    feedbackKnob.value = fb;
    feedbackKnob.label = sprintf(gain_string, "%.1f dB", 20*log10(.95*exp(-4.0*(1.0-fb))));
    feedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Feedback amount\n\nControls how quickly the delay decays.", 0);
    feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? (
      fb = feedbackKnob.value;
      this.updateToSliderRec();
    );
    
    feedbackSignToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, feedbackSign, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Feedback sign\n\nSwitch signal polarity when feeding back.");
    feedbackSign = feedbackSignToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    allpassToggle.drawToggle(cX+1.25*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, allpass, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Allpass toggle\nToggle whether this should be a comb feedback or allpass.");
    allpass = allpassToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    cX += 3.5*knobSpacing;
    flutterKnob.active = 1;
    flutterKnob.value = flutter;
    flutterKnob.drawKnob(cX, cY, knobSize, "Flutter", "Flutter.\n\nControls random variability in delay time.", 0);
    flutterKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? flutter = flutterKnob.value;    
    
    cX += 5*knobSpacing;
  );

function processRegularCtrls(cX, cY)
  instance(gain, vol, y, pan, lpf, hpf, x, dtime, pingpong, midside, shift_pitch, pitch,
  inputGainKnob, outputGainKnob, panningKnob, lpfKnob, hpfKnob, pingpongToggle, midSideToggle,
  pitchToggle, pitchToggle2, pitchKnob, isReverb, lpfResonance, resonanceKnob)
  local(gain_string, tmp)
  global(mouse_x, mouse_y, mouse_cap, scaling, knobSize, buttonSize, knobSpacing,
         widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a,
         panelY, panelHeight, panelPad)
  (
    gfx_setfont(4);
    
    drawPanel("BALANCE", cX - 1.75*knobSpacing, panelY - panelPad, 14*knobSpacing, panelHeight);
    
    inputGainKnob.active = 1;
    inputGainKnob.value = 1 - gain;
    gain_string = 101;
    inputGainKnob.label = sprintf(gain_string, "%.1f dB", 20*log10(yToVol(gain)));
    inputGainKnob.drawKnob(cX, cY, knobSize, "In Gain", "Input gain.\n\nControls how much of the input is\npumped into the delay line.", 0);
    inputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? gain = 1-inputGainKnob.value;
        
    cX += 3.5*knobSpacing;
    outputGainKnob.active = 1;
    outputGainKnob.value = 1 - y;
    outputGainKnob.label = sprintf(gain_string, "%.1f dB", 20*log10(yToVol(y)));
    outputGainKnob.drawKnob(cX, cY, knobSize, "Out Gain", "Output gain\n\nControls how much of the signal\nis routed to the output.", 0);
    outputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      y = 1 - outputGainKnob.value;
      this.updateToSliderRec();
    );
    
    cX += 3.5*knobSpacing;
    
    panningKnob.active = 1;
    panningKnob.value = pan;
    panningKnob.label = sprintf(gain_string, "%d°", 180*pan - 90);
    midside ? (
      panningKnob.drawKnob(cX, cY, knobSize, "[M] Panning [S]", "Panning.", 0);
    ) : (
      panningKnob.drawKnob(cX, cY, knobSize, "[L] Panning [R]", "Panning.", 0);
    );
    panningKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      pan = panningKnob.value;
      this.updateToSliderRec();
    );
    
    pingpongToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pingpong, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Toggle ping\npong panning");
    pingpong = pingpongToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    midsideToggle.drawToggle(cX+1.25*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, midside, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Toggle mid/side\nprocessing");
    midside = midsideToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    cX += 3.5*knobSpacing;
    
    pitchToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pitch > 0, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Toggle pitch shifting.");
    tmp = pitchToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    tmp > 0 && pitch == 0 ? ( pitch = 1; );
    tmp == 0 && pitch > 0 ? ( pitch = 0; );
    
    pitchToggle2.active = pitch > 0;
    pitchToggle2.drawToggle(cX+1.25*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pitch > 1, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Place pitch shifter after feedback.");
    pitch > 0 ? (
      pitch = pitchToggle2.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? 2 : 1;
    );
    
    pitchKnob.active = pitch;
    pitchKnob.value = shift_pitch*0.5 + 0.5;
    pitchKnob.label = sprintf(gain_string, "%.2f st", 12*shift_pitch);
    pitchKnob.label = gain_string;
    pitchKnob.drawKnob(cX, cY, knobSize, "Pitch", "Pitch shift.", 0);
    pitchKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      shift_pitch = 2 * pitchKnob.value - 1.0;
      mouse_cap & 2 > 0 ? (
        shift_pitch = floor(12 * shift_pitch + .5)/12;
      );
    );
    
    cX += 5 * knobSpacing;
    
    isReverb ? (
      cX = this.reverbCtrls(cX, cY);
    ) : (
      cX = this.delayCtrls(cX, cY);
    );
    
    drawPanel("FILTERS", cX - 1.75*knobSpacing, panelY - panelPad, 10.5*knobSpacing, panelHeight);
    hpfKnob.active = 1;
    hpfKnob.value = hpf;

    tmp = f_trafo_hz(hpf);
    tmp < 1000 ? (
      hpf == 0 ? (
        hpfKnob.label = sprintf(gain_string, "OFF", tmp);
      ) : (
        hpfKnob.label = sprintf(gain_string, "%d Hz", tmp);
      );
    ) : (
      hpfKnob.label = sprintf(gain_string, "%d kHz", tmp/1000);
    );
    hpfKnob.drawKnob(cX, cY, knobSize, "High pass", "High pass filter.\n\nControls cutoff frequency of high pass filter.", 0);
    hpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      hpf = hpfKnob.value;
      lpf < hpf ? (
        lpf = hpf;
      );
    );
    
    cX += 3.5*knobSpacing;
    tmp = f_trafo_hz(lpf);
    tmp < 1000 ? (
      lpfKnob.label = sprintf(gain_string, "%d Hz", tmp);
    ) : (
      (lpf < 1.0 || lpfResonance > 0.0) ? (
        lpfKnob.label = sprintf(gain_string, "%d kHz", tmp/1000);
      ) : (
        lpfKnob.label = sprintf(gain_string, "OFF");
      );
    );
    lpfKnob.active = 1;
    lpfKnob.value = lpf;
    lpfKnob.drawKnob(cX, cY, knobSize, "Low pass", "Low pass filter.\n\nControls cutoff frequency of low pass filter.", 0);
    lpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      lpf = lpfKnob.value;
      lpf < hpf ? (
        hpf = lpf;
      );
    );
    
    cX += 3.5*knobSpacing;
    resonanceKnob.active = 1;
    resonanceKnob.value = lpfResonance;
    resonanceKnob.label = sprintf(gain_string, "%.2f", lpfResonance);
    resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Resonance.\n\nResonance control for LPF.", 0);
    resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? lpfResonance = resonanceKnob.value;    
    
    cX += 5*knobSpacing
  );


// Draw grain controls
function processGrainCtrls(cX, cY)
  instance(grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread, grainReverse, grainSizeVar,
                  lengthKnob,  jitterKnob,  overlapKnob,  speedKnob,  panSpreadKnob,  detuneKnob, grainToggle, reverseKnob, sizeVarKnob, grainToggle2)
  local(y_spacing, smallknobsize, x_start, y_start, panel_width, y_font_offset, tmp, s_spacing)
  global(mouse_x, mouse_y, mouse_cap, scaling, buttonSize, knobSize, knobSpacing,
         widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, 
         edge_r, edge_g, edge_b, edge_a, BAND_FONT, panelY, panelPad, panelHeight)
  (
    gfx_setfont(4);
    
    panel_width = 7.6*knobSpacing; //162 * (1+scaling);
    x_start = cX - 1.75*knobSpacing;
    y_start = panelY;
    
    drawPanel("GRAIN", x_start, y_start-panelPad, panel_width + knobSpacing, panelHeight);
    
    y_spacing = .95 * knobSpacing;
    smallknobsize = .42*knobSize;
    y_font_offset = 2 * (1+scaling);
    
    cX -= .7*knobSpacing;
    grainToggle2.active = grain > 0;
    grainToggle2.drawToggle(cX-.45*knobSpacing + panel_width, y_start, buttonSize-2, buttonSize-2, grain > 1, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Do not feed grains back.\n\nMove granular resynthesis outside feedback loop.\nEnabling this will place the granular resynthesis\nafter the feedback routine, not putting granulated\naudio into the feedback loop.\n");
    grain > 0 ? (
      grain = grainToggle2.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? 2 : 1;
    );
    
    grainToggle.drawToggle(cX-.85*knobSpacing, y_start, buttonSize-2, buttonSize-2, grain > 0, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Granular synthesis.\n\nEnable granular resampling.");
    tmp = grainToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    tmp > 0 && grain == 0 ? ( grain = 1; );
    tmp == 0 && grain > 0 ? ( grain = 0; );
    
    cX += .05 * knobSpacing;
    
    lengthKnob.active = grain;
    lengthKnob.value = (grainLength-40)/260;
    lengthKnob.y_font_offset = y_font_offset;
    lengthKnob.drawKnob(cX, cY-y_spacing, smallknobsize, "Length", "Grain length\n\nControls how long each grain sample is.", 0);
    lengthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? grainLength = lengthKnob.value*260+40;
      
    overlapKnob.active = grain;
    overlapKnob.value = grainOverlap;
    overlapKnob.y_font_offset = y_font_offset;
    overlapKnob.drawKnob(cX, cY+y_spacing, smallknobsize, "Overlap", "Grain overlap\n\nControls how much the grains overlap.\nIncrease it for a denser sound (note\nthat this increases CPU).\n", 0);
    overlapKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.75) ? grainOverlap = overlapKnob.value;
      
    cX += 2.1*knobSpacing;
    
    jitterKnob.active = grain;
    jitterKnob.value = grainJitter/10;
    jitterKnob.y_font_offset = y_font_offset;
    jitterKnob.drawKnob(cX, cY-y_spacing, smallknobsize, "Jitter", "Position jitter.\n\nControls how spread out the\ngrains are taken from the\ndelay buffer. Longer creates\nmore complex sounds.", 0);
    jitterKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.3) ? grainJitter = jitterKnob.value*10;
      
    panSpreadKnob.active = grain;
    panSpreadKnob.value = grainPanSpread;
    panSpreadKnob.y_font_offset = y_font_offset;
    panSpreadKnob.drawKnob(cX, cY+y_spacing, smallknobsize, "Spread", "Spread\n\nControls pan randomization.\nIncrease for more width.", 0);
    panSpreadKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? grainPanSpread = panSpreadKnob.value;
      
    cX += 2.1*knobSpacing;
    speedKnob.active = grain;
    speedKnob.value = ((log(grainSpeed)/log(2))+2)*.25;
    sprintf(5, "%.3g", grainSpeed);
    speedKnob.label = 5;
    speedKnob.y_font_offset = y_font_offset;
    speedKnob.drawKnob(cX, cY-y_spacing, smallknobsize, "Pitch", "Pitch\n\nControl grain pitch.", 0);
    speedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? grainSpeed = 2^(4*speedKnob.value-2);

    detuneKnob.active = grain;
    detuneKnob.value = grainSpeedSpread*4;
    detuneKnob.y_font_offset = y_font_offset;
    detuneKnob.drawKnob(cX, cY+y_spacing, smallknobsize, "Detune", "Detune\n\nControls relative tuning of the grains.", 0);
    detuneKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? grainSpeedSpread = detuneKnob.value*.25;
    cX += 2.1*knobSpacing;
    
    sizeVarKnob.active = grain;
    sizeVarKnob.value = grainSizeVar;
    sizeVarKnob.y_font_offset = y_font_offset;
    sizeVarKnob.drawKnob(cX, cY-y_spacing, smallknobsize, "Size Var", "Size variability..", 0);
    sizeVarKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.0) ? grainSizeVar = sizeVarKnob.value;
    
    reverseKnob.active = grain;
    reverseKnob.value = grainReverse;
    reverseKnob.y_font_offset = y_font_offset;
    reverseKnob.drawKnob(cX, cY+y_spacing, smallknobsize, "Reverse", "Reverse probability\n\nProbability that grain plays in reverse.", 0);
    reverseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.0) ? grainReverse = reverseKnob.value;
    cX += 3*knobSpacing;
  );

function processShapers(cX, cY)
  instance(rectify, saturationGain, warmth,
           shaperSelect, ceilingKnob, warmthKnob)
  local(x_start, y_start)
  global(nShapers, mouse_x, mouse_y, mouse_cap, scaling, knobSize, knobSpacing, BAND_FONT, combobox_open,
         edge_r, edge_g, edge_b, edge_a, panelY, panelPad, panelHeight)
(
  /* Combobox to select shaper */
  x_start = cX - 1.75*knobSpacing;
  y_start = panelY;
 
  drawPanel("FX", x_start, y_start - panelPad, 4.75*knobSpacing, panelHeight);
   
  shaperSelect.combobox(x_start + panelPad, y_start, 4.75*knobSpacing - 1.75 * panelPad, 25*(1+scaling), .4, .4, .8, 1, nShapers, 1, 1, 1, BAND_FONT, "Waveshaper selection." );
  shaperSelect.combobox_setcuritem(rectify);
  shaperSelect.combobox_draw();  
  shaperSelect.combobox_draw_top();
  shaperSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    rectify = shaperSelect.curitem;
  );
  
  ceilingKnob.active = rectify > 0;
  ceilingKnob.value = saturationGain/36;
  ceilingKnob.drawKnob(cX-.4*knobSize, cY+.47*knobSize, .5*knobSize, "Strength", "Strength\n\nControls the saturation level of the saturator.", 0);
  ceilingKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? saturationGain = ceilingKnob.value*36;
  
  warmthKnob.active = rectify > 0;
  warmthKnob.value = warmth;
  warmthKnob.drawKnob(cX+1.2*knobSize, cY+.47*knobSize, .5*knobSize, "Warmth", "Warmth\n\nAdds warmth to the saturation by\nde-emphasizing bass before saturation\nand re-emphasizing it after.", 0);
  warmthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? warmth = warmthKnob.value;
  
  cX += 6.25*knobSpacing
);

function processLFO(cX, cY)
  instance(lfoDepth, lfoFrequency, lfo,
           lfoDepthKnob, lfoFrequencyKnob, lfoSelect)
  local(nLFOs, x_start, y_start, x_width, y_height)
  global(mouse_x, mouse_y, mouse_cap, scaling, knobSize, knobSpacing, BAND_FONT, combobox_open,
         edge_r, edge_g, edge_b, edge_a, panelY, panelPad, panelHeight)
(
  /* Combobox to select shaper */
  nLFOs = 2;
  
  x_start = cX - 2*(1+scaling);
  y_start = panelY;
  x_width = 4.6*knobSpacing;
  y_height = 82*(1+scaling);
  
  drawPanel("LFO", x_start - panelPad, y_start - panelPad, x_width + panelPad, panelHeight);
  
  lfoSelect.combobox(x_start, y_start, x_width - panelPad, 25*(1+scaling), .4, .4, .8, 1, nLFOs, 4, 1, 1, BAND_FONT, "LFO selection." );
  lfoSelect.combobox_setcuritem(lfo);
  lfoSelect.combobox_draw();  
  lfoSelect.combobox_draw_top();
  lfoSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    lfo = lfoSelect.curitem;
  );
  
  lfoDepthKnob.active = lfo > 0;
  lfoDepthKnob.value = lfoDepth * .25;
  lfoDepthKnob.drawKnob(cX+.6*knobSize, cY+.47*knobSize, .5*knobSize, "Depth", "Depth of the LFO.", 0);
  lfoDepthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? lfoDepth = 4 * lfoDepthKnob.value;
  
  lfoFrequencyKnob.active = lfo > 0;
  lfoFrequencyKnob.value = lfoFrequency * .2;
  lfoFrequencyKnob.drawKnob(cX+2.2*knobSize, cY+.47*knobSize, .5*knobSize, "Freq", "Frequency\n\nFrequency of the LFO..", 0);
  lfoFrequencyKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? lfoFrequency = 5.0 * lfoFrequencyKnob.value;
  
  cX += 7*knobSpacing
);

function processSettings(cX, cY)
  local(x_start, y_start, width)
  global(edge_r, edge_g, edge_b, edge_a,
         buttonSize, knobSpacing, scaling, BAND_FONT,
         mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y,
         dc_correction, sendSaturation,
         widget_r, widget_g, widget_b, widget_a,
         toggle_r, toggle_g, toggle_b, toggle_a,
         knob_font_color_r, knob_font_color_g, knob_font_color_b, knob_font_color_a,
         panelY, panelPad, panelHeight, compensate_pdc, freeNodes)
  instance(dcCorrectionToggle, sendSaturationToggle, pdcToggle, clampToggle)
  (
    gfx_set(edge_r, edge_g, edge_b, edge_a);
    x_start = cX - 2*(1+scaling);
    y_start = panelY;
    width = 112 * (1+scaling);
    
    drawPanel("SETTINGS", x_start - panelPad, y_start - panelPad, width + panelPad, panelHeight);

    dcCorrectionToggle.label = "DC Correction";
    dcCorrectionToggle.drawToggle(cX+1.9*(1+scaling), cy - 1.2*knobSpacing, buttonSize, buttonSize, dc_correction, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Correct DC of incoming signal.\n\nDisable when not needed as it costs CPU.");
    dc_correction = dcCorrectionToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    sendSaturationToggle.label = "Saturate sends";
    sendSaturationToggle.drawToggle(cX+1.9*(1+scaling), cy - 1.2*buttonSize, buttonSize, buttonSize, sendSaturation, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Send saturation.\n\nWhen enabled, this toggle adds a saturator on the sum of\nnode inputs coming from other nodes. This can help stabilize\nsend cycles and/or can be used to add some character.\n\nDisable when not needed as it costs CPU.");
    sendSaturation = sendSaturationToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
    pdcToggle.label = "Pitch PDC";
    pdcToggle.drawToggle(cX+1.9*(1+scaling), cy + 1.9*buttonSize, buttonSize, buttonSize, compensate_pdc, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Pitch delay compensation.\n\nWhen enabled, the plugin reports an\napproximate pdc for the global pitch\nshifting.");
    compensate_pdc = pdcToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    clampToggle.label = "Free nodes";
    clampToggle.drawToggle(cX+1.9*(1+scaling), cy + 5.2*buttonSize, buttonSize, buttonSize, freeNodes, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "When enabled, nodes are no longer clamped to the\nvisible X-range, meaning they can be offscreen\nand require a different timing view to see.");
    freeNodes = clampToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    /*sendSaturationToggle.drawToggle(cX+1.9*(1+scaling), cy + knobSpacing + buttonSize, buttonSize, buttonSize, sendSaturation, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Send saturation.\n\nWhen enabled, this toggle adds a saturator on the sum of\nnode inputs coming from other nodes. This can help stabilize\nsend cycles and/or can be used to add some character.");
    gfx_x = cX + 2*buttonSize + 1;
    gfx_y = cY - 4*(1+scaling) - 1 + knobSpacing + buttonSize;
    gfx_set(knob_font_color_r, knob_font_color_g, knob_font_color_b, knob_font_color_a);
    gfx_printf("Saturate sends");
    sendSaturation = sendSaturationToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);*/
    
    cX + width + panelPad;
  );

function processTiming(cX, cY)
local(x_start, y_start, nModes, nDensity, width)
global(buttonSize, knobSpacing, scaling, BAND_FONT, syncMode, mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y, Snap, gridDensity,
       widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a,
       knob_font_color_r, knob_font_color_g, knob_font_color_b, knob_font_color_a, KNOB_FONT,
       edge_r, edge_g, edge_b, edge_a, panelY, panelHeight, panelPad)
instance(snap_select, grid_density_select, snap_toggle)
(
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  x_start = cX;
  y_start = panelY;
  width = 98 * (1+scaling);
  
  drawPanel("TIMING", x_start - panelPad, y_start - panelPad, width + panelPad, panelHeight);
  
  nModes = 7;
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  snap_select.combobox(x_start, y_start, width-5*(1+scaling), 25*(1+scaling), .4, .4, .8, 1, nModes, 2, 1, 1, BAND_FONT, "Timing mode\n\nDelays can either be set\non a logarithmic scale\nor a linear rhythmic scale." );
  snap_select.combobox_setcuritem(SyncMode);
  snap_select.combobox_draw();  
  snap_select.combobox_draw_top();
  snap_select.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? SyncMode = snap_select.curitem;
  
  y_start += 1.3*knobSpacing;
  nDensity = 3;
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  grid_density_select.combobox(x_start, y_start, width-5*(1+scaling), 25*(1+scaling), .4, .4, .8, 1, nDensity, 3, 1, 1, BAND_FONT, "Set grid density." );
  grid_density_select.combobox_setcuritem(gridDensity);
  grid_density_select.combobox_draw();  
  grid_density_select.combobox_draw_top();
  grid_density_select.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? gridDensity = grid_density_select.curitem;
  
  cY += 1.2*knobSpacing;
  snap_toggle.label = "Snap to grid";
  snap_toggle.drawToggle(cX+1.9*(1+scaling), cy+4*(1+scaling), buttonSize, buttonSize, Snap, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Snap to grid.");
  Snap = snap_toggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX + width + 2 * knobSpacing * (1+scaling);
);

function processDucking(cX, cY)
local(x_start, y_start, nModes, nDensity, width, height, y_font_offset, vu_start, smallknobsize, smallknobspacing, pad, 
      steps, floorLevel, xc, yc, N, idx)
global(buttonSize, knobSpacing, scaling, BAND_FONT, syncMode, mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y,
       widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a,
       knob_font_color_r, knob_font_color_g, knob_font_color_b, knob_font_color_a, KNOB_FONT,
       label_r, label_g, label_b,
       edge_r, edge_g, edge_b, edge_a, y_spacing, knobSize,
       duckingActive, duckingAttack, duckingRelease, duckingThreshold, duckingRatio, duckingKnee, render_time
       ducker.attack, ducker.release, ducker.ratio, ducker.c,
       panelY, panelPad, panelHeight)
instance(attackKnob, releaseKnob, thresholdKnob, ratioKnob, duckingToggle)
(
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  x_start = cX - 2*(1+scaling);
  y_start = panelY;
  width = 200*(1+scaling);
  height = 82*(1+scaling);
//  y_spacing = .95 * knobSpacing;
  smallknobsize = .7*knobSize;
  smallknobspacing = .57*knobSpacing;
  y_font_offset = 2 * (1+scaling);
  y_spacing = .95 * knobSpacing;
  y_font_offset = 2 * (1+scaling);
  pad = 6*(1+scaling);
  
  drawPanel("DUCKING", x_start - panelPad, y_start - panelPad, width + panelPad, panelHeight);

  duckingToggle.drawToggle(cX - .15*smallknobsize, y_start, buttonSize-2, buttonSize-2, duckingActive, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Ducking.\n\nEnable sidechain compression\non the delays. This helps\nfree up space when playing\nmelodies, allowing the delay\nto breathe only when you're\nnot playing.");
  duckingActive = duckingToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

  cY -= .8 * smallknobspacing;
  cX += 1.85 * smallknobspacing;
  thresholdKnob.active = duckingActive > 0;
  thresholdKnob.value = 1 + duckingThreshold / 40;
  thresholdKnob.y_font_offset = y_font_offset;
  thresholdKnob.label = sprintf(100, "%.1f", (thresholdKnob.value - 1.0) * 40);
  thresholdKnob.drawKnob(cX, cY, smallknobsize, "Thr. [dB]", "Threshold\n\nSets compressor threshold.", 0);
  thresholdKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? duckingThreshold = (thresholdKnob.value - 1.0) * 40;
  cX += 4 * smallknobspacing;

  ratioKnob.active = duckingActive > 0;
  ratioKnob.value = duckingRatio * 0.5;
  ratioKnob.y_font_offset = y_font_offset;  
  ratioKnob.label = sprintf(100, "1:%d", ducker.ratio);
  ratioKnob.drawKnob(cX, cY, smallknobsize, "Ratio [-]", "Ratio\n\nCompression ratio.", 0);
  ratioKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? duckingRatio = 2 * ratioKnob.value;
  
  cX += 4 * smallknobspacing;
  attackKnob.active = duckingActive > 0;
  attackKnob.value = duckingAttack;
  attackKnob.y_font_offset = y_font_offset;  
  attackKnob.label = sprintf(100, "%.1f", ducker.attack);
  attackKnob.drawKnob(cX, cY, smallknobsize, "Atk. [ms]", "Attack\n\nCompressor attack.", 0);
  attackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? duckingAttack = attackKnob.value;
  
  cX += 4 * smallknobspacing;
  releaseKnob.active = duckingActive > 0;
  releaseKnob.value = duckingRelease;
  releaseKnob.y_font_offset = y_font_offset;
  releaseKnob.label = sprintf(100, "%.1f", ducker.release);
  releaseKnob.drawKnob(cX, cY, smallknobsize, "Rel. [ms]", "Release\n\nCompressor release.", 0);
  releaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? duckingRelease = releaseKnob.value;
  
  cX += 4 * smallknobspacing;
  
  vu_start = y_start + .77 * height;
  xc = x_start + width - pad;
  yc = vu_start;
  gfx_set(label_r, label_g, label_b, edge_a * .4 + .6*duckingActive);
  gfx_line(x_start, yc-1, x_start + width - pad, yc-1 );
  floorLevel = 40;
  steps = floor( (width-pad) * (-ducker.c/floorLevel) / 2 );

  duckingActive > 0 ? (
    gfx_set(1, 0, .5, .8 + .1 * sin(5*render_time));
    loop(steps,
      gfx_line(xc, yc, xc, yc + 4);
      xc -= 2;
    );
  );  
  
  yc += 5 * (1+scaling);
  gfx_set(label_r, label_g, label_b, edge_a * .4 + .6*duckingActive);
  gfx_line(x_start, yc, x_start + width - pad, yc );
  N = 6; idx = 0;
  xc = x_start + width - pad;
  steps = (width-pad) / N;
  loop(N + 1,
    gfx_line(xc, yc, xc, yc + 4);
    gfx_x = xc;
    gfx_y = yc;
    idx > 0 ? gfx_printf(" -%d", idx * floorLevel / N);
     xc -= steps;
    idx += 1;
  );
    
  cX = x_start + width + 2 * knobSpacing;
);

knobSize = 30*(1+scaling);
knobSpacing = 21*(1+scaling);

buttonSize = floor(.3 * knobSpacing);
widget_r = .3;
widget_g = .1;
widget_b = .3;
widget_a = 1.0;
toggle_r = .7;
toggle_g = .2;
toggle_b = .6;
toggle_a = 1.0;

cY = gfx_h - control_offset;
panelY = cY - 32 * (1+scaling);
panelPad = 6;
panelHeight = 88 * (1+scaling);
cX = 90*(1+scaling);

gfx_x = 0;
gfx_y = 100;
selectedNode = 0;
(nSelected < 2) && (multiSelect == 0) ? (
  node1.selected || (nSelected == 0 && node1.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 1; cX = node1.processRegularCtrls(cX, cY); cX = node1.processShapers(cX, cY); cX = node1.processGrainCtrls(cX, cY); cX = node1.processLFO(cX, cY); ) :
  node2.selected || (nSelected == 0 && node2.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 2; cX = node2.processRegularCtrls(cX, cY); cX = node2.processShapers(cX, cY); cX = node2.processGrainCtrls(cX, cY); cX = node2.processLFO(cX, cY); ) :
  node3.selected || (nSelected == 0 && node3.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 3; cX = node3.processRegularCtrls(cX, cY); cX = node3.processShapers(cX, cY); cX = node3.processGrainCtrls(cX, cY); cX = node3.processLFO(cX, cY); ) :
  node4.selected || (nSelected == 0 && node4.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 4; cX = node4.processRegularCtrls(cX, cY); cX = node4.processShapers(cX, cY); cX = node4.processGrainCtrls(cX, cY); cX = node4.processLFO(cX, cY); ) :
  node5.selected || (nSelected == 0 && node5.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 5; cX = node5.processRegularCtrls(cX, cY); cX = node5.processShapers(cX, cY); cX = node5.processGrainCtrls(cX, cY); cX = node5.processLFO(cX, cY); ) :
  node6.selected || (nSelected == 0 && node6.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 6; cX = node6.processRegularCtrls(cX, cY); cX = node6.processShapers(cX, cY); cX = node6.processGrainCtrls(cX, cY); cX = node6.processLFO(cX, cY); ) :
  node7.selected || (nSelected == 0 && node7.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 7; cX = node7.processRegularCtrls(cX, cY); cX = node7.processShapers(cX, cY); cX = node7.processGrainCtrls(cX, cY); cX = node7.processLFO(cX, cY); ) :
  node8.selected || (nSelected == 0 && node8.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 8; cX = node8.processRegularCtrls(cX, cY); cX = node8.processShapers(cX, cY); cX = node8.processGrainCtrls(cX, cY); cX = node8.processLFO(cX, cY); ) :
  node9.selected || (nSelected == 0 && node9.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 9; cX = node9.processRegularCtrls(cX, cY); cX = node9.processShapers(cX, cY); cX = node9.processGrainCtrls(cX, cY); cX = node9.processLFO(cX, cY); ) :
  node10.selected || (nSelected == 0 && node10.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 10; cX = node10.processRegularCtrls(cX, cY); cX = node10.processShapers(cX, cY); cX = node10.processGrainCtrls(cX, cY); cX = node10.processLFO(cX, cY); );
  node11.selected || (nSelected == 0 && node11.mouse_over(mouse_x, mouse_y, w1x, w1y, w1w, w1h)) ? ( selectedNode = 11; cX = node11.processVerbCtrls(cX, cY); cX = node11.processShapers(cX, cY); );
);



(selectedNode > 0) ? (
  // Band indicator
  sprintf(16, "NODE %d", selectedNode);
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  gfx_rect(8, panelY - panelPad, 16 * (1+scaling), panelHeight);
  vLabel.drawVertLabel(8,  panelY - panelPad, 16, panelHeight, BAND_FONT, 3, font_color_r, font_color_g, font_color_b, .7, 0);
) : (
  // Band indicator
  sprintf(16, "GLOBAL", selectedNode);
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  gfx_rect(8, panelY - panelPad, 16 * (1+scaling), panelHeight);
  vLabel.drawVertLabel(8,  panelY - panelPad, 16, panelHeight, BAND_FONT, 3, font_color_r, font_color_g, font_color_b, .7, 0);
  gainKnob.active = 1;
  gainKnob.value = (WetGain+32)/64;
  gain_string = 100;
  gainKnob.label = sprintf(gain_string, "%.1f dB", WetGain);
  gainKnob.drawKnob(cX, cY, knobSize, "Gain", "Gain\n\nOverall output gain.", 0);
  gainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    WetGain = gainKnob.value*64-32;
    slider_automate(WetGain);
  );
  drawPanel("BALANCE", cX - 1.75*knobSpacing, panelY - panelPad, 17.5*knobSpacing, panelHeight);
  
  cX += 3.5*knobSpacing;
  drywetKnob.active = 1;
  drywetKnob.value = drywet;
  drywetKnob.label = sprintf(gain_string, "%d", 100*drywet);
  drywetKnob.drawKnob(cX, cY, knobSize, "Dry/Wet", "Dry/Wet.", 0);
  drywetKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    drywet = drywetKnob.value;
    slider_automate(drywet);
  );
  
  cX += 3.5*knobSpacing;
  globalFeedbackKnob.active = 1;
  globalFeedbackKnob.value = 1.0 - globalFeedbackAttn;
  globalFeedbackKnob.label = sprintf(gain_string, "%.1f dB", -36 * globalFeedbackAttn);
  globalFeedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Global Feedback\n\nThis slider can be used to\nattenuate all feedbacks at\na global level.", 0);
  globalFeedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1.0) ? ( 
    globalFeedbackAttn = 1.0 - globalFeedbackKnob.value;
    updateGlobalFeedback();
  );
  
  cX += 3.5*knobSpacing;
  glideTimeKnob.active = 1;
  glideTimeKnob.value = note_response_time / 200;
  glideTimeKnob.label = sprintf(gain_string, "%d ms", note_response_time + 1);
  glideTimeKnob.drawKnob(cX, cY, knobSize, "Glide time", "Glide time (only used for MIDI note-dependent delays).", 0);
  glideTimeKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1.0) ? ( 
    note_response_time = 200 * glideTimeKnob.value;
  );
  
  cX += 3.5*knobSpacing;
  pitchToggle.drawToggle(cX-1.5*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pitch > 0, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Toggle pitch shifting.");
  tmp = pitchToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  pitchKnob.active = pitch;
  pitchKnob.value = shift_pitch*0.5 + 0.5;
  tmp > 0 && pitch == 0 ? ( pitch = 1; );
  tmp == 0 && pitch > 0 ? ( pitch = 0; );
  
  pitchToggle2.active = pitch > 0;
  pitchToggle2.drawToggle(cX+1.25*knobSpacing, cy-1.5*knobSpacing, buttonSize, buttonSize, pitch > 1, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Place pitch shifter after feedback.");
  pitch > 0 ? (
    pitch = pitchToggle2.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? 2 : 1;
  );
  
  pitchKnob.label = sprintf(gain_string, "%.2f st", 12*shift_pitch);
  pitchKnob.label = gain_string;
  pitchKnob.drawKnob(cX, cY, knobSize, "Pitch", "Pitch shift.", 0);
  pitchKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    shift_pitch = 2 * pitchKnob.value - 1.0;
    mouse_cap & 2 > 0 ? (
      shift_pitch = floor(12 * shift_pitch + .5)/12;
    );
  );

  cX += 5*knobSpacing;
  
  drawPanel("FILTERS", cX - 1.75*knobSpacing, panelY - panelPad, 10.5*knobSpacing, panelHeight);
  hpKnob.active = 1;
  hpKnob.value = HP;
  gain_string = 100;
  tmp = f_trafo_hz(HP);
  tmp < 1000 ? (
    HP == 0 ? (
      hpKnob.label = sprintf(gain_string, "OFF", tmp);
    ) : (
      hpKnob.label = sprintf(gain_string, "%d Hz", tmp);
    );
  ) : (
    hpKnob.label = sprintf(gain_string, "%d kHz", tmp/1000);
  );
  hpKnob.drawKnob(cX, cY, knobSize, "High pass", "Global high pass filter frequency.", 0);
  hpKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    HP = hpKnob.value;
    slider_automate(HP);
  );

  cX += 3.5*knobSpacing;
  lpKnob.active = 1;
  lpKnob.value = LP;
  gain_string = 100;
  tmp = f_trafo_hz(LP);
  tmp < 1000 ? (
    lpKnob.label = sprintf(gain_string, "%d Hz", tmp);
  ) : (
    (LP < 1.0 || LPRES > 0.0) ? (
      lpKnob.label = sprintf(gain_string, "%d kHz", tmp/1000);
    ) : (
      lpKnob.label = sprintf(gain_string, "OFF");
    );
  );  
  lpKnob.drawKnob(cX, cY, knobSize, "Low pass", "Global low pass filter frequency.", 0);
  lpKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    LP = lpKnob.value;
    slider_automate(LP);
  );
  
  cX += 3.5*knobSpacing;
  resonanceKnob.active = 1;
  resonanceKnob.value = LPRES;
  resonanceKnob.label = sprintf(gain_string, "%.2f", LPRES);
  resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Resonance.\n\nResonance control for LPF.", 0);
  resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    LPRES = resonanceKnob.value;
    slider_automate(LPRES);
  );
  
  cX += 3.5 * knobSpacing;
  cX = processTiming(cX, cY);
  cX = processDucking(cX, cY);
  cX = processSettings(cX, cY);
  
  randomizeButton.drawButton( cX + knobSpacing, cY, 3 * knobSpacing, knobSpacing, "Randomize", KNOB_FONT, 1 );
  randomizeButton.button_processMouse(mouse_x, mouse_y, mouse_cap) ? randomize();
);

updateToSliderAll();
hideHints == 0 ? (
  hinter.drawHint_draw();
);

/* Draw logo */
loaded = 0;
!loaded || (modVisible != lastModVisible) ? (
  ( modVisible == 0 ) ? (
    loaded = gfx_loadimg(5, "./Reflectosaurus_Dependencies/reflecto_logo.png");
  );
  lastModVisible = modVisible;
);
gfx_x = -4 * (1+scaling);
gfx_y = -12 * (1+scaling);

recSpeed = .3+.5*rand();
lsMod = lsMod * (1-recSpeed) + lightState * recSpeed;
gfx_a = .2 + .8*lsMod * (.96+.04*sin(314*render_time));
rand() > lightProb ? (
  lightState = 1-lightState;
);
lightState ? (
  lightProb = lightProb + .1;
  lightProb > .99 ? lightProb = .99;
) : (
  lightProb = .5;
);

gfx_blit(5, (1+scaling), 0);
gfx_mode=1;
gfx_a = .5*gfx_a;
gfx_blit(5, (1+scaling), 0);
gfx_mode=0;


tried_to_make_more_nodes_than_available > .001 ? (
  tried_to_make_more_nodes_than_available *= .95;
  gfx_set(1, 1, 1, tried_to_make_more_nodes_than_available);
  gfx_setfont(5, "Arial", 20);
  gfx_x = gfx_w * .015;
  gfx_y = gfx_h * .05;
  gfx_printf("WARNING: You can only make 10 regular nodes!");
);

mouse_cap == 0 && lcap & 1 > 0 ? (
  ((mouse_x < (185 * (1+scaling))) && (mouse_y < (30 * (1+scaling)))) ? (
    colorscheme = 1 - colorscheme;
  );
);
lcap = mouse_cap;
