desc:Saike Spectral Analyzer (beta)
tags: analysis FFT meter spectrum
version: 5.0.4
author: Joep Vanlier, Trond-Viggo Melssen, Cockos, Feed The Cat
changelog: Swap signal y1 and y2 in diff mode
provides: colormaps.jsfx-inc
Copyright (C) 2007 Cockos Incorporated
Copyright (C) 2018 Joep Vanlier, Trond-Viggo Melssen
License: LGPL - http://www.gnu.org/licensses/lgpl.html

This file was modified by Joep Vanlier and Trond-Viggo Melssen to enable multispectrum analysis analysis, sonogram and time domain plots. Thanks to cjewellstudios for the smooth colormap.

options:maxmem=9000000

import colormaps.jsfx-inc

slider1:9<0,9,1{16,32,64,128,256,512,1024,2048,4096,8192,16384,32768}>-FFT size
slider2:-90<-450,-12,6>-floor
slider3:0<0,1,1{disabled,enabled}>-show phase
slider4:2<0,4,1{rectangular,hamming,blackman-harris,blackman,flat-top}>-window
slider5:200<0,2500,1>-integration time (ms)
slider6:1<1,6,.2>-scaling
slider7:smoothing=20<0,100,1>-smoothing
slider8:1<0,14,1{dark,intense,fluo,colorblind,pimp,shades,fancy,pastel,purple,dark2,dark3,dark4,dark5,colorblind2,smooth}>-colormap
slider9:16<1,16,1>-mxchannels
slider10:.15<0,1,.4>-colorBackground

slider11:1<0,1,1>-Ch1
slider12:1<0,1,1>-Ch2
slider13:1<0,1,1>-Ch3
slider14:1<0,1,1>-Ch4
slider15:1<0,1,1>-Ch5
slider16:1<0,1,1>-Ch6
slider17:1<0,1,1>-Ch7
slider18:1<0,1,1>-Ch8
slider19:1<0,1,1>-Ch9
slider20:1<0,1,1>-Ch10
slider21:1<0,1,1>-Ch11
slider22:1<0,1,1>-Ch12
slider23:1<0,1,1>-Ch13
slider24:1<0,1,1>-Ch14
slider25:1<0,1,1>-Ch15
slider26:1<0,1,1>-Ch16
slider27:1<0,1,1>-Sum
slider28:-1<-1,1,16>-Channel
slider29:0<1,0,2{Sample,Sonogram,Off}>-Sonogram
slider30:5000<10,45000,100>-SonoScale
slider31:.5<0.1,3,.03>-SignalScale
slider32:6<0,7,1{viridis,viridisinv,magma,magmainv,inferno,infernoinv,plasma,plasmainv}>-colormap2
slider33:1<1,0,1{Logarithmic,Linear}>-Sonolog
slider34:0<0,0,1{Yes,No}>-SonoBig
slider35:1<1,8,1>-Factor
slider36:-1<-1,1,16>-Solo channel
slider37:.15<0,1,.4>-Alpha
slider38:0<0,9,.25>-slope

slider39:1<0,1,1{disabled,enabled}>-show grid
slider40:.15<0,1,.4>-gridAlpha
slider41:0<0,1,1{disabled,enabled}>-show channels
slider42:0<0,1,1{disabled,enabled}>-show options
slider43:0<0,1,1{disabled,enabled}>-show theme
slider44:0<0,1,1{disabled,enabled}>-freeze spectrum
slider45:4<0,4,1{Average,Maximum,Loess,Adaptive,Fast}>-Smoothing method

slider46:Dummy=0<0,1,1>-Dummy
slider47:Dummy=0<0,1,1>-Dummy
slider48:Dummy=0<0,1,1>-Dummy
slider49:Dummy=0<0,1,1>-Dummy

slider50:0<0,1,0>-Initialized
slider51:LatencyCompensation=0<0,1,0>-Latency Compensation
slider52:Dummy=0<0,1,1>-Dummy
slider53:showA=0<0,1,1>-Show A
slider54:showB=0<0,1,1>-Show B
slider55:maxIntegrate=0<0,1,0>-Integration mode
slider56:showSide=0<0,1,0>-Show side channel
slider57:noRenderBuffer=0<0,1,1>-Offscreen buffer
slider58:dummy=0<0,1,1>-Dummy
slider59:dummy=0<0,1,1>-Dummy
slider60:displayMode=0<0,1,1>-Display mode
slider61:scale_offset_db_user=0<-48,48,1>-Scale offset
//in_pin:left input 
//in_pin:right input
options:no_meter
options:gmem=saike_spectrum_analyzer

@init
copyTo    = 0;
magma     = 2000;
viridis   = 4000;
inferno   = 6000;
plasma    = 8000;
!sono_frac ? sono_frac = .35;

freeze = 0;

function setChannelNames()
(
  chName = 1;
  while (chName <= 16) (
    chName < 10 ? (
      chNames[chName-1] = sprintf(chName-1, "Ch %{chName}i");
    ) : (
      chNames[chName-1] = sprintf(chName-1, "Ch%{chName}i");
    );
    chName = chName + 1;
  );
);
!trCnt ? setChannelNames();

function updateChannelSliders()
global(slider11, slider12, slider13, slider14, slider15, 
       slider16, slider17, slider18, slider19, slider20, 
       slider21, slider22, slider23, slider24, slider25, 
       slider26, slider27, actc, activechannels, maxchannels,
       showSum)
local(mx)
(
  // For some reason this isn't being called in @slider
  actc = activechannels;
  mx = 0;
  actc[] = slider11 ? (mx=1; 1);
  actc[1] = slider12 ? (mx=2; 1);
  actc[2] = slider13 ? (mx=3; 1);
  actc[3] = slider14 ? (mx=4; 1);
  actc[4] = slider15 ? (mx=5; 1);
  actc[5] = slider16 ? (mx=6; 1);
  actc[6] = slider17 ? (mx=7; 1);
  actc[7] = slider18 ? (mx=8; 1);
  actc[8] = slider19 ? (mx=9; 1);
  actc[9] = slider20 ? (mx=10; 1);
  actc[10] = slider21 ? (mx=11; 1);
  actc[11] = slider22 ? (mx=12; 1);
  actc[12] = slider23 ? (mx=13; 1);
  actc[13] = slider24 ? (mx=14; 1);
  actc[14] = slider25 ? (mx=15; 1);
  actc[15] = slider26 ? (mx=16; 1);

  maxchannels = mx;
  showSum = slider27;
);

function initCh()
global(slider11, slider12, slider13, slider14, slider15,
       slider16, slider17, slider18, slider19, slider20,
       slider21, slider22, slider23, slider24, slider25, 
       slider26, slider50, num_ch)
local(i1)
(
  slider50 == 0 ? (
    slider11 = slider12 = slider13 = slider14 = slider15 = slider16 = slider17 = slider18 = slider19 = slider20 = slider21 = slider22 = slider23 = slider24 = slider25 = slider26 = 0;
  
    i1 = 11;
    loop(num_ch*.5,
      slider(i1) = 1;
      i1 = i1 + 1;
    );
    
    updateChannelSliders();
    slider50 = 1;
  )
);

function printColorMapName(cmapidx, inv)
(
  ( cmapidx == 1 && inv == 0 ) ? gfx_printf( "Magma" ) : (
  ( cmapidx == 1 && inv == 1 ) ? gfx_printf( "Magma inv" ) : (
  ( cmapidx == 2 && inv == 0 ) ? gfx_printf( "Viridis" ) : (
  ( cmapidx == 2 && inv == 1 ) ? gfx_printf( "Viridis inv" ) : (
  ( cmapidx == 3 && inv == 0 ) ? gfx_printf( "Inferno" ) : (
  ( cmapidx == 3 && inv == 1 ) ? gfx_printf( "Inferno inv" ) : (
  ( cmapidx == 4 && inv == 0 ) ? gfx_printf( "Plasma" ) : (
  ( cmapidx == 4 && inv == 1 ) ? gfx_printf( "Plasma inv" ) : (
    gfx_printf("Unknown"); ))))))));
);

gfx_ext_retina  = 1.0;
ext_nodenorm    = 1; 
gfx_clear       = -1;
windowtype      = -1;
fftidx          = -1;
scaling         = 1;
max_fft_size    = 32768;
fftsize         = max_fft_size;
window          = max_fft_size + (max_fft_size*0.5 - 1);
histsize        = max_fft_size + (max_fft_size*0.5 - 1);

SONOSURFACE   = 4;
gfx_dest      = SONOSURFACE;
gfx_setimgdim(SONOSURFACE, 0.5*fftsize, 0.5*fftsize);
gfx_x=gfx_y   = 0;
gfx_r=gfx_g   = 0;
gfx_b         = 0;
gfx_a         = 1;
gfx_rectto(0.5*fftsize, 0.5*fftsize);
gfx_dest      = -1;

drawHz          = 0;
update = slider44 == 0;

function init_memory_mapping()
local(rpos, curshift, rpos, hsize, fftw, ibuf, csh)
global(recpositions, histsizes, fftworkspaces, integrate_bufs, shifts, activechannels, maxchannels, totchannels, offscreenbuf, spacing, M_BLOCK_SIZE, 
       window, max_fft_size, maxIntegrate, filtout, filtout2, sumshl, sumshr, sumposl, sumposr, fftwl, fftwr, ibufl, ibufr, sumhsl, sumhsr
       latencyBuffer, latencyBufferMax, latencyPtr, memA, memB, memA2, memB2)
(
  recpositions    = 100;
  histsizes       = 200;
  fftworkspaces   = 300;
  integrate_bufs  = 400;
  shifts          = 500;
  activechannels  = 600;
  maxchannels     = 16;
  totchannels     = 16;
  offscreenbuf    = 1;
  spacing         = 3; // Used to be 3
  M_BLOCK_SIZE    = 65536;
  
  curshift  = M_BLOCK_SIZE;
  rpos      = recpositions;
  hsize     = histsizes;
  fftw      = fftworkspaces; 
  ibuf      = integrate_bufs;
  csh       = shifts;
  
  loop(totchannels*2,
    rpos[]  = curshift;
    hsize[] = curshift + window;
    fftw[]  = curshift + window + (max_fft_size*0.5 + 1);
    ibuf[]  = curshift + window + (max_fft_size*0.5 + 1) + max_fft_size*2;
    csh[]   = curshift;
    
    memset(fftw[],0,max_fft_size);
    memset(ibuf[],0-100*maxIntegrate,max_fft_size);
    memset(rpos[],0,max_fft_size);
    
    rpos  += 1;
    hsize += 1;
    fftw  += 1;
    ibuf  += 1;
    csh   += 1;
    
    curshift += spacing*M_BLOCK_SIZE;
  );
  
  // Memory for the filter on the spectrum
  filtout   = (curshift += spacing*M_BLOCK_SIZE);
  memset(filtout,0,max_fft_size);
  filtout2  = (curshift += spacing*M_BLOCK_SIZE);
  memset(filtout2,0,max_fft_size);
  
  // Memory for the sum signals
  sumshl  = (curshift += spacing*M_BLOCK_SIZE);
  sumposl = sumshl;
  fftwl   = sumshl + window + (max_fft_size*0.5 + 1);
  ibufl   = sumshl + window + (max_fft_size*0.5 + 1) + max_fft_size*2;
  sumhsl  = sumshl + window;
  
  sumshr  = (curshift += spacing*M_BLOCK_SIZE);
  sumposr = sumshr;
  fftwr   = sumshr + window + (max_fft_size*0.5 + 1);
  ibufr   = sumshr + window + (max_fft_size*0.5 + 1) + max_fft_size*2;
  sumhsr  = sumshr + window;
  
  memset(ibufl,0-100*maxIntegrate,max_fft_size);
  memset(ibufr,0-100*maxIntegrate,max_fft_size);
  
  // Buffer for delay compensation
  latencyBuffer  = (curshift += spacing*M_BLOCK_SIZE);
  latencyBufferMax = latencyBuffer + M_BLOCK_SIZE; // should be x64
  latencyPtr = latencyBuffer;
  memset(latencyBuffer, 0, latencyBufferMax - latencyBuffer);
  
  memA  = (curshift += spacing*M_BLOCK_SIZE);
  memB  = (curshift += spacing*M_BLOCK_SIZE);
  memA2 = (curshift += spacing*M_BLOCK_SIZE);
  memB2 = (curshift += spacing*M_BLOCK_SIZE);
);

memA == 0 ? init_memory_mapping();
updateChannelSliders();

@serialize
file_mem(0, memA, 65536);
file_mem(0, memB, 65536);
file_mem(0, memA2, 65536);
file_mem(0, memB2, 65536);
file_var(0, sModeA);
file_var(0, kernelSizeA);
file_var(0, fftSizeA);
file_var(0, xscaleA);
file_var(0, sModeB);
file_var(0, kernelSizeB);
file_var(0, fftSizeB);
file_var(0, xscaleB);

@slider
slider2 != lfloor ? old_w=0;
updateChannelSliders();

@block
displayMode != lastDisplayMode ? (
  lastDisplayMode = displayMode;
  init_memory_mapping();
);

slider2 != lfloor ? (
  lfloor = slider2;
  minvol=2*exp(log(10)/20*slider2);
);

@sample
updateSliders ? (
  updateSliders = 0;
  updateChannelSliders();
);

function update()
local(jch, active, recpos, hs, sh, sl, sr, iLoad)
global(activechannels, recpositions, histsizes, shifts, slider44, maxchannels, slider28, 
       showSide, sumposl, sumposr, sumhsl, sumshl, sumhsr, sumshr)
(
  iLoad     = 0;
  jch       = 0;
  active    = activechannels;
  recpos    = recpositions;
  hs        = histsizes;
  sh        = shifts;
  sl        = 0;
  sr        = 0;
  
  ( slider44 == 0 ) ?
  (
    loop(maxchannels,
      (active[] == 1 || (slider28==iLoad)) ? (
        recpos[][]=.5*(spl(jch)+spl(jch+1));
        recpos[] = ((recpos[]+1) >= hs[] ? sh[] : (recpos[]+1));
      );
  
      sl = sl+spl(jch);
      sr = sr+spl(jch+1);
      
      active += 1;
      recpos += 1; 
      hs     += 1;
      sh     += 1;
      jch    += 2;
      iLoad  += 1;
    );
    
    showSide ? (
      jch = 0;
      active = activechannels;
      iLoad = 0;
      loop(maxchannels,
        (active[] == 1 || (slider28==iLoad)) ? (
          recpos[][] = .5*(spl(jch)-spl(jch+1));
          recpos[] = ((recpos[]+1) >= hs[] ? sh[] : (recpos[]+1));
        );
        
        active += 1;
        recpos += 1;
        hs     += 1;
        sh     += 1;
        jch    += 2;
        iLoad  += 1;
      );
      
      sumposl[] = 0.5 * (sl + sr);
      sumposr[] = 0.5 * (sl - sr);
    ) : (
      sumposl[] = sl;
      sumposr[] = sr;
    );
    
    sumposl = ((sumposl+1) >= sumhsl ? sumshl : (sumposl+1));
    sumposr = ((sumposr+1) >= sumhsr ? sumshr : (sumposr+1));
  );
);
update();

latencyCompensation ? (
  j = 0;
  loop(num_ch,
    latencyPtr[] = spl(j);
    latencyPtr += 1;
    j += 1;
  );
  ( latencyPtr > latencyBufferMax ) ? latencyPtr -= (latencyBufferMax - latencyBuffer);
  
  latencyRead = latencyPtr - num_ch * latencyLength;
  ( latencyRead <= latencyBuffer ) ? latencyRead += (latencyBufferMax - latencyBuffer);
  j = 0;
  loop(num_ch,
    spl(j) = latencyRead[];
    latencyRead += 1;
    j += 1;
  );
);

@gfx 900 600
scaling = slider6;
initCh();

gfx_ext_retina>1 ? gfx_setfont(1,"Arial",max(12,12*gfx_ext_retina),'b') : gfx_setfont(0);

function proceed(val, h)
(
  gfx_x < val ? (
    gfx_y = gfx_y + h;
    gfx_x = optBar;
    ) : gfx_y = gfx_y - 5;
  gfx_y;
);

function str_add_measure(str)
instance(w, h, bw, bh)
global(reset_measurements)
local(tw, th)
(
  reset_measurements ? ( w = 0; h = 0; );
  
  gfx_measurestr(str, tw, th);
  tw += 3;
  tw > bw ? bw = tw;
  th > bh ? bh = th;
  w = bw + 3;
  h = bh + 9;
);

function draw_button_core(x, y, bw, bh)
local(xp)
globals(bgcolor, gfx_a, gfx_x, gfx_y)
instance()
(
  gfx_set(bgcolor,bgcolor,bgcolor-.15*bgcolor);
  gfx_rect(x, y, bw, bh);

  ( bgcolor == 1 ) ? (
    gfx_set(1-.4, 1-.6, 1-.8);
  ) : (
    gfx_set(0 * bgColor + 0.9 * ( 1 - bgColor ), 1 * bgColor + 0.9 * ( 1 - bgColor ),  1 * bgColor + 0.6 * ( 1 - bgColor ));  
  );
  gfx_line(x, y,x + bw, y);
  gfx_line(x + bw,y, x + bw,y + bh);
  gfx_line(x, y + bh,x + bw,y + bh);
  gfx_line(x, y, x, y + bh);
  
  gfx_a = .333333*gfx_a;
  gfx_line(x-1,y+1,x+bw+1,y+1);
  gfx_line(x+bw+1,y,x+bw+1,y+bh+1);
  gfx_line(x,y+bh+1,x+bw,y+bh+1);
  gfx_line(x-1,y,x-1,y+bh+1);
  gfx_a = 3*gfx_a;
);

/* Button that wraps when there is insufficient space*/
function draw_button_wrap(yp, str, wcomp) 
  instance(w, h, x, y, bw, bh)
  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,gfx_a,bgcolor,slider8) 
  local(xp, wtxt, htxt)
(

  gfx_measurestr(str, wtxt, htxt);
  xp = gfx_x - (w+3);
  yp = proceed(wcomp+w+8, h);
  xp = gfx_x - (w+3);
  x=xp;
  y=yp;
  
  draw_button_core(x, y, w+2, h);
  gfx_x=floor(xp+2-.5*(wtxt-w)); gfx_y=yp+5;
  gfx_drawstr(str);
  gfx_x = xp - 8;
  
  y + h + 1
);

function draw_button(xp, yp, str) 
  instance(w,h,x,y) 
  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,gfx_a,bgcolor,slider8) 
(
  gfx_measurestr(str, w, h);
  w+=3;
  h+=9;
  xp -= w+3;
  x=xp;
  y=yp;
  gfx_set(bgcolor,bgcolor,bgcolor-.15*bgcolor);
  
  draw_button_core(x, y, w, h);
  gfx_x=xp+2; gfx_y=yp+5;
  gfx_drawstr(str);
  gfx_x = xp;
  
  y + h + 1
);

function draw_button_fixedWidth(xp, yp, iw, str) 
  instance(w,h,x,y) 
  local(fw, fh)
  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,gfx_a,bgcolor,slider8) 
(
  w = iw;
  gfx_measurestr(str, fw, h);
  xp -= w;
  x = xp;
  y = yp;
  h+=9;
  draw_button_core(x, y, w, h);
  
  h+=1;
  w+=1;
  gfx_x=x+.5*(w-fw); gfx_y=yp+5;
  gfx_drawstr(str);
  
  y+h
);

function draw_button2_fixedWidth(xp, yp, _w, str, active, selected, solo, somethingsolo, coloridx)
  instance(x,y, w, h,fade,cc) 
  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,gfx_a,slider8,bgcolor)
  local(fw, fh)
(
  gfx_measurestr(str, fw, fh);
  
  w = _w;
  xp -= w;
  x = xp;
  y = yp;
  fh += 10;
  h = fh;

  gfx_set(bgcolor,bgcolor,bgcolor-.15*bgcolor);
  gfx_rect(x,y,w,fh);  

  cc = (10000 + 100*floor(slider8));
  cc += 3 * coloridx; 
  ( coloridx > -1 ) ? (
    gfx_set(cc[0], cc[1], cc[2]);
    gfx_a = 0.8;
    gfx_rect(x, y+h,w,3);
    gfx_a = .4;
    gfx_rect(x, y, w, h);
    gfx_a = 0.9;
    gfx_rect(x-1, y+h+2,w+3,3);
    gfx_a = 1;
  );
  
  fade = .7+1 * active;  
  ( bgcolor == 1 ) ? (
    gfx_set(1-.4*fade+.8*solo, 1-.6*fade+.5*selected, 1-.8*fade);
  ) : (
    gfx_set(.4*fade+.8*solo, .6*fade+.5*selected, .8*fade);
  );
  gfx_line(x,y,x+w,y);
  gfx_line(x+w,y,x+w,y+fh);
  gfx_line(x,y+fh,x+w,y+fh);
  gfx_line(x,y,x,y+fh);
  
  gfx_a = .333333*gfx_a;
  gfx_line(x-1,y+1,x+w+1,y+1);
  gfx_line(x+w+1,y,x+w+1,y+fh+1);
  gfx_line(x,y+fh+1,x+w,y+fh+1);
  gfx_line(x-1,y,x-1,y+fh+1);
  gfx_a = 3*gfx_a;
  
  selected == 1 ? (
    gfx_a = .5 + .5 * sin(5*time_precise());
    gfx_line(x+1,y,x+1,y+fh);
    gfx_line(x,y+fh-1,x+w,y+fh-1);
    gfx_line(x,y+1,x+w,y+1);
    gfx_line(x+w-1,y,x+w-1,y+fh);
    gfx_line(x+2,y,x+2,y+fh);
    gfx_line(x,y+fh-2,x+w,y+fh-2);
    gfx_line(x,y+2,x+w,y+2);
    gfx_line(x+w-2,y,x+w-2,y+fh);
 );
 gfx_a = 1.0;
  
  w+=1;
  
  gfx_x=x+.5*(w-fw); gfx_y=yp+5;
  gfx_drawstr(str);

  somethingsolo ? (
    solo == 0 ? (
      gfx_set(0, 0, 0, .4);
      gfx_rect(x, y, w, h);
    );
  );

  gfx_x = x;
  
  y+fh
);

function hit_button(xp,yp,cm) 
  instance(w,h,x,y) 
  globals(cap_mode, cap_last_x, cap_last_y) 
( 
  xp>=x&&yp>=y&&xp<x+w&&yp<y+h ? (
    cap_last_x = xp;
    cap_last_y = yp;
    cap_mode=cm;
  );
);


function drag_slider(x, y, z, dx)
  globals(mouse_y, cap_last_y, cap_drag)
(
  x = min(max(x + dx * (cap_last_y-mouse_y),y),z);
  cap_last_y=mouse_y;
  cap_drag=1;
  x;
);

function mouse_wheel_button(x, y, z, dx)
(
  x = min(max(x + dx,y),z);
  x;
);

function drag_slider_precise(x, y, z, dx)
  globals(mouse_cap)
(
  (mouse_cap & 4) ? dx *= 0.1;
  drag_slider(x, y, z, dx);
);

function drag_slider_micro(x, y, z, dx)
  globals(mouse_cap)
(
  (mouse_cap & 4) ? dx *= 0.01;
  drag_slider(x, y, z, dx);
);


function cycle_slider(x, y, z, dx)
  globals(last_mouse_cap)
(
  (last_mouse_cap & 16) ? x -= dx : x += dx;
  y > z ? ( dx=y; y=z; z=dx; );
  x > z ? y : x < y ? z : x;
);
  
function scope.drawGrid(xp, yp, wp, hp, scaling)
  instance(w, h, x, y, dx, last, xcoord, hh, sig)
  globals(gfx_r, gfx_g, gfx_b, gfx_a, gfx_x, gfx_y, bufl)
(
  gfx_r=gfx_g=gfx_b=gfx_a=.4;
  y = yp + 0.5*hp;
  while( y<(yp+hp) ? ( 
    gfx_line(0, y, wp, y);
    y = y + 50*scaling;
    ) );
  
  y = yp + 0.5*hp;
  while( y>yp ? ( 
    gfx_line(0, y, wp, y);
    y = y - 50*scaling;
    ) );
    
  x = xp;
  while( x<(xp+wp) ? ( 
    gfx_line(x, yp, x, yp+hp);
    x = x + .1 * w;
    ) );
);
  
function scope.drawSignal( xp, yp, wp, hp, rpos, scaling, sampleSize, rr, gg, bb)
  instance(w, h, x, y, dx, last, xcoord, hh, sig)
  globals(gfx_r, gfx_g, gfx_b, gfx_a, gfx_x, gfx_y, bufl)
(
  w = wp;
  h = hp;
  hh = 0.5 * h;
  
  dx = w / sampleSize;
  last = scaling * ( rpos[] );
  xcoord = x;
  
  scope.drawGrid(xp, yp, wp, hp, scaling);
  
  x = xp;
  y = yp;
  gfx_r=gfx_g=gfx_b=gfx_a=1.;
  gfx_line(xcoord,  y+h,  xcoord+w,   y+h);
  gfx_line(xcoord,  y,    xcoord+w,   y);
  gfx_line(xcoord,  y,    xcoord,     y+h);  
  gfx_line(xcoord+w,y,    xcoord+w,   y+h);    
  
  gfx_r=rr; gfx_g=gg; gfx_b=bb; gfx_a=.6;
  loop(sampleSize,
    xcoord += dx;
    sig = scaling * ( rpos[] );
    ( sig > 1.0 ) ? sig = 1.0 : ( sig < -1.0 ? sig = -1.0 );
    
    gfx_line(xcoord,y+hh*sig+hh,xcoord+dx,y+hh*last+hh);
    last = sig;
    rpos += 1;
  );
);

function scope.drawMovingSignal( xp, yp, wp, hp, rpos, endpos, startpos, scaling, sampleSize, rr, gg, bb)
  instance(w, h, x, y, dx, last, xcoord, hh, sig)
  globals(gfx_r, gfx_g, gfx_b, gfx_a, gfx_x, gfx_y, bufl)
(
  hh = 0.5 * h;
  
  rpos = rpos + 1;
  dx = w / sampleSize;
  last = scaling * ( rpos[] );
  xcoord = x;
  
  scope.drawGrid(xp, yp, wp, hp, scaling);
  
  x = xp;
  y = yp;
  w = wp;
  h = hp;
  
  gfx_r=gfx_g=gfx_b=gfx_a=1.;
  gfx_line(xcoord,  y+h,  xcoord+w,   y+h);
  gfx_line(xcoord,  y,    xcoord+w,   y);
  gfx_line(xcoord,  y,    xcoord,     y+h);  
  gfx_line(xcoord+w,y,    xcoord+w,   y+h);    
  gfx_r=rr; gfx_g=gg; gfx_b=bb; gfx_a=.6;
  loop(sampleSize,
    xcoord += dx;
    sig = scaling * ( rpos[] );
    ( sig > 1.0 ) ? sig = 1.0 : ( sig < -1.0 ? sig = -1.0 );
    
    gfx_line(xcoord,y+hh*sig+hh,xcoord+dx,y+hh*last+hh);
    last = sig;
    rpos = ( rpos > endpos ) ? startpos : rpos + 1;
  );
);

function hit(xp,yp,cm) 
  instance(w,h,x,y) 
  globals(cap_mode, cap_last_x, cap_last_y) 
( 
  xp>=x&&yp>=y&&xp<x+w&&yp<y+h ? (
    cap_last_x = xp;
    cap_last_y = yp;
    cap_mode=cm;
  );
);

function checkChannelButtons()
(
  hit = 0;

  ch1.hit_button(mouse_x,mouse_y,11)  ? ( hit=11; ) :
  ch2.hit_button(mouse_x,mouse_y,12)  ? ( hit=12; ) :
  ch3.hit_button(mouse_x,mouse_y,13)  ? ( hit=13; ) :
  ch4.hit_button(mouse_x,mouse_y,14)  ? ( hit=14; ) :
  ch5.hit_button(mouse_x,mouse_y,15)  ? ( hit=15; ) :
  ch6.hit_button(mouse_x,mouse_y,16)  ? ( hit=16; ) :
  ch7.hit_button(mouse_x,mouse_y,17)  ? ( hit=17; ) :
  ch8.hit_button(mouse_x,mouse_y,18)  ? ( hit=18; ) :
  ch9.hit_button(mouse_x,mouse_y,19)  ? ( hit=19; ) :
  ch10.hit_button(mouse_x,mouse_y,20) ? ( hit=20; ) :
  ch11.hit_button(mouse_x,mouse_y,21) ? ( hit=21; ) :
  ch12.hit_button(mouse_x,mouse_y,22) ? ( hit=22; ) :                                                                       
  ch13.hit_button(mouse_x,mouse_y,23) ? ( hit=23; ) :
  ch14.hit_button(mouse_x,mouse_y,24) ? ( hit=24; ) :
  ch15.hit_button(mouse_x,mouse_y,25) ? ( hit=25; ) :
  ch16.hit_button(mouse_x,mouse_y,26) ? ( hit=26; );
    
  hit > 0 ? (
    (slider36 == -1) ? (
      slider(hit) = !slider(hit);
      slider_automate(slider(hit)); 
      updateSliders = 1;
      old_w = 0;
    ) : (
      slider36 = -1;
    );
  );
    
  chA.hit_button(mouse_x,mouse_y,200) ? ( showA=!showA; slider_automate(showA); );
  chB.hit_button(mouse_x,mouse_y,200) ? ( showB=!showB; slider_automate(showB); );
  
  hit > 0;
);

SONOSURFACE2 = 3;
function drawSono(sonogramBuffer, sonoColorMap, invert, sonoScale, xp, yp, wp, hp, logarithmic, fmaxFactor)
  instance(w, h, x, y, preSonoDest, preSonoX, preSonoY, sonoSize,sonoSizeX, sonoColorLoc, sonoColorMap, iv, sonosurf, blurred, tx, tl, i, xscale, logarithmic, wsc, cv, N, norm, fmax)
  globals(slider44, gfx_dest, gfx_r, gfx_g, gfx_b, gfx_a, gfx_x, gfx_y, fftsize, SONOSURFACE, SONOSURFACE2, gfx_mode)
  local(val)
(
  x = xp;
  y = yp;
  w = wp;
  h = hp;

  sonosurf = SONOSURFACE;
  blurred  = SONOSURFACE2;    
  
  preSonoDest = gfx_dest;
  gfx_a = 1;
  //sonoSize  = 2048;
  sonoSize  = hp;
  sonoSizeX = 256;

  // MaxF
  fmax     = fftsize / fmaxFactor;

  // For log-drawing
  xscale   = 800/(fmax-4);
  wsc      = sonoSize/(log(1+.5*fmax*xscale));
  
  // Start by drawing the previous buffer to this one
  ( slider44 == 0 ) ? (
    gfx_dest = sonosurf;
    gfx_setimgdim(sonosurf, sonoSizeX, sonoSize);
    gfx_setimgdim(blurred, sonoSizeX, sonoSize);  
    gfx_x = -1;
    gfx_y = 0;
    gfx_blit(sonosurf, 1, 0);
  
    // Draw the stuff
    gfx_x = sonoSizeX-10;
    gfx_y = sonoSize;
    tl = 0;
    i = 0; 
    
    ( logarithmic == 0 ) ? 
    (
      // Actual FFT density is better than what we can display
      N = .5*fmax/sonoSize;
      norm = sonoScale/N;
      ( N > 1 ) ?
      (
        gfx_x = sonoSizeX-1;
        loop(sonoSize,
          cv = 0;
          loop(N,
            cv = cv + norm * sonogramBuffer[];
            sonogramBuffer += 1;
          );
        
          sonoColorLoc = sonoColorMap + 3*ceil(  (  invert + ( 1 - 2*invert ) * (1-exp(-cv))  )*255);   
          gfx_setpixel(sonoColorLoc[],sonoColorLoc[1],sonoColorLoc[2]);
          gfx_y -= 1;
        );
      ) : ( 
        // Actual FFT density is crappier    
        N = 1/N;
        i = sonoSize;
        loop(sonoSize/N,
          sonoColorLoc = sonoColorMap + 3*ceil(  (  invert + ( 1 - 2*invert ) * (1-exp(-sonogramBuffer[]*sonoScale))  )*255);   
          gfx_r = sonoColorLoc[];
          gfx_g = sonoColorLoc[1];
          gfx_b = sonoColorLoc[2];
          gfx_a = 1.0;
          
          gfx_line(sonoSizeX-1,i,sonoSizeX-1,i+N);
          
          i -= N;
          sonogramBuffer += 1;
        );
      )
    ) : (
      tl = 0; val = 0;
      loop(.5*fmax,
        tx = log(1.0+i*xscale)*wsc;
        val = max(val, sonogramBuffer[]);
        
        (tx - tl) > 0.999999 ?
        (  
          sonoColorLoc = sonoColorMap + 3*ceil(  (  invert + ( 1 - 2*invert ) * (1-exp(- val*sonoScale))  )*255);
          val = 0;
          
          gfx_r = sonoColorLoc[];
          gfx_g = sonoColorLoc[1];
          gfx_b = sonoColorLoc[2];    
          gfx_line(sonoSizeX-1,sonoSize-tl,sonoSizeX-1,sonoSize-tx);
          tl = tx;
        );
        
        i += 1;
        sonogramBuffer += 1;
      );
    );
  );
  
  // Draw the sonogram to the screen
  gfx_dest = preSonoDest;
  gfx_x = x;
  gfx_y = y;
  gfx_a = .95;
  gfx_blit(sonosurf, 1, 0, 0, 0, sonoSizeX, sonoSize, x, y, w, h);  
  
  // Blur it in a second buffer
  /*gfx_dest = blurred;
  gfx_x = gfx_y = 0;
  gfx_blit(sonosurf, 1, 0);
  gfx_x = gfx_y = 0;
  loop(2,
    gfx_blurto(sonoSizeX,sonoSizeX);
  );
  
  // Add it on top
  gfx_mode = 1;
  gfx_x = gfx_y = 0;
  gfx_dest = preSonoDest; 
  gfx_blit(blurred, 1, 0, 0, 0, sonoSizeX, sonoSize, x, y, w, h);  
  gfx_blit(blurred, 1, 0, 0, 0, sonoSizeX, sonoSize, x, y, w, h); */   
  gfx_mode = 0;
);

function drawGrid()
local(intensity, textintensity,
      gv, cnt, y, gfx_texth, bottom_line, f, lx, ltxt, tx, dotext, scale_offset)
global(bgColor, wsc, logf_to_pixels, scale_offset_db,
       gfx_r, gfx_g, gfx_b, gfx_a, gfx_x, gfx_y, gfx_w, gfx_h,
       slider39, slider40, srate,
       spectrum_yoffset, spectrum_yoffsetbottom, spectrum_xpad,
       scaling, spectrum_xmax, spectrum_xoffset, hideUI)
(
  intensity = 0 * bgColor + 1 * ( 1 - bgColor );
  textintensity = 0.1 * bgColor + 1.0 * ( 1 - bgColor ); 
  
  // draw horz grid
  gfx_r=gfx_g=gfx_b=intensity;
  gv=1;
  cnt=100;
  gfx_y = spectrum_yoffset;
  
  scale_offset = 10^(scale_offset_db/20);
  gv /= scale_offset;
  
  y=spectrum_yoffset-log(gv*scale_offset)*logf_to_pixels;
  while(
    y > 0 ? (
      gfx_r=gfx_g=gfx_b=intensity; gfx_a=0.8 * slider39 * slider40;
      gfx_line(0,y,gfx_w-spectrum_xpad,y,0);
      bottom_line = gfx_y;
      
      !hideUI ? (
        gfx_x=7; 
        gfx_y=y+2;
        gfx_r=gfx_g=gfx_b=textintensity; gfx_a=0.9;
        gfx_drawnumber(log10(gv)*20,0);
        gfx_drawchar($'d');
        gfx_drawchar($'B');
        gfx_y+=gfx_texth;
      );
    );
    gv*=0.5;
  
    y=spectrum_yoffset-log(gv*scale_offset)*logf_to_pixels;
    y<(gfx_h-spectrum_yoffsetbottom) && cnt-=1 > 0;
  );
  
  wsc = scaling*gfx_w/log(1+400) * (spectrum_xmax/gfx_w);

  // draw vert grid
  f=20;
  gfx_x+=4;
  lx=gfx_x;
  ltxt = 0;
  tx = log(1.0+((f/srate-spectrum_xoffset)*2.0)*400) * wsc;
  while(
    gfx_r=gfx_g=gfx_b=intensity; gfx_a=0.8 * slider39 * slider40;
    dotext = !hideUI && (tx > gfx_x && f!=40 && f!=4000 && f != 15000 &&
       (f<400 || f >= 1000 || f == 500) && (f<6000 || f>=10000) || (tx-ltxt)>.1*gfx_w);
    tx > lx ? ( lx=tx+4; gfx_line(tx,spectrum_yoffset,tx,gfx_h - spectrum_yoffsetbottom - (dotext ? 0 : gfx_texth+2),0); );
    // NOTE: Note that the line above didn't have a rescale Y
    gfx_r=gfx_g=gfx_b=textintensity; gfx_a=0.9;
    dotext ? (
      ltxt = tx;
      gfx_x = tx + 3;
      gfx_y = gfx_h-gfx_texth-spectrum_yoffsetbottom;
      gfx_line( gfx_x-3, gfx_y, gfx_x-3, gfx_y+gfx_texth );
      f>=1000 ? gfx_printf("%dkHz",f*.001) : gfx_printf("%dHz",f);
    );
    f += (f<100?10:f<1000?100:f<10000?1000:5000);
    tx = log(1.0+((f/srate-spectrum_xoffset)*2.0)*400) * wsc;
    tx < spectrum_xmax
  );
);

function drawFFT(bufout, fftsize, xscale, kernelSize, rr, gg, bb, fill, draw, offset)
local(i, curh, ixsc,
      prec, tx, ty, tx0, lx0, lx, ly, 
      fill_slast, fill_slmin, ly2, ty2)
global(gfx_w, gfx_h, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a,
       slider37, displayMode,
       spectrum_yoffsetbottom, spectrum_yoffset,
       spectrum_xoffsetbottom, spectrum_xoffset
       wsc, spectrum_xmax, scale_offset_db,
       spectral_offset_pixels, zeroline)
instance()
(
  i = 0;
  fill_slmin=gfx_h;
  fill_slast=0;
  curh = gfx_h-spectrum_yoffsetbottom;
  
  ixsc = 0;
  prec = fftsize*spectrum_xoffset*xscale;
  zeroline = spectrum_yoffset-spectral_offset_pixels;
  loop(fftsize*0.5-kernelSize,
    tx = log(1.0+ixsc-prec)*wsc;
    ty = bufout[];
    ty = min(ty, gfx_h - spectrum_yoffsetbottom);
  
    ( i && ( tx < spectrum_xmax ) ) ?
    ( 
      gfx_r=rr;
      gfx_g=gg;
      gfx_b=bb;
        
      fill ? (
        gfx_a=slider37;
        tx0=tx|0;
        lx0=lx|0;
        tx0>lx0? (
          displayMode == 1 ? (
            gfx_triangle(lx0,max(zeroline,ly),lx0,ly,tx0-1,ty,tx0-1,max(zeroline,ty));
            gfx_triangle(lx0,min(zeroline,ly),lx0,ly,tx0-1,ty,tx0-1,min(zeroline,ty));
          ) : (
            ly < curh || ty < curh ? gfx_triangle(lx0,max(curh,ly),lx0,ly,tx0-1,ty,tx0-1,max(curh,ty));
          );
        ) : (
          tx0 > fill_slast ? (
           fill_slast < curh ? gfx_line(fill_slast,curh,fill_slast,fill_slmin);
           fill_slmin=curh;
         ) : (
           fill_slmin=min(fill_slmin,ty);
          );
        );
        fill_slast=tx0;        
      );  
      gfx_a=1;
      gfx_x=lx; gfx_y=ly; draw == 1 ? gfx_lineto(tx,ty,1) ;
   );
   
   lx=tx; ly=ty; ly2=ty2; bufout+=1; i+=1; ixsc+=xscale;
  )
);

function prepareForDrawing(filtout, rpos, fftwspace, intbuf, bufStart, histEnd, rr, gg, bb, fill, draw, fftsize, xscale, smoothMode, kernelSize)
local(bufout, fout, scfac, jk, tmp, curSize, kern, tsc, i, curh
      sumWtY, iSize, xij, SumWtS,
      d, w, yAdaptive, res, 
      M_est, S_est,
      alpha, Sq_est)
global(smoothing, filtout2,
       spectrum_xmax, spectrum_center, slider37)
instance()
(
  gfx_line(0, spectrum_center, 1000, spectrum_center);

  ( smoothing > 0 ) ? (
    ( smoothMode == 0 ) ? (
      // Convolve it
      bufout      = filtout+kernelSize;
      fout        = filtout2;
      scfac       = kernelSize / log(1+400);
      jk          = 1;
      
      loop(fftsize*0.5,
        tmp = 0;
        curSize   = ceil(scfac * log(1.0+jk*xscale));
        kern      = bufout-curSize;
        tsc       = 1 / (2*curSize+1);
        loop(2*curSize+1,
          tmp = tmp + kern[];
          kern += 1;
        );
        fout[] = tmp * tsc;
        bufout += 1;
        fout += 1;
        jk += 1;
      );
    
      bufout = filtout2;
    ) : ( smoothMode == 1 ) ? (
      // Determine maximum
      bufout      = filtout+kernelSize;
      fout        = filtout2;
      scfac       = kernelSize / log(1+400);
      jk          = 1;
      
      loop(fftsize*0.5,
        tmp       = 10000;
        curSize   = ceil( scfac * log(1.0+jk*xscale) );
        kern      = bufout-curSize;
        loop(2*curSize+1,
          tmp = min( tmp, kern[] );
          
          kern += 1;
        );
        fout[] = tmp;
        bufout += 1;
        fout += 1;
        jk += 1;
      );
          
      bufout = filtout2;
    ) : ( smoothMode == 2 ) ? (
      // LOESS filtering
      bufout      = filtout+kernelSize;
      fout        = filtout2;
      scfac       = kernelSize / log(1+400);
      jk          = 1;
      
      loop(fftsize*0.5,
        tmp       = 10000;
        curSize   = 1+ceil( scfac * log(1.0+jk*xscale) );
        kern      = bufout-curSize;
        
        SumWtY    = 0;
        isize     = 1.0 / curSize;
        xij       = - curSize;
 
        SumWts    = 1.1571 * curSize;
        loop(2*curSize+1,
          d       = abs(xij) * isize;
          w       = (1.0 - d*d*d);
          w       = w*w*w;
          SumWtY  = SumWtY + kern[] * w;
                    
          kern    += 1;
          xij     += 1;
        );
        
        fout[] = SumWtY / SumWts;
        bufout += 1;
        fout += 1;
        jk += 1;
      );
          
      bufout = filtout2;
    ) : ( smoothMode == 3 ) ? (
      // Adaptive filtering
      bufout      = filtout+kernelSize;
      fout        = filtout2;
      scfac       = kernelSize / log(1+400);
      jk          = 1;
      
      loop(fftsize*0.5,
        tmp       = 10000;
        curSize   = 1+ceil( scfac * log(1.0+jk*xscale) );
        kern      = bufout-curSize;
        
        SumWtY    = 0;
        isize     = 1.0 / curSize;
        xij       = - curSize;
 
        SumWts    = 1.1571 * curSize;
        loop(2*curSize+1,
          d       = abs(xij) * isize;
          w       = (1.0 - d*d*d);
          w       = w*w*w;
          SumWtY  = SumWtY + kern[] * w;
                    
          kern    += 1;
          xij     += 1;
        );
        yAdaptive    = SumWtY / SumWts;
        
        res  = bufout[] - yAdaptive;
        ( -res < abs( M_est + 2*sqrt( S_est ) ) ) ?
        ( 
          alpha   = 0.99;
          M_est   = alpha * M_est  + ( 1 - alpha ) * res;
          Sq_est  = alpha * Sq_est + ( 1 - alpha ) * res * res;
          S_est   = Sq_est - M_est*M_est;
        ) : (
          // Don't use LOESS value at peaks
          yAdaptive = bufout[];
        );
        
        fout[] = yAdaptive;
        bufout += 1;
        fout += 1;
        jk += 1;
      );
          
      bufout = filtout2;
    ) : ( smoothMode == 4 ) ? (
      bufout      = filtout + kernelSize;
      fout        = filtout2;
      scfac       = .00025 * kernelSize * kernelSize;
      jk          = 1;
      
      tmp = bufout[];
      loop(fftsize*0.5,
        kern = 1/(1+scfac*jk);
        tmp = kern * bufout[] + (1-kern) * tmp;

        fout[] = tmp;
        bufout += 1;
        fout += 1;
        jk += 1;
      );
      
      bufout = filtout2 + fftsize * 0.5 - 1;
      fout = filtout2 + fftsize * 0.5 - 1;
      tmp = bufout[];
      jk = fftsize*0.5;
      loop(fftsize*0.5,
        kern = 1/(1+scfac*jk);
        tmp = kern * bufout[] + (1-kern) * tmp;

        fout[] = tmp;
        bufout -= 1;
        fout -= 1;
        jk -= 1;
      );      
    
      bufout = filtout2;
    );
  ) : bufout = filtout;
  
  draw ? drawFFT(bufout, fftsize, xscale, kernelSize, rr, gg, bb, fill, draw, 0);
  
  bufout
);


function windowAndTransform(rpos, fftsize, bufStart, histSize, window, fftwspace, histEnd)
local(buf1, buf2, buf3)
local()
global()
instance()
(
  buf1=rpos-fftsize;
  buf1<bufStart ? buf1+=histsize;
  buf2=window;
  buf3=fftwspace;
  loop(fftsize*.5 + 1,
    buf3[] = buf1[]*buf2[];
    buf3+=1;
  
    buf2+=1;
    (buf1+=1) >= histEnd ? buf1 -= histsize;
  );
  buf2-=1;
  loop(fftsize*.5 - 1,
    buf3[] = buf1[]*(buf2-=1)[];
    buf3+=1;
    (buf1+=1) >= histEnd ? buf1 -= histsize;
  );
  
  fft_real(fftwspace,fftsize);
  fft_permute(fftwspace,fftsize/2);
  fftwspace[1]=0;
  
  fftwspace
);

function processFFT(rpos, fftwspace, intbuf, bufStart, histEnd, rr, gg, bb, fill, draw)
local(buf1, buf2, buf3, bufout, ascale, i, lx, ang, ty, ty2, tx, ly2,
      yOut, slope, prec, last)
global(histsize, fftsize, window, filtout,
       max_fft_size,
       spectrum_yoffset, bottom_pad, spectrum_xmax, wsc, logf_to_pixels, spectral_offset_pixels,
       gfx_x, gfx_y, gfx_h, 
       slider3, slider38, maxIntegrate, slider45, smoothing,
       integrate_en, integrate_sc,
       kernelSize, xscale)
instance()
(
  fftwspace = windowAndTransform(rpos, fftsize, bufStart, histSize, window, fftwspace, histEnd);

  ascale=gfx_h/$pi*0.25;
  xscale=800.0/(fftsize-4.0);
 
  buf3=fftwspace;
  buf2=intbuf+max_fft_size*0.5;
  i=0;
  lx=0;
  
  // Draw phase (angle)
  draw ? (
    slider3 ? loop(fftsize*0.5,
      ang=-atan2(buf3[1],buf3[]);
      buf3+=2;
      
      integrate_en ? (
        ang = buf2[] += integrate_sc * (ang - buf2[]);
        buf2+=1;
      );
      
      ty2=(ang*ascale + gfx_h*0.5) + spectrum_yoffset;
      tx = log(1.0+i*xscale)*wsc;
  
      i && ( tx < spectrum_xmax ) ? 
      ( 
        gfx_x=lx; gfx_y=ly2; gfx_lineto(tx,ty2,1) ;
      );
  
      lx=tx; ly2=ty2;
      i+=1;
    );
  );
  
  lx=0;
  i=0;

  // Process FFT
  kernelSize  = smoothing > 0 ? floor( smoothing/5 + 1 ) : 0;
  bufout = filtout + kernelSize;
  
  // Integrate the FFT over time to smooth it.
  // Note that yOut and buf3 both point to the FFTW space. yOut is written after buf3 is read so 
  // they don't conflict.
  buf3 = fftwspace;
  yOut = fftwspace;
  buf2 = intbuf;
  i    = 0;
  slope = .5*log(2)*slider38;
  prec = (10^(-500/20*2));
  loop(fftsize*0.5,   
    yOut[] = sqr(buf3[0])+sqr(buf3[1]);
    ty = log(max(yOut[],prec));
    ty = ty + slope*log(1.0+i*xscale);
    yOut += 1;
    buf3 += 2;    
  
    integrate_en ? (
      maxIntegrate ? (
        ty = buf2[] = max(ty, buf2[] - integrate_sc);
      ) : (
        ty = buf2[] += integrate_sc * (ty - buf2[]);
      );
      buf2+=1;
    );
    
    bufout[] = ty * -0.5 * logf_to_pixels + spectrum_yoffset - spectral_offset_pixels;
    bufout += 1;
    i += 1;
  );
    
  // Copy the last few to the front
  bufout = filtout + kernelSize;
  last = bufout[];
  loop(kernelSize,
    bufout -= 1;
    bufout[] = last;
  );
  
  prepareForDrawing(filtout, rpos, fftwspace, intbuf, bufStart, histEnd, rr, gg, bb, fill, draw, fftsize, xscale, floor(slider45), kernelSize)
);

function processFFTDifference(rpos, fftwspace, intbuf, bufStart, histEnd, 
                              rpos2, fftwspace2, intbuf2, bufStart2, histEnd2, 
                              rr, gg, bb, fill, draw)
local(buf1, buf2, buf3, bufout, ascale, i, lx, ang, last_ang, plot_ang, phase_diff, ty, ty2, tx, ly2,
      yOut, slope, prec, last, y1, y2, eps, yy, xx, mag,
      intbuf_ptr, intbuf2_ptr,
      )
global(histsize, fftsize, window, filtout, 
       max_fft_size,
       spectrum_yoffset, bottom_pad, spectrum_xmax, wsc, logf_to_pixels, spectral_offset_pixels, spectrum_yoffsetbottom,
       gfx_x, gfx_y, gfx_h, 
       slider3, slider38, maxIntegrate, slider45, smoothing,
       integrate_en, integrate_sc,
       kernelSize, xscale, unwrap)
instance()
(
  fftwspace = windowAndTransform(rpos, fftsize, bufStart, histSize, window, fftwspace, histEnd);
  fftwspace2 = windowAndTransform(rpos2, fftsize, bufStart2, histSize, window, fftwspace2, histEnd2);

  ascale=(gfx_h - spectrum_yoffsetbottom - spectrum_yoffset)/$pi*0.25;
  xscale=800.0/(fftsize-4.0);
 
  buf3=fftwspace;
  buf1=fftwspace2;
  intbuf_ptr=intbuf+max_fft_size*0.5;
  i=0;
  lx=0;

  eps = 0.000000000001;
  plot_ang = last_ang = intbuf_ptr[];
  ly2 = (plot_ang * ascale + (gfx_h - spectrum_yoffsetbottom - spectrum_yoffset)*0.5) + spectrum_yoffset;

  // Draw phase (angle)
  draw ? (
    slider3 ? loop(fftsize*0.5,
      yy = buf3[0]*buf1[1]-buf3[1]*buf1[0];
      xx = buf3[0]*buf1[0]+buf3[1]*buf1[1];
      mag = 100000000000*(buf3[]*buf3[] + buf3[1]*buf3[1]) * (buf1[]*buf1[] + buf1[1]*buf1[1]);
      gfx_set(.6, .6, 1, min(mag, 1.0));
      ang = -atan2(yy, xx);
      buf3+=2;
      buf1+=2;
      
      integrate_en ? (
        ang = intbuf_ptr[] += integrate_sc * (ang - intbuf_ptr[]);
        intbuf_ptr+=1;
      );
      
      unwrap = 0;
      unwrap ? (
        phase_diff = ang - last_ang;
        phase_diff > ($pi-eps) ? phase_diff -= 2.0 * $pi;
        phase_diff < -($pi-eps) ? phase_diff += 2.0 * $pi;
        last_ang = ang;
        plot_ang += phase_diff;
      ) : plot_ang = ang;
      
      ty2=(plot_ang*ascale + (gfx_h - spectrum_yoffsetbottom - spectrum_yoffset)*0.5) + spectrum_yoffset;
      tx = log(1.0+i*xscale)*wsc;
  
      i && ( tx < spectrum_xmax ) ? 
      ( 
        //gfx_x=lx; gfx_y=ly2; gfx_lineto(tx,ty2,1) ;
        gfx_circle(tx, ty2, 2, 1);
      );
  
      lx=tx; ly2=ty2;
      i+=1;
    );
  );

  // Process FFT
  kernelSize  = smoothing > 0 ? floor( smoothing/5 + 1 ) : 0;
  bufout = filtout + kernelSize;
  
  // Integrate the FFT over time to smooth it.
  // Note that yOut and buf3 both point to the FFTW space. yOut is written after buf3 is read so 
  // they don't conflict.
  buf3 = fftwspace2;
  buf1 = fftwspace;
  yOut = fftwspace;
  
  intbuf_ptr = intbuf;
  intbuf2_ptr = intbuf2;
  i    = 0;
  slope = .5*log(2)*slider38;
  prec = (10^(-500/20*2));
  eps = 0.000000000000000000001;
  loop(fftsize*0.5,
    y1 = sqr(buf3[0])+sqr(buf3[1]);
    y2 = sqr(buf1[0])+sqr(buf1[1]);
    
    ty = log(max(y1,prec));
    ty2 = log(max(y2,prec));

    integrate_en ? (
      maxIntegrate ? (
        ty = intbuf_ptr[] = max(ty, intbuf_ptr[] - integrate_sc);
        ty2 = intbuf2_ptr[] = max(ty2, intbuf2_ptr[] - integrate_sc);
      ) : (
        ty = intbuf_ptr[] += integrate_sc * (ty - intbuf_ptr[]);
        ty2 = intbuf2_ptr[] += integrate_sc * (ty2 - intbuf2_ptr[]);        
      );
      intbuf_ptr+=1;
      intbuf2_ptr+=1;
    );
    
    ty -= ty2;
   // ty2 < eps && ty > eps ? ty = 100000000;
    yOut[] = ty; 
    yOut += 1;
    
    bufout[] = ty*-0.5*logf_to_pixels + spectrum_yoffset - spectral_offset_pixels;
    bufout += 1;
    i += 1;
    
    buf3 += 2;
    buf1 += 2;
  );
    
  // Copy the last few to the front
  bufout = filtout + kernelSize;
  last = bufout[];
  loop(kernelSize,
    bufout -= 1;
    bufout[] = last;
  );
  
  prepareForDrawing(filtout, rpos, fftwspace, intbuf, bufStart, histEnd, rr, gg, bb, fill, draw, fftsize, xscale, floor(slider45), kernelSize)
);



// Scrollwheel
(abs(mouse_wheel) > 0) ?
(
  mouse_wheel = 0.01 * mouse_wheel;
  sonogram.hit_button(mouse_x,mouse_y,-1) ? (
    ( slider29 == 0 ) ? slider35 = mouse_wheel_button(slider35, 1, 8, mouse_wheel) : slider31 = mouse_wheel_button(slider31, 1, 8, mouse_wheel);
  ) : ( 
    slider6 = mouse_wheel_button(slider6, 1, 8, mouse_wheel);
  );
  mouse_wheel = 0;
);

(mouse_cap & 2) ? (
  !(last_mouse_cap & 2) ? (
    ch1.hit_button(mouse_x,mouse_y,-1) ? ( slider28=0; slider_automate(slider28); old_w = 0);
    ch2.hit_button(mouse_x,mouse_y,-1) ? ( slider28=1; slider_automate(slider28); old_w = 0);
    ch3.hit_button(mouse_x,mouse_y,-1) ? ( slider28=2; slider_automate(slider28); old_w = 0);
    ch4.hit_button(mouse_x,mouse_y,-1) ? ( slider28=3; slider_automate(slider28); old_w = 0);
    ch5.hit_button(mouse_x,mouse_y,-1) ? ( slider28=4; slider_automate(slider28); old_w = 0);
    ch6.hit_button(mouse_x,mouse_y,-1) ? ( slider28=5; slider_automate(slider28); old_w = 0);
    ch7.hit_button(mouse_x,mouse_y,-1) ? ( slider28=6; slider_automate(slider28); old_w = 0);
    ch8.hit_button(mouse_x,mouse_y,-1) ? ( slider28=7; slider_automate(slider28); old_w = 0);
    ch9.hit_button(mouse_x,mouse_y,-1) ? ( slider28=8; slider_automate(slider28); old_w = 0);
    ch10.hit_button(mouse_x,mouse_y,-1) ? ( slider28=9; slider_automate(slider28); old_w = 0);
    ch11.hit_button(mouse_x,mouse_y,-1) ? ( slider28=10; slider_automate(slider28); old_w = 0);
    ch12.hit_button(mouse_x,mouse_y,-1) ? ( slider28=11; slider_automate(slider28); old_w = 0);                                                                        
    ch13.hit_button(mouse_x,mouse_y,-1) ? ( slider28=12; slider_automate(slider28); old_w = 0);
    ch14.hit_button(mouse_x,mouse_y,-1) ? ( slider28=13; slider_automate(slider28); old_w = 0);
    ch15.hit_button(mouse_x,mouse_y,-1) ? ( slider28=14; slider_automate(slider28); old_w = 0);
    ch16.hit_button(mouse_x,mouse_y,-1) ? ( slider28=15; slider_automate(slider28); old_w = 0);
    showSumButton.hit_button(mouse_x,mouse_y,-1) ? ( slider28=-1; slider_automate(slider28); old_w = 0);  
    showChannel = slider28;        

    ( mouse_y < (gfx_h-sono_yoffset_bottom-sono_size) ) && ( mouse_x < ( gfx_w - spectrum_xpad ) ) ? 
    (
      ( zoomMode == 0 ) ? (
        // Not zooming
        old_mouse_x = mouse_x;
        old_mouse_y = mouse_y;
        zoomMode = 1;
      );
      ( zoomMode == 2 ) ? (
        spectrum_xoffset = 0;
        slider6 = 1.0;
        scaling = slider6;
        slider_automate(slider6);
        zoomMode = 0;
      );
    );

    slider29 == 0 && cap_last_y != mouse_y ) ? (
      sonogram.hit_button(mouse_x,mouse_y,-1) ? ( slider32 = cycle_slider(slider32, 0, 7, 1);
    );  
  );
) : (
  ( zoomMode == 1 ) ? (
    zoomMode = 2;
      
    f1 = (1/800) * ( exp(old_mouse_x/wsc)-1 ) + spectrum_xoffset;
    f2 = (1/800) * ( exp(mouse_x/wsc)-1 ) + spectrum_xoffset;
    f2 < f1 ? (
      tmp = f2;
      f2 = f1;
      f1 = tmp;
    );
  
    f2-f1 > .001 ?
    (
      spectrum_xoffset = f1;  
      diff  = f2-spectrum_xoffset;
      
      // Notes
      // f = (1/800) * ( exp(mouse_x/wsc)-1 ) * srate + spectrum_xoffset * srate;
      // wsc   = spectrum_xmax / log( 1.0 + 800 * diff );
      // denom = spectrum_xmax / log( 1 + 400 );
  
      newscale = log( 1 + 400 ) / log( 1.0 + 800 * diff );
      slider6 = newscale;
      scaling = slider6;
      slider_automate(slider6);
    );
  );
);

(mouse_cap & 1) ? (
   !(last_mouse_cap & 1) ? (
      // Reset to defaults
       (cap_mode == 1||cap_mode == 4||cap_mode == 5||cap_mode == 6||cap_mode == 8||cap_mode == 9||cap_mode == 10||cap_mode ==30||cap_mode ==31
       ||cap_mode ==32 ||cap_mode ==40 ||cap_mode ==42||cap_mode == 44||cap_mode == 49|| (cap_mode > 10 && cap_mode < 27)||cap_mode==28) && !cap_drag && cap_timer < 12 ?(
         cap_mode == 1 ? (
            slider2 = -90;
            slider_automate(slider2);
          ) : (
          cap_mode == 49 ? (
             scale_offset_db_user = 0;
             slider_automate(scale_offset_db_user);
           ) : (
            cap_mode == 4 ? (
              slider5 = 0;
              slider_automate(slider5);
            ) : (
              cap_mode == 5 ? (
                slider6 = 1.0;
                slider_automate(slider6);
              ) : (
                cap_mode == 6 ? (
                  // Smoothing
                  smoothing = 20;
                  slider_automate(smoothing);
                ) : (
                  cap_mode == 8 ? (                
                    // Sonogram
                    slider34 = !slider34;
//                    slider30 = 2500;
                    slider_automate(slider34);
                  ) : (
                    cap_mode == 9 ? (
                      // Time
                      slider34 = !slider34;
//                      slider31 = 1;
                      slider_automate(slider31);
                    ) : (
                      cap_mode == 10 ? (
                        // Sonogram scaling
                        slider35 = 1;
                        slider_automate(slider35);
                      ) : ( 
                        cap_mode == 29 ? (
                          // Slope
                          slider38 = 0;
                          slider_automate(slider38);
                        ) : (                       
                          cap_mode == 28 ? (
                            // Alpha
                            slider37 = .5;
                          ) : (
                            
                            cap_mode == 30 ? (
                                 // ColorBackground
                                 slider10 = .5;
                               ) : (
                               
                               cap_mode == 31 ? (
                                    // gridAlpha
                                    slider40 = .5;
                                  ) : (
                                  
                                  cap_mode == 32 ? (
                                       // Freeze
                                       slider44 = 0;
                                     ) : (
                                     cap_mode == 42 ? (
                                          // Options
                                          slider42 = 1;
                                          slider_automate(slider42);
                                        ) : (
                                  // One of the channel buttons
                                  (cap_mode > 10 && cap_mode < 27) ? (
                                    // Was something solo'd?
                                    ( slider36 > -1 ) ? ( slider36 = -1; ) : ( 
                                      ( ch1.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 11 ) ? ( slider36 = 0; slider11 = 1; slider_automate(slider11); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch2.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 12 ) ? ( slider36 = 1; slider12 = 1; slider_automate(slider12); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch3.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 13 ) ? ( slider36 = 2; slider13 = 1; slider_automate(slider13); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch4.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 14 ) ? ( slider36 = 3; slider14 = 1; slider_automate(slider14); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch5.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 15 ) ? ( slider36 = 4; slider15 = 1; slider_automate(slider15); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch6.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 16 ) ? ( slider36 = 5; slider16 = 1; slider_automate(slider16); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch7.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 17 ) ? ( slider36 = 6; slider17 = 1; slider_automate(slider17); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch8.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 18 ) ? ( slider36 = 7; slider18 = 1; slider_automate(slider18); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch9.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 19 ) ? ( slider36 = 8; slider19 = 1; slider_automate(slider19); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch10.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 20 ) ? ( slider36 = 9; slider20 = 1; slider_automate(slider20); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch11.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 21 ) ? ( slider36 = 10; slider21 = 1; slider_automate(slider21); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch12.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 22 ) ? ( slider36 = 11; slider22 = 1; slider_automate(slider22); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch13.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 23 ) ? ( slider36 = 12; slider23 = 1; slider_automate(slider23); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch14.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 24 ) ? ( slider36 = 13; slider24 = 1; slider_automate(slider24); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch15.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 25 ) ? ( slider36 = 14; slider25 = 1; slider_automate(slider25); updateSliders = 1; ) : checkChannelButtons(); );
                                      ( ch16.hit_button(mouse_x,mouse_y,cap_mode) ? ( cap_mode == 26 ) ? ( slider36 = 15; slider26 = 1; slider_automate(slider26); updateSliders = 1; ) : checkChannelButtons(); );
                                    );
                                  );
                                );
                              );
                            );
                          );
                        );
                      );
                    );
                  );
                );
              );
            );
          );
        );
        );
         cap_mode=0;
         old_w=0;
       ) : (
         cap_mode = cap_drag = cap_timer = 0;
         store_a_button.hit_button(mouse_x,mouse_y,-1) ? ( copyTo = 1; showA = 1; ) :   
         store_b_button.hit_button(mouse_x,mouse_y,-1) ? ( copyTo = 2; showB = 1; ) :            
         freeze_button.hit_button(mouse_x,mouse_y,-1) ? ( slider44=1 - slider44; slider_automate(slider44); old_w = 0) :   
         options_button.hit_button(mouse_x,mouse_y,-1) ? ( slider42=!slider42; slider_automate(slider42); old_w = 0; ) :
         (
           slider42 == 0 ? (
              phase_button.hit_button(mouse_x,mouse_y,-1) ? ( slider3=!slider3; slider_automate(slider3); old_w = 0; );
              theme_button.hit_button(mouse_x,mouse_y,-1) ? ( slider43=!slider43; slider_automate(slider43); old_w = 0; );
              grid_button.hit_button(mouse_x,mouse_y,-1) ? ( slider39=!slider39; slider_automate(slider39); old_w = 0; );
              gridAlpha_button.hit_button(mouse_x,mouse_y,31);
            );
          );
         
         channels_button.hit_button(mouse_x,mouse_y,-1) ? ( slider41=!slider41; slider_automate(slider41); old_w = 0; ) :
         
         sonogram.hit_button(mouse_x,mouse_y,8+slider29);
         
         checkChannelButtons() ? : 
                 slider42 == 0 ? showSumButton.hit_button(mouse_x,mouse_y,-1) ? ( slider27=!slider27; slider_automate(slider27); updateSliders = 1; old_w = 0) :
                 slider42 == 0 ? floor_button.hit_button(mouse_x,mouse_y,1);
                 slider42 == 0 ? ceil_button.hit_button(mouse_x,mouse_y, 49);
                 slider42 == 0 ? slope_button.hit_button(mouse_x,mouse_y,29);
                 slider42 == 0 ? window_button.hit_button(mouse_x,mouse_y,2);
                 slider42 == 0 ? fft_button.hit_button(mouse_x,mouse_y,3);
                 slider42 == 0 ? integrate_button.hit_button(mouse_x,mouse_y,4); 
                 slider42 == 0 ? integration_type_button.hit_button(mouse_x, mouse_y, 46);
                 slider42 == 0 ? show_side_button.hit_button(mouse_x, mouse_y, 47);
                 slider42 == 0 ? diff_mode_button.hit_button(mouse_x, mouse_y, 48);
                 slider42 == 0 ? scaling.hit_button(mouse_x,mouse_y,5);
                 slider42 == 0 ? colormap.hit_button(mouse_x,mouse_y,7);              
                 slider42 == 0 ? smoothing_button.hit_button(mouse_x,mouse_y,6);
                 slider42 == 0 ? alphalevel.hit_button(mouse_x,mouse_y,28);
                 slider42 == 0 ? background_button.hit_button(mouse_x,mouse_y,30);                 
                 slider42 == 0 ? sonoScale.hit_button(mouse_x,mouse_y,10) ? :
                 slider42 == 0 ? smoothing_type.hit_button(mouse_x,mouse_y,45);
                
                 (      // Note that the sonogram condition works for capmode8 and 9 (sonogram / scope) since they are in the same position 
                    slider42 == 0 ? sonoLog.hit_button(mouse_x,mouse_y,-1) ? ( slider33=!slider33; slider_automate(slider33); updateSliders = 1; old_w = 0) :
                    slider42 == 0 ? sonogram_button.hit_button(mouse_x,mouse_y,-1) ? ( slider29=slider29+1; slider29>2?slider29=0; slider_automate(slider29); old_w = 0 ):
                    drawHz = 1;
                )                
          );
          
          ( (mouse_y > (gfx_h-sono_yoffset_bottom-sono_size-14)) && (mouse_y < (gfx_h-sono_yoffset_bottom-sono_size + 14)) ) ?
          (
            !(cap_mode > 10 && cap_mode < 27) ? (
              cap_mode = 60;
              cap_last_y = mouse_y;
            );
          );
    ) :
    cap_mode == 1 && cap_last_y != mouse_y ? (
      slider2 = drag_slider_precise(slider2, -450, -12, 0.2);
      old_w=0;
      slider_automate(slider2);
    ) :
    cap_mode == 49 && cap_last_y != mouse_y ? (
      scale_offset_db_user = drag_slider_precise(scale_offset_db_user, -48, 48, 0.1);
      old_w=0;
      slider_automate(scale_offset_db_user);
    ) :
    cap_mode == 2 && cap_last_y != mouse_y ? (
      slider4 = drag_slider(slider4, 0.0, 3.0, .03);
      old_w=0;
      slider_automate(slider4);
    ) :
    cap_mode == 46 && cap_last_y != mouse_y ? (
      maxIntegrate = drag_slider(maxIntegrate, 0.0, 1.0, .03);
      old_w=0;
      slider_automate(maxIntegrate);
    ) :
    cap_mode == 47 && cap_last_y != mouse_y ? (
      showSide = drag_slider(showSide, 0.0, 1.0, .03);
      old_w=0;
      slider_automate(showSide);
    ) :
    cap_mode == 48 && cap_last_y != mouse_y ? (
      displayMode = drag_slider(displayMode, 0.0, 1.0, .03);
      old_w=0;
      slider_automate(displayMode);    
    ) :
      cap_mode == 3 && cap_last_y != mouse_y ? (
      slider1 = drag_slider(slider1, 0.0, 11.0, .03);
      old_w=0;
      slider_automate(slider1);
    ) :
    cap_mode == 4 && cap_last_y != mouse_y ? (
      // Integration time
      slider5 = drag_slider_precise(slider5, 0.0, 25000.0, 5);
      old_w=0;
      slider_automate(slider5);
    ) :
    cap_mode == 5 && cap_last_y != mouse_y ? (
      // Scale
      slider6 = drag_slider_precise(slider6, 1.0, 6, .2);
      old_w=0;
      slider_automate(slider6);
    ) :
    cap_mode == 6 && cap_last_y != mouse_y ? (
      // Smoothing
      smoothing = drag_slider_precise(smoothing, 0.0, 100, 1);
      old_w=0;
      slider_automate(smoothing);
    ) :
    cap_mode == 7 && cap_last_y != mouse_y ? (
      // Colormap
      slider8 = drag_slider(slider8, 0.01, 14, .03);
      old_w=0;
      slider_automate(slider8);
    ) :
    cap_mode == 8 && cap_last_y != mouse_y ? (
      // Sonogram
      slider30 = drag_slider(slider30, 0, 15000, 100);
      old_w=0;
      slider_automate(slider30);
    ) :
    cap_mode == 9 && cap_last_y != mouse_y ? (
      // Signal
      slider31 = drag_slider_precise(slider31, .1, 3, .03);
      old_w=0;
      slider_automate(slider31);
    ) :
    cap_mode == 10 && cap_lasty_y != mouse_y ? (
      // Sono scaling
      slider35 = floor(drag_slider_precise(slider35, 1, 8, .1));
      old_w=0;
      slider_automate(slider35);
    ) :
    cap_mode == 28 && cap_lasty_y != mouse_y ? (
      // Alpha level
      slider37 = drag_slider_precise(slider37, 0, 1, .025);
      old_w=0;
      slider_automate(slider37);
    ) :
    cap_mode == 29 && cap_lasty_y != mouse_y ? (
      slider38 = drag_slider_precise(slider38, 0,9,.25);
      old_w=0;
      slider_automate(slider38);      
    ) :
    cap_mode == 30 && cap_lasty_y != mouse_y ? (
      // Alpha level
      slider10 = drag_slider_precise(slider10, 0, 1, .025);
      old_w=0;
      slider_automate(slider10);
    ) :
    cap_mode == 31 && cap_lasty_y != mouse_y ? (
      // Grid Alpha
      slider40 = drag_slider_precise(slider40, 0, 1, .025);
      old_w=0;
      slider_automate(slider40);
    ) :
    cap_mode == 60 && cap_lasty_y != mouse_y ? (
      sono_frac = (1-(mouse_y+sono_yoffset_bottom)/gfx_h);
    ) : cap_mode == 45 && cap_last_y != mouse_y ? (
      slider45 = drag_slider(slider45, 0.0, 4.0, .03);
      old_w=0;
      slider_automate(slider45);
    );
) : (
  // RMB
  
  drawHz = 0;
  (last_mouse_cap & 1) && !cap_drag ? (
    cap_mode == 2 ? (
    slider4 = cycle_slider(slider4, 0.0, 3.0, 1.0);
      old_w=0;
      slider_automate(slider4);
    );
    cap_mode == 3 ? (
      slider1 = cycle_slider(slider1, 0.0, 11.0, 1.0);
      old_w=0;
      slider_automate(slider1);
    );
    cap_mode == 45 ? (
      slider45 = cycle_slider(slider45, 0.0, 4.0, 1.0);
      old_w=0;
      slider_automate(slider45);
    );
    cap_mode == 46 ? (
      maxIntegrate = cycle_slider(maxIntegrate, 0.0, 1.0, 1.0);
      old_w=0;
      slider_automate(maxIntegrate);
    );
    cap_mode == 47 ? (
      showSide = cycle_slider(showSide, 0.0, 1.0, 1.0);
      old_w=0;
      slider_automate(showSide);
    );
    cap_mode == 48 ? (
      displayMode = cycle_slider(displayMode, 0.0, 1.0, 1.0);
      old_w=0;
      slider_automate(displayMode);
    );
  );
);

function DrawButtons()
(
    buttonPad = 3;
    
    gfx_measurestr(" >A", storeAX, freezeY);
    gfx_measurestr(" >A >B", storeBX, freezeY);    
    frstr = slider44 == 1 ? "Unfreeze" : "Freeze";
    gfx_measurestr(frstr, freezeX, freezeY);
    freeze_button.draw_button(freezeX+8, 3, frstr);
    
    gfx_measurestr(">", addX, freezeY);
    freezeX = freezeX + addX;
    storeAX = storeAX + freezeX;
    storeBX = storeBX + freezeX;
    store_a_button.draw_button(storeAX, 3, ">A");
    store_b_button.draw_button(storeBX, 3, ">B");
    
    // hide buttons
    gfx_measurestr("| <- |", arrowX, arrowY);
    arrowY = gfx_h-arrowY - 14;
    channels_button.draw_button(arrowX + 8, arrowY, slider41 ?"| -> |" : "| <- |");
    postOptions = options_button.draw_button(gfx_w - 10, 3, slider42 ?"<<:: OPTIONS ::" : ">>:: OPTIONS ::");
    gfx_x -= 8;
    optBar = gfx_x;
    
    gfx_y = 8;
    slider42 == 0 ? (
      fft_button.str_add_measure("FFT 32768");
      fft_button.draw_button_wrap(gfx_y, sprintf(#,"FFT: %d",16<<slider1), storeBX);
      window_button.str_add_measure("Blackman-Harris");
      window_button.draw_button_wrap(gfx_y, 
                        (slider4|0)==1 ? "Hamming" :  
                        (slider4|0)==2 ? "Blackman-Harris" :
                        (slider4|0)==3 ? "Blackman" : 
                        (slider4|0)==4 ? "Rectangular":
                          "Flat-top", storeBX);
    
      floor_button.str_add_measure("Floor: 888.8 dB");
      floor_button.draw_button_wrap(gfx_y, sprintf(#,"Floor: %.1fdB", slider2), storeBX);
      ceil_button.str_add_measure("Ceil: 88.8 dB");
      ceil_button.draw_button_wrap(gfx_y, sprintf(#,"Ceil: %.1fdB", -scale_offset_db_user + .00000000001), storeBX);
      slope_button.str_add_measure("Slope: 8.8 dB/oct");
      slope_button.draw_button_wrap(gfx_y, sprintf(#,"Slope: %.1fdB/oct", slider38), storeBX);
      smoothing_button.str_add_measure("Smooth: 888.8");
      smoothing_button.draw_button_wrap(gfx_y,sprintf(#,"Smooth: %.1f",smoothing), storeBX);
      smoothing_type.str_add_measure("Average");
      smoothing_type.str_add_measure("Maximum");
      smoothing_type.str_add_measure("LOESS");
      smoothing_type.str_add_measure("Adaptive");
      smoothing_type.draw_button_wrap(gfx_y, 
                        (slider45|0)==0 ? "Average" :  
                        (slider45|0)==1 ? "Maximum" :
                        (slider45|0)==2 ? "LOESS" : 
                        (slider45|0)==3 ? "Adaptive" :
                          "Fast", storeBX);
                          
      integrate_button.str_add_measure("Maxtime: 888ms");
      integrate_button.str_add_measure("Integrate: 8888ms");
      maxIntegrate ? ( 
        integrate_button.draw_button_wrap(gfx_y, sprintf(#,"Maxtime: %dms",slider5|0), storeBX);
      ) : (
        integrate_button.draw_button_wrap(gfx_y, sprintf(#,"Integrate: %dms",slider5|0), storeBX);      
      );
      
      integration_type_button.str_add_measure("Max");
      integration_type_button.str_add_measure("Int");
      integration_type_button.draw_button_wrap(gfx_y, maxIntegrate ? "Max" : "Int", storeBX);
      show_side_button.str_add_measure("Mid/Side");
      show_side_button.draw_button_wrap(gfx_y, showSide ? "Mid/Side" : "Mono", storeBX);
      diff_mode_button.str_add_measure("Diff (BETA)");
      diff_mode_button.draw_button_wrap(gfx_y, displayMode ? "Diff (BETA)" : "Normal", storeBX);      
    );
          
  gfx_measurestr("^^:: THEMES ::^^", themeW, themeH);
  yShift = themeH + 18;
    slider42 == 0 ? theme_button.draw_button(gfx_w -10, arrowY, slider43 ?"<<:: THEMES   ::" : "^^:: THEMES ::^^");
    slider42 == 0 ? slider43 == 1 ? alphalevel.draw_button(gfx_w - 10, arrowY - yShift, sprintf(#,"Ch.Color(a): %.1f",slider37));
    slider42 == 0 ? slider43 == 1 ? background_button.draw_button(gfx_w - 10, arrowY - 2*yShift, sprintf(#,"Bg Color:    %.1f",slider10));
    slider42 == 0 ? slider43 == 1 ? colormap.draw_button(gfx_w - 10, arrowY - 3*yShift, 
      (slider8|0)==0 ? "Theme:      Dark":  
      (slider8|0)==1 ? "Theme:   Intense":
      (slider8|0)==2 ? "Theme:      Fluo":
      (slider8|0)==3 ? "Theme:Colorblind":  
      (slider8|0)==4 ? "Theme:      Pimp":
      (slider8|0)==5 ? "Theme:    Shades":
      (slider8|0)==6 ? "Theme:     Fancy":  
      (slider8|0)==7 ? "Theme:    Pastel":
      (slider8|0)==8 ? "Theme:    Purple":
      (slider8|0)==9 ? "Theme:     Dark2":
      (slider8|0)==10 ? "Theme:     Dark3":  
      (slider8|0)==11 ? "Theme:     Dark4":
      (slider8|0)==12 ? "Theme:     Dark5":
      (slider8|0)==13 ? "Theme:Colorblind2":
      (slider8|0)==14 ? "Theme:    Smooth":
      "Theme:    Tracks"); 
    
  slider42 == 0 ? slider43 == 1 ? yShift = yShift*4;
 
    gmem[0] > 0 ? (
      // Reset channel names
      setChannelNames();
      gmem[0] == 2 ? (
        // Back up current user colortheme
        cref_bak = slider8 != 15 ? slider8 : cref_bak;
        // Change to track colortheme
        sliderchange(slider8 = 15);
        cref = (10000 + 100*floor(slider8));
        // Set default colors to dark gray
        cidx = 0;
        while (cidx < 16*3) (
          cref[cidx] = 0.13;
          cidx = cidx + 1;
        );
      ) :
      cref_bak > 0 && slider8 == 15 ? (
        // Restore user colortheme
        sliderchange(slider8 = cref_bak);
      );
      cidx = 0;
      addr = 1;
      chName = 0;
      while (gmem[addr] != 0) (
        gmem[0] == 2 ? (
          // Load RGB color to track colortheme
          cref[cidx+0] = gmem[addr+0] / 255;
          cref[cidx+1] = gmem[addr+1] / 255;
          cref[cidx+2] = gmem[addr+2] / 255;
          cidx = cidx + 3;
          addr = addr + 3;
        );
        // Change channel name to track name
        sOffs = 0;
        while (gmem[addr] != 0) (
          str_setchar(chName, sOffs, gmem[addr], 'c');
          sOffs = sOffs + 1;
          addr = addr + 1;
        );
        str_setlen(chName, min(10, sOffs));
        chName = chName + 1;
        addr = addr + 1;
      );
      trCnt = chName;
      update = 1;
      gmem[0] = 0;
    );
    
    gfx_measurestr("Ch16", chW, chH);
    chButtonPad = !trCnt ? 8 : 10;
    chButtonWidth = !trCnt ? chW + 10 : chW + 58;
    chButtonSpace = chButtonWidth+chButtonPad;
    chButtonYSpace = chH + 24;
    totalButtonWidth = !trCnt ? 18 * chButtonSpace : (trCnt + 2) * chButtonSpace;
    xButBlocked = max(spectrum_xpad, theme_button.w+8);
    slider41 == 0 ?(
      gfx_w > ( totalButtonWidth + xButBlocked + arrowX + 8 ) ? (
      
        chB.draw_button2_fixedWidth(gfx_w/2 -xButBlocked*0.5 + .5*totalButtonWidth + .5*arrowX, arrowY, chButtonWidth, "MemB", showB, 0, 0, 0, 15);
        chA.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, "MemA", showA, 0, 0, 0, 15);
       
        !trCnt || trCnt > 15 ? ch16.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[15], slider26, slider28==15, slider36==15, slider36>-1, 15);     
        !trCnt || trCnt > 14 ? ch15.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[14], slider25, slider28==14, slider36==14, slider36>-1, 14);     
        !trCnt || trCnt > 13 ? ch14.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[13], slider24, slider28==13, slider36==13, slider36>-1, 13);     
        !trCnt || trCnt > 12 ? ch13.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[12], slider23, slider28==12, slider36==12, slider36>-1, 12);     
        !trCnt || trCnt > 11 ? ch12.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[11], slider22, slider28==11, slider36==11, slider36>-1, 11);            
        !trCnt || trCnt > 10 ? ch11.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[10], slider21, slider28==10, slider36==10, slider36>-1, 10);     
        !trCnt || trCnt > 9  ? ch10.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[9],  slider20, slider28==9,  slider36==9,  slider36>-1, 9);     
        !trCnt || trCnt > 8  ?  ch9.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[8],  slider19, slider28==8,  slider36==8,  slider36>-1, 8);
             
        !trCnt || trCnt > 7  ?  ch8.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[7], slider18, slider28==7, slider36==7, slider36>-1, 7);     
        !trCnt || trCnt > 6  ?  ch7.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[6], slider17, slider28==6, slider36==6, slider36>-1, 6);             
        !trCnt || trCnt > 5  ?  ch6.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[5], slider16, slider28==5, slider36==5, slider36>-1, 5);            
        !trCnt || trCnt > 4  ?  ch5.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[4], slider15, slider28==4, slider36==4, slider36>-1, 4);     
        !trCnt || trCnt > 3  ?  ch4.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[3], slider14, slider28==3, slider36==3, slider36>-1, 3);     
        !trCnt || trCnt > 2  ?  ch3.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[2], slider13, slider28==2, slider36==2, slider36>-1, 2);     
        !trCnt || trCnt > 1  ?  ch2.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[1], slider12, slider28==1, slider36==1, slider36>-1, 1);     
        !trCnt || trCnt > 0  ?  ch1.draw_button2_fixedWidth(gfx_x-=8, arrowY, chButtonWidth, chNames[0], slider11, slider28==0, slider36==0, slider36>-1, 0);     
                              
        
      ) : (
        slider42 != 0 ?(
          yBStart = 6 * chButtonYSpace + chH + postOptions + 24; // + 24 = Small fix? Avoid channel buttons overlapping with options
        ) : (
          yBStart = gfx_h - yShift - chButtonYSpace;
        );
        
        bRowCol1 = gfx_w-10;
        bRowCol2 = gfx_w-10-chButtonWidth-chButtonPad;
        
        chB.draw_button2_fixedWidth(bRowCol1 , yBStart, chButtonWidth, "MemB",  showB, 0, 0, 0, 7);
        ch16.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[15], slider26, slider28==15, slider36==15, slider36>-1, 15);
        ch15.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[14], slider25, slider28==14, slider36==14, slider36>-1, 14);
        ch14.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[13], slider24, slider28==13, slider36==13, slider36>-1, 13);
        ch13.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[12], slider23, slider28==12, slider36==12, slider36>-1, 12);
        ch12.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[11], slider22, slider28==11, slider36==11, slider36>-1, 11);
        ch11.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[10], slider21, slider28==10, slider36==10, slider36>-1, 10);
        ch10.draw_button2_fixedWidth(bRowCol1 , gfx_y-chButtonYSpace, chButtonWidth, chNames[9],  slider20, slider28==9,  slider36==9,  slider36>-1, 9);
        ch9.draw_button2_fixedWidth(bRowCol1 ,  gfx_y-chButtonYSpace, chButtonWidth, chNames[8],  slider19, slider28==8,  slider36==8,  slider36>-1, 8);

        chA.draw_button2_fixedWidth(bRowCol2 , yBStart, chButtonWidth, "MemA",  showA, 0, 0, 0, 7);
        ch8.draw_button2_fixedWidth(bRowCol2 , gfx_y-chButtonYSpace, chButtonWidth, chNames[7],  slider18, slider28==7,  slider36==7,  slider36>-1, 7);
        ch7.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[6],  slider17, slider28==6,  slider36==6,  slider36>-1, 6);
        ch6.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[5],  slider16, slider28==5,  slider36==5,  slider36>-1, 5);
        ch5.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[4],  slider15, slider28==4,  slider36==4,  slider36>-1, 4);
        ch4.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[3],  slider14, slider28==3,  slider36==3,  slider36>-1, 3);
        ch3.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[2],  slider13, slider28==2,  slider36==2,  slider36>-1, 2);
        ch2.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[1],  slider12, slider28==1,  slider36==1,  slider36>-1, 1);
        ch1.draw_button2_fixedWidth(bRowCol2,  gfx_y-chButtonYSpace, chButtonWidth, chNames[0],  slider11, slider28==0,  slider36==0,  slider36>-1, 0);
      )
    );
    slider42 == 0 ?
    (
      gfx_measurestr("Log(Sonogram)", sonoTxtW, sonoTxtH);
      gfx_measurestr("<  Sonogram  |", hideTxtW, sonoTxtH);
      postOptions = showSumButton.draw_button2_fixedWidth(gfx_w-10, postOptions+2*buttonPad, hideTxtW, "SUM", slider27, slider28==-1, 0, 0, -1);
      postOptions = phase_button.draw_button2_fixedWidth(gfx_w-10,postOptions+buttonPad, hideTxtW, "Phase", slider3, slider3>1, slider3== 2, slider3>-1, -1);
      postOptions = grid_button.draw_button2_fixedWidth(gfx_w-10, postOptions+buttonPad, hideTxtW, "GRID", slider39, slider39>1, slider39== 2, slider39>-1, -1);

      slider39 == 1 ? ( postOptions = gridAlpha_button.draw_button_fixedWidth(gfx_w-10, postOptions+buttonPad, hideTxtW, sprintf(#,"^ Alpha: %.1f ^" ,slider40)) );
      
      postSono = sonogram_button.draw_button_fixedWidth(gfx_w-10, postOptions + 4*buttonPad, hideTxtW, slider29==1?">>   Hide   >>" : slider29==0?"<    Time    >" : "<  Sonogram  |");
      slider29 == 0 ? ( sonoLog.draw_button2_fixedWidth(gfx_w-10, postSono+buttonPad, hideTxtW, "Log(Sonogram)", slider33, 0, 0, 0, -1) );
    );
);

function updateSpectralBounds()
(
  slider29 == 2 ? sono_size = 0 : sono_size = sono_frac*gfx_h;

  // SET THE OFFSETS HERE
  spectrum_yoffset = 25 * (1 - hideUI);
  ( slider42 == 0 ) ? (
    spectrum_xpad = 150 * (1 - hideUI);
    sono_yoffset_bottom = 35;
    spectrum_yoffsetbottom = sono_yoffset_bottom + sono_size;
    spectrum_xmax = gfx_w - spectrum_xpad;
  ) : (
    spectrum_xpad = 0;
    sono_yoffset_bottom = 35;
    spectrum_yoffsetbottom = sono_yoffset_bottom + sono_size;
    spectrum_xmax = gfx_w - spectrum_xpad;
  );
  
  ( slider41 == 0 ) ? (
    sono_yoffset_bottom = 30;
    spectrum_yoffsetbottom = sono_yoffset_bottom + sono_size;    
  ) : (
    sono_yoffset_bottom = 6;
    spectrum_yoffsetbottom = sono_yoffset_bottom + sono_size;
  );
  
  spectrum_center = spectrum_yoffset - spectral_offset_pixels;

  scaling = slider6;
  bgcolor = slider10;
);

function sub(mem1, mem2, size)
local()
global()
instance()
(
  loop(size,
    mem1[] -= mem2[];
    mem1 += 1;
    mem2 += 1;
  );
);

function drawDifferenceSpectra(rpos, fftw, ibuf, shft, hsiz)
global(maxchannels, activechannels, isActive,
       showSide,
       fftsize
       filtout,
       xscale, kernelSize,
       slider8, ss)
local(j,
      first, second,
      from, to,
      rr, gg, bb,
      ccolor, cref)
(
  first = -1;
  second = -1;
  isActive = activechannels;
  from = 0;
  to = 0;
  j = 0;
  
  loop(maxchannels,
    (isActive[j] == 1) ? (
      (first == -1) ? (
        first = j;
      ) : ( second == -1 ) ? (
        second = j;
      );
    );
    j += 1;    
  );
  
  cref = (10000 + 100*floor(slider8));
  ccolor   = cref;
  
  (first > -1) && (second > -1) ? (
    showSide ? processFFTDifference((rpos + maxchannels)[first], (fftw + maxchannels)[first], (ibuf + maxchannels)[first], (shft + maxchannels)[first], (hsiz + maxchannels)[first],
                                    (rpos + maxchannels)[second], (fftw + maxchannels)[second], (ibuf + maxchannels)[second], (shft + maxchannels)[second], (hsiz + maxchannels)[second],
                                    ccolor[0], ccolor[1], ccolor[2], 1, 2);
  
    processFFTDifference(rpos[first], fftw[first], ibuf[first], shft[first], hsiz[first],
                         rpos[second], fftw[second], ibuf[second], shft[second], hsiz[second],
                         ccolor[0], ccolor[1], ccolor[2], 1, 1);
  );
);

function drawSpectra(rpos, fftw, ibuf, shft, hsiz)
global(slider8, slider36, slider45,
       maxchannels, showSide, activechannels, showSum, copyTo, bgcolor,
       sumposr, fftwr, ibufr, sumshr, sumhsr,
       sumposl, fftwl, ibufl, sumshl, sumhsl
       fftw, ibuf, shft, hsiz, rpos,
       memA, memA2, memB, memB2,
       filtout,
       showA, showB,
       M_BLOCK_SIZE,
       kernelSize, fftsize, xscale,
       sModeA, kernelSizeA, fftSizeA, xScaleA,
       sModeB, kernelSizeB, fftSizeB, xScaleB)
local(jl, incr, cref, ccolor, jl, isActive, halfShade, shade)
instance()
(
  incr  = 3;
  cref = (10000 + 100*floor(slider8));
  
  ccolor   = cref;
  jl       = 1;
  isActive = activechannels;
  loop(maxchannels,
    (isActive[] == 1) ? (
      ( slider36 < 0 || ( slider36 == (jl-1) ) ) ? (
        showSide ? processFFT((rpos+maxchannels)[], (fftw+maxchannels)[], (ibuf+maxchannels)[], (shft+maxchannels)[], (hsiz+maxchannels)[], ccolor[0], ccolor[1], ccolor[2], 1, 2);
        processFFT(rpos[], fftw[], ibuf[], shft[], hsiz[], ccolor[0], ccolor[1], ccolor[2], 1, 1);
      );
    );
    
    rpos     += 1;
    fftw     += 1;
    ibuf     += 1;
    shft     += 1;
    hsiz     += 1;
    
    jl       += 1;
    ccolor   += incr;
    isActive += 1; 
  );

  showSum || copyTo ? (
    halfshade = 0.3 * bgcolor + 0.7 * ( 1-bgcolor );
    shade = 1-bgcolor;
    processFFT(sumposr, fftwr, ibufr, sumshr, sumhsr, halfshade, halfshade, halfshade, 0, 1);
    
    (copyTo == 1) ? memcpy(memA2, filtout, 65536);
    (copyTo == 2) ? memcpy(memB2, filtout, 65536);
    (copyTo == 2) ? memcpy(memB2, filtout, 65536);
    
    processFFT(sumposl, fftwl, ibufl, sumshl, sumhsl, shade, shade, shade, 0, 1);
    
    copyTo == 1 ? (
      memcpy(memA, filtout, M_BLOCK_SIZE);
      copyTo = 0;
      sModeA = floor(slider45);
      kernelSizeA = kernelSize;
      fftSizeA = fftsize;
      xscaleA = xscale;
    );
    
    copyTo == 2 ? (
      memcpy(memB, filtout, M_BLOCK_SIZE);
      copyTo = 0;
      sModeB = floor(slider45);
      kernelSizeB = kernelSize;
      fftSizeB = fftsize;
      xscaleB = xscale;
    );
  );
  
  showA ? (
    memcpy(filtout, memA, M_BLOCK_SIZE);
    prepareForDrawing(filtout, sumposl, fftwl, ibufl, sumshl, sumhsl, .5, .5, .5, 1, 1, fftsizeA, xscaleA, sModeA, kernelSizeA);
    memcpy(filtout, memA2, M_BLOCK_SIZE);
    prepareForDrawing(filtout, sumposl, fftwl, ibufl, sumshl, sumhsl, .5, .5, .5, 1, 1, fftsizeA, xscaleA, sModeA, kernelSizeA);
  );
  
  showB ? (
    memcpy(filtout, memB, M_BLOCK_SIZE);
    prepareForDrawing(filtout, sumposl, fftwl, ibufl, sumshl, sumhsl, .5, .5, .5, 1, 1, fftsizeB, xscaleB, sModeB, kernelSizeB);
    memcpy(filtout, memB2, M_BLOCK_SIZE);
    prepareForDrawing(filtout, sumposl, fftwl, ibufl, sumshl, sumhsl, .5, .5, .5, 1, 1, fftsizeB, xscaleB, sModeB, kernelSizeB);
  );
);


cap_mode && cap_timer < 12 ? cap_timer += 1;
last_mouse_cap = mouse_cap;

UI_SCREEN = 1;

// Force updates when mouse activity is registered
mouse_cap > 0 ? (
  update = 1;
);

// only update if new fft data is there or if the size changed
( update == 1 || old_w != gfx_w || old_h!=gfx_h ) ? (
  update = 0;
  
  noRenderBuffer ? (
    gfx_dest = -1;
  ) : (
    gfx_dest = UI_SCREEN;
    gfx_setimgdim(UI_SCREEN, gfx_w, gfx_h);
  );
  gfx_clear = 0;

  //gfx_dest = scroll_buf;
  old_w=gfx_w; old_h=gfx_h;
  
  // Clear screen
  gfx_r=gfx_g=gfx_b=bgcolor -0; gfx_a=1.0;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w,gfx_h);
  logdb_to_pixels=(gfx_h - spectrum_yoffset - spectrum_yoffsetbottom)/(-slider2);
  logf_to_pixels=logdb_to_pixels*20/log(10);
  scale_offset_db = scale_offset_db_user;
  displayMode == 1 ? scale_offset_db += 0.5 * slider2;
  spectral_offset_pixels = scale_offset_db * logdb_to_pixels;
  
  latencyLength = fftSize;
  ( latencyCompensation == 0 ) ? latencyLength = 0;
  
  ( pdc_delay != latencyLength ) ? (
    pdc_top_ch = num_ch;
    pdc_delay = latencyLength;
  );
  
  integrate_sc = 1;
  slider5 > 0 ? (
    integrate_now = time_precise();
    integrate_en ? (
      // fps = 1/(integrate_now - integrate_lastt);
      integrate_sc -= exp(-5 * 1000.0 * (integrate_now - integrate_lastt) / slider5);
    ) : (
      // force overwrite of buffer
      integrate_en = 1;
    );
    integrate_lastt = integrate_now;
  ) : (
    integrate_en = 0;
  );

  fftidx != (slider1|0) ? (
    fftidx=slider1|0;
    fftsize=2^(min(max(fftidx,0),11)+4);
    integrate_sc=1;
  );

  windowsize != fftsize || windowtype != (slider4|0) ? (
    windowtype=slider4|0; 
    windowsize=fftsize;
    dwindowpos = $pi*2/fftsize;
    i=pwr=0;
    loop(fftsize*.5+1,
       windowpos=i*dwindowpos;
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
    integrate_sc=1;
  );

  displayMode == 0 ? drawSpectra(recpositions, fftworkspaces, integrate_bufs, shifts, histsizes)
  : displayMode == 1 ? drawDifferenceSpectra(recpositions, fftworkspaces, integrate_bufs, shifts, histsizes);
  
  ( zoomMode == 1 ) ? (
    gfx_r = gfx_g = gfx_b = gfx_a = 1.0;
    gfx_line( old_mouse_x, old_mouse_y, mouse_x, old_mouse_y );
    gfx_line( old_mouse_x, old_mouse_y, old_mouse_x, mouse_y );
    gfx_line( old_mouse_x, mouse_y, mouse_x, mouse_y );
    gfx_line( mouse_x, old_mouse_y, mouse_x, mouse_y );
  );
  
  // Note: slider34 can still be used to detect clicks on the sono
  gfx_r = gfx_g = gfx_b = 1;
  gfx_a = 1;

  sigw = 1;// - spectrum_xpad/gfx_w; // <== Note: If you want the width to keep the bar free, uncomment this!
  sigh = sono_size/gfx_h;
  selected = slider28;
  
  gfx_x = 0;  
  gfx_y = gfx_h-sono_yoffset_bottom-sono_size;
  ( slider29 == 1 ) ? (
    // Time window
    ( selected > -1 ) ? (
      ( slider34 == 0 ) ? (
        scope.drawSignal( gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, shifts[selected], slider31, histsizes[0] - shifts[0], cref[], cref[1], cref[2] );  
      ) : (
        scope.drawMovingSignal( gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, recpositions[selected], histsizes[selected], shifts[selected], slider31, histsizes[0] - shifts[0], cref[], cref[1], cref[2] );  
      );

      gfx_r=gfx_g=gfx_b=1.0-bgColor;
      gfx_y = gfx_h-sono_yoffset_bottom-sono_size + 5;
      gfx_x = 5;
      gfx_printf( "Ch %d", selected + 1 );
    ) : (
      ( slider34 == 0 ) ? (
        scope.drawSignal( gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, sumshl, slider31, histsizes[0] - shifts[0], cref[4], cref[5], cref[6] );  
        scope.drawSignal( gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, sumshr, slider31, histsizes[0] - shifts[0], cref[], cref[1], cref[2] );
      ) : (
        sll = sumposl; srr= sumposr;
        scope.drawMovingSignal( gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, sll, sumhsl, sumshl, slider31, histsizes[0] - shifts[0], cref[4], cref[5], cref[6] );
        scope.drawMovingSignal( gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, srr, sumhsr, sumshr, slider31, histsizes[0] - shifts[0], cref[], cref[1], cref[2] );
      );    
    
      gfx_r=gfx_g=gfx_b=1.0-bgColor;      
      gfx_y = gfx_h-sono_yoffset_bottom-sono_size + 5;
      gfx_x = 5;
      gfx_printf( "Sum" );
    );
  ) : ( slider29 == 0 ) ? (
    // Sonogram
    
    cmapidx = (floor(slider32/2) + 1);
    invert = slider32 - (floor(slider32/2))*2;
    ( selected > -1 ) ? (
      // Make sure that the sonogram is still updated if it's not currently being rendered.       
      ( activeChannels[selected] == 0 ) ? (
        processFFT(recpositions[selected], fftworkspaces[selected], integrate_bufs[selected], shifts[selected], histsizes[selected], ccolor[0], ccolor[1], ccolor[2], 1, 0);
      );
      sonogram.drawSono( fftworkspaces[selected], cmapidx * 2000, invert, slider30, gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, slider33, slider35 );
      gfx_mode = 1;
      gfx_r = gfx_g = gfx_a = 1.0;
      gfx_y = gfx_h-sono_yoffset_bottom-sono_size + 5;
      gfx_x = 5;
      gfx_printf( "Ch: %d, Sc: %d", selected + 1, slider30 );
    ) : (
      ( showSum == 0 ) ? (
        // Make sure that the sonogram is still updated if it's not currently being rendered.
        processFFT(sumposr, fftwr, ibufr, sumshr, sumhsr, halfshade, halfshade, halfshade, 0, 0);  
        processFFT(sumposl, fftwl, ibufl, sumshl, sumhsl, shade, shade, shade, 0, 0);
      );
    
      sonogram.drawSono( fftwr, cmapidx * 2000, invert, slider30, gfx_x, gfx_y, sigw*gfx_w, sigh*gfx_h, slider33, slider35 );    
      gfx_mode = 0;
      !hideUI ? (
        gfx_r = gfx_g = gfx_a = 1.0;
        gfx_y = gfx_h-sono_yoffset_bottom-sono_size + 5;
        gfx_x = 5;
        gfx_printf( "Sum, Sc: %d", slider30 );
      );
    );
    !hideUI ? (
      gfx_measurestr("Sum. Sc: 123456789", junk, tSkip);
      gfx_y = gfx_h-sono_yoffset_bottom-sono_size + 5 + tSkip;
      gfx_x = 5;
      
      printColorMapName(cmapidx, invert);
    );
    gfx_mode = 0;
  );
  
  drawGrid();
  !hideUI ? DrawButtons();
  updateSpectralBounds();
  gfx_r=gfx_g=gfx_b=gfx_a=1.0;
  
  !noRenderBuffer ? (
    gfx_dest = -1;
    gfx_x = 0;
    gfx_y = 0;
    gfx_blit(UI_SCREEN, 1, 0);
  );
  
  ( drawHz == 1 ) ? (
    gfx_r = gfx_g = gfx_b = 1 - bgColor;
    gfx_a = 1.0;
    gfx_x = mouse_x + 10;
    gfx_y = mouse_y;
    
    f = (1/800) * ( exp(mouse_x/wsc)-1 ) * srate + spectrum_xoffset * srate;
    y = -20 * ( (mouse_y - spectrum_yoffset + spectral_offset_pixels) / logf_to_pixels ) / log(10);   
    
    gfx_printf("%dHz %gdB", f, y); 
  );

  lchar == 13 && gfx_getchar() == 0 ? hideUI = 1 - hideUI;
  lchar = gfx_getchar();

  // Finished
  update = 1;
);
