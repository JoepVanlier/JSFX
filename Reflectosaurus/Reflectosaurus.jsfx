desc:Saike Reflectosaurus (work in progress | do not use)
tags: multi-tap delay plugin
version: 0.06
author: Joep Vanlier
changelog: Added mute/solo
license: MIT

slider1:drywet=1.0<0,1,.001>Dry/Wet
slider2:SyncMode=0<0,1,4{Off,Fourth,Third,Fifth>Sync Mode
slider3:Snap=0<0,1,1{Off,On}>Snap

@init
function updateRange()
(
  SyncMode ? (
    maxTime = 4*tempo/60;
    minTime = 0;
  ) : (
    minTime = 4/100;
    maxTime = 4;
  );
);
updateRange();

function initWindow(_x, _y, _w, _h)
  local()
  global()
  instance(x, y, w, h)
  (
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function resetBuffer()
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    memset(scopebuffer, 0, scopebuffermax - scopebuffer + 1);
  );
  
function initBufferLen(scopebuffer_in, bufferlen)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffer + bufferlen;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );  
  
function draw_buffer(x, y, w, h, mul, fill)
  instance(scopeptr, scopebuffer, scopebuffermax)
  globals(gfx_x, gfx_y)
  local(len, scopeptr2, lx, ly, xx, dx, lptr, yy, lastx, lasty, isc, yref)
  (
    xx = x;
    len = scopebuffermax-scopebuffer;
    dx = floor(len/w);
    scopeptr2 = scopeptr;
    
    lptr = floor((scopeptr2)/dx)*dx;
    gfx_x = xx;
    gfx_y = y+h;
    isc = h;
    yref = y+h;
    ly = y+h;
    loop((scopebuffermax-scopeptr2)/dx - 1,
      yy = yref - h*min(1,lptr[]);
      
      lptr += dx;
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
    
    lptr = floor((scopebuffer)/dx)*dx;
    loop((scopeptr2 - scopebuffer)/dx - 1,
      lptr += dx;
      yy = yref - h*min(1,lptr[]);
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
  );  
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
   
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 2;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    readptr -= 1;
    
    c2 * (1.0-frac) + c1 * frac
  );
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );
  
function f_trafo(freq)
  local()
  global(slider54, legacyCutoff)
  instance()
  (
    exp( (1-freq) * log(20/22050) ) * $pi / (max(1,slider54));
  );


function init_linearSVF(freq, res)
  global(srate, slider54)
  local(g)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    g = tan(.5 * f_trafo(freq));
    k = 2 - 2*res;
    
    a1 = 1/(1+g*(g+k));
    a2 = g*a1;
    a3 = g*a2;
  ); 

function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );
  
function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2
  );  
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );  
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );

function xToTime(x)
  global(mintime, maxtime, xmin, xmax, srate, SyncMode)
  local()
  (
    SyncMode > 0 ? (
      maxTime * x + minTime;
    ) : ( 
      (maxTime/1024) * 2^(10*x)
    );
  );

function log2(x)
  local()
  global()
  (
    log(x)/log(2)
  );

function timeToX(dtime)
  global(mintime, maxtime, xmin, xmax, SyncMode)
  local()
  (
    SyncMode ? (
      (dTime - minTime) / maxTime
    ) : (
      log2( ( dTime * 1024 ) / maxTime )/10;
    );
  );
  
function yToVol(y)
  global(minvol, maxvol, ymin, ymax)
  local()
  (
    // Same as 10^(-30*dB/20)
    exp(-1.5*y*log(10)) 
  );
  
function updateNode()
  local(newdtime)
  global(srate, MAX_MOVE)
  instance(diff, buffer, tx, x, y, dtime, vol, pan, panlast, lPanTerm, rPanTerm, lpl, hpl, lpr, hpr, lpf, hpf, llpf, lhpf, fb, fbcoeff, xlast, ylast, fblast, olddtime, mute)
  (
    y > 1 ? y = 1;
    x > 1 ? x = 1;
    y < 0 ? y = 0;
    x < 0 ? x = 0;
  
    newdtime = .00005 * 2 * srate * dtime + 0.99995*olddtime;
    diff = olddtime - newdtime;
    ( abs( diff ) > .001 ) ? (
      buffer.setOffset(newdtime); 
    );
    olddtime = newdtime;
  
    ( !mute ) ? (
      ( y != ylast ) ? ( vol   = yToVol(y);  ylast = y; );
      ( fb != fblast ) ? ( fbcoeff = .95*exp( -4 * ( 1 - fb ) ) );  
      ( pan != panlast ) ? ( lPanTerm = cos($pi*pan/2); rPanTerm = sin($pi*pan/2); panlast = pan; );     
    
      (lpf < 1.0 && lpf != llpf ) ? ( lpl.init_linearSVF(lpf, 0); lpr.init_linearSVF(lpf, 0); llpf = lpf; );
      (hpf > 0.0 && hpf != lhpf ) ? ( hpl.init_linearSVF(hpf, 0); hpr.init_linearSVF(hpf, 0); lhpf = hpf; );
    );
  );

function process(l_in, r_in)
  local(l, r)
  global(lOut, rOut)
  instance(buffer, vol, fbcoeff, lpl, lpr, hpl, hpr, lpf, hpf, pan, level, lPanTerm, rPanTerm, mute, play)
  (
    ( !mute ) ? (
      l = buffer.readBuffer();
      r = buffer.readBuffer();
      
      l = fbcoeff * l;
      r = fbcoeff * r;
      lpf < 1.0 ? ( l = lpl.eval_linearSVF_LP( l ); r = lpr.eval_linearSVF_LP( r ); );
      hpf > 0.0 ? ( l = hpl.eval_linearSVF_HP( l ); r = hpr.eval_linearSVF_HP( r ); );
  
      buffer.updateBuffer(l + l_in);
      buffer.updateBuffer(r + r_in);
      
      l = vol*l*lPanTerm;
      r = vol*r*rPanTerm;
      
      lOut += l;
      rOut += r;
    );
    
    level = .5*(abs(l)+abs(r))*play;
  );

function initNode(_memloc, _dtime, _y)
  local()
  instance(buffer, memloc, dtime,  y, fb, vol, pan, hpf, lpf, active, panlast, fblast, llpf, lhpf)
  global(bufsize)
  (
    memloc = _memloc;
    buffer.initBuffer(memloc, memloc+bufsize-2);
    buffer.resetBuffer();
    
    panlast = -9999;
    fblast = -9999;
    llpf = -9999;
    lhpf = -9999;
    
    !dtime ? ( dtime = _dtime; y = _y; fb = 0.8; vol = 1.0; pan = 0.5; hpf = 0.0; lpf = 1.0; active = 1; );
  );

function serializeNode()
  local()
  global()
  instance( x, y, active,
            dtime, temposync, fb, lpf, hpf, widen, sat, pan, variance,
            mute, solo, play )
  (
    file_var( 0, active );
    file_var( 0, dtime );
    file_var( 0, y );
    file_var( 0, temposync );
    file_var( 0, fb );
    file_var( 0, lpf );
    file_var( 0, hpf );
    file_var( 0, widen );
    file_var( 0, sat );
    file_var( 0, pan );
    file_var( 0, mute );
    file_var( 0, solo );
    file_var( 0, play );
    
    /* Memory to expand into when features are added */
    file_mem( 0, 0, 96 );
  );

function draw(xmin, ymin, w, h)
  local(xmin, ymin, w, h, adv, alpha, xl, yl, tf, logLevel, outer, panSize, silent)
  global(gfx_a, gfx_x, gfx_y)
  instance(x, y, r, fbcoeff, lpf, hpf, dtime, level, pan, selected, play, mute, solo)
  (     
    silent = max(0,1-play);
    r = 4;
    alpha = 1.0;
    tf = 100*dtime;
    adv = min(0.99, fbcoeff);
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
    
    outer = 8+4.15*ceil(log(.2)/log(fbcoeff));    
    
    panSize = 7;
    gfx_set(0,0,3,.8 - .7*silent);
    gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize+2, 1);
    gfx_set(1,1,1,1 - .7*silent);
    gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize, 1);
    
    gfx_set(0,0,.3,.95);
    gfx_circle(xl, yl, outer, 1, 1);    
    
    gfx_set(0.2,0.35,1.0,.4);
    gfx_circle(xl, yl, outer, 0, 0);
    gfx_circle(xl, yl, outer+.5, 1, 0);
    gfx_circle(xl, yl, outer+1, 0, 1);
    
    mute ? (
      gfx_set(0.7,0,.1,.95);
      gfx_circle(xl, yl, outer+1, 0, 1);
      gfx_circle(xl, yl, outer+1.5, 0, 0);
      gfx_circle(xl, yl, outer+2, 0, 1);
    );
    
    selected ? (
      gfx_set(0.2,0.35,1.0,1);
      gfx_circle(xl, yl, outer, 0, 0);
      gfx_circle(xl, yl, outer+.5, 1, 0);
      gfx_circle(xl, yl, outer+1, 0, 1);
    );
    
    solo ? (
      gfx_set(0,1,.3,.95);
      gfx_circle(xl, yl, outer+1, 0, 1);
      gfx_circle(xl, yl, outer+1.5, 0, 0);
      gfx_circle(xl, yl, outer+2, 0, 1);
    );
    
    gfx_set(1 - .7*silent, 1 - .7*silent, 1 - .7*silent, alpha);
    while(
      gfx_a = alpha;
      gfx_circle(xl, yl, r, 0, 0);
      gfx_a = .5*alpha;
      gfx_circle(xl, yl, r+1, 0, 1);
      gfx_circle(xl, yl, r-1, 0, 1);
      
      r += 4;
      alpha *= adv;
      alpha>.2
    );
    
    gfx_a = 1 - .7*silent;
    hpf < lpf ? (
      loop(5,
        gfx_arc(xl, yl, r, 2*lpf*$pi - $pi, 2*hpf*$pi - $pi, 1);
        r += .5;
      );
    );
    
    logLevel = log(4000*level-2);
    silent ? logLevel = 0;
    
    gfx_set(1, 1, 1, .2);
    gfx_circle(xl, yl, logLevel*5, 1, 1);
    
    gfx_set(1, 1, 1, .1);
    gfx_circle(xl, yl, logLevel*6, 1, 1);
    
    gfx_set(1, 1, 1, .05);
    gfx_circle(xl, yl, logLevel*8, 1, 1);
    
    r = r*r;
  );

function clamp(x, lb, ub)
  local()
  global()
  instance()
  (
    max(lb,min(ub,x))
  );

function select(xmin, ymin, w, h, xselectmin, xselectmax, yselectmin, yselectmax)
  local(xl, yl)
  global()
  instance(x, y, dtime, selected)
  (
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
        
    selected = ( xl > xselectmin ) && ( xl < xselectmax ) && ( yl > yselectmin ) && ( yl < yselectmax ) ? 1 : 0;
  );

function amIChosen()
  local()
  global()
  instance(selected)
  (
    selected = ( selected == 2 ) ? 1 : 0;
  );

function overNode(xmin, ymin, w, h, mousex, mousey, mousecap)
  local(dx, dy, dist, xl, yl)
  global(nodeCap)
  instance(x, y, r, dtime, lastleft, left, lastright, right, lx, ly, selected)
  (
    left  = mousecap & 1;
    right = mousecap & 2;
    x = timeToX(dtime);
    
    xl = xmin + x*w;
    yl = ymin + y*h;
    dx = mousex - xl;
    dy = mousey - yl;
    
    ( left ) ? (
      ( (nodeCap == 0) && (lastleft == 0) && (lastright == 0) ) ? (
        dist = dx * dx + dy * dy;
        ( dist < r ) ? (
          nodeCap = 1;
          
          /* If this one is not selected, signal that all others have to be deselected */
          !selected ? (
            selected = 2;
            nodeCap = -nodeCap;
          );
        );
      );
    ) : ( right ) ? (
      ( (nodeCap == 0) && (lastright == 0) && (lastleft == 0) ) ? (
        dist = dx * dx + dy * dy;
        ( dist < r ) ? (
          nodeCap = 2;
          
          /* If this one is not selected, signal that all others have to be deselected */
          !selected ? (
            selected = 2;
            nodeCap = -nodeCap;
          );
        );
      );
    ) : ( 
      nodeCap = 0;
    );
    
    lastleft = left;
    lastright = right;    
  );

function nodeProcessMouse(xmin, ymin, w, h, mousex, mousey, mousecap, cap, lx, ly)
  local(left, right, dist, shift, ctrl, alt)
  global(SyncMode, Snap)
  instance(x, y, r, dtime, fb, lpf, hpf, pan, selected, lcap)
  (
    shift = mousecap & 8;
    ctrl  = mousecap & 4;
    alt   = mousecap & 16;
    left  = mousecap & 1;
    right = mousecap & 2;    
    
    x = timeToX(dtime);
    left ? (
      ( cap == 1 && selected ) ? (
        ( shift ) ? (
          ( ctrl ) ? (
            hpf = clamp( hpf - (mousey-ly)/h, 0, lpf );
          ) : (
            lpf = clamp( lpf - (mousey-ly)/h, hpf, 1 );
          );
        ) : (
          ( alt ) ? (
            pan = clamp( pan - (mousey-ly)/h, 0, 1);
          ) : (
            x += (mousex-lx)/w;
            y += (mousey-ly)/h;
          );
        );
      );
    ) : ( right ) ? (
      ( cap == 2 && selected ) ? (
        fb = fb - (mousey-ly)/w;
        fb = clamp(fb, 0, .999);
      );
    );
    
    ( cap == 0 ) && ( lcap == 1 ) ? (
      Snap ? (
        ( SyncMode == 1 ) ? (
          x= floor(x*16+.5)/16;
        ) : ( SyncMode == 2 ) ? (
          x= floor(x*12+.5)/12;
        ) : ( SyncMode == 3 ) ? (
          x= floor(x*20+.5)/20;
        );
      );
    );
    
    dtime = xToTime(x);
    
    lcap = cap && selected;
  );

// MEMORY LAYOUT
bufSize = 65536*8;
minvol = 0.05;
maxvol = 1;

dTap1  = 0;
dTap2  = bufSize;
dTap3  = 2*bufSize;
dTap4  = 3*bufSize;
dTap5  = 4*bufSize;
dTap6  = 5*bufSize;
dTap7  = 6*bufSize;
dTap8  = 7*bufSize;
dTap9  = 8*bufSize;
dTap10 = 9*bufSize;

node1.initNode(dTap1,   xToTime(0.5),  0.5);
node2.initNode(dTap2,   xToTime(0.1),  1.0);
node3.initNode(dTap3,   xToTime(0.2),  1.0);
node4.initNode(dTap4,   xToTime(0.3),  1.0);
node5.initNode(dTap5,   xToTime(0.4),  1.0);
node6.initNode(dTap6,   xToTime(0.5),  1.0);
node7.initNode(dTap7,   xToTime(0.6),  1.0);
node8.initNode(dTap8,   xToTime(0.7),  1.0);
node9.initNode(dTap9,   xToTime(0.8),  1.0);
node10.initNode(dTap10, xToTime(0.9),  1.0);

@serialize
file_var(0, maxtime);
file_var(0, mintime);

node1.serializeNode();
node2.serializeNode();
node3.serializeNode();
node4.serializeNode();
node5.serializeNode();
node6.serializeNode();
node7.serializeNode();
node8.serializeNode();
node9.serializeNode();
node10.serializeNode();

@slider

@block
!node1.mute  ? node1.play  = 1 : node1.play  = 0;
!node2.mute  ? node2.play  = 1 : node2.play  = 0;
!node3.mute  ? node3.play  = 1 : node3.play  = 0;
!node4.mute  ? node4.play  = 1 : node4.play  = 0;
!node5.mute  ? node5.play  = 1 : node5.play  = 0;
!node6.mute  ? node6.play  = 1 : node6.play  = 0;
!node7.mute  ? node7.play  = 1 : node7.play  = 0;
!node8.mute  ? node8.play  = 1 : node8.play  = 0;
!node9.mute  ? node9.play  = 1 : node9.play  = 0;
!node10.mute ? node10.play = 1 : node10.play = 0;

( node1.solo || node2.solo || node3.solo || node4.solo || node5.solo || node6.solo || node7.solo || node8.solo || node9.solo || node10.solo ) ? 
( node1.play = node2.play = node3.play = node4.play = node5.play = node6.play = node7.play = node8.play = node9.play = node10.play = 0 );

node1.solo  ? node1.play  = 1;
node2.solo  ? node2.play  = 1;
node3.solo  ? node3.play  = 1;
node4.solo  ? node4.play  = 1;
node5.solo  ? node5.play  = 1;
node6.solo  ? node6.play  = 1;
node7.solo  ? node7.play  = 1;
node8.solo  ? node8.play  = 1;
node9.solo  ? node9.play  = 1;
node10.solo ? node10.play = 1;

@sample
updateRange();

lOut = 0;
rOut = 0;

node1.updateNode();
node2.updateNode();
node3.updateNode();
node4.updateNode();
node5.updateNode();
node6.updateNode();
node7.updateNode();
node8.updateNode();
node9.updateNode();
node10.updateNode();

node1.process(spl0, spl1);
node2.process(spl0, spl1);
node3.process(spl0, spl1);
node4.process(spl0, spl1);
node5.process(spl0, spl1);
node6.process(spl0, spl1);
node7.process(spl0, spl1);
node8.process(spl0, spl1);
node9.process(spl0, spl1);
node10.process(spl0, spl1);

spl0 = spl0 * (1-drywet) + lOut * drywet;
spl1 = spl1 * (1-drywet) + rOut * drywet;

@gfx
/* Gradients are buffered to save rendering perf */
function drawGradients(w, h, spectrumH, gradient_bg)
instance(lw, lh, lSpectrumH, m, c)
global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
       gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
local( oldDest, oldMode, ang1, ang2, alpha, q, centerNoise, bump, cx, cy, angSiz )
(
  oldMode = gfx_mode;
  gfx_mode = 0;
  gfx_set(1,1,1,1);
  ( ( lw != w ) || ( lh != h ) || (spectrumH != lSpectrumH) ) ? (
    /* Only draw gradients when size changes */
    gfx_x = gfx_y = 0;
    lw = w;
    lh = h;
    lSpectrumH = spectrumH;
    oldDest = gfx_dest;
    gfx_setimgdim(gradient_bg, w, h);
    gfx_dest = gradient_bg;
    gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);

    m = max(w,h);
    gfx_mode = 1;
    alpha = .1;
    bump = 1.05;
    q = 0;
    centerNoise = 0.1*rand();
    cx = w*rand();
    cy = h*rand();
    angSiz = rand();
    ( angSiz < .5 ) ? ( angSiz = .00015 )
    : ( angSiz = .0015 );
    
    loop(200,
      c = rand();
      ( c < .4 ) ? ( gfx_set( 1, 0.1, 0.4, alpha ) )
      : ( c < .9 ) ? ( gfx_set( 0.2, 0.2, 1, alpha) )
      : ( gfx_set( 0, 0, 0, alpha ) );
      
      ang1 = $pi * rand() * 2;
      q == 0 ? ( 
        ang2 = 0;
      ) : (
        ang2 = ang1 + $pi * rand() * angSiz / q;
      );
      gfx_triangle(cx + centerNoise*w*(rand()-0.5), cy + centerNoise*h*(rand()-0.5), .5*w + m * cos(ang1), .5*h + m * sin(ang1), .5*w + m * cos(ang2), .5*h + m * sin(ang2));
      q += 1;
      
      gfx_x = gfx_y = 0;
      q > 4 ? (
        q = 0;
        gfx_blurto(w, h);
        gfx_muladdrect(0, 0, w, h, bump, bump, bump, 1.0, 0, 0, 0, 0);
      );
    );
    gfx_mode = 0;
    
    gfx_dest = oldDest;
  );
    
  gfx_x = gfx_y = 0;
  gfx_blit(gradient_bg, 1, 0);
  gfx_mode = oldMode;
);

font_color_r = 1;
font_color_g = 1;
font_color_b = 1;
font_color_a = 1;
line_color_r = .3;
line_color_g = 0;
line_color_b = 1;
line_color_a = .7;

FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", 16);

function drawWindow(x, y, w, h)
  local(dx, dy, Nx, Ny, pw, ph, xValue, yLevel, dyL, dxL, i, ct)
  global(gfx_x, gfx_y, FONT_GRID, SyncMode,
          font_color_r, font_color_g, font_color_b, font_color_a, 
          line_color_r, line_color_g, line_color_b, line_color_a )
  instance()
  (
    SyncMode == 0 ? (
      Nx = 10;
      Ny = 10;
    ) : ( SyncMode == 1 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 2 ) ? (
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 3 ) ? (
      Nx = 5*4;
      Ny = 10;
    );
    dx = w/Nx;
    dy = h/Ny;
    dyL = 1/Ny;
    dxL = 1/Nx;
    gfx_y = y+dy;
    
    gfx_measurestr("8888", pw, ph);
    gfx_setfont( FONT_GRID );
    yLevel = 1-dyL;
    loop(Ny,
      gfx_set(0, 0, 0, .7);
      gfx_line(x, gfx_y-1, x+w, gfx_y-1);
      gfx_set(line_color_r, line_color_g, line_color_b, line_color_a);
      gfx_line(x, gfx_y, x+w, gfx_y);
      gfx_set(0, 0, 0, .7);
      gfx_line(x, gfx_y+1, x+w-pw, gfx_y+1);
      
      gfx_x = x+w + 10;
      gfx_y -= .5*ph;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      gfx_printf("%d dB", 20*log10(yToVol(1-yLevel)) );
      
      gfx_y += dy + .5*ph;
      yLevel -= dyL;
    );
    
    gfx_x = x;
    gfx_y = h;
    i = 1;
    xValue = 0;
    loop(Nx+1,
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x-1, y, gfx_x-1, y+h);
      gfx_set(line_color_r, line_color_g, line_color_b, line_color_a);
      gfx_line(gfx_x, y, gfx_x, y+h);
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x+1, y, gfx_x+1, y+h);
      
      //gfx_x = x + .1*pw;
      ct = 1000*xToTime(xValue);
      gfx_x += .2*pw;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      ( abs(ct - floor(ct+.5)) < .1 ) ? gfx_printf("%d", floor(ct+.5)) : gfx_printf("%.1f", ct);
      
      gfx_x = x + dx * i;
      xValue += dxL;
      i += 1;
    );
  );

gfx_set(0,0,0,1);
gfx_rect(0, 0, gfx_w, gfx_h);

ymin = 0;
ymax = gfx_h;
xmin = 0;
xmax = gfx_w;

w1x = 0;
w1y = 0;
w1w = .9*gfx_w;
w1h = .9*gfx_h;

bg_color_r = 1.1;
bg_color_g = 0.3;
bg_color_b = 0.3;
bg_color_a = 0.8;

grads.drawGradients(w1w, w1h, w1h, 0);

drawWindow(w1x, w1y, w1w, w1h);

node1.draw(w1x, w1y, w1w, w1h);
node2.draw(w1x, w1y, w1w, w1h);
node3.draw(w1x, w1y, w1w, w1h);
node4.draw(w1x, w1y, w1w, w1h);
node5.draw(w1x, w1y, w1w, w1h);
node6.draw(w1x, w1y, w1w, w1h);
node7.draw(w1x, w1y, w1w, w1h);
node8.draw(w1x, w1y, w1w, w1h);
node9.draw(w1x, w1y, w1w, w1h);
node10.draw(w1x, w1y, w1w, w1h);

lastleft = left;
left = mouse_cap & 1;

!lastleft ? multiSelect = 0;
multiSelect == 0 ? (
   /* These functions will fill global nodeCap with the capture mode that occurred */
   /* 1 - LMB, 2 - RMB                                                             */
   node1.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node2.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node3.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node4.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node5.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node6.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node7.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node8.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node9.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node10.overNode(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap );
  
   /* An unselected one was selected. Deselect all others */
   nodeCap < 0 ? (
    node1.amIChosen();
    node2.amIChosen();
    node3.amIChosen();
    node4.amIChosen();
    node5.amIChosen();
    node6.amIChosen();
    node7.amIChosen();
    node8.amIChosen();
    node9.amIChosen();
    node10.amIChosen();
    nodeCap = abs(nodeCap);
   );
   
  // nodeCap = abs(nodeCap);
   
   nodeCap ? (
     node1.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node2.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node3.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node4.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node5.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node6.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node7.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node8.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node9.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
     node10.nodeProcessMouse(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
  );
  lastMouseX = mouse_x;
  lastMouseY = mouse_y;
  
  !nodeCap ? (
    // No nodes manipulated => Do multi-select
    ( mouse_x > w1x ) && ( mouse_y > w1y ) && ( mouse_x < ( w1x + w1w ) ) && ( mouse_y < ( w1y + w1h ) ) ? (
      ( ( lastleft == 0 ) && ( left == 1 ) ) ? (
        multiSelect = 1;
        refx = mouse_x;
        refy = mouse_y;
      );
    );
  );
) : ( multiSelect == 1 ) ? (
  xmi = min(refx, mouse_x);
  xma = max(refx, mouse_x);
  ymi = min(refy, mouse_y);
  yma = max(refy, mouse_y);
  gfx_set(1, 1, 1, .4);
  gfx_rect(xmi, ymi, xma-xmi, yma-ymi);
  // Select nodes upon release
  !left ? (
    node1.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node2.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node3.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node4.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node5.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node6.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node7.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node8.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node9.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node10.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
  );
);

gfx_set(0,0,0,1);
gfx_x = 5; gfx_y = 5;
gfx_printf("RMB - Feedback\n");
gfx_x = 5; gfx_y = 20;
gfx_printf("SHIFT - LPF\n");
gfx_x = 5; gfx_y = 35;
gfx_printf("Ctrl + Shift - HPF\n");
gfx_x = 5; gfx_y = 50;
gfx_printf("Alt - Panning\n");
gfx_x = 5; gfx_y = 65;
gfx_printf("M - Mute\n");
gfx_x = 5; gfx_y = 80;
gfx_printf("S - Solo\n");

gfx_set(1,1,1,1);
gfx_x = 5; gfx_y = 6;
gfx_printf("RMB - Feedback\n");
gfx_x = 5; gfx_y = 21;
gfx_printf("SHIFT - LPF\n");
gfx_x = 5; gfx_y = 36;
gfx_printf("Ctrl + Shift - HPF\n");
gfx_x = 5; gfx_y = 51;
gfx_printf("Alt - Panning\n");
gfx_x = 5; gfx_y = 66;
gfx_printf("M - Mute\n");
gfx_x = 5; gfx_y = 81;
gfx_printf("S - Solo\n");

lastchar = gfx_getchar();

/* Mute */
( lastchar == 109 ) ? (
  node1.selected  ? node1.mute  = 1 - node1.mute;
  node2.selected  ? node2.mute  = 1 - node2.mute;
  node3.selected  ? node3.mute  = 1 - node3.mute;
  node4.selected  ? node4.mute  = 1 - node4.mute;
  node5.selected  ? node5.mute  = 1 - node5.mute;
  node6.selected  ? node6.mute  = 1 - node6.mute;
  node7.selected  ? node7.mute  = 1 - node7.mute;
  node8.selected  ? node8.mute  = 1 - node8.mute;
  node9.selected  ? node9.mute  = 1 - node9.mute;
  node10.selected ? node10.mute = 1 - node10.mute;
);

/* Solo */
( lastchar == 115 ) ? (
  node1.selected  ? node1.solo  = 1 - node1.solo;
  node2.selected  ? node2.solo  = 1 - node2.solo;
  node3.selected  ? node3.solo  = 1 - node3.solo;
  node4.selected  ? node4.solo  = 1 - node4.solo;
  node5.selected  ? node5.solo  = 1 - node5.solo;
  node6.selected  ? node6.solo  = 1 - node6.solo;
  node7.selected  ? node7.solo  = 1 - node7.solo;
  node8.selected  ? node8.solo  = 1 - node8.solo;
  node9.selected  ? node9.solo  = 1 - node9.solo;
  node10.selected ? node10.solo = 1 - node10.solo;
);
