desc:Saike Reflectosaurus (work in progress | do not use)
tags: multi-tap delay plugin
version: 0.23
author: Joep Vanlier
changelog: Fix reverb issue with peak near Nyquist.
license: MIT
provides: Reflectosaurus_Dependencies/*

import Reflectosaurus_grainlib.jsfx-inc
import Reflectosaurus_widgets.jsfx-inc

slider1:drywet=1.0<0,1,.001>Dry/Wet
slider2:SyncMode=0<0,1,5{Off,Fourth,Third,Fifth,Eight,Sixth>Mode
slider3:Snap=0<0,1,1{Off,On}>Snap

slider10:X1=0<0,1,.000000001>-X1
slider11:Y1=0<0,1,.000000001>-Y1
slider12:X2=0<0,1,.000000001>-X2
slider13:Y2=0<0,1,.000000001>-Y2
slider14:X3=0<0,1,.000000001>-X3
slider15:Y3=0<0,1,.000000001>-Y3
slider16:X4=0<0,1,.000000001>-X4
slider17:Y4=0<0,1,.000000001>-Y4
slider18:X5=0<0,1,.000000001>-X5
slider19:Y5=0<0,1,.000000001>-Y5
slider20:X6=0<0,1,.000000001>-X6
slider21:Y6=0<0,1,.000000001>-Y6
slider22:X7=0<0,1,.000000001>-X7
slider23:Y7=0<0,1,.000000001>-Y7
slider24:X8=0<0,1,.000000001>-X8
slider25:Y8=0<0,1,.000000001>-Y8
slider26:X9=0<0,1,.000000001>-X9
slider27:Y9=0<0,1,.000000001>-Y9
slider28:X10=0<0,1,.000000001>-X10
slider29:Y10=0<0,1,.000000001>-Y10
slider30:X11=0<0,1,.000000001>-X11
slider31:Y11=0<0,1,.000000001>-Y11

slider64:WetGain=0<-32,32,1>Gain

@init
globalFeedback = 1;
update_alpha = log(2) / (0.28881132523331055*srate/4);
inv_update_alpha = 1.0 - update_alpha;

function updateGain()
  global(gainFactor, WetGain)
  local()
  (
    gainFactor = 10^(WetGain/20);
  );

function updateRange()
(
  SyncMode ? (
    SyncMode > 3 ? (
      maxTime = 2*tempo/60;
      minTime = 0;
    ) : (
      maxTime = 4*tempo/60;
      minTime = 0;
    );
  ) : (
    minTime = 4/100;
    maxTime = 4;
  );
);
updateRange();

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function resetBuffer()
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    memset(scopebuffer, 0, scopebuffermax - scopebuffer + 1);
  );
  
function draw_buffer(x, y, w, h, mul, fill)
  instance(scopeptr, scopebuffer, scopebuffermax)
  globals(gfx_x, gfx_y)
  local(len, scopeptr2, lx, ly, xx, dx, lptr, yy, lastx, lasty, isc, yref)
  (
    xx = x;
    len = scopebuffermax-scopebuffer;
    dx = floor(len/w);
    scopeptr2 = scopeptr;
    
    lptr = floor((scopeptr2)/dx)*dx;
    gfx_x = xx;
    gfx_y = y+h;
    isc = h;
    yref = y+h;
    ly = y+h;
    loop((scopebuffermax-scopeptr2)/dx - 1,
      yy = yref - h*min(1,lptr[]);
      
      lptr += dx;
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
    
    lptr = floor((scopebuffer)/dx)*dx;
    loop((scopeptr2 - scopebuffer)/dx - 1,
      lptr += dx;
      yy = yref - h*min(1,lptr[]);
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
  );  
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer);
  );
   
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 2;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    readptr -= 1;
    
    c2 * (1.0-frac) + c1 * frac
  );
  
function readBuffer2()
  local(c1l, c2l, c1r, c2r)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac, outL, outR)
  (
    readptr > scopebuffermax ? readptr = scopebuffer;
  
    c1l = readptr[];
    c1r = readptr[1];
    readptr += 2;
    
    readptr > scopebuffermax ? readptr = scopebuffer;

    c2l = readptr[];
    c2r = readptr[1];

    outL = c2l * (1.0-frac) + c1l * frac;
    outR = c2r * (1.0-frac) + c1r * frac;
  );  
  
function updateBuffer2(L, R)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = L;
    scopeptr[1] = R;
    scopeptr += 2;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
  );
  
  
/***************************/
/* Reverb section          */
/***************************/  
function initWindow(_window_mem, windowtype, fftSize)
  global()
  instance(pwr, window_mem)
  local(i, dwindowpos, windowpos, windowSize)
  (
    windowSize = fftSize*.5;
    window_mem = _window_mem;
    windowpos = 0;
    dwindowpos = $pi*2/windowSize;
    i = 0; pwr = 0;
    loop(fftSize/2+1,
       pwr += (window_mem[i] = (
         windowtype==0 ? ( 0.5 - cos(windowpos)*0.5 ) :
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
      
    i = 0;
    loop(fftSize*.5+1, 
      window_mem[i] = sqrt(window_mem[i]);
      i+=1; 
    );
  );  
   
function windowBlock()
  instance(window_mem, fft_mem, fftSize)
  local(fftPtr, windowPtr)
  global()
  (
    /* Window */
    windowPtr = window_mem;
    fftPtr = fft_mem;

    loop(fftSize,
      fftPtr[] *= windowPtr[];
      fftPtr += 1;
      fftPtr[] *= windowPtr[];
      fftPtr += 1;
      windowPtr += 1;
    );
  );

 function processBlockVerb(outputPtr)
    instance(fft_mem, fftSize, nSamples, mag_mem, phase_mem, offset, 
             dampFactor, sharedBuffer, outputBufStart, outputBufEnd)
    local(ifftSize, fwd, bwd, chnk1, 
          r1, r2, i1, i2, re1, im1, re2, im2, x1, x2, x1sq, x2sq, sqlen, isqlen, ang1, ang2,
          cMag, cPhase, outPtr, fftPtr, fftPtr2, magPtr, magPtr2, phasePtr, 
          i, last, new)
    global(mode)
    ( 
      this.windowBlock();
       
      // FFT this block
      ifftSize = 1/fftSize;
      fft(fft_mem, fftSize);
      fft_permute(fft_mem, fftSize);
  
      magPtr      = mag_mem;
      phasePtr    = phase_mem;
      
      re1         = fft_mem[] + fft_mem[];
      re2         = fft_mem[1] + fft_mem[1];
      magPtr[]    = re1; magPtr += 1;
      magPtr[]    = re2; magPtr += 1;
      
      // Decompose into magnitude and phase
      fwd       = 2;
      bwd       = fftSize;
      loop(fftSize/2 - 1,
        bwd = 2*fftSize - fwd;
        r1  = fft_mem[fwd];
        i1  = fft_mem[fwd + 1];
        r2  = fft_mem[bwd];
        i2  = fft_mem[bwd + 1];
        
        re1 = r1 + r2;
        im1 = i1 - i2;
        re2 = i1 + i2;
        im2 = r2 - r1;
        
        magPtr[]    = sqrt(re1*re1 + im1*im1); magPtr += 1;
        magPtr[]    = sqrt(re2*re2 + im2*im2); magPtr += 1;
        
        // Since we dump the phase anyway, don't compute it.
        // phasePtr[]  = atan2(im1,re1); phasePtr += 1;
        // phasePtr[]  = atan2(im2,re2); phasePtr += 1;
        
        fwd += 2;
      );      
      
      /////////////////////////////
      // Perform processing here //
      /////////////////////////////
      fftPtr = sharedBuffer;
      magPtr = mag_mem;
      
      loop( fftSize - 1,
        mode == 1 ? (
          fftPtr[] = fftPtr[]*dampFactor + magPtr[];
        ) : (
          fftPtr[] = max(fftPtr[]*dampFactor, magPtr[]);
        );
        fftPtr += 1;
        magPtr += 1;
      );
      
      // Add basic verb from magnitude
      fftPtr = sharedBuffer;
      magPtr = mag_mem;
      loop( fftSize - 1,
        magPtr[] = fftPtr[];
        fftPtr += 1;
        magPtr += 1;
      );

      /////////////////////////////
      // End processing here     //
      /////////////////////////////
      
      /* Fix issue with peak near nyquist */
      fwd = 0;
      loop(4,
        mag_mem[fwd] = 0;
        mag_mem[fftSize-fwd] = 0;
        fwd += 1;
      );
      
      /* TO DO: Investigate why this peak beyond the end of the buffer affects the FFT */
      fwd = 0;
      loop(4,
        fft_mem[fftSize-fwd] = 0;
        fft_mem[fftSize+fwd] = 0;
        fwd += 1;
      );
      
      // Spectra at this point are interleaved                
      // At this point magPtr contains interleaved magnitude  
      // Phase contains interleaved phases                   
      //      fft_mem[0] = 0;
      //      fft_mem[1] = mag_mem[1] * cos(phase_mem[1]);
       
      fwd = 0;
      bwd = fftSize;
      magPtr = mag_mem;
      phasePtr = phase_mem;
      ifftSize = .5*ifftSize; /* Normalizing constant */
      
      bwd = 2*fftSize;
      loop(fftSize/2 - 1,
        //bwd = 2*fftSize - fwd;
          
        // Spectrum 1
        cMag        = ifftSize*magPtr[];
          
        // Generate random phase angle uniform on the circle without sin/cos (von Neumann1951)
        // Note that technically for accurate uniformity, we should check whether x1sq+x2sq >= 1 and
        // reject the sample if it is, but this is omitted. This leads to a slight bias in the angles 
        // as this will be violated with a probability of 1-(pi/4).
        x1 = 2*rand()-1;
        x2 = 2*rand()-1;
        x1sq = x1*x1;
        x2sq = x2*x2;
        sqlen = x1sq + x2sq;
          
        isqlen = 1 / sqlen;
        ang1 = (x1sq - x2sq) * isqlen;
        re1 = cMag * ang1; // Real
        ang2 = (2 * x1 * x2) * isqlen;
        im1 = cMag * ang2; // Imaginary   
          
        magPtr += 1;
          
        // Spectrum 2
        cMag        = ifftSize*magPtr[];
          
        x1 = 2*rand()-1;
        x2 = 2*rand()-1;
        x1sq = x1*x1;
        x2sq = x2*x2;
        sqlen = x1sq + x2sq;
            
        isqlen = 1 / sqlen;
        ang1 = (x1sq - x2sq) * isqlen;
        re2 = cMag * ang1; // Real
        ang2 = (2 * x1 * x2) * isqlen;
        im2 = cMag * ang2; // Imaginary
          
        magPtr += 1;
        
        // Multiplex it back into the complex spectrum before backtrafo
        fft_mem[fwd]      = re1 - im2;  // Real 1
        fft_mem[bwd]      = re1 + im2;  // Real 2
        
        fft_mem[fwd + 1]  = re2 + im1;  // Imag 1
        fft_mem[bwd + 1]  = re2 - im1;  // Imag 2
          
        fwd += 2;
        bwd -= 2;
      );
      
      fft_ipermute(fft_mem, fftSize);
      ifft(fft_mem, fftSize);
      
      this.windowBlock();
      
      outPtr = outputPtr + offset;
      fftPtr = fft_mem;
      loop(nSamples,
        ( outPtr > outputBufEnd ) ? outPtr = outputBufStart;
      
        outPtr[] += fftPtr[]; outPtr += 1; fftPtr += 1;
        outPtr[] += fftPtr[]; outPtr += 1; fftPtr += 1;        
      );
    );

/* One overlapping chunk of the convolution */
function updateVerb(verbOutputPtr, left, right)
  instance(fft_mem, fft_end, ptr)
  local()
  global()
  (
    (ptr >= fft_end) ? (
      this.processBlockVerb(verbOutputPtr);
      ptr = fft_mem;
      memset(ptr, 0, 65536);
    );
      
    ptr[]  = left;    ptr += 1;
    ptr[]  = right;   ptr += 1;
  );
    
function initFFTBuffer(_fft_mem, _nSamples, _fftSize, _mag_mem, _phase_mem)
  instance(fft_mem, fft_end, ptr, fftSize, nSamples, mag_mem, phase_mem)
  local()
  global()
  (
    fft_mem   = _fft_mem;
    nSamples  = _nSamples;
    fft_end   = _fft_mem + _nSamples;
    ptr       = _fft_mem;
    fftSize   = _fftSize;
    mag_mem   = _mag_mem;
    phase_mem = _phase_mem;
  );    
    
function initializeVerb(bufferPos)
  local(fftSize, nSamples, windowType,
        bufMem, magMem, phaseMem, bufMem2, magMem2, phaseMem2, windowMem, sharedBuffer,
        bufferDist )
  global()
  instance(verbBuf, verbBuf2, verbOutputPtr, verbOutputBufStart, verbOutputBufEnd)
  (
    bufferDist  = 65536;
    
    verbOutputBufStart = bufferPos;
    verbOutputBufEnd   = bufferPos + bufferDist - 4;
    
    bufMem         = bufferPos + 1*bufferDist;
    magMem         = bufferPos + 2*bufferDist;
    phaseMem       = bufferPos + 3*bufferDist;
    windowMem      = bufferPos + 4*bufferDist;
    
    bufMem2        = bufferPos + 5*bufferDist;
    magMem2        = bufferPos + 6*bufferDist;
    phaseMem2      = bufferPos + 7*bufferDist;
    
    /* Temporary buffer */
    sharedBuffer   = bufferPos + 8*bufferDist;
  
    fftSize     = 2048*8;
    nSamples    = 1024*8;
    windowType  = 0;

    verbBuf.initFFTBuffer(bufMem, nSamples, fftSize, magMem, phaseMem);  
    verbBuf.initWindow(windowMem, windowType, nSamples);
    verbBuf2.initFFTBuffer(bufMem2, nSamples, fftSize, magMem2, phaseMem2); 
    verbBuf2.initWindow(windowMem, windowType, nSamples);
    
    verbOutputBufStart      = verbOutputBufStart;
    verbOutputBufEnd        = verbOutputBufEnd;
    verbBuf.sharedBuffer    = sharedBuffer;
    verbBuf2.sharedBuffer   = sharedBuffer;
    verbBuf.outputBufStart  = verbOutputBufStart;
    verbBuf2.outputBufStart = verbOutputBufStart;
    verbBuf.outputBufEnd    = verbOutputBufEnd;
    verbBuf2.outputBufEnd   = verbOutputBufEnd;
    
    verbOutputPtr = verbOutputBufStart;
    
    verbBuf2.ptr += nSamples/2;
    
    bufferPos + 9*bufferDist
  );

function processVerb(inL, inR)
  global()
  local()
  instance(verbBuf, verbBuf2, outL, outR, verbOutputPtr, verbOutputBufStart, verbOutputBufEnd, damp, mode)
  (  
    verbBuf.dampFactor = damp;
    verbBuf2.dampFactor = damp;
    verbBuf.mode = mode;
    verbBuf2.mode = mode;
    
    verbBuf.updateVerb(verbOutputPtr, inL, inR);
    verbBuf2.updateVerb(verbOutputPtr, inL, inR);
    verbOutputPtr > verbOutputBufEnd ? verbOutputPtr = verbOutputBufStart;
    outL = verbOutputPtr[]; verbOutputPtr[] = 0; verbOutputPtr += 1; 
    outR = verbOutputPtr[]; verbOutputPtr[] = 0; verbOutputPtr += 1;
  );
  
/***************************/
/* End of reverb section   */
/***************************/  
  
function f_trafo(freq)
  local()
  global(slider54, legacyCutoff)
  instance()
  (
    exp( (1-freq) * log(20/22050) ) * $pi / (max(1,slider54));
  );


function init_linearSVF(freq, res)
  global(srate, slider54)
  local(g)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    g = tan(.5 * f_trafo(freq));
    k = 2 - 2*res;
    
    a1 = 1/(1+g*(g+k));
    a2 = g*a1;
    a3 = g*a2;
  ); 

function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );
  
function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2
  );  
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );  
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );

function xToTime(x)
  global(mintime, maxtime, xmin, xmax, srate, SyncMode)
  local()
  (
    SyncMode > 0 ? (
      maxTime * x + minTime;
    ) : ( 
      (maxTime/1024) * 2^(10*x)
    );
  );

function log2(x)
  local()
  global()
  (
    log(x)/log(2)
  );

function timeToX(dtime)
  global(mintime, maxtime, SyncMode)
  local()
  (
    SyncMode ? (
      clamp( (dTime - minTime) / maxTime, 0, 1 );
    ) : (
      clamp( log2( ( dTime * 1024 ) / maxTime )/10, 0, 1 );
    );
  );
  
function yToVol(y)
  global(minvol, maxvol)
  local()
  (
    // Same as 10^(-30*dB/20)
    exp(-1.5*y*log(10)) 
  );  
  
  function updateNode()
  local(newdtime)
  global(srate, MAX_MOVE, globalFeedback, update_alpha, inv_update_alpha)
  instance(fbc, diff, buffer, tx, x, y, dtime, activevol, Gain, invol, invollast, oldvol, vol, pan, panlast, lPanTerm, rPanTerm, lpl, hpl, lpr, hpr, lpf, hpf, llpf, lhpf, fb, fbcoeff, xlast, ylast, fblast, olddtime, mute, solo)
  (
    y > 1 ? y = 1;
    x > 1 ? x = 1;
    y < 0 ? y = 0;
    x < 0 ? x = 0;
  
    ( !mute || solo ) ? (
      newdtime = update_alpha * srate * dtime + inv_update_alpha * olddtime;
      diff = olddtime - newdtime;
      ( abs( diff ) > .0000001 || ( invollast == 99999 ) ) ? (
        buffer.setOffset(newdtime - floor(newdtime) + floor(newdtime*.5)*2 );       
      );
      olddtime = newdtime;
      
      activevol = update_alpha * vol + inv_update_alpha * oldvol;
      oldvol = activevol;
      
      fbc = fb * globalFeedback;
    
      ( y != ylast ) ? ( vol = yToVol(y);  ylast = y; );
      ( Gain != invollast ) ? ( invol = Gain<1 ? yToVol(Gain) : 0; invollast = Gain; );
      ( fbc != fblast ) ? ( fbcoeff = .95*exp( -4 * ( 1 - fbc ) ) );  
      ( pan != panlast ) ? ( lPanTerm = cos($pi*pan/2); rPanTerm = sin($pi*pan/2); panlast = pan; );
    
      ( lpf < 1.0 && lpf != llpf ) ? ( lpl.init_linearSVF(lpf, 0); lpr.init_linearSVF(lpf, 0); llpf = lpf; );
      ( hpf > 0.0 && hpf != lhpf ) ? ( hpl.init_linearSVF(hpf, 0); hpr.init_linearSVF(hpf, 0); lhpf = hpf; );
    );
  );

  function tanh(x)
  local()
  global()
  instance()
  (
    (2/(1+exp(-2*x)))-1.0
  );
  
POSITION_LOC = 10;
function updateFromSlider()
  local()
  global(slider, POSITION_LOC)
  instance(y, dtime, me)
  (
    dtime = xToTime( slider(POSITION_LOC + (me-1)*2) );
    y = slider(POSITION_LOC + (me-1)*2 + 1);
  );
  
function updateToSlider()
  local(xl)
  global(slider, POSITION_LOC)
  instance(y, dtime, me)
  (
    xl = POSITION_LOC + (me-1)*2;
    slider(xl) = timeToX(dtime);
    xl = POSITION_LOC + (me-1)*2 + 1;
    slider(xl) = y;
  );
  
function updateToSliderRec()
  local(xl)
  global(slider, POSITION_LOC)
  instance(y, dtime, me)
  (
    xl = POSITION_LOC + (me-1)*2;
    slider(xl) = timeToX(dtime);
    slider_automate(xl);
    xl = POSITION_LOC + (me-1)*2 + 1;
    slider(xl) = y;
    slider_automate(xl);
  );

function updateNodeBlock()
  local()
  global()
  instance(recv, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11)
  (
    recv = fromNode1 || fromNode2 || fromNode3 || fromNode4 || fromNode5 || fromNode6 || fromNode7 || fromNode8 || fromNode9 || fromNode10 || fromNode11;
 );

function getReceives()
  local()
  global( node1.lastL, node2.lastL, node3.lastL, node4.lastL, node5.lastL, node6.lastL, node7.lastL, node8.lastL, node9.lastL, node10.lastL, node11.lastL, 
          node1.lastR, node2.lastR, node3.lastR, node4.lastR, node5.lastR, node6.lastR, node7.lastR, node8.lastR, node9.lastR, node10.lastR, node11.lastR )
  instance(recv, lIn, rIn, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11, me)
  (
    recv ? (
      ( me == 1 )    ? ( fromNode1 *= 0 )
      : ( me == 2 )  ? ( fromNode2 *= 0 )
      : ( me == 3 )  ? ( fromNode3 *= 0 )
      : ( me == 4 )  ? ( fromNode4 *= 0 )
      : ( me == 5 )  ? ( fromNode5 *= 0 )
      : ( me == 6 )  ? ( fromNode6 *= 0 )
      : ( me == 7 )  ? ( fromNode7 *= 0 )
      : ( me == 8 )  ? ( fromNode8 *= 0 )
      : ( me == 9 )  ? ( fromNode9 *= 0 )
      : ( me == 10 ) ? ( fromNode10 *= 0 )
      : ( me == 11 ) ? ( fromNode11 *= 0 );
      
      fromNode1 ? (
        lIn = lIn + fromNode1 * node1.lastL;
        rIn = rIn + fromNode1 * node1.lastR;
      );
      
      fromNode2 ? (
        lIn = lIn + fromNode2 * node2.lastL;
        rIn = rIn + fromNode2 * node2.lastR;
      );
        
      fromNode3 ? (
        lIn = lIn + fromNode3 * node3.lastL;
        rIn = rIn + fromNode3 * node3.lastR;
      );
        
      fromNode4 ? (
        lIn = lIn + fromNode4 * node4.lastL;
        rIn = rIn + fromNode4 * node4.lastR;
      );
      
      fromNode5 ? (
        lIn = lIn + fromNode5 * node5.lastL;
        rIn = rIn + fromNode5 * node5.lastR;
      );
      
      fromNode6 ? (
        lIn = lIn + fromNode6 * node6.lastL;
        rIn = rIn + fromNode6 * node6.lastR;
      );
      
      fromNode7 ? (
        lIn = lIn + fromNode7 * node7.lastL;
        rIn = rIn + fromNode7 * node7.lastR;
      );
      
      fromNode8 ? (
        lIn = lIn + fromNode8 * node8.lastL;
        rIn = rIn + fromNode8 * node8.lastR;
      );
      
      fromNode9 ? (
        lIn = lIn + fromNode9 * node9.lastL;
        rIn = rIn + fromNode9 * node9.lastR;
      );
      
      fromNode10 ? (
        lIn = lIn + fromNode10 * node10.lastL;
        rIn = rIn + fromNode10 * node10.lastR;
      );
      
      fromNode11 ? (
        lIn = lIn + fromNode11 * node11.lastL;
        rIn = rIn + fromNode11 * node11.lastR;
      );
    );
  );

eps = 0.0000000001;
function rectify(in)
  instance(last, diff, F0last)
  local(out, F0n)
  global(eps)
  (
    F0n = .5*in*in*sign(in);
    diff = in - last;
  
    ( diff > eps ) ? (
      out = ( F0n - F0last ) / diff;
    ) : (
      out = abs(.5*(in+last));
    );
    
    last = in;
    F0last = F0n;
    
    out
  );
  
  /* Simple monopole */
  function fixdc(x)
  local()
  global()
  instance(DC_fixed, prev)
  (
    DC_fixed=0.995*DC_fixed + x - prev;
    prev=x;
  
    DC_fixed
  );  

function process(l_in, r_in)
  local(l, r, tmp, lr, ll)
  global(lOut, rOut, srate)
  instance(dcfl, dcfr, rectl, rectr, invol, lIn, rIn, buffer, activevol, fbcoeff, lpl, lpr, hpl, hpr, lpf, hpf, pan, level, lPanTerm, rPanTerm, mute, solo, play, lastL, lastR, 
           pingpong, rectify,
           granulator, grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread )
  (
    ( !mute || solo ) ? (
      lIn = l_in * invol;
      rIn = r_in * invol;

      this.getReceives();
    
      grain ? (
        granulator.granulator_update((grainLength/1000)*srate, grainJitter, grainOverlap, grainSpeed, grainSpeedSpread, grainPanSpread, buffer.readptr, buffer.scopebuffer, buffer.scopebuffermax, buffer.scopeptr);
        buffer.readptr += 2;
        buffer.readptr > buffer.scopebuffermax ? buffer.readptr = buffer.scopebuffer;
        l = granulator.L;
        r = granulator.R;
      ) : (
        buffer.readBuffer2();
        l = buffer.outL;
        r = buffer.outR;
      );
      
      lpf < 1.0 ? ( l = lpl.eval_linearSVF_LP( l ); r = lpr.eval_linearSVF_LP( r ); );
      hpf > 0.0 ? ( l = hpl.eval_linearSVF_HP( l ); r = hpr.eval_linearSVF_HP( r ); );
  
      lastL = l * lPanTerm;
      lastR = r * rPanTerm;

      rectify ? (
        // Higher quality anti-aliasing rectification
        // decided against this for performance reasons
        //l = this.rectl.rectify(l);
        //r = this.rectr.rectify(r);
        l = abs(l);
        r = abs(r);
        
        l = this.dcfl.fixdc(l);
        r = this.dcfr.fixdc(r);
      );
  
      pingpong ? (
        tmp = l*lPanTerm;
        l = r*rPanTerm;
        r = tmp;
        buffer.updateBuffer2(fbcoeff*l + lIn, fbcoeff*r + rIn);
        
        l = activevol*l*play;
        r = activevol*r*play;  
      ) : (
        l = l;
        r = r;
        buffer.updateBuffer2(fbcoeff*l + lIn, fbcoeff*r + rIn);
        
        l = activevol*l*lPanTerm*play;
        r = activevol*r*rPanTerm*play;  
      );

      lOut += l;
      rOut += r;
    );
    
    level = .5*(abs(l)+abs(r))*play;
  );

function processVerbNode(l_in, r_in)
  local(l, r)
  global(lOut, rOut)
  instance(verb, lIn, rIn, buffer, invol, vol, activevol, fbcoeff, lpl, lpr, hpl, hpr, lpf, hpf, pan, level, lPanTerm, rPanTerm, mute, solo, play, lastL, lastR)
  (
    ( !mute || solo ) ? (
      lIn = l_in * invol;
      rIn = r_in * invol;
    
      this.getReceives();
      
      verb.damp = fbcoeff;
      verb.processVerb(lIn, rIn);
      
      l = verb.outL;
      r = verb.outR;
      
      lpf < 1.0 ? ( l = lpl.eval_linearSVF_LP( l ); r = lpr.eval_linearSVF_LP( r ); );
      hpf > 0.0 ? ( l = hpl.eval_linearSVF_HP( l ); r = hpr.eval_linearSVF_HP( r ); );
      
      lastL = l * lPanTerm;
      lastR = r * rPanTerm;
    
      l = activevol*l*lPanTerm*play;
      r = activevol*r*rPanTerm*play;
      
      lOut += l;
      rOut += r;
    );
    
    level = .5*(abs(l)+abs(r))*play;
  );
   
function initNode(_memloc, _dtime, _y, idx, off)
  local()
  instance(mute, buffer, memloc, dtime,  y, fb, vol, invollast, pan, hpf, lpf, active, panlast, fblast, llpf, lhpf, me, lastL, lastR, lpl, lpr, hpl, hpr,
           granulator, grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread )
  global(bufsize, srate)
  (
    me = idx;
    memloc = _memloc;
    buffer.initBuffer(memloc, memloc+bufsize-4);
    buffer.resetBuffer();
    lastL = 0;
    lastR = 0;
    
    panlast = -9999;
    fblast = -9999;
    llpf = -9999;
    lhpf = -9999;
    invollast = 99999;    
    
    /* Cleanly reset the nodes */
    lpl.reset_linearSVF();
    hpl.reset_linearSVF();
    lpr.reset_linearSVF();
    hpr.reset_linearSVF();
    
    granulator.granulator_init();
    
    !dtime ? ( dtime = _dtime; y = _y; fb = 0.8; vol = 1.0; pan = 0.5; hpf = 0.0; lpf = 1.0; active = 1; mute = off; );
    !grainLength ? ( grain = 0; grainLength = 60; grainJitter = .15; grainOverlap = .66; grainSpeed = 1; grainPanSpread = .5; grainSpeedSpread = .05; );
  );

function initFFTNode(loc)
  instance(verb, lpf, hpf, fb)
  local()
  global()
  (
    /* Initialize reverb buffers */
    verb.mode = 1;
    verb.initializeVerb(loc)
  );

function serializeNode()
  local()
  global(readread, SyncMode)
  instance( x, y, active,
            dtime, temposync, fb, lpf, hpf, widen, sat, pan, variance, pingpong, rectify, Gain,
            mute, solo, play,
            fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11,
            grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread )
  (
    ( file_avail(0) < 0 ) ? (
      this.updateFromSlider();
    );
  
    file_var( 0, active );
    file_var( 0, dtime );
    file_var( 0, y );
    file_var( 0, temposync );
    file_var( 0, fb );
    file_var( 0, lpf );
    file_var( 0, hpf );
    file_var( 0, widen );
    file_var( 0, sat );
    file_var( 0, pan );
    file_var( 0, mute );
    file_var( 0, solo );
    file_var( 0, play );
    
    file_var( 0, fromNode1 );
    file_var( 0, fromNode2 );
    file_var( 0, fromNode3 );
    file_var( 0, fromNode4 );
    file_var( 0, fromNode5 );
    file_var( 0, fromNode6 );
    file_var( 0, fromNode7 );
    file_var( 0, fromNode8 );
    file_var( 0, fromNode9 );
    file_var( 0, fromNode10 );
    file_var( 0, fromNode11 );
    
    file_var( 0, pingpong );
    file_var( 0, rectify );
    file_var( 0, Gain );
    
    file_var( 0, grain );
    file_var( 0, grainLength );
    file_var( 0, grainJitter );
    file_var( 0, grainOverlap );
    file_var( 0, grainSpeed );
    file_var( 0, grainPanSpread );
    file_var( 0, grainSpeedSpread );
    
    /* Memory to expand into when features are added */
    memset(0,0,100);
    file_mem( 0, 0, 75 );
    
    /* <0 if writing */
    ( file_avail(0) >= 0 ) ? (
      this.updateToSlider();
    );
  );

connectorSize = 16;

function drawConnector( xmin, ymin, w, h, xl, yl, nx, ny, idx, fromLevel )
  local(dmx, dmy, diffx, diffy, len, mx, my, nx, ny, ytri1, ytri2, ytri3, xtri1, xtri2, xtri3, xl2, yl2, ang,
        connector_r, connector_g, connector_b)
  global(connectorSize, mouse_x, mouse_y, render_time)
  instance(overConnector)
  (
    xl2 = xmin + w*nx;
    yl2 = ymin + h*ny;
    mx  = (.4*xl+.6*xl2);
    my  = (.4*yl+.6*yl2);
    gfx_set(.5,.4,.7,.8);
    gfx_line(xl, yl, xl2, yl2, 1);
    gfx_set(.5,.4,.7,.8+.2*sin(4*render_time));
    gfx_line(xl, yl+1, xl2, yl2+1, 1);
    
    gfx_set(0,0,0,1);
    gfx_circle(mx, my, connectorSize-.5, 0, 1);
    gfx_circle(mx, my, connectorSize, 0, 0);
    gfx_circle(mx, my, connectorSize+.5, 0, 1);
    gfx_circle(mx, my, connectorSize-2.5, 0, 1);
    gfx_circle(mx, my, connectorSize-3.5, 0, 1);
    gfx_circle(mx, my, connectorSize+2.5, 0, 1);
    gfx_circle(mx, my, connectorSize+3.5, 0, 1);
    gfx_circle(mx, my, connectorSize+4.5, 0, 1);
    
    connector_r = .6;
    connector_g = .6;
    connector_b = .8;
    
    gfx_set(connector_r, connector_g, connector_b,1.0);
    gfx_circle(mx, my, connectorSize-.5, 0, 1);
    gfx_circle(mx, my, connectorSize, 0, 0);
    gfx_circle(mx, my, connectorSize+.5, 0, 1);
    
    ang = 2*fromLevel*$pi - $pi;
    gfx_arc(mx, my, connectorSize+1,   -$pi, ang, 1);
    gfx_arc(mx, my, connectorSize+1.5, -$pi, ang, 1);
    gfx_arc(mx, my, connectorSize+2,   -$pi, ang, 1);
    
    diffx = xl - xl2;
    diffy = yl - yl2;
    len   = sqrt( diffx * diffx + diffy * diffy );
    nx    = 10 * diffx / len;
    ny    = 10 * diffy / len;
    
    xtri1 = mx - .5*nx + ny;
    ytri1 = my - .5*ny - nx;
    xtri2 = mx - .5*nx - ny;
    ytri2 = my - .5*ny + nx;
    xtri3 = mx + nx;
    ytri3 = my + ny;
    
    dmx = mx - mouse_x;
    dmy = my - mouse_y;
    ( dmx * dmx + dmy * dmy ) < (connectorSize*connectorSize) ? overConnector = idx;

    gfx_set(connector_r, connector_g, connector_b,.5);
    gfx_triangle( xtri1-1, ytri1, xtri2-1, ytri2, xtri3-1, ytri3 );
    gfx_triangle( xtri1+1, ytri1, xtri2+1, ytri2, xtri3+1, ytri3 );
    gfx_triangle( xtri1, ytri1-1, xtri2, ytri2-1, xtri3, ytri3-1 );
    gfx_triangle( xtri1, ytri1+1, xtri2, ytri2+1, xtri3, ytri3+1 );

    gfx_set(connector_r, connector_g, connector_b,1.0);
    gfx_triangle( xtri1, ytri1, xtri2, ytri2, xtri3, ytri3 );
  );

function drawConnections(xmin, ymin, w, h)
  global( node1.x, node2.x, node3.x, node4.x, node5.x, node6.x, node7.x, node8.x, node9.x, node10.x, node11.x, 
          node1.y, node2.y, node3.y, node4.y, node5.y, node6.y, node7.y, node8.y, node9.y, node10.y, node11.y )
  instance(overConnector, x, y, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11)
  local(xl, yl)
  (
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
    
    overConnector = 0;
    fromNode1  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node1.x,  node1.y,  1,  fromNode1 );
    fromNode2  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node2.x,  node2.y,  2,  fromNode2 );
    fromNode3  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node3.x,  node3.y,  3,  fromNode3 );
    fromNode4  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node4.x,  node4.y,  4,  fromNode4 );
    fromNode5  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node5.x,  node5.y,  5,  fromNode5 );
    fromNode6  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node6.x,  node6.y,  6,  fromNode6 );
    fromNode7  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node7.x,  node7.y,  7,  fromNode7 );
    fromNode8  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node8.x,  node8.y,  8,  fromNode8 );
    fromNode9  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node9.x,  node9.y,  9,  fromNode9 );
    fromNode10 ? this.drawConnector( xmin, ymin, w, h, xl, yl, node10.x, node10.y, 10, fromNode10 );
    fromNode11 ? this.drawConnector( xmin, ymin, w, h, xl, yl, node11.x, node11.y, 11, fromNode11 );
    
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
  );

function draw(xmin, ymin, w, h, verb)
  local(adv, alpha, xl, yl, tf, logLevel, outer, panSize, silent, radius, rectS, cr, cg, cb)
  global(gfx_a, gfx_x, gfx_y)
  instance(x, y, r, fbcoeff, lpf, hpf, dtime, level, pan, selected, play, mute, solo, pingpong, rectify, gain, grain)
  (     
    silent = max(0,1-play);
    r = 4;
    alpha = 1.0;
    tf = 100*dtime;
    radius = exp(-3*(1.0-fbcoeff));
    
    adv = min(0.99, radius);
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
    
    outer = 8+4.15*ceil(log(.2)/log(radius));    
    
    rectify ? (
      rectS = outer-3;
      gfx_set(1, 1, 1,.1);
      //gfx_rect(xl-rectS, yl-rectS, 2*rectS+2, 2*rectS+2);
      rectS += 2;
      //gfx_rect(xl-rectS, yl-rectS, 2*rectS+2, 2*rectS+2);
      rectS += 4;
      //gfx_rect(xl-rectS, yl-rectS, 2*rectS+2, 2*rectS+2);
      rectS += 7;
      gfx_rect(xl-rectS, yl-rectS, 2*rectS+2, 2*rectS+2);
    );
    
    grain ? (
      gfx_set(1.6,0.2,1,1);
      
      rectS = 0;
      loop(30,
        gfx_circle(xl+2*outer*cos(time_precise()*rectS), yl+2*outer*sin(time_precise()*rectS), 2);
        rectS += $pi/60;
      );
    );
    
    cr = .8;
    cg = .8;
    cb = .9;
    
    panSize = 7;
    gfx_set(cr*.5,cg*.5,cb*.5,.8 - .7*silent);
    gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize+2, 1);
    gfx_set(cr,cg,cb,1 - .7*silent);
    gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize, 1);    
    
    pingpong ? (
      gfx_set(cr*.2,cg*.2,cb*.2,.8 - .7*silent);
      gfx_circle(xl-outer*cos($pi*(1-pan)), yl-outer*sin($pi*(1-pan)), panSize+2, 1);
      gfx_set(cr,cg,cb,.4 - .7*silent);
      gfx_circle(xl-outer*cos($pi*(1-pan)), yl-outer*sin($pi*(1-pan)), panSize, 1);    
    );
    
    gfx_set(0,0,.3,.95);
    gfx_circle(xl, yl, outer, 1, 1);    
    
    gfx_set(0.2,0.25,0.1,.4);
    gfx_circle(xl, yl, outer, 0, 0);
    gfx_circle(xl, yl, outer+.5, 1, 0);
    gfx_circle(xl, yl, outer+1, 0, 1);
    
    verb ? (
      gfx_set(1,1,1,.2);
      rectS = 1.1*outer;
      panSize = 1.8*outer;
      gfx_line(xl-rectS, yl-rectS, xl+rectS, yl-rectS);
      gfx_line(xl-rectS, yl+rectS, xl+rectS, yl+rectS);
      gfx_line(xl-rectS, yl-rectS, xl-rectS, yl+rectS);
      gfx_line(xl+rectS, yl-rectS, xl+rectS, yl+rectS);
    
      gfx_line(xl-rectS, yl-rectS, xl-panSize, yl-panSize);
      gfx_line(xl+rectS, yl+rectS, xl+panSize, yl+panSize);
      gfx_line(xl-rectS, yl+rectS, xl-panSize, yl+panSize);
      gfx_line(xl+rectS, yl-rectS, xl+panSize, yl-panSize);
      
      gfx_set(1,1,1,.6);
      rectS = panSize;
      gfx_line(xl-rectS, yl-rectS, xl+rectS, yl-rectS);
      gfx_line(xl-rectS, yl+rectS, xl+rectS, yl+rectS);
      gfx_line(xl-rectS, yl-rectS, xl-rectS, yl+rectS);
      gfx_line(xl+rectS, yl-rectS, xl+rectS, yl+rectS);
    );
    
    mute ? (
      gfx_set(0.7,0,.1,.95);
      gfx_circle(xl, yl, outer+1, 0, 1);
      gfx_circle(xl, yl, outer+1.5, 0, 0);
      gfx_circle(xl, yl, outer+2, 0, 1);
    );
    
    selected ? (
      gfx_set(0.35,0.4,.7,1);
      gfx_circle(xl, yl, outer, 0, 0);
      gfx_circle(xl, yl, outer+.5, 1, 0);
      gfx_circle(xl, yl, outer+1, 0, 1);
    );
    
    solo ? (
      gfx_set(0,1,.3,.95);
      gfx_circle(xl, yl, outer+1, 0, 1);
      gfx_circle(xl, yl, outer+1.5, 0, 0);
      gfx_circle(xl, yl, outer+2, 0, 1);
    );    
    
    
//    gfx_set(1 - .7*silent, 1 - .7*silent, 1 - .7*silent, alpha);
//    gfx_set(.4 - .7*silent, .3 - .7*silent, .8 - .7*silent, alpha);
    gfx_set(cr, cg, cb, 1);
    
    gfx_a = alpha;
    gfx_arc(xl, yl, r, - $pi, 2*(1-gain)*$pi - $pi, 1);
    gfx_a = .2*alpha;
    gfx_arc(xl, yl, r+1, - $pi, 2*(1-gain)*$pi - $pi, 1);
    gfx_arc(xl, yl, r-1, - $pi, 2*(1-gain)*$pi - $pi, 1);
    
    r += 4;
    alpha *= adv;
    while(
      gfx_a = alpha;
      gfx_circle(xl, yl, r, 0, 0);
      gfx_a = .5*alpha;
      gfx_circle(xl, yl, r+1, 0, 1);
      gfx_circle(xl, yl, r-1, 0, 1);
      
      r += 4;
      alpha *= adv;
      alpha>.2
    );
    
    gfx_a = 1 - .7*silent;
    hpf < lpf ? (
      loop(5,
        gfx_arc(xl, yl, r, 2*lpf*$pi - $pi, 2*hpf*$pi - $pi, 1);
        r += .5;
      );
    );
    
    logLevel = log(4000*level-2);
    silent ? logLevel = 0;
    
    gfx_set(1, 1, 1, .03);
    gfx_circle(xl, yl, logLevel*5, 1, 1);
    
    gfx_set(1, 1, 1, .03);
    gfx_circle(xl, yl, logLevel*6, 1, 1);
    
    gfx_set(1, 1, 1, .03);
    gfx_circle(xl, yl, logLevel*8, 1, 1);    
    
    r = r*r;
  );

function clamp(x, lb, ub)
  local()
  global()
  instance()
  (
    max(lb,min(ub,x))
  );

function select(xmin, ymin, w, h, xselectmin, xselectmax, yselectmin, yselectmax)
  local(xl, yl)
  global()
  instance(x, y, dtime, selected)
  (
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
        
    selected = ( xl > xselectmin ) && ( xl < xselectmax ) && ( yl > yselectmin ) && ( yl < yselectmax ) ? 1 : 0;
  );

function amIChosen()
  local()
  global()
  instance(selected)
  (
    selected = ( selected == 2 ) ? 1 : 0;
  );

function tryNodeConnect(xmin, ymin, w, h, from, mousex, mousey)
  local(xl, yl, outer, dx, dy)
  instance(dtime, x, y, fbcoeff,
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11)
  global()
  (
    x = timeToX(dtime);
    outer = 8+4.15*ceil(log(.2)/log(fbcoeff)); 
    xl = xmin + x*w;
    yl = ymin + y*h;
    
    dx = mousex - xl;
    dy = mousey - yl;
    
    /* Yeah! We're in range. hook us up! */
    ( (dx*dx + dy*dy) < (outer*outer) ) ? (
      ((from == 1)  && (fromNode1  == 0)) ? fromNode1 = fbcoeff;
      ((from == 2)  && (fromNode2  == 0)) ? fromNode2 = fbcoeff;
      ((from == 3)  && (fromNode3  == 0)) ? fromNode3 = fbcoeff;
      ((from == 4)  && (fromNode4  == 0)) ? fromNode4 = fbcoeff;
      ((from == 5)  && (fromNode5  == 0)) ? fromNode5 = fbcoeff;
      ((from == 6)  && (fromNode6  == 0)) ? fromNode6 = fbcoeff;
      ((from == 7)  && (fromNode7  == 0)) ? fromNode7 = fbcoeff;
      ((from == 8)  && (fromNode8  == 0)) ? fromNode8 = fbcoeff;
      ((from == 9)  && (fromNode9  == 0)) ? fromNode9 = fbcoeff;
      ((from == 10) && (fromNode10 == 0)) ? fromNode10 = fbcoeff;
      ((from == 11) && (fromNode11 == 0)) ? fromNode11 = .5;
    );
  );

function overNode(xmin, ymin, w, h, mousex, mousey, mousecap)
  local(dx, dy, dist, xl, yl)
  global(nodeCap)
  instance(overConnector, x, y, r, dtime, lastleft, left, lastright, right, lx, ly, selected)
  (
    left  = mousecap & 1;
    right = mousecap & 2;
    x = timeToX(dtime);
    
    xl = xmin + x*w;
    yl = ymin + y*h;
    dx = mousex - xl;
    dy = mousey - yl;
    
    ( left ) ? (
      ( (nodeCap == 0) && (lastleft == 0) && (lastright == 0) ) ? (
        ( overConnector ) ? (
          nodeCap = -10-overConnector;
          selected = 2;
        ) : (
          dist = dx * dx + dy * dy;
          ( dist < r ) ? (
            nodeCap = 1;
            
            /* If this one is not selected, signal that all others have to be deselected */
            !selected ? (
              selected = 2;
              nodeCap = -nodeCap;
            );
          );
        );
      );
    ) : ( right ) ? (
      ( (nodeCap == 0) && (lastright == 0) && (lastleft == 0) ) ? (
        ( overConnector ) ? (
          nodeCap = -10-overConnector;
          selected = 2;
        ) : (
          dist = dx * dx + dy * dy;
          ( dist < r ) ? (
            nodeCap = 2;
            
            /* If this one is not selected, signal that all others have to be deselected */
            !selected ? (
              selected = 2;
              nodeCap = -nodeCap;
            );
          );
        );
      );
    ) : ( 
      nodeCap = 0;
    );
    
    lastleft = left;
    lastright = right;    
  );

function nodeProcessMouse(xmin, ymin, w, h, mousex, mousey, mousecap, currentCap, lx, ly, dbl)
  local(left, right, dist, shift, ctrl, alt, from, chy, xl, yl, moved)
  global(SyncMode, Snap, nodeCap, 
          node1.tryNodeConnect,
          node2.tryNodeConnect,
          node3.tryNodeConnect,
          node4.tryNodeConnect,
          node5.tryNodeConnect,
          node6.tryNodeConnect,
          node7.tryNodeConnect,
          node8.tryNodeConnect,
          node9.tryNodeConnect, 
          node10.tryNodeConnect,
          node11.tryNodeConnect )
  instance(x, y, r, dtime, fb, lpf, hpf, pan, selected, lcap,
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, fromNode11, Connecting, me)
  (
    shift = mousecap & 8;
    ctrl  = mousecap & 4;
    alt   = mousecap & 16;
    left  = mousecap & 1;
    right = mousecap & 2;    
    
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
    moved = 0;
    
    left ? (
      ( currentCap > 10 && selected ) ? (
        chy = (ly-mousey)/h;
        currentCap == 11 ? fromNode1  = clamp( fromNode1 + chy, 0.001, .999 );
        currentCap == 12 ? fromNode2  = clamp( fromNode2 + chy, 0.001, .999 );
        currentCap == 13 ? fromNode3  = clamp( fromNode3 + chy, 0.001, .999 );
        currentCap == 14 ? fromNode4  = clamp( fromNode4 + chy, 0.001, .999 );
        currentCap == 15 ? fromNode5  = clamp( fromNode5 + chy, 0.001, .999 );
        currentCap == 16 ? fromNode6  = clamp( fromNode6 + chy, 0.001, .999 );
        currentCap == 17 ? fromNode7  = clamp( fromNode7 + chy, 0.001, .999 );
        currentCap == 18 ? fromNode8  = clamp( fromNode8 + chy, 0.001, .999 );
        currentCap == 19 ? fromNode9  = clamp( fromNode9 + chy, 0.001, .999 );
        currentCap == 20 ? fromNode10 = clamp( fromNode10 + chy, 0.001, .999 );
        currentCap == 21 ? fromNode11 = clamp( fromNode11 + chy, 0.001, .999 );
      ) : ( currentCap == 1 && selected ) ? (
        moved = 1;
        ( shift ) ? (
          ( alt ) ? (
            gfx_set( 1, 1, 1, 1 );
            gfx_line(xl, yl, mousex, mousey);
            gfx_line(xl, yl+1, mousex, mousey+1);
            gfx_line(xl, yl-1, mousex, mousey-1);
            gfx_line(xl+1, yl, mousex+1, mousey+1);
            gfx_line(xl-1, yl, mousex-1, mousey-1);
            Connecting = 1;
          ) : ( ctrl ) ? (
            hpf = clamp( hpf - (mousey-ly)/h, 0, lpf );
          ) : (
            lpf = clamp( lpf - (mousey-ly)/h, hpf, 1 );
          );
        ) : (
          ( alt ) ? (
            dbl ? ( 
              pan = 0.5;
            ) : (
              pan = clamp( pan - (mousey-ly)/h, 0, 1);
            );
          ) : (
            x += (mousex-lx)/w;
            y += (mousey-ly)/h;
          );
        );
      );
    ) : ( right ) ? (
      ( currentCap > 10 && selected ) ? (
        currentCap == 11 ? fromNode1  = 0;
        currentCap == 12 ? fromNode2  = 0;
        currentCap == 13 ? fromNode3  = 0;
        currentCap == 14 ? fromNode4  = 0;
        currentCap == 15 ? fromNode5  = 0;
        currentCap == 16 ? fromNode6  = 0;
        currentCap == 17 ? fromNode7  = 0;
        currentCap == 18 ? fromNode8  = 0;
        currentCap == 19 ? fromNode9  = 0;
        currentCap == 20 ? fromNode10 = 0;
        currentCap == 21 ? fromNode11 = 0;
      ) : ( currentCap == 2 && selected ) ? (
        fb = fb - (mousey-ly)/w;
        fb = clamp(fb, 0, .999);
      );
    );
    
    ( ( currentCap == 0 ) && ( lcap > 0 ) ) ? (
      Snap ? (
        ( SyncMode == 1 ) ? (
          x= floor(x*16+.5)/16;
        ) : ( SyncMode == 2 ) ? (
          x= floor(x*12+.5)/12;
        ) : ( SyncMode == 3 ) ? (
          x= floor(x*20+.5)/20;
        ) : ( SyncMode == 4 ) ? (
          x= floor(x*16+.5)/16;
        ) : ( SyncMode == 5 ) ? (
          x= floor(x*12+.5)/12;
        );
      );
      
      Connecting ? (
        node1.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node2.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node3.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node4.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node5.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node6.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node7.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node8.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node9.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node10.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node11.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
      );
      
      Connecting = 0;
    );
    
    dtime = xToTime(x);
    
    moved ? (
      this.updateToSliderRec();
    );
    
    selected ? (
      lcap = currentCap;
    ) : (
      lcap = 0;
    );
  );

// MEMORY LAYOUT
bufSize = 65536*8;
minvol = 0.05;
maxvol = 1;

dTap1  = 1;
dTap2  = 2*bufSize;
dTap3  = 3*bufSize;
dTap4  = 4*bufSize;
dTap5  = 5*bufSize;
dTap6  = 6*bufSize;
dTap7  = 7*bufSize;
dTap8  = 8*bufSize;
dTap9  = 9*bufSize;
dTap10 = 10*bufSize;

function Init()
  (
    /* Initialize or reset the nodes */
    node1.initNode(dTap1,   xToTime(0.5),  0.1, 1,  0);
    node2.initNode(dTap2,   xToTime(0.1),  1.0, 2,  0);
    node3.initNode(dTap3,   xToTime(0.2),  1.0, 3,  0);
    node4.initNode(dTap4,   xToTime(0.3),  1.0, 4,  0);
    node5.initNode(dTap5,   xToTime(0.4),  1.0, 5,  0);
    node6.initNode(dTap6,   xToTime(0.5),  1.0, 6,  1);
    node7.initNode(dTap7,   xToTime(0.6),  1.0, 7,  1);
    node8.initNode(dTap8,   xToTime(0.7),  1.0, 8,  1);
    node9.initNode(dTap9,   xToTime(0.8),  1.0, 9,  1);
    node10.initNode(dTap10, xToTime(0.9),  1.0, 10, 1);
    node11.initNode(dTap10, xToTime(0.9),   .5, 11, 1);
    freemem = node11.initFFTNode(12*bufSize);
 
    BUF_SIZE = 64000;
    freemem = (height = freemem) + BUF_SIZE;
    freemem = (velocity_x = freemem) + BUF_SIZE;
    freemem = (velocity_y = freemem) + BUF_SIZE;
    freemem = (height_gradient_x = freemem) + BUF_SIZE;
    freemem = (height_gradient_y = freemem) + BUF_SIZE;
    freemem = (velocity_prediction_x = freemem) + BUF_SIZE;
    freemem = (velocity_prediction_y = freemem) + BUF_SIZE;
    
    updateGain();
    startFade.fadeIn(50);
  );
  
function updateFromSliderAll()
(
  node1.updateFromSlider();
  node2.updateFromSlider();
  node3.updateFromSlider();
  node4.updateFromSlider();
  node5.updateFromSlider();
  node6.updateFromSlider();
  node7.updateFromSlider();
  node8.updateFromSlider();
  node9.updateFromSlider();
  node10.updateFromSlider();
  node11.updateFromSlider();
);

function updateToSliderAll()
(
  node1.updateToSlider();
  node2.updateToSlider();
  node3.updateToSlider();
  node4.updateToSlider();
  node5.updateToSlider();
  node6.updateToSlider();
  node7.updateToSlider();
  node8.updateToSlider();
  node9.updateToSlider();
  node10.updateToSlider();
  node11.updateToSlider();
);

Init();

@serialize
file_var(0, maxTime);
file_var(0, minTime);

node1.serializeNode();
node2.serializeNode();
node3.serializeNode();
node4.serializeNode();
node5.serializeNode();
node6.serializeNode();
node7.serializeNode();
node8.serializeNode();
node9.serializeNode();
node10.serializeNode();
node11.serializeNode();

@slider

@block
!node1.mute  ? node1.play  = 1 : node1.play  = 0;
!node2.mute  ? node2.play  = 1 : node2.play  = 0;
!node3.mute  ? node3.play  = 1 : node3.play  = 0;
!node4.mute  ? node4.play  = 1 : node4.play  = 0;
!node5.mute  ? node5.play  = 1 : node5.play  = 0;
!node6.mute  ? node6.play  = 1 : node6.play  = 0;
!node7.mute  ? node7.play  = 1 : node7.play  = 0;
!node8.mute  ? node8.play  = 1 : node8.play  = 0;
!node9.mute  ? node9.play  = 1 : node9.play  = 0;
!node10.mute ? node10.play = 1 : node10.play = 0;
!node11.mute ? node11.play = 1 : node11.play = 0;

( node1.solo || node2.solo || node3.solo || node4.solo || node5.solo || node6.solo || node7.solo || node8.solo || node9.solo || node10.solo || node11.solo ) ? 
( node1.play = node2.play = node3.play = node4.play = node5.play = node6.play = node7.play = node8.play = node9.play = node10.play = node11.play = 0 );

node1.solo  ? node1.play  = 1;
node2.solo  ? node2.play  = 1;
node3.solo  ? node3.play  = 1;
node4.solo  ? node4.play  = 1;
node5.solo  ? node5.play  = 1;
node6.solo  ? node6.play  = 1;
node7.solo  ? node7.play  = 1;
node8.solo  ? node8.play  = 1;
node9.solo  ? node9.play  = 1;
node10.solo ? node10.play = 1;
node11.solo ? node11.play = 1;

node1.updateNodeBlock();
node2.updateNodeBlock();
node3.updateNodeBlock();
node4.updateNodeBlock();
node5.updateNodeBlock();
node6.updateNodeBlock();
node7.updateNodeBlock();
node8.updateNodeBlock();
node9.updateNodeBlock();
node10.updateNodeBlock();
node11.updateNodeBlock();

updateGain();

israte = 1 / srate;

@sample
samples += 1;
updateRange();

cPos += 50*israte;
lOut = 0;
rOut = 0;

samples % 4 == 0 ? (
  node1.updateNode();
  node2.updateNode();
  node3.updateNode();
  node4.updateNode();
  node5.updateNode();
  node6.updateNode();
  node7.updateNode();
  node8.updateNode();
  node9.updateNode();
  node10.updateNode();
  node11.updateNode();
);

fade = startFade.evaluateFade();
spl0 *= fade;
spl1 *= fade;

node1.process(spl0, spl1);
node2.process(spl0, spl1);
node3.process(spl0, spl1);
node4.process(spl0, spl1);
node5.process(spl0, spl1);
node6.process(spl0, spl1);
node7.process(spl0, spl1);
node8.process(spl0, spl1);
node9.process(spl0, spl1);
node10.process(spl0, spl1);
node11.processVerbNode(spl0, spl1);

spl0 = spl0 * (1-drywet) + lOut * drywet * gainFactor;
spl1 = spl1 * (1-drywet) + rOut * drywet * gainFactor;

@gfx
render_time = render_time + 1/60;
lastchar = gfx_getchar();

function draw_to_sim(xmin, ymin, w, h, xs, Ny)
local(cx, cy, intensity)
global(gfx_a, gfx_x, gfx_y, height)
instance(x, y, level)
(     
  //radius = fbcoeff/(1+.15*verb);
  //adv = min(0.99, radius);
  cx = floor((xmin + x*w) / xs);
  cy = floor((ymin + y*h) / xs);
  
  intensity = 30*level;
  height[cx * Ny + cy] += intensity;
  
  cx = cx + 1;
  height[cx * Ny + cy] += intensity;
  cx = cx - 2;
  height[cx * Ny + cy] += intensity;  
);

function simulation(sim_w, sim_h, xs)
(
  (last_sim_w != sim_w || last_sim_h != sim_h) ? (
    last_sim_w = sim_w;
    last_sim_h = sim_h;
    
    memset(height, 0, BUF_SIZE);
    memset(velocity_x, 0, BUF_SIZE);
    memset(velocity_y, 0, BUF_SIZE);
    memset(height_gradient_x, 0, BUF_SIZE);
    memset(height_gradient_y, 0, BUF_SIZE);
    memset(velocity_prediction_x, 0, BUF_SIZE);
    memset(velocity_prediction_y, 0, BUF_SIZE);
  );

  Nx = sim_w/xs + 1;
  Ny = sim_h/xs + 1;
 
  c1r = 17/256;
  c1g = 11/256;
  c1b = 34/256;
   
  c2r = 175/256;
  c2g = 121/256;
  c2b = 274/256;
  
  dtg = 9.81*0.1;
  dth = .4*0.1;
  
  /*(mouse_cap & 1 && !capped) > 0 ? (  
    (mouse_x < sim_w) && (mouse_y < sim_h) && (mouse_x > 0) && (mouse_y > 0) ? (
      dt = time_precise() - last_time;
      vx = (mouse_x - last_mouse_x) / dt;
      vy = (mouse_y - last_mouse_y) / dt;
      cx = floor(mouse_x / xs);
      cy = floor(mouse_y / xs);
      height[cx * Ny + cy] += 3;
    );
  );*/
  
  node1.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node2.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node3.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node4.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node5.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node6.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node7.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node8.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node9.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node10.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  node11.draw_to_sim(w1x, w1y, w1w, w1h, xs, Ny);
  
  xl = floor(xmin + x*w);
  yl = floor(ymin + y*h);
  
  /*cx = (Nx-4) * rand() + 2;
  cy = (Ny-4) * rand() + 2;
  height[cx * Ny + cy] = 8*(rand()>.65)*(.5+rand());*/
  
  cx = 0;
  loop(Nx-1,
    cy = 0;
    loop(Ny-1,
      h = height[cx * Ny + cy];
      dHx = h - height[(cx-1) * Ny + cy];
      dHy = h - height[cx * Ny + cy-1];
    
      velocity_prediction_x[cx * Ny + cy] = velocity_x[cx * Ny + cy] - dtg * dHx;
      velocity_prediction_y[cx * Ny + cy] = velocity_y[cx * Ny + cy] - dtg * dHy;
      cy += 1;
    );
    cx += 1;
  );
  
  cx = 0;
  loop(Ny,
    velocity_prediction_x[0 + cy] = 0;
    velocity_prediction_x[(Nx-1) * Ny + cy] = 0;
    cy += 1;
  );
  
  cy = 0;
  loop(Nx,
    velocity_prediction_y[cx * Ny + 0] = 0;
    velocity_prediction_y[cx * Ny + (Ny-1)] = 0;
    cx += 1;
  );
  
  cx = 0;
  loop(Nx-1,
    cy = 0;
    loop(Ny-1,
      dUx = velocity_prediction_x[(cx+1) * Ny + cy] - velocity_prediction_x[cx * Ny + cy];
      dUy = velocity_prediction_y[cx * Ny + cy + 1] - velocity_prediction_y[cx * Ny + cy];
    
      h = height[cx * Ny + cy];
      height[cx * Ny + cy] = h - dth * (dUx + dUy) - .005*h;
      cy += 1;
      lvl = h>1?1:h;
            
      gfx_set(c1r * (1-lvl) + c2r * lvl, 
              c1g * (1-lvl) + c2g * lvl,
              c1b * (1.0-lvl) + c2b * lvl,
              1.0);
      gfx_rect(cx * xs, cy * xs, xs-1, xs-1);
      gfx_a = .8;
      gfx_rect(cx * xs, cy * xs, xs, xs);
    );
    cx += 1;
  );
  
  cx = 0;
  loop(Nx-1,
    cy = 0;
    loop(Ny-1,
      h = height[cx * Ny + cy];
      dHx = h - height[(cx-1) * Ny + cy];
      dHy = h - height[cx * Ny + cy-1];
    
      velocity_x[cx * Ny + cy] = velocity_x[cx * Ny + cy] - dtg * dHx;
      velocity_y[cx * Ny + cy] = velocity_y[cx * Ny + cy] - dtg * dHy;
      cy += 1;
    );
    cx += 1;
  );
);

// Gradients are buffered to save rendering perf
function drawGradients(w, h, spectrumH, gradient_bg)
instance(lw, lh, lSpectrumH, m, c)
global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
       gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
local( oldDest, oldMode, ang1, ang2, alpha, q, centerNoise, bump, cx, cy, angSiz )
(
  oldMode = gfx_mode;
  gfx_mode = 0;
  gfx_set(1,1,1,1);
  ( ( lw != w ) || ( lh != h ) || (spectrumH != lSpectrumH) ) ? (
    // Only draw gradients when size changes
    gfx_x = gfx_y = 0;
    lw = w;
    lh = h;
    lSpectrumH = spectrumH;
    oldDest = gfx_dest;
    gfx_setimgdim(gradient_bg, w, h);
    
    gfx_dest = gradient_bg;
    gfx_set(0, 0, 0, 1);
    gfx_rect(0, 0, w, h);
    
    gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);
    m = max(w,h);
    gfx_mode = 1;
    alpha = .1;
    bump = 1.05;
    q = 0;
    centerNoise = 0.1*rand();
    cx = w*rand();
    cy = h*rand();
    angSiz = rand();
    ( angSiz < .5 ) ? ( angSiz = .00015 )
    : ( angSiz = .0015 );
    
    loop(200,
      c = rand();
      ( c < .4 ) ? ( gfx_set( 1, 0.1, 0.4, alpha ) )
      : ( c < .9 ) ? ( gfx_set( 0.2, 0.2, 1, alpha) )
      : ( gfx_set( 0, 0, 0, alpha ) );
      
      ang1 = $pi * rand() * 2;
      q == 0 ? ( 
        ang2 = 0;
      ) : (
        ang2 = ang1 + $pi * rand() * angSiz / q;
      );
      gfx_triangle(cx + centerNoise*w*(rand()-0.5), cy + centerNoise*h*(rand()-0.5), .5*w + m * cos(ang1), .5*h + m * sin(ang1), .5*w + m * cos(ang2), .5*h + m * sin(ang2));
      q += 1;
      
      gfx_x = gfx_y = 0;
      q > 4 ? (
        q = 0;
        gfx_blurto(w, h);
        gfx_muladdrect(0, 0, w, h, bump, bump, bump, 1.0, 0, 0, 0, 0);
      );
    );
    gfx_mode = 0;
    
    gfx_dest = oldDest;
  );
    
  gfx_x = gfx_y = 0;
  gfx_blit(gradient_bg, 1, 0);
  gfx_mode = oldMode;
);

font_color_r = 1;
font_color_g = 1;
font_color_b = 1;
font_color_a = 1;
line_color_r = .3;
line_color_g = 0;
line_color_b = 1;
line_color_a = .7;
knob_font_color_r = 0;
knob_font_color_g = 0;
knob_font_color_b = 0;
knob_font_color_a = 1;

FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", 16);

BAND_FONT = 5;
gfx_setfont(BAND_FONT, "Arial", 16);

KNOB_FONT = 6;
gfx_setfont(KNOB_FONT, "Arial", 14);

KNOB_FONT2 = 7;
gfx_setfont(KNOB_FONT2, "Arial", 13);

function drawWindow(x, y, w, h)
  local(dx, dy, Nx, Ny, pw, ph, xValue, yLevel, dyL, dxL, i, ct)
  global(gfx_x, gfx_y, FONT_GRID, SyncMode,
          font_color_r, font_color_g, font_color_b, font_color_a, 
          line_color_r, line_color_g, line_color_b, line_color_a )
  instance()
  (
    SyncMode == 0 ? (
      Nx = 10;
      Ny = 10;
    ) : ( SyncMode == 1 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 2 ) ? (
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 3 ) ? (
      Nx = 5*4;
      Ny = 10;
    ) : ( SyncMode == 4 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 5 ) ? ( 
      Nx = 3*4;
      Ny = 10;
    );
    dx = w/Nx;
    dy = h/Ny;
    dyL = 1/Ny;
    dxL = 1/Nx;
    gfx_y = y+dy;
    
    gfx_measurestr("8888", pw, ph);
    gfx_setfont( FONT_GRID );
    yLevel = 1-dyL;
    loop(Ny-1,
      gfx_set(0, 0, 0, .7);
      gfx_line(x, gfx_y-1, x+w, gfx_y-1);
      //gfx_set(line_color_r, line_color_g, line_color_b, line_color_a);
      gfx_line(x, gfx_y, x+w, gfx_y);
      gfx_line(x, gfx_y+1, x+w, gfx_y+1);
      gfx_set(0, 0, 0, .2);
      gfx_line(x, gfx_y+1, x+w-pw, gfx_y+1);
      
      gfx_x = x+w + 10;
      gfx_y -= .5*ph;
      //gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      //gfx_printf("%d dB", 20*log10(yToVol(1-yLevel)) );
      
      gfx_y += dy + .5*ph;
      yLevel -= dyL;
    );
    
    gfx_x = x;
    gfx_y = h;
    i = 1;
    xValue = 0;
    loop(Nx+1,
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x-1, y, gfx_x-1, y+h);
      //gfx_set(line_color_r, line_color_g, line_color_b, line_color_a);
      gfx_line(gfx_x, y, gfx_x, y+h);
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x+1, y, gfx_x+1, y+h);
      
      //gfx_x = x + .1*pw;
      ct = 1000*xToTime(xValue);
      gfx_x += .2*pw;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      ( abs(ct - floor(ct+.5)) < .1 ) ? gfx_printf("%d", floor(ct+.5)) : gfx_printf("%.1f", ct);
      
      gfx_x = x + dx * i;
      xValue += dxL;
      i += 1;
    );
  );

function drawWindowText(x, y, w, h)
  local(dx, dy, Nx, Ny, pw, ph, xValue, yLevel, dyL, dxL, i, ct)
  global(gfx_x, gfx_y, FONT_GRID, SyncMode,
          font_color_r, font_color_g, font_color_b, font_color_a, 
          line_color_r, line_color_g, line_color_b, line_color_a )
  instance()
  (
    SyncMode == 0 ? (
      Nx = 10;
      Ny = 10;
    ) : ( SyncMode == 1 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 2 ) ? (
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 3 ) ? (
      Nx = 5*4;
      Ny = 10;
    ) : ( SyncMode == 4 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 5 ) ? ( 
      Nx = 3*4;
      Ny = 10;
    );
    dx = w/Nx;
    dy = h/Ny;
    dyL = 1/Ny;
    dxL = 1/Nx;
    gfx_y = y+dy;
    
    gfx_measurestr("8888", pw, ph);
    gfx_setfont( FONT_GRID );
    yLevel = 1-dyL;
    loop(Ny-1,
      gfx_x = x+w + 10;
      gfx_y -= .5*ph;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      gfx_printf("%d dB", 20*log10(yToVol(1-yLevel)) );
      
      gfx_y += dy + .5*ph;
      yLevel -= dyL;
    );
    
    gfx_x = x;
    gfx_y = h;
    i = 1;
    xValue = 0;
    loop(Nx+1,
      //gfx_x = x + .1*pw;
      ct = 1000*xToTime(xValue);
      gfx_x += .2*pw;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      ( abs(ct - floor(ct+.5)) < .1 ) ? gfx_printf("%d", floor(ct+.5)) : gfx_printf("%.1f", ct);
      
      gfx_x = x + dx * i;
      xValue += dxL;
      i += 1;
    );
  );

gfx_set(0,0,0,1);
gfx_rect(0, 0, gfx_w, gfx_h);

ymin = 0;
ymax = gfx_h;
xmin = 0;
xmax = gfx_w;

w1x = 0;
w1y = 0;
w1w = .92*gfx_w;
w1h = .8*gfx_h;

bg_color_r = 1.1;
bg_color_g = 0.3;
bg_color_b = 0.3;
bg_color_a = 0.8;

//grads.drawGradients(w1w, w1h, w1h, 0);

simulation(w1w, w1h, 5);

drawWindow(w1x, w1y, w1w, w1h);

node1.drawConnections(w1x, w1y, w1w, w1h);
node2.drawConnections(w1x, w1y, w1w, w1h);
node3.drawConnections(w1x, w1y, w1w, w1h);
node4.drawConnections(w1x, w1y, w1w, w1h);
node5.drawConnections(w1x, w1y, w1w, w1h);
node6.drawConnections(w1x, w1y, w1w, w1h);
node7.drawConnections(w1x, w1y, w1w, w1h);
node8.drawConnections(w1x, w1y, w1w, w1h);
node9.drawConnections(w1x, w1y, w1w, w1h);
node10.drawConnections(w1x, w1y, w1w, w1h);
node11.drawConnections(w1x, w1y, w1w, w1h);

node1.draw(w1x, w1y, w1w, w1h, 0);
node2.draw(w1x, w1y, w1w, w1h, 0);
node3.draw(w1x, w1y, w1w, w1h, 0);
node4.draw(w1x, w1y, w1w, w1h, 0);
node5.draw(w1x, w1y, w1w, w1h, 0);
node6.draw(w1x, w1y, w1w, w1h, 0);
node7.draw(w1x, w1y, w1w, w1h, 0);
node8.draw(w1x, w1y, w1w, w1h, 0);
node9.draw(w1x, w1y, w1w, w1h, 0);
node10.draw(w1x, w1y, w1w, w1h, 0);
node11.draw(w1x, w1y, w1w, w1h, 1);

gfx_set(0,0,0,1);
gfx_rect(0, w1y+w1h+1, gfx_w, gfx_h-w1h);

drawWindowText(w1x, w1y, w1w, w1h);

lastleft = left;
left = mouse_cap & 1;

((left > 0) && (lastleft == 0)) ? leftTime = time_precise();
ddtime  = ( leftTime - lastLeftTime );
dblclick = ( (left > 0) && (lastleft == 0) && ( ( leftTime - lastLeftTime ) < .2 ) ) ? 1 : 0;
lastLeftTime = leftTime;

!lastleft ? multiSelect = 0;
multiSelect == 0 ? (
   // These functions will fill global nodeCap with the capture mode that occurred
   // 1 - LMB, 2 - RMB
   node1.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node2.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node3.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node4.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node5.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node6.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node7.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node8.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node9.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node10.overNode(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap );
   node11.overNode(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap );
  
   // An unselected one was selected. Deselect all others
   nodeCap < 0 ? (
    node1.amIChosen();
    node2.amIChosen();
    node3.amIChosen();
    node4.amIChosen();
    node5.amIChosen();
    node6.amIChosen();
    node7.amIChosen();
    node8.amIChosen();
    node9.amIChosen();
    node10.amIChosen();
    node11.amIChosen();
    nodeCap = abs(nodeCap);
   );
   
   node1.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node2.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node3.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node4.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node5.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node6.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node7.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node8.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node9.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node10.nodeProcessMouse(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);
   node11.nodeProcessMouse(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY, dblclick);

  lastMouseX = mouse_x;
  lastMouseY = mouse_y;
  
  !nodeCap ? (
    // No nodes manipulated => Do multi-select
    ( mouse_x > w1x ) && ( mouse_y > w1y ) && ( mouse_x < ( w1x + w1w ) ) && ( mouse_y < ( w1y + w1h ) ) ? (
      ( ( lastleft == 0 ) && ( left == 1 ) ) ? (
        multiSelect = 1;
        refx = mouse_x;
        refy = mouse_y;
      );
    );
  );
) : ( multiSelect == 1 ) ? (
  xmi = min(refx, mouse_x);
  xma = max(refx, mouse_x);
  ymi = min(refy, mouse_y);
  yma = max(refy, mouse_y);
  gfx_set(1, 1, 1, .4);
  gfx_rect(xmi, ymi, xma-xmi, yma-ymi);
  // Select nodes upon release
  !left ? (
    node1.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node2.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node3.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node4.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node5.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node6.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node7.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node8.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node9.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node10.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node11.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
  );
);

  function printRight(str)
  (
    gfx_set(0,0,0,1);
    gfx_measurestr(str, tx, ty);
    gfx_x = w1x+w1w-tx-5;
    gfx_printf(str);
    gfx_y = gfx_y + 1;
    gfx_x = w1x+w1w-tx-5;
    gfx_set(1,1,1,1);
    gfx_printf(str);
    gfx_y = gfx_y + ty;
  );

gfx_y = 5;
printRight("RMB - Feedback\n");
printRight("Shift - LPF\n");
printRight("Ctrl + Shift - HPF\n");
printRight("Shift + Alt - Add Send\n");
printRight("Alt - Panning\n");
printRight("M - Mute\n");
printRight("S - Solo\n");
printRight("P - Ping pong\n");
printRight("R - Rectify\n");
printRight("Wheel - Direct In Gain\n");
printRight("G - Grain\n");
printRight("T - Scale by feedback\n");

// F1 - reset delay lines
( lastchar == 26161 ) ? (
  Init();
);

// Mute
( lastchar == 109 ) ? (
  node1.selected  ? node1.mute  = node1.mute  ? 0 : 1;
  node2.selected  ? node2.mute  = node2.mute  ? 0 : 1;
  node3.selected  ? node3.mute  = node3.mute  ? 0 : 1;
  node4.selected  ? node4.mute  = node4.mute  ? 0 : 1;
  node5.selected  ? node5.mute  = node5.mute  ? 0 : 1;
  node6.selected  ? node6.mute  = node6.mute  ? 0 : 1;
  node7.selected  ? node7.mute  = node7.mute  ? 0 : 1;
  node8.selected  ? node8.mute  = node8.mute  ? 0 : 1;
  node9.selected  ? node9.mute  = node9.mute  ? 0 : 1;
  node10.selected ? node10.mute = node10.mute ? 0 : 1;
  node11.selected ? node11.mute = node11.mute ? 0 : 1;
);

// Grain
( lastchar == 103 ) ? (
  node1.selected  ? node1.grain  = node1.grain  ? 0 : 1;
  node2.selected  ? node2.grain  = node2.grain  ? 0 : 1;
  node3.selected  ? node3.grain  = node3.grain  ? 0 : 1;
  node4.selected  ? node4.grain  = node4.grain  ? 0 : 1;
  node5.selected  ? node5.grain  = node5.grain  ? 0 : 1;
  node6.selected  ? node6.grain  = node6.grain  ? 0 : 1;
  node7.selected  ? node7.grain  = node7.grain  ? 0 : 1;
  node8.selected  ? node8.grain  = node8.grain  ? 0 : 1;
  node9.selected  ? node9.grain  = node9.grain  ? 0 : 1;
  node10.selected ? node10.grain = node10.grain ? 0 : 1;
  //node11.selected ? node11.grain = node11.grain ? 0 : 1;
  init();
);

// Solo
( lastchar == 115 ) ? (
  node1.selected  ? node1.solo  = node1.solo  ? 0 : 1;
  node2.selected  ? node2.solo  = node2.solo  ? 0 : 1;
  node3.selected  ? node3.solo  = node3.solo  ? 0 : 1;
  node4.selected  ? node4.solo  = node4.solo  ? 0 : 1;
  node5.selected  ? node5.solo  = node5.solo  ? 0 : 1;
  node6.selected  ? node6.solo  = node6.solo  ? 0 : 1;
  node7.selected  ? node7.solo  = node7.solo  ? 0 : 1;
  node8.selected  ? node8.solo  = node8.solo  ? 0 : 1;
  node9.selected  ? node9.solo  = node9.solo  ? 0 : 1;
  node10.selected ? node10.solo = node10.solo ? 0 : 1;
  node11.selected ? node11.solo = node11.solo ? 0 : 1;
);

// Pingpong (P)
( lastchar == 112 ) ? (
  node1.selected  ? node1.pingpong  = node1.pingpong  ? 0 : 1;
  node2.selected  ? node2.pingpong  = node2.pingpong  ? 0 : 1;
  node3.selected  ? node3.pingpong  = node3.pingpong  ? 0 : 1;
  node4.selected  ? node4.pingpong  = node4.pingpong  ? 0 : 1;
  node5.selected  ? node5.pingpong  = node5.pingpong  ? 0 : 1;
  node6.selected  ? node6.pingpong  = node6.pingpong  ? 0 : 1;
  node7.selected  ? node7.pingpong  = node7.pingpong  ? 0 : 1;
  node8.selected  ? node8.pingpong  = node8.pingpong  ? 0 : 1;
  node9.selected  ? node9.pingpong  = node9.pingpong  ? 0 : 1;
  node10.selected ? node10.pingpong = node10.pingpong ? 0 : 1;
);

// Rectify (R)
( lastchar == 114 ) ? (
  node1.selected  ? node1.rectify  = node1.rectify  ? 0 : 1;
  node2.selected  ? node2.rectify  = node2.rectify  ? 0 : 1;
  node3.selected  ? node3.rectify  = node3.rectify  ? 0 : 1;
  node4.selected  ? node4.rectify  = node4.rectify  ? 0 : 1;
  node5.selected  ? node5.rectify  = node5.rectify  ? 0 : 1;
  node6.selected  ? node6.rectify  = node6.rectify  ? 0 : 1;
  node7.selected  ? node7.rectify  = node7.rectify  ? 0 : 1;
  node8.selected  ? node8.rectify  = node8.rectify  ? 0 : 1;
  node9.selected  ? node9.rectify  = node9.rectify  ? 0 : 1;
  node10.selected ? node10.rectify = node10.rectify ? 0 : 1;
);

// T - transform
function convertToNewFormat()
  instance(fbCoeff, y)
  local(curVol)
  global()
  (
    curVol = yToVol(y);
    y = (-2/3)*log(curVol * fbCoeff)/log(10);
  );
  
( lastchar == 116 ) ? (
  node1.convertToNewFormat();
  node2.convertToNewFormat();
  node3.convertToNewFormat();
  node4.convertToNewFormat();
  node5.convertToNewFormat();
  node6.convertToNewFormat();
  node7.convertToNewFormat();
  node8.convertToNewFormat();
  node9.convertToNewFormat();
  node10.convertToNewFormat();
  lastchar = 0;
);

( abs( mouse_wheel ) > 0 ) ? (
  shift = mouse_cap & 8;
  ctrl  = mouse_cap & 4;
  dy = - mouse_wheel * .001;
  
  shift ? ( dy /= 4 );
  ctrl ? ( dy /= 4 );
  
  node1.selected   ? node1.gain  = clamp( node1.gain  + dy, 0, 1);
  node2.selected   ? node2.gain  = clamp( node2.gain  + dy, 0, 1);
  node3.selected   ? node3.gain  = clamp( node3.gain  + dy, 0, 1);
  node4.selected   ? node4.gain  = clamp( node4.gain  + dy, 0, 1);
  node5.selected   ? node5.gain  = clamp( node5.gain  + dy, 0, 1);
  node6.selected   ? node6.gain  = clamp( node6.gain  + dy, 0, 1);
  node7.selected   ? node7.gain  = clamp( node7.gain  + dy, 0, 1);
  node8.selected   ? node8.gain  = clamp( node8.gain  + dy, 0, 1);
  node9.selected   ? node9.gain  = clamp( node9.gain  + dy, 0, 1);
  node10.selected  ? node10.gain = clamp( node10.gain + dy, 0, 1);
  node11.selected  ? node11.gain = clamp( node11.gain + dy, 0, 1);

  mouse_wheel = 0;
);

nSelected = node1.selected + node2.selected + node3.selected + node4.selected + node5.selected + node6.selected + node7.selected + node8.selected + node9.selected + node10.selected + node11.selected*1;

function processVerbCtrls(cX, cY)
  instance(gain, vol, y, fb, pan, lpf, hpf,
  dcfl, dcfr, rectl, rectr, invol, lIn, rIn, buffer, activevol, fbcoeff, lpl, lpr, hpl, hpr, level, lPanTerm, rPanTerm, mute, solo, play, lastL, lastR, pingpong, rectify,
  inputGainKnob, outputGainKnob, feedbackKnob, panningKnob, lpfKnob, hpfKnob)
  local(knobSize, knobSpacing)
  global(mouse_x, mouse_y, mouse_cap, scaling)
  (
    gfx_setfont(4);
    knobSize = 35*(1+scaling);
    knobSpacing = 25*(1+scaling);
    
    inputGainKnob.active = 1;
    inputGainKnob.value = 1 - gain;
    inputGainKnob.drawKnob(cX, cY, knobSize, "In Gain", "Input gain.", 0);
    inputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? gain = 1-inputGainKnob.value;
        
    cX += 4*knobSpacing;
    outputGainKnob.active = 1;
    outputGainKnob.value = 1 - y;
    outputGainKnob.drawKnob(cX, cY, knobSize, "In Gain", "Input gain.", 0);
    outputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      y = 1 - outputGainKnob.value;
      this.updateToSliderRec();
    );
    
    cX += 4*knobSpacing;
    feedbackKnob.active = 1;
    feedbackKnob.value = fb;
    feedbackKnob.drawKnob(cX, cY, knobSize, "Decay time", "Feedback amount.", 0);
    feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? fb = clamp(feedbackKnob.value,0,.999);
    
    cX += 4*knobSpacing;
    lpfKnob.active = 1;
    lpfKnob.value = lpf;
    lpfKnob.drawKnob(cX, cY, knobSize, "Low pass", "Low pass filter.", 0);
    lpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      lpf = lpfKnob.value;
      lpf < hpf ? (
        hpf = lpf;
      );
    );
    
    cX += 4*knobSpacing;
    panningKnob.active = 1;
    panningKnob.value = pan;
    panningKnob.drawKnob(cX, cY, knobSize, "Panning", "Panning.", 0);
    panningKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? pan = panningKnob.value;
    
    cX += 4*knobSpacing;
    hpfKnob.active = 1;
    hpfKnob.value = hpf;
    hpfKnob.drawKnob(cX, cY, knobSize, "High pass", "High pass filter.", 0);
    hpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      hpf = hpfKnob.value;
      lpf < hpf ? (
        lpf = hpf;
      );
    );
    
    cX += .25*knobSpacing;
  );

function processRegularCtrls(cX, cY)
  instance(gain, vol, y, fb, pan, lpf, hpf, x, dtime,
  dcfl, dcfr, rectl, rectr, invol, lIn, rIn, buffer, activevol, fbcoeff, lpl, lpr, hpl, hpr, level, lPanTerm, rPanTerm, mute, solo, play, lastL, lastR, pingpong, rectify,
  inputGainKnob, outputGainKnob, feedbackKnob, panningKnob, lpfKnob, hpfKnob, timeKnob)
  local(knobSize, knobSpacing)
  global(mouse_x, mouse_y, mouse_cap, scaling)
  (
    gfx_setfont(4);
    knobSize = 35*(1+scaling);
    knobSpacing = 25*(1+scaling);
    
    inputGainKnob.active = 1;
    inputGainKnob.value = 1 - gain;
    inputGainKnob.drawKnob(cX, cY, knobSize, "In Gain", "Input gain.", 0);
    inputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? gain = 1-inputGainKnob.value;
        
    cX += 4*knobSpacing;
    outputGainKnob.active = 1;
    outputGainKnob.value = 1 - y;
    outputGainKnob.drawKnob(cX, cY, knobSize, "In Gain", "Input gain.", 0);
    outputGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      y = 1 - outputGainKnob.value;
      this.updateToSliderRec();
    );
    
    cX += 4*knobSpacing;
    timeKnob.active = 1;
    timeKnob.value = x;
    timeKnob.drawKnob(cX, cY, knobSize, "Delay Time", "Delay time.", 0);
    timeKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? (
      x = clamp(timeKnob.value,0,1);
      dtime = xToTime(x);
    );
    
    cX += 4*knobSpacing;
    feedbackKnob.active = 1;
    feedbackKnob.value = fb;
    feedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Feedback amount.", 0);
    feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.15) ? fb = clamp(feedbackKnob.value,0,.999);
    
    cX += 4*knobSpacing;
    panningKnob.active = 1;
    panningKnob.value = pan;
    panningKnob.drawKnob(cX, cY, knobSize, "Panning", "Panning.", 0);
    panningKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? pan = panningKnob.value;
    
    cX += 4*knobSpacing;
    hpfKnob.active = 1;
    hpfKnob.value = hpf;
    hpfKnob.drawKnob(cX, cY, knobSize, "High pass", "High pass filter.", 0);
    hpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      hpf = hpfKnob.value;
      lpf < hpf ? (
        lpf = hpf;
      );
    );
    
    cX += 4*knobSpacing;
    lpfKnob.active = 1;
    lpfKnob.value = lpf;
    lpfKnob.drawKnob(cX, cY, knobSize, "Low pass", "Low pass filter.", 0);
    lpfKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
      lpf = lpfKnob.value;
      lpf < hpf ? (
        hpf = lpf;
      );
    );    
    
    cX += .25*knobSpacing;
  );

// Draw grain controls
function processGrainCtrls(cX, cY)
  instance(grain, grainLength, grainJitter, grainOverlap, grainSpeed, grainPanSpread, grainSpeedSpread, 
                  lengthKnob,  jitterKnob,  overlapKnob,  speedKnob,  panSpreadKnob,  detuneKnob)
  local(knobSize, knobSpacing)
  global(mouse_x, mouse_y, mouse_cap, scaling)
  (
    gfx_setfont(4);
    knobSize = 35*(1+scaling);
    knobSpacing = 25*(1+scaling);
    grain ? (
      lengthKnob.active = 1;
      lengthKnob.value = (grainLength-40)/260;
      lengthKnob.drawKnob(cX, cY, knobSize, "Length", "Grain Length.", 0);
      lengthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? grainLength = lengthKnob.value*260+40;
      
      cX += 4*knobSpacing;
      
      overlapKnob.active = 1;
      overlapKnob.value = grainOverlap;
      overlapKnob.drawKnob(cX, cY, knobSize, "Overlap", "Grain Overlap.", 0);
      overlapKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.75) ? grainOverlap = overlapKnob.value;
      
      cX += 4*knobSpacing;
    
      jitterKnob.active = 1;
      jitterKnob.value = grainJitter/10;
      jitterKnob.drawKnob(cX, cY, knobSize, "Jitter", "Position Jitter.", 0);
      jitterKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.3) ? grainJitter = jitterKnob.value*10;
      
      cX += 4*knobSpacing;
      
      panSpreadKnob.active = 1;
      panSpreadKnob.value = grainPanSpread;
      panSpreadKnob.drawKnob(cX, cY, knobSize, "Spread", "Pan Jitter.", 0);
      panSpreadKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? grainPanSpread = panSpreadKnob.value;
      
      cX += 4*knobSpacing;
      
      speedKnob.active = 1;
      speedKnob.value = ((log(grainSpeed)/log(2))+2)*.25;
      sprintf(5, "%.3g", grainSpeed);
      speedKnob.label = 5;
      speedKnob.drawKnob(cX, cY, knobSize, "Pitch", "Control grain pitch.", 0);
      speedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? grainSpeed = 2^(4*speedKnob.value-2);
      
      cX += 4*knobSpacing;
      
      detuneKnob.active = 1;
      detuneKnob.value = grainSpeedSpread*4;
      detuneKnob.drawKnob(cX, cY, knobSize, "Detune", "Detune.", 0);
      detuneKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.1) ? grainSpeedSpread = detuneKnob.value*.25;
    );
  );

( nSelected == 1 ) ? (
  cY = w1h + .5*(gfx_h-w1h);
  cX = 100*(1+scaling);
  node1.selected ? ( selectedNode = 1; cX += node1.processRegularCtrls(cX, cY); node1.processGrainCtrls(cX, cY); ) :
  node2.selected ? ( selectedNode = 2; cX += node2.processRegularCtrls(cX, cY); node2.processGrainCtrls(cX, cY); ) :
  node3.selected ? ( selectedNode = 3; cX += node3.processRegularCtrls(cX, cY); node3.processGrainCtrls(cX, cY); ) :
  node4.selected ? ( selectedNode = 4; cX += node4.processRegularCtrls(cX, cY); node4.processGrainCtrls(cX, cY); ) :
  node5.selected ? ( selectedNode = 5; cX += node5.processRegularCtrls(cX, cY); node5.processGrainCtrls(cX, cY); ) :
  node6.selected ? ( selectedNode = 6; cX += node6.processRegularCtrls(cX, cY); node6.processGrainCtrls(cX, cY); ) :
  node7.selected ? ( selectedNode = 7; cX += node7.processRegularCtrls(cX, cY); node7.processGrainCtrls(cX, cY); ) :
  node8.selected ? ( selectedNode = 8; cX += node8.processRegularCtrls(cX, cY); node8.processGrainCtrls(cX, cY); ) :
  node9.selected ? ( selectedNode = 9; cX += node9.processRegularCtrls(cX, cY); node9.processGrainCtrls(cX, cY); ) :
  node10.selected ? ( selectedNode = 10; cX += node10.processRegularCtrls(cX, cY); node10.processGrainCtrls(cX, cY); );
  node11.selected ? ( selectedNode = 11; cX += node11.processVerbCtrls(cX, cY); );
  
  // Band indicator
  gfx_set(1,1,1,1);
  sprintf(16, "Node %d", selectedNode);
  vLabel.drawVertLabel(8, w1h, 16, gfx_h-w1h, BAND_FONT, 3);
  
) : (
  // Band indicator
  gfx_set(1,1,1,1);
  sprintf(16, "-", selectedNode);
  vLabel.drawVertLabel(8, w1h, 16, gfx_h-w1h, BAND_FONT, 3);
);

updateToSliderAll();

