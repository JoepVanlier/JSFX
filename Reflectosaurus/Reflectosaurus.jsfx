desc:Saike Reflectosaurus (work in progress | do not use)
tags: multi-tap delay plugin
version: 0.07
author: Joep Vanlier
changelog: Critical bugfix serialization. Added feedforward system.
license: MIT

slider1:drywet=1.0<0,1,.001>Dry/Wet
slider2:SyncMode=0<0,1,4{Off,Fourth,Third,Fifth>Sync Mode
slider3:Snap=0<0,1,1{Off,On}>Snap

@init
globalFeedback = 1;

function updateRange()
(
  SyncMode ? (
    maxTime = 4*tempo/60;
    minTime = 0;
  ) : (
    minTime = 4/100;
    maxTime = 4;
  );
);
updateRange();

function initWindow(_x, _y, _w, _h)
  local()
  global()
  instance(x, y, w, h)
  (
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function resetBuffer()
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    memset(scopebuffer, 0, scopebuffermax - scopebuffer + 1);
  );
  
function initBufferLen(scopebuffer_in, bufferlen)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffer + bufferlen;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );  
  
function draw_buffer(x, y, w, h, mul, fill)
  instance(scopeptr, scopebuffer, scopebuffermax)
  globals(gfx_x, gfx_y)
  local(len, scopeptr2, lx, ly, xx, dx, lptr, yy, lastx, lasty, isc, yref)
  (
    xx = x;
    len = scopebuffermax-scopebuffer;
    dx = floor(len/w);
    scopeptr2 = scopeptr;
    
    lptr = floor((scopeptr2)/dx)*dx;
    gfx_x = xx;
    gfx_y = y+h;
    isc = h;
    yref = y+h;
    ly = y+h;
    loop((scopebuffermax-scopeptr2)/dx - 1,
      yy = yref - h*min(1,lptr[]);
      
      lptr += dx;
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
    
    lptr = floor((scopebuffer)/dx)*dx;
    loop((scopeptr2 - scopebuffer)/dx - 1,
      lptr += dx;
      yy = yref - h*min(1,lptr[]);
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
  );  
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
   
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 2;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    readptr -= 1;
    
    c2 * (1.0-frac) + c1 * frac
  );
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );
  
function f_trafo(freq)
  local()
  global(slider54, legacyCutoff)
  instance()
  (
    exp( (1-freq) * log(20/22050) ) * $pi / (max(1,slider54));
  );


function init_linearSVF(freq, res)
  global(srate, slider54)
  local(g)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    g = tan(.5 * f_trafo(freq));
    k = 2 - 2*res;
    
    a1 = 1/(1+g*(g+k));
    a2 = g*a1;
    a3 = g*a2;
  ); 

function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );
  
function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2
  );  
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );  
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );

function xToTime(x)
  global(mintime, maxtime, xmin, xmax, srate, SyncMode)
  local()
  (
    SyncMode > 0 ? (
      maxTime * x + minTime;
    ) : ( 
      (maxTime/1024) * 2^(10*x)
    );
  );

function log2(x)
  local()
  global()
  (
    log(x)/log(2)
  );

function timeToX(dtime)
  global(mintime, maxtime, xmin, xmax, SyncMode)
  local()
  (
    SyncMode ? (
      (dTime - minTime) / maxTime
    ) : (
      log2( ( dTime * 1024 ) / maxTime )/10;
    );
  );
  
function yToVol(y)
  global(minvol, maxvol, ymin, ymax)
  local()
  (
    // Same as 10^(-30*dB/20)
    exp(-1.5*y*log(10)) 
  );
  
function updateNode()
  local(newdtime)
  global(srate, MAX_MOVE, globalFeedback)
  instance(fbc, diff, buffer, tx, x, y, dtime, vol, pan, panlast, lPanTerm, rPanTerm, lpl, hpl, lpr, hpr, lpf, hpf, llpf, lhpf, fb, fbcoeff, xlast, ylast, fblast, olddtime, mute)
  (
    y > 1 ? y = 1;
    x > 1 ? x = 1;
    y < 0 ? y = 0;
    x < 0 ? x = 0;
  
    newdtime = .00005 * 2 * srate * dtime + 0.99995*olddtime; //+ .01*sin(20*time_precise())
    diff = olddtime - newdtime;
    ( abs( diff ) > .001 ) ? (
      buffer.setOffset(newdtime); 
    );
    olddtime = newdtime;
  
    fbc = fb * globalFeedback;
    ( !mute ) ? (
      ( y != ylast ) ? ( vol   = yToVol(y);  ylast = y; );
      ( fbc != fblast ) ? ( fbcoeff = .95*exp( -4 * ( 1 - fbc ) ) );  
      ( pan != panlast ) ? ( lPanTerm = cos($pi*pan/2); rPanTerm = sin($pi*pan/2); panlast = pan; );     
    
      ( lpf < 1.0 && lpf != llpf ) ? ( lpl.init_linearSVF(lpf, 0); lpr.init_linearSVF(lpf, 0); llpf = lpf; );
      ( hpf > 0.0 && hpf != lhpf ) ? ( hpl.init_linearSVF(hpf, 0); hpr.init_linearSVF(hpf, 0); lhpf = hpf; );
    );
  );

  function tanh(x)
  local()
  global()
  instance()
  (
    (2/(1+exp(-2*x)))-1
  );

function updateNodeBlock()
  local()
  global()
  instance(recv, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10)
  (
    recv = fromNode1 || fromNode2 || fromNode3 || fromNode4 || fromNode5 || fromNode6 || fromNode7 || fromNode8 || fromNode9 || fromNode10;
  );

function getReceives()
  local()
  global( node1.lastL, node2.lastL, node3.lastL, node4.lastL, node5.lastL, node6.lastL, node7.lastL, node8.lastL, node9.lastL, node10.lastL,
          node1.lastR, node2.lastR, node3.lastR, node4.lastR, node5.lastR, node6.lastR, node7.lastR, node8.lastR, node9.lastR, node10.lastR)
  instance(recv, lIn, rIn, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, me)
  (
    recv ? (
      ( me == 1 )    ? ( fromNode1 *= 0 )
      : ( me == 2 )  ? ( fromNode2 *= 0 )
      : ( me == 3 )  ? ( fromNode3 *= 0 )
      : ( me == 4 )  ? ( fromNode4 *= 0 )
      : ( me == 5 )  ? ( fromNode5 *= 0 )
      : ( me == 6 )  ? ( fromNode6 *= 0 )
      : ( me == 7 )  ? ( fromNode7 *= 0 )
      : ( me == 8 )  ? ( fromNode8 *= 0 )
      : ( me == 9 )  ? ( fromNode9 *= 0 )
      : ( me == 10 ) ? ( fromNode10 *= 0 );
      
      fromNode1 ? (
        lIn = lIn + fromNode1 * node1.lastL;
        rIn = rIn + fromNode1 * node1.lastR;
      );
      
      fromNode2 ? (
        lIn = lIn + fromNode2 * node2.lastL;
        rIn = rIn + fromNode2 * node2.lastR;
      );
        
      fromNode3 ? (
        lIn = lIn + fromNode3 * node3.lastL;
        rIn = rIn + fromNode3 * node3.lastR;
      );
        
      fromNode4 ? (
        lIn = lIn + fromNode4 * node4.lastL;
        rIn = rIn + fromNode4 * node4.lastR;
      );
      
      fromNode5 ? (
        lIn = lIn + fromNode5 * node5.lastL;
        rIn = rIn + fromNode5 * node5.lastR;
      );
      
      fromNode6 ? (
        lIn = lIn + fromNode6 * node6.lastL;
        rIn = rIn + fromNode6 * node6.lastR;
      );
      
      fromNode7 ? (
        lIn = lIn + fromNode7 * node7.lastL;
        rIn = rIn + fromNode7 * node7.lastR;
      );
      
      fromNode8 ? (
        lIn = lIn + fromNode8 * node8.lastL;
        rIn = rIn + fromNode8 * node8.lastR;
      );
      
      fromNode9 ? (
        lIn = lIn + fromNode9 * node9.lastL;
        rIn = rIn + fromNode9 * node9.lastR;
      );
      
      fromNode10 ? (
        lIn = lIn + fromNode10 * node10.lastL;
        rIn = rIn + fromNode10 * node10.lastR;
      );
      
      lIn = tanh(lIn);
      rIn = tanh(rIn);
    );
  );

function process(l_in, r_in)
  local(l, r)
  global(lOut, rOut)
  instance(lIn, rIn, buffer, vol, fbcoeff, lpl, lpr, hpl, hpr, lpf, hpf, pan, level, lPanTerm, rPanTerm, mute, solo, play, lastL, lastR)
  (
    ( !mute || solo ) ? (
      lIn = l_in;
      rIn = r_in;
    
      this.getReceives();
    
      l = buffer.readBuffer();
      r = buffer.readBuffer();
            
      lpf < 1.0 ? ( l = lpl.eval_linearSVF_LP( l ); r = lpr.eval_linearSVF_LP( r ); );
      hpf > 0.0 ? ( l = hpl.eval_linearSVF_HP( l ); r = hpr.eval_linearSVF_HP( r ); );
  
      lastL = l;
      lastR = r;
  
      l = fbcoeff * l;
      r = fbcoeff * r;
    
      buffer.updateBuffer(l + lIn);
      buffer.updateBuffer(r + rIn);
      
      l = vol*l*lPanTerm*play;
      r = vol*r*rPanTerm*play;      
      
      lOut += l;
      rOut += r;
    );
    
    level = .5*(abs(l)+abs(r))*play;
  );

function initNode(_memloc, _dtime, _y, idx)
  local()
  instance(buffer, memloc, dtime,  y, fb, vol, pan, hpf, lpf, active, panlast, fblast, llpf, lhpf, me, lastL, lastR)
  global(bufsize)
  (
    me = idx;
    memloc = _memloc;
    buffer.initBuffer(memloc, memloc+bufsize-2);
    buffer.resetBuffer();
    lastL = 0;
    lastR = 0;
    
    panlast = -9999;
    fblast = -9999;
    llpf = -9999;
    lhpf = -9999;
    
    !dtime ? ( dtime = _dtime; y = _y; fb = 0.8; vol = 1.0; pan = 0.5; hpf = 0.0; lpf = 1.0; active = 1; );
  );

function serializeNode()
  local()
  global()
  instance( x, y, active,
            dtime, temposync, fb, lpf, hpf, widen, sat, pan, variance,
            mute, solo, play,
            fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10 )
  (
    file_var( 0, active );
    file_var( 0, dtime );
    file_var( 0, y );
    file_var( 0, temposync );
    file_var( 0, fb );
    file_var( 0, lpf );
    file_var( 0, hpf );
    file_var( 0, widen );
    file_var( 0, sat );
    file_var( 0, pan );
    file_var( 0, mute );
    file_var( 0, solo );
    file_var( 0, play );
    
    file_var( 0, fromNode1 );
    file_var( 0, fromNode2 );
    file_var( 0, fromNode3 );
    file_var( 0, fromNode4 );
    file_var( 0, fromNode5 );
    file_var( 0, fromNode6 );
    file_var( 0, fromNode7 );
    file_var( 0, fromNode8 );
    file_var( 0, fromNode9 );
    file_var( 0, fromNode10 );
    
    /* Memory to expand into when features are added */
    memset(0,0,100);
    file_mem( 0, 0, 86 );
  );

connectorSize = 16;

function drawConnector( xmin, ymin, w, h, xl, yl, nx, ny, idx, fromLevel )
  local(dmx, dmy, diffx, diffy, len, mx, my, nx, ny, ytri1, ytri2, ytri3, xtri1, xtri2, xtri3, xl2, yl2, ang)
  global(connectorSize, mouse_x, mouse_y)
  instance(overConnector)
  (
    gfx_set(1,1,1,1);
    xl2 = xmin + w*nx;
    yl2 = ymin + h*ny;
    mx  = (.4*xl+.6*xl2);
    my  = (.4*yl+.6*yl2);
    gfx_line(xl, yl, xl2, yl2, 1);
    gfx_circle(mx, my, connectorSize-.5, 0, 1);
    gfx_circle(mx, my, connectorSize, 0, 0);
    gfx_circle(mx, my, connectorSize+.5, 0, 1);
    
    ang = 2*fromLevel*$pi - $pi;
    gfx_arc(mx, my, connectorSize+1,   -$pi, ang, 1);
    gfx_arc(mx, my, connectorSize+1.5, -$pi, ang, 1);
    gfx_arc(mx, my, connectorSize+2,   -$pi, ang, 1);
    
    diffx = xl - xl2;
    diffy = yl - yl2;
    len   = sqrt( diffx * diffx + diffy * diffy );
    nx    = 10 * diffx / len;
    ny    = 10 * diffy / len;
    
    xtri1 = mx - .5*nx + ny;
    ytri1 = my - .5*ny - nx;
    xtri2 = mx - .5*nx - ny;
    ytri2 = my - .5*ny + nx;
    xtri3 = mx + nx;
    ytri3 = my + ny;
    
    dmx = mx - mouse_x;
    dmy = my - mouse_y;
    ( dmx * dmx + dmy * dmy ) < (connectorSize*connectorSize) ? overConnector = idx;
    
    gfx_triangle( xtri1, ytri1, xtri2, ytri2, xtri3, ytri3 );
  );

function drawConnections(xmin, ymin, w, h)
  global( node1.x, node2.x, node3.x, node4.x, node5.x, node6.x, node7.x, node8.x, node9.x, node10.x,
          node1.y, node2.y, node3.y, node4.y, node5.y, node6.y, node7.y, node8.y, node9.y, node10.y)
  instance(overConnector, x, y, fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10)
  local(xl, yl)
  (
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
    
    overConnector = 0;
    fromNode1  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node1.x,  node1.y,  1,  fromNode1 );
    fromNode2  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node2.x,  node2.y,  2,  fromNode2 );
    fromNode3  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node3.x,  node3.y,  3,  fromNode3 );
    fromNode4  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node4.x,  node4.y,  4,  fromNode4 );
    fromNode5  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node5.x,  node5.y,  5,  fromNode5 );
    fromNode6  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node6.x,  node6.y,  6,  fromNode6 );
    fromNode7  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node7.x,  node7.y,  7,  fromNode7 );
    fromNode8  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node8.x,  node8.y,  8,  fromNode8 );
    fromNode9  ? this.drawConnector( xmin, ymin, w, h, xl, yl, node9.x,  node9.y,  9,  fromNode9 );
    fromNode10 ? this.drawConnector( xmin, ymin, w, h, xl, yl, node10.x, node10.y, 10, fromNode10 );
    
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
  );

function draw(xmin, ymin, w, h)
  local(xmin, ymin, w, h, adv, alpha, xl, yl, tf, logLevel, outer, panSize, silent)
  global(gfx_a, gfx_x, gfx_y)
  instance(x, y, r, fbcoeff, lpf, hpf, dtime, level, pan, selected, play, mute, solo)
  (     
    silent = max(0,1-play);
    r = 4;
    alpha = 1.0;
    tf = 100*dtime;
    adv = min(0.99, fbcoeff);
    xl = floor(xmin + x*w);
    yl = floor(ymin + y*h);
    
    outer = 8+4.15*ceil(log(.2)/log(fbcoeff));    
    
    panSize = 7;
    gfx_set(0,0,3,.8 - .7*silent);
    gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize+2, 1);
    gfx_set(1,1,1,1 - .7*silent);
    gfx_circle(xl-outer*cos($pi*pan), yl-outer*sin($pi*pan), panSize, 1);
    
    gfx_set(0,0,.3,.95);
    gfx_circle(xl, yl, outer, 1, 1);    
    
    gfx_set(0.2,0.35,1.0,.4);
    gfx_circle(xl, yl, outer, 0, 0);
    gfx_circle(xl, yl, outer+.5, 1, 0);
    gfx_circle(xl, yl, outer+1, 0, 1);
    
    mute ? (
      gfx_set(0.7,0,.1,.95);
      gfx_circle(xl, yl, outer+1, 0, 1);
      gfx_circle(xl, yl, outer+1.5, 0, 0);
      gfx_circle(xl, yl, outer+2, 0, 1);
    );
    
    selected ? (
      gfx_set(0.2,0.35,1.0,1);
      gfx_circle(xl, yl, outer, 0, 0);
      gfx_circle(xl, yl, outer+.5, 1, 0);
      gfx_circle(xl, yl, outer+1, 0, 1);
    );
    
    solo ? (
      gfx_set(0,1,.3,.95);
      gfx_circle(xl, yl, outer+1, 0, 1);
      gfx_circle(xl, yl, outer+1.5, 0, 0);
      gfx_circle(xl, yl, outer+2, 0, 1);
    );
    
    gfx_set(1 - .7*silent, 1 - .7*silent, 1 - .7*silent, alpha);
    while(
      gfx_a = alpha;
      gfx_circle(xl, yl, r, 0, 0);
      gfx_a = .5*alpha;
      gfx_circle(xl, yl, r+1, 0, 1);
      gfx_circle(xl, yl, r-1, 0, 1);
      
      r += 4;
      alpha *= adv;
      alpha>.2
    );
    
    gfx_a = 1 - .7*silent;
    hpf < lpf ? (
      loop(5,
        gfx_arc(xl, yl, r, 2*lpf*$pi - $pi, 2*hpf*$pi - $pi, 1);
        r += .5;
      );
    );
    
    logLevel = log(4000*level-2);
    silent ? logLevel = 0;
    
    gfx_set(1, 1, 1, .2);
    gfx_circle(xl, yl, logLevel*5, 1, 1);
    
    gfx_set(1, 1, 1, .1);
    gfx_circle(xl, yl, logLevel*6, 1, 1);
    
    gfx_set(1, 1, 1, .05);
    gfx_circle(xl, yl, logLevel*8, 1, 1);
    
    r = r*r;
  );

function clamp(x, lb, ub)
  local()
  global()
  instance()
  (
    max(lb,min(ub,x))
  );

function select(xmin, ymin, w, h, xselectmin, xselectmax, yselectmin, yselectmax)
  local(xl, yl)
  global()
  instance(x, y, dtime, selected)
  (
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
        
    selected = ( xl > xselectmin ) && ( xl < xselectmax ) && ( yl > yselectmin ) && ( yl < yselectmax ) ? 1 : 0;
  );

function amIChosen()
  local()
  global()
  instance(selected)
  (
    selected = ( selected == 2 ) ? 1 : 0;
  );

function tryNodeConnect(xmin, ymin, w, h, from, mousex, mousey)
  local(xl, yl, outer, dx, dy)
  instance(dtime, x, y, fbcoeff,
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10)
  global()
  (
    x = timeToX(dtime);
    outer = 8+4.15*ceil(log(.2)/log(fbcoeff)); 
    xl = xmin + x*w;
    yl = ymin + y*h;
    
    dx = mousex - xl;
    dy = mousey - yl;
    
    /* Yeah! We're in range. hook us up! */
    ( (dx*dx + dy*dy) < (outer*outer) ) ? (
      ((from == 1)  && (fromNode1  == 0)) ? fromNode1 = fbcoeff;
      ((from == 2)  && (fromNode2  == 0)) ? fromNode2 = fbcoeff;
      ((from == 3)  && (fromNode3  == 0)) ? fromNode3 = fbcoeff;
      ((from == 4)  && (fromNode4  == 0)) ? fromNode4 = fbcoeff;
      ((from == 5)  && (fromNode5  == 0)) ? fromNode5 = fbcoeff;
      ((from == 6)  && (fromNode6  == 0)) ? fromNode6 = fbcoeff;
      ((from == 7)  && (fromNode7  == 0)) ? fromNode7 = fbcoeff;
      ((from == 8)  && (fromNode8  == 0)) ? fromNode8 = fbcoeff;
      ((from == 9)  && (fromNode9  == 0)) ? fromNode9 = fbcoeff;
      ((from == 10) && (fromNode10 == 0)) ? fromNode10 = fbcoeff;
    );
  );

function overNode(xmin, ymin, w, h, mousex, mousey, mousecap)
  local(dx, dy, dist, xl, yl)
  global(nodeCap)
  instance(overConnector, x, y, r, dtime, lastleft, left, lastright, right, lx, ly, selected)
  (
    left  = mousecap & 1;
    right = mousecap & 2;
    x = timeToX(dtime);
    
    xl = xmin + x*w;
    yl = ymin + y*h;
    dx = mousex - xl;
    dy = mousey - yl;
    
    ( left ) ? (
      ( (nodeCap == 0) && (lastleft == 0) && (lastright == 0) ) ? (
        ( overConnector ) ? (
          nodeCap = -10-overConnector;
          selected = 2;
        ) : (
          dist = dx * dx + dy * dy;
          ( dist < r ) ? (
            nodeCap = 1;
            
            /* If this one is not selected, signal that all others have to be deselected */
            !selected ? (
              selected = 2;
              nodeCap = -nodeCap;
            );
          );
        );
      );
    ) : ( right ) ? (
      ( (nodeCap == 0) && (lastright == 0) && (lastleft == 0) ) ? (
        ( overConnector ) ? (
          nodeCap = -10-overConnector;
          selected = 2;
        ) : (
          dist = dx * dx + dy * dy;
          ( dist < r ) ? (
            nodeCap = 2;
            
            /* If this one is not selected, signal that all others have to be deselected */
            !selected ? (
              selected = 2;
              nodeCap = -nodeCap;
            );
          );
        );
      );
    ) : ( 
      nodeCap = 0;
    );
    
    lastleft = left;
    lastright = right;    
  );

function nodeProcessMouse(xmin, ymin, w, h, mousex, mousey, mousecap, currentCap, lx, ly)
  local(left, right, dist, shift, ctrl, alt, from, chy, xl, yl)
  global(SyncMode, Snap, nodeCap, 
          node1.tryNodeConnect,
          node2.tryNodeConnect,
          node3.tryNodeConnect,
          node4.tryNodeConnect,
          node5.tryNodeConnect,
          node6.tryNodeConnect,
          node7.tryNodeConnect,
          node8.tryNodeConnect,
          node9.tryNodeConnect, 
          node10.tryNodeConnect )
  instance(x, y, r, dtime, fb, lpf, hpf, pan, selected, lcap,
           fromNode1, fromNode2, fromNode3, fromNode4, fromNode5, fromNode6, fromNode7, fromNode8, fromNode9, fromNode10, Connecting, me)
  (
    shift = mousecap & 8;
    ctrl  = mousecap & 4;
    alt   = mousecap & 16;
    left  = mousecap & 1;
    right = mousecap & 2;    
    
    x = timeToX(dtime);
    xl = xmin + x*w;
    yl = ymin + y*h;
    
    left ? (
      ( currentCap > 10 && selected ) ? (
        chy = (ly-mousey)/h;
        currentCap == 11 ? fromNode1  = clamp( fromNode1 + chy, 0.001, .999 );
        currentCap == 12 ? fromNode2  = clamp( fromNode2 + chy, 0.001, .999 );
        currentCap == 13 ? fromNode3  = clamp( fromNode3 + chy, 0.001, .999 );
        currentCap == 14 ? fromNode4  = clamp( fromNode4 + chy, 0.001, .999 );
        currentCap == 15 ? fromNode5  = clamp( fromNode5 + chy, 0.001, .999 );
        currentCap == 16 ? fromNode6  = clamp( fromNode6 + chy, 0.001, .999 );
        currentCap == 17 ? fromNode7  = clamp( fromNode7 + chy, 0.001, .999 );
        currentCap == 18 ? fromNode8  = clamp( fromNode8 + chy, 0.001, .999 );
        currentCap == 19 ? fromNode9  = clamp( fromNode9 + chy, 0.001, .999 );
        currentCap == 20 ? fromNode10 = clamp( fromNode10 + chy, 0.001, .999 );
      ) : ( currentCap == 1 && selected ) ? (
        ( shift ) ? (
          ( alt ) ? (
            gfx_set( 1, 1, 1, 1 );
            gfx_line(xl, yl, mousex, mousey);
            gfx_line(xl, yl+1, mousex, mousey+1);
            gfx_line(xl, yl-1, mousex, mousey-1);
            gfx_line(xl+1, yl, mousex+1, mousey+1);
            gfx_line(xl-1, yl, mousex-1, mousey-1);
            Connecting = 1;
          ) : ( ctrl ) ? (
            hpf = clamp( hpf - (mousey-ly)/h, 0, lpf );
          ) : (
            lpf = clamp( lpf - (mousey-ly)/h, hpf, 1 );
          );
        ) : (
          ( alt ) ? (
            pan = clamp( pan - (mousey-ly)/h, 0, 1);
          ) : (
            x += (mousex-lx)/w;
            y += (mousey-ly)/h;
          );
        );
      );
    ) : ( right ) ? (
      ( currentCap > 10 && selected ) ? (
        currentCap == 11 ? fromNode1  = 0;
        currentCap == 12 ? fromNode2  = 0;
        currentCap == 13 ? fromNode3  = 0;
        currentCap == 14 ? fromNode4  = 0;
        currentCap == 15 ? fromNode5  = 0;
        currentCap == 16 ? fromNode6  = 0;
        currentCap == 17 ? fromNode7  = 0;
        currentCap == 18 ? fromNode8  = 0;
        currentCap == 19 ? fromNode9  = 0;
        currentCap == 20 ? fromNode10 = 0;
      ) : ( currentCap == 2 && selected ) ? (
        fb = fb - (mousey-ly)/w;
        fb = clamp(fb, 0, .999);
      );
    );
    
    ( ( currentCap == 0 ) && ( lcap > 0 ) ) ? (
      Snap ? (
        ( SyncMode == 1 ) ? (
          x= floor(x*16+.5)/16;
        ) : ( SyncMode == 2 ) ? (
          x= floor(x*12+.5)/12;
        ) : ( SyncMode == 3 ) ? (
          x= floor(x*20+.5)/20;
        );
      );
      
      Connecting ? (
        node1.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node2.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node3.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node4.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node5.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node6.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node7.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node8.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node9.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
        node10.tryNodeConnect(xmin, ymin, w, h, me, mousex, mousey);
      );
      
      Connecting = 0;
    );
    
    dtime = xToTime(x);
    
    selected ? (
      lcap = currentCap;
    ) : (
      lcap = 0;
    );
  );

// MEMORY LAYOUT
bufSize = 65536*8;
minvol = 0.05;
maxvol = 1;

dTap1  = 1;
dTap2  = 2*bufSize;
dTap3  = 3*bufSize;
dTap4  = 4*bufSize;
dTap5  = 5*bufSize;
dTap6  = 6*bufSize;
dTap7  = 7*bufSize;
dTap8  = 8*bufSize;
dTap9  = 9*bufSize;
dTap10 = 10*bufSize;

node1.initNode(dTap1,   xToTime(0.5),  0.5, 1);
node2.initNode(dTap2,   xToTime(0.1),  1.0, 2);
node3.initNode(dTap3,   xToTime(0.2),  1.0, 3);
node4.initNode(dTap4,   xToTime(0.3),  1.0, 4);
node5.initNode(dTap5,   xToTime(0.4),  1.0, 5);
node6.initNode(dTap6,   xToTime(0.5),  1.0, 6);
node7.initNode(dTap7,   xToTime(0.6),  1.0, 7);
node8.initNode(dTap8,   xToTime(0.7),  1.0, 8);
node9.initNode(dTap9,   xToTime(0.8),  1.0, 9);
node10.initNode(dTap10, xToTime(0.9),  1.0, 10);

@serialize
file_var(0, maxtime);
file_var(0, mintime);

node1.serializeNode();
node2.serializeNode();
node3.serializeNode();
node4.serializeNode();
node5.serializeNode();
node6.serializeNode();
node7.serializeNode();
node8.serializeNode();
node9.serializeNode();
node10.serializeNode();

@slider

@block
!node1.mute  ? node1.play  = 1 : node1.play  = 0;
!node2.mute  ? node2.play  = 1 : node2.play  = 0;
!node3.mute  ? node3.play  = 1 : node3.play  = 0;
!node4.mute  ? node4.play  = 1 : node4.play  = 0;
!node5.mute  ? node5.play  = 1 : node5.play  = 0;
!node6.mute  ? node6.play  = 1 : node6.play  = 0;
!node7.mute  ? node7.play  = 1 : node7.play  = 0;
!node8.mute  ? node8.play  = 1 : node8.play  = 0;
!node9.mute  ? node9.play  = 1 : node9.play  = 0;
!node10.mute ? node10.play = 1 : node10.play = 0;

( node1.solo || node2.solo || node3.solo || node4.solo || node5.solo || node6.solo || node7.solo || node8.solo || node9.solo || node10.solo ) ? 
( node1.play = node2.play = node3.play = node4.play = node5.play = node6.play = node7.play = node8.play = node9.play = node10.play = 0 );

node1.solo  ? node1.play  = 1;
node2.solo  ? node2.play  = 1;
node3.solo  ? node3.play  = 1;
node4.solo  ? node4.play  = 1;
node5.solo  ? node5.play  = 1;
node6.solo  ? node6.play  = 1;
node7.solo  ? node7.play  = 1;
node8.solo  ? node8.play  = 1;
node9.solo  ? node9.play  = 1;
node10.solo ? node10.play = 1;

node1.updateNodeBlock();
node2.updateNodeBlock();
node3.updateNodeBlock();
node4.updateNodeBlock();
node5.updateNodeBlock();
node6.updateNodeBlock();
node7.updateNodeBlock();
node8.updateNodeBlock();
node9.updateNodeBlock();
node10.updateNodeBlock();

@sample
updateRange();

lOut = 0;
rOut = 0;

node1.updateNode();
node2.updateNode();
node3.updateNode();
node4.updateNode();
node5.updateNode();
node6.updateNode();
node7.updateNode();
node8.updateNode();
node9.updateNode();
node10.updateNode();

node1.process(spl0, spl1);
node2.process(spl0, spl1);
node3.process(spl0, spl1);
node4.process(spl0, spl1);
node5.process(spl0, spl1);
node6.process(spl0, spl1);
node7.process(spl0, spl1);
node8.process(spl0, spl1);
node9.process(spl0, spl1);
node10.process(spl0, spl1);

spl0 = spl0 * (1-drywet) + lOut * drywet;
spl1 = spl1 * (1-drywet) + rOut * drywet;

@gfx
/* Gradients are buffered to save rendering perf */
function drawGradients(w, h, spectrumH, gradient_bg)
instance(lw, lh, lSpectrumH, m, c)
global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
       gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
local( oldDest, oldMode, ang1, ang2, alpha, q, centerNoise, bump, cx, cy, angSiz )
(
  oldMode = gfx_mode;
  gfx_mode = 0;
  gfx_set(1,1,1,1);
  ( ( lw != w ) || ( lh != h ) || (spectrumH != lSpectrumH) ) ? (
    /* Only draw gradients when size changes */
    gfx_x = gfx_y = 0;
    lw = w;
    lh = h;
    lSpectrumH = spectrumH;
    oldDest = gfx_dest;
    gfx_setimgdim(gradient_bg, w, h);
    gfx_dest = gradient_bg;
    gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);

    m = max(w,h);
    gfx_mode = 1;
    alpha = .1;
    bump = 1.05;
    q = 0;
    centerNoise = 0.1*rand();
    cx = w*rand();
    cy = h*rand();
    angSiz = rand();
    ( angSiz < .5 ) ? ( angSiz = .00015 )
    : ( angSiz = .0015 );
    
    loop(200,
      c = rand();
      ( c < .4 ) ? ( gfx_set( 1, 0.1, 0.4, alpha ) )
      : ( c < .9 ) ? ( gfx_set( 0.2, 0.2, 1, alpha) )
      : ( gfx_set( 0, 0, 0, alpha ) );
      
      ang1 = $pi * rand() * 2;
      q == 0 ? ( 
        ang2 = 0;
      ) : (
        ang2 = ang1 + $pi * rand() * angSiz / q;
      );
      gfx_triangle(cx + centerNoise*w*(rand()-0.5), cy + centerNoise*h*(rand()-0.5), .5*w + m * cos(ang1), .5*h + m * sin(ang1), .5*w + m * cos(ang2), .5*h + m * sin(ang2));
      q += 1;
      
      gfx_x = gfx_y = 0;
      q > 4 ? (
        q = 0;
        gfx_blurto(w, h);
        gfx_muladdrect(0, 0, w, h, bump, bump, bump, 1.0, 0, 0, 0, 0);
      );
    );
    gfx_mode = 0;
    
    gfx_dest = oldDest;
  );
    
  gfx_x = gfx_y = 0;
  gfx_blit(gradient_bg, 1, 0);
  gfx_mode = oldMode;
);

font_color_r = 1;
font_color_g = 1;
font_color_b = 1;
font_color_a = 1;
line_color_r = .3;
line_color_g = 0;
line_color_b = 1;
line_color_a = .7;

FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", 16);

function drawWindow(x, y, w, h)
  local(dx, dy, Nx, Ny, pw, ph, xValue, yLevel, dyL, dxL, i, ct)
  global(gfx_x, gfx_y, FONT_GRID, SyncMode,
          font_color_r, font_color_g, font_color_b, font_color_a, 
          line_color_r, line_color_g, line_color_b, line_color_a )
  instance()
  (
    SyncMode == 0 ? (
      Nx = 10;
      Ny = 10;
    ) : ( SyncMode == 1 ) ? (
      Nx = 16;
      Ny = 10;
    ) : ( SyncMode == 2 ) ? (
      Nx = 3*4;
      Ny = 10;
    ) : ( SyncMode == 3 ) ? (
      Nx = 5*4;
      Ny = 10;
    );
    dx = w/Nx;
    dy = h/Ny;
    dyL = 1/Ny;
    dxL = 1/Nx;
    gfx_y = y+dy;
    
    gfx_measurestr("8888", pw, ph);
    gfx_setfont( FONT_GRID );
    yLevel = 1-dyL;
    loop(Ny,
      gfx_set(0, 0, 0, .7);
      gfx_line(x, gfx_y-1, x+w, gfx_y-1);
      gfx_set(line_color_r, line_color_g, line_color_b, line_color_a);
      gfx_line(x, gfx_y, x+w, gfx_y);
      gfx_set(0, 0, 0, .7);
      gfx_line(x, gfx_y+1, x+w-pw, gfx_y+1);
      
      gfx_x = x+w + 10;
      gfx_y -= .5*ph;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      gfx_printf("%d dB", 20*log10(yToVol(1-yLevel)) );
      
      gfx_y += dy + .5*ph;
      yLevel -= dyL;
    );
    
    gfx_x = x;
    gfx_y = h;
    i = 1;
    xValue = 0;
    loop(Nx+1,
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x-1, y, gfx_x-1, y+h);
      gfx_set(line_color_r, line_color_g, line_color_b, line_color_a);
      gfx_line(gfx_x, y, gfx_x, y+h);
      gfx_set(0, 0, 0, .7);
      gfx_line(gfx_x+1, y, gfx_x+1, y+h);
      
      //gfx_x = x + .1*pw;
      ct = 1000*xToTime(xValue);
      gfx_x += .2*pw;
      gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
      ( abs(ct - floor(ct+.5)) < .1 ) ? gfx_printf("%d", floor(ct+.5)) : gfx_printf("%.1f", ct);
      
      gfx_x = x + dx * i;
      xValue += dxL;
      i += 1;
    );
  );

gfx_set(0,0,0,1);
gfx_rect(0, 0, gfx_w, gfx_h);

ymin = 0;
ymax = gfx_h;
xmin = 0;
xmax = gfx_w;

w1x = 0;
w1y = 0;
w1w = .9*gfx_w;
w1h = .9*gfx_h;

bg_color_r = 1.1;
bg_color_g = 0.3;
bg_color_b = 0.3;
bg_color_a = 0.8;

grads.drawGradients(w1w, w1h, w1h, 0);

drawWindow(w1x, w1y, w1w, w1h);

node1.drawConnections(w1x, w1y, w1w, w1h);
node2.drawConnections(w1x, w1y, w1w, w1h);
node3.drawConnections(w1x, w1y, w1w, w1h);
node4.drawConnections(w1x, w1y, w1w, w1h);
node5.drawConnections(w1x, w1y, w1w, w1h);
node6.drawConnections(w1x, w1y, w1w, w1h);
node7.drawConnections(w1x, w1y, w1w, w1h);
node8.drawConnections(w1x, w1y, w1w, w1h);
node9.drawConnections(w1x, w1y, w1w, w1h);
node10.drawConnections(w1x, w1y, w1w, w1h);

node1.draw(w1x, w1y, w1w, w1h);
node2.draw(w1x, w1y, w1w, w1h);
node3.draw(w1x, w1y, w1w, w1h);
node4.draw(w1x, w1y, w1w, w1h);
node5.draw(w1x, w1y, w1w, w1h);
node6.draw(w1x, w1y, w1w, w1h);
node7.draw(w1x, w1y, w1w, w1h);
node8.draw(w1x, w1y, w1w, w1h);
node9.draw(w1x, w1y, w1w, w1h);
node10.draw(w1x, w1y, w1w, w1h);

lastleft = left;
left = mouse_cap & 1;

!lastleft ? multiSelect = 0;
multiSelect == 0 ? (
   /* These functions will fill global nodeCap with the capture mode that occurred */
   /* 1 - LMB, 2 - RMB                                                             */
   node1.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node2.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node3.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node4.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node5.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node6.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node7.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node8.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node9.overNode(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap );
   node10.overNode(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap );
  
   /* An unselected one was selected. Deselect all others */
   nodeCap < 0 ? (
    node1.amIChosen();
    node2.amIChosen();
    node3.amIChosen();
    node4.amIChosen();
    node5.amIChosen();
    node6.amIChosen();
    node7.amIChosen();
    node8.amIChosen();
    node9.amIChosen();
    node10.amIChosen();
    nodeCap = abs(nodeCap);
   );
   
   node1.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node2.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node3.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node4.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node5.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node6.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node7.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node8.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node9.nodeProcessMouse(w1x, w1y, w1w, w1h,  mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);
   node10.nodeProcessMouse(w1x, w1y, w1w, w1h, mouse_x, mouse_y, mouse_cap, nodeCap, lastMouseX, lastMouseY);

  lastMouseX = mouse_x;
  lastMouseY = mouse_y;
  
  !nodeCap ? (
    // No nodes manipulated => Do multi-select
    ( mouse_x > w1x ) && ( mouse_y > w1y ) && ( mouse_x < ( w1x + w1w ) ) && ( mouse_y < ( w1y + w1h ) ) ? (
      ( ( lastleft == 0 ) && ( left == 1 ) ) ? (
        multiSelect = 1;
        refx = mouse_x;
        refy = mouse_y;
      );
    );
  );
) : ( multiSelect == 1 ) ? (
  xmi = min(refx, mouse_x);
  xma = max(refx, mouse_x);
  ymi = min(refy, mouse_y);
  yma = max(refy, mouse_y);
  gfx_set(1, 1, 1, .4);
  gfx_rect(xmi, ymi, xma-xmi, yma-ymi);
  // Select nodes upon release
  !left ? (
    node1.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node2.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node3.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node4.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node5.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node6.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node7.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node8.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node9.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
    node10.select(w1x, w1y, w1w, w1h, xmi, xma, ymi, yma);
  );
);

gfx_set(0,0,0,1);
gfx_x = 5; gfx_y = 5;
gfx_printf("RMB - Feedback\n");
gfx_x = 5; gfx_y = 20;
gfx_printf("Shift - LPF\n");
gfx_x = 5; gfx_y = 35;
gfx_printf("Ctrl + Shift - HPF\n");
gfx_x = 5; gfx_y = 50;
gfx_printf("Shift + Alt - Add Send\n");
gfx_x = 5; gfx_y = 65;
gfx_printf("Alt - Panning\n");
gfx_x = 5; gfx_y = 80;
gfx_printf("M - Mute\n");
gfx_x = 5; gfx_y = 95;
gfx_printf("S - Solo\n");

gfx_set(1,1,1,1);
gfx_x = 5; gfx_y = 6;
gfx_printf("RMB - Feedback\n");
gfx_x = 5; gfx_y = 21;
gfx_printf("Shift - LPF\n");
gfx_x = 5; gfx_y = 36;
gfx_printf("Ctrl + Shift - HPF\n");
gfx_x = 5; gfx_y = 51;
gfx_printf("Shift + Alt - Add Send\n");
gfx_x = 5; gfx_y = 66;
gfx_printf("Alt - Panning\n");
gfx_x = 5; gfx_y = 82;
gfx_printf("M - Mute\n");
gfx_x = 5; gfx_y = 96;
gfx_printf("S - Solo\n");

lastchar = gfx_getchar();

/* Mute */
( lastchar == 109 ) ? (
  node1.selected  ? node1.mute  = node1.mute  ? 0 : 1;
  node2.selected  ? node2.mute  = node2.mute  ? 0 : 1;
  node3.selected  ? node3.mute  = node3.mute  ? 0 : 1;
  node4.selected  ? node4.mute  = node4.mute  ? 0 : 1;
  node5.selected  ? node5.mute  = node5.mute  ? 0 : 1;
  node6.selected  ? node6.mute  = node6.mute  ? 0 : 1;
  node7.selected  ? node7.mute  = node7.mute  ? 0 : 1;
  node8.selected  ? node8.mute  = node8.mute  ? 0 : 1;
  node9.selected  ? node9.mute  = node9.mute  ? 0 : 1;
  node10.selected ? node10.mute = node10.mute ? 0 : 1;
);

/* Solo */
( lastchar == 115 ) ? (
  node1.selected  ? node1.solo  = node1.solo  ? 0 : 1;
  node2.selected  ? node2.solo  = node2.solo  ? 0 : 1;
  node3.selected  ? node3.solo  = node3.solo  ? 0 : 1;
  node4.selected  ? node4.solo  = node4.solo  ? 0 : 1;
  node5.selected  ? node5.solo  = node5.solo  ? 0 : 1;
  node6.selected  ? node6.solo  = node6.solo  ? 0 : 1;
  node7.selected  ? node7.solo  = node7.solo  ? 0 : 1;
  node8.selected  ? node8.solo  = node8.solo  ? 0 : 1;
  node9.selected  ? node9.solo  = node9.solo  ? 0 : 1;
  node10.selected ? node10.solo = node10.solo ? 0 : 1;
);
