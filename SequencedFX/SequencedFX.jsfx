desc:Saike Sequenced FX (pre-alpha WIP)
tags: time-based effect
version: 0.05
author: Joep Vanlier
changelog: Add logo.
license: MIT
about:
  # A small effect for doing sequencing of time based stutters, slowdowns and simple effects.

slider1:current_speed=4<1,16,1>Current speed
slider10:reset_enabled=1<0,1,1>-Reset enabled
slider11:slowdown_enabled=1<0,1,1>-Slowdown enabled
slider12:dynamic_slowdown_enabled=1<0,1,1>-Dynamic slowdown enabled
slider13:retrigger_enabled=1<0,1,1>-Retrigger enabled
slider14:reverse_enabled=1<0,1,1>-Reverse enabled
slider15:gate_enabled=0<0,1,1>-Gate enabled
slider16:filter_enabled=0<0,1,1>-Filter enabled
slider17:reverb_enabled=0<0,1,1>-Reverb enabled
slider25:filter_type=1<0,17,1{Linear,MS-20,Linear x2,Moog,Ladder,303,MS-20 asym,DblRes,DualPeak,TriplePeak,svf nl 2p,svf nl 4p,svf nl 2p inc,svf nl 4p inc,rectified resonance,Steiner,SteinerA}>-Filter type
slider26:drive=0<-32,48,1>-Filter Drive (dB)
slider27:cutoff_start=.6<0,1,.0001>-Cutoff Start
slider28:cutoff_final=.6<0,1,.0001>-Cutoff Finish
slider29:resonance=0.7<0,1,.0001>-Resonance
slider30:morph=0<0,1,.0001>-Morph
slider31:cutoff_atk=0<0,1,0.0001>-Envelope Rise
slider32:cutoff_decay=0<0,1,0.0001>-Envelope Decay
slider33:cutoff_sustain=0<0,1,0.0001>-Envelope Sustain
slider63:inertia=60<0,200,.001>-Filter Inertia [ms]

options:maxmem=12000000
in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import Saike_Yutani_Delays.jsfx-inc
import Saike_Yutani_Widgets.jsfx-inc
import Saike_Yutani_filters.jsfx-inc
import Saike_Yutani_envelope.jsfx-inc
import Saike_Yutani_interpolators.jsfx-inc

@init
log10d20_conversion  = 0.11512925464970228420089957273422;

sample_clock = 0;
oversampling = 1;
pattern_change = 1;
current_sample = 0;
version = 0;
n_segments = 32;
max_segments = 64;
max_effects = 32;
max_stored_patterns = 64;
crossfade_samples = 128;

function load_defaults()
(
  verb_diffusion_default = 0.7;
  verb_decay_default = 0.4;
  verb_mod_depth_default = 0.0;
  verb_mod_rate_default = 0.5;
  verb_lowpass_default = 1.0;
  verb_highpass_default = 0.3;
  verb_dry_default = 0;
  verb_wet_default = -8;
  verb_gate_atk_default = 0.06;
  verb_gate_decay_default = 0.6;
  verb_gate_sustain_default = 0.2;
  
  gate_start_default = -12;
  gate_stop_default = 0;
  gate_atk_default = 0.06;
  gate_decay_default = 0.6;
  gate_sustain_default = 1.0;
);

function init_to_defaults()
(
  verb_diffusion = verb_diffusion_default;
  verb_decay = verb_decay_default;
  verb_mod_depth = verb_mod_depth_default;
  verb_mod_rate = verb_mod_rate_default;
  verb_lowpass = verb_lowpass_default;
  verb_highpass = verb_highpass_default;
  verb_dry = verb_dry_default;
  verb_wet = verb_wet_default;
  verb_gate_atk = verb_gate_atk_default;
  verb_gate_decay = verb_gate_decay_default;
  verb_gate_sustain = verb_gate_sustain_default;
  
  gate_start = gate_start_default;
  gate_stop = gate_stop_default;
  gate_atk = gate_atk_default;
  gate_decay = gate_decay_default;
  gate_sustain = gate_sustain_default;
);

load_defaults();
loaded == 0 ? init_to_defaults();

function init_playhead()
(
  current_playhead = 0;
  amp0 = 1;
  amp1 = 0;
);

function pattern_update()
(
  current_pattern = pattern_buffer + current_pattern_index * pattern_size;
  reset_values = current_pattern;
  speed_values = current_pattern + max_segments;
  dynspeed_values = current_pattern + 2 * max_segments;
  retrig_values = current_pattern + 3 * max_segments;
  filt_values = current_pattern + 4 * max_segments;
  reverse_values = current_pattern + 5 * max_segments;
  gate_values = current_pattern + 6 * max_segments;
  reverb_values = current_pattern + 7 * max_segments;
  
  reset_values[0] = 1;
);

function interpolator_init()
(
  // Set up the interpolators
  drive_interpolator.interpolator_init(26);
  cutoff_start_interpolator.interpolator_init(27);
  cutoff_final_interpolator.interpolator_init(28);
  reso_interpolator.interpolator_init(29);
  morph_interpolator.interpolator_init(30);
     
  (last_inertia != inertia) ? (
    last_inertia = inertia;
    inertia_cutoff = 1000.0/inertia;
    drive_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_start_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_final_interpolator.initialize_smoother(inertia_cutoff);
    reso_interpolator.initialize_smoother(inertia_cutoff);
    morph_interpolator.initialize_smoother(inertia_cutoff);
    
    drive_interpolator.s = slider(26);
    cutoff_start_interpolator.s = slider(27);
    cutoff_final_interpolator.s = slider(28);
    reso_interpolator.s = slider(29);
    morph_interpolator.s = slider(30);
  );
);

function interpolators_block()
(
  drive_interpolator.interpolator_block();
  cutoff_start_interpolator.interpolator_block();
  cutoff_final_interpolator.interpolator_block();
  reso_interpolator.interpolator_block();
  morph_interpolator.interpolator_block();
);

function init_allpass(buffer, buffer_size)
instance(buffer)
(
  this.initBuffer(buffer, buffer + buffer_size);
  buffer + buffer_size + 1
);

function eval_allpass(x)
local(ap_sample, delayed_sample)
instance(gain, offset)
(
  delayed_sample = this.readBuffer_fixed(offset);
  ap_sample = x + gain * delayed_sample;
  y = delayed_sample - gain * ap_sample;

  this.writeBuffer(ap_sample);
  
  y
);

function eval_tpt_monopole(x)
instance(s, coeff)
global()
local(y, v)
(
  v = coeff*(x - s);
  y = v + s;
  s = y + v;
  y
);
  
function init_tpt_monopole(cutoff)
instance(coeff)
global(srate)
local(g)
( 
  g = tan($pi*cutoff/srate);
  coeff = g/(1+g);
);

function init_reverb(buffer_position)
global(srate)
local(buffer_size)
instance(diffuser1, diffuser2, diffuser3, diffuser4,
         lfo_diffuser_left, lfo_diffuser_right
         decay_diffuser_left, decay_diffuser_right,
         delay_left_1, delay_right_1,
         delay_left_2, delay_right_2,
         delay_right_2_offset, delay_left_2_offset, 
         delay_left_1_offset, delay_right_1_offset, 
         delay_left_2_offset, delay_right_2_offset,
         srate_scaling,
         out_delay1_left, out_delay2_left, out_delay3_left, out_delay4_left, out_delay5_left, out_delay6_left, out_delay7_left,
         out_delay1_right, out_delay2_right, out_delay3_right, out_delay4_right, out_delay5_right, out_delay6_right, out_delay7_right)
(
  /* Datorro Reverb (1997) */
  buffer_size = 8192;
  srate_scaling = srate / 29761;
  
  buffer_position = diffuser1.init_allpass(buffer_position, buffer_size);
  diffuser1.offset = 142 * srate_scaling;
  buffer_position = diffuser2.init_allpass(buffer_position, buffer_size);
  diffuser2.offset = 107 * srate_scaling;
  buffer_position = diffuser3.init_allpass(buffer_position, buffer_size);
  diffuser3.offset = 379 * srate_scaling;
  buffer_position = diffuser4.init_allpass(buffer_position, buffer_size);
  diffuser4.offset = 277 * srate_scaling;
  
  buffer_position = lfo_diffuser_left.init_allpass(buffer_position, buffer_size);
  lfo_diffuser_left.offset = 672 * srate_scaling;
  buffer_position = lfo_diffuser_right.init_allpass(buffer_position, buffer_size);
  lfo_diffuser_right.offset = 908 * srate_scaling;
  
  buffer_position = decay_diffuser_left.init_allpass(buffer_position, buffer_size);
  decay_diffuser_left.offset = 1800 * srate_scaling;
  buffer_position = decay_diffuser_right.init_allpass(buffer_position, buffer_size);
  decay_diffuser_right.offset = 2656 * srate_scaling;
  
  buffer_position = delay_left_1.init_allpass(buffer_position, buffer_size);
  buffer_position = delay_right_1.init_allpass(buffer_position, buffer_size);
  buffer_position = delay_left_2.init_allpass(buffer_position, buffer_size);
  buffer_position = delay_right_2.init_allpass(buffer_position, buffer_size);
  
  delay_right_2_offset = 3163 * srate_scaling;
  delay_left_2_offset = 3720 * srate_scaling;
  delay_left_1_offset = 4453 * srate_scaling;
  delay_right_1_offset = 4217 * srate_scaling;
  delay_left_2_offset = 3720 * srate_scaling;
  delay_right_2_offset = 3163 * srate_scaling;
  
  out_delay1_left = 266 * srate_scaling;
  out_delay2_left = 2974 * srate_scaling;
  out_delay3_left = 1913 * srate_scaling;
  out_delay4_left = 1996 * srate_scaling;
  out_delay5_left = 1990 * srate_scaling;
  out_delay6_left = 187 * srate_scaling;
  out_delay7_left = 1066 * srate_scaling;
  
  out_delay1_right = 353 * srate_scaling;
  out_delay2_right = 3627 * srate_scaling;
  out_delay3_right = 1228 * srate_scaling;
  out_delay4_right = 2673 * srate_scaling;
  out_delay5_right = 2111 * srate_scaling;
  out_delay6_right = 335 * srate_scaling;
  out_delay7_right = 121 * srate_scaling;  
  
  buffer_position
);

function update_reverb_settings(diffusion, decay, depth, freq, lowpass, highpass)
instance(diffuser1, diffuser2, diffuser3, diffuser4,
         lfo_diffuser_left, lfo_diffuser_right,
         decay_diffuser_left, decay_diffuser_right, fb,
         mod_depth, mod_rate,
         lp1, hp1, lp2, hp2)
local()
global(srate)
(
  diffuser1.gain = - 0.98684211 * diffusion; /* Decorrelate input signal */
  diffuser2.gain = - 0.98684211 * diffusion; /* Decorrelate input signal */
  diffuser3.gain = - 0.82236842 * diffusion; /* Decorrelate input signal */
  diffuser4.gain = - 0.82236842 * diffusion; /* Decorrelate input signal */
  lfo_diffuser_left.gain = 0.92105263 * diffusion;  /* Tail density */
  lfo_diffuser_right.gain = 0.92105263 * diffusion;  /* Tail density */
  decay_diffuser_left.gain = - 0.65789474 * diffusion;  /* Decorrelate tank signal */
  decay_diffuser_right.gain = - 0.65789474 * diffusion;  /* Decorrelate tank signal */
  fb = decay;
  mod_depth = 32 * depth;
  mod_rate = freq / srate;
  
  lp1.init_tpt_monopole(0.5 * srate * exp( (1.0 - lowpass) * log(20/22050) ));
  lp2.coeff = lp1.coeff;
  hp1.init_tpt_monopole(0.5 * srate * exp( (1.0 - highpass) * log(20/22050) ));
  hp2.coeff = hp1.coeff;
);

function eval_reverb(l, r)
instance(diffuser1, diffuser2, diffuser3, diffuser4,
         lfo_diffuser_left, lfo_diffuser_right,
         decay_diffuser_left, decay_diffuser_right,
         delay_left_1, delay_right_1,
         delay_left_2, delay_right_2,
         delay_right_2_offset, delay_left_2_offset, 
         delay_left_1_offset, delay_right_1_offset, 
         delay_left_2_offset, delay_right_2_offset,
         fb, out_left, out_right, srate_scaling,
         out_delay1_left, out_delay2_left, out_delay3_left, out_delay4_left, out_delay5_left, out_delay6_left, out_delay7_left
         out_delay1_right, out_delay2_right, out_delay3_right, out_delay4_right, out_delay5_right, out_delay6_right, out_delay7_right,
         mod_rate, mod_depth,
         lp1, lp2, hp1, hp2)
local(in, diffused, left_tank, right_tank, l_delay, r_delay, accumulator)
global(sample_clock)
(
  in = 0.5 * (l + r);
  
  diffused = 
    diffuser4.eval_allpass(
      diffuser3.eval_allpass(
        diffuser2.eval_allpass(
          diffuser1.eval_allpass(
            in
          )
        )
      )
    );
  
  left_tank = right_tank = diffused;
  
  // Flipped on purpose!
  left_tank += fb * delay_right_2.readBuffer_fixed(delay_right_2_offset);
  right_tank += fb * delay_left_2.readBuffer_fixed(delay_left_2_offset);
  
  lfo_diffuser_left.offset = (672 + mod_depth * sin(mod_rate * sample_clock)) * srate_scaling;
  lfo_diffuser_right.offset = (908 + mod_depth * sin(mod_rate * sample_clock)) * srate_scaling;

  delay_left_1.writeBuffer(lfo_diffuser_left.eval_allpass(left_tank));
  delay_right_1.writeBuffer(lfo_diffuser_right.eval_allpass(right_tank));
  
  // Damping here
  l_delay = lp1.eval_tpt_monopole(delay_left_1.readBuffer_fixed(delay_left_1_offset));
  r_delay = lp2.eval_tpt_monopole(delay_right_1.readBuffer_fixed(delay_right_1_offset)) ;
  
  l_delay = decay_diffuser_left.eval_allpass(l_delay);
  r_delay = decay_diffuser_right.eval_allpass(r_delay);
  
  delay_left_2.writeBuffer(l_delay);
  delay_right_2.writeBuffer(r_delay);
  
  l_delay = delay_left_2.readBuffer_fixed(delay_left_2_offset);
  r_delay = delay_right_2.readBuffer_fixed(delay_right_2_offset);
  
  // Left output
  accumulator = 0.6 * delay_right_1.readBuffer_fixed(out_delay1_left);
  accumulator += 0.6 * delay_right_1.readBuffer_fixed(out_delay2_left);
  accumulator -= 0.6 * decay_diffuser_right.readBuffer_fixed(out_delay3_left);
  accumulator += 0.6 * delay_right_2.readBuffer_fixed(out_delay4_left);
  accumulator -= 0.6 * delay_left_1.readBuffer_fixed(out_delay5_left);
  accumulator -= 0.6 * decay_diffuser_left.readBuffer_fixed(out_delay6_left);
  out_left = accumulator - 0.6 * delay_left_2.readBuffer_fixed(out_delay7_left);

  accumulator = 0.6 * delay_left_1.readBuffer_fixed(out_delay1_right);
  accumulator += 0.6 * delay_left_1.readBuffer_fixed(out_delay2_right);
  accumulator -= 0.6 * decay_diffuser_left.readBuffer_fixed(out_delay3_right);
  accumulator += 0.6 * delay_left_2.readBuffer_fixed(out_delay4_right);
  accumulator -= 0.6 * delay_right_1.readBuffer_fixed(out_delay5_right);
  accumulator -= 0.6 * decay_diffuser_right.readBuffer_fixed(out_delay6_right);
  out_right = accumulator - 0.6 * delay_right_2.readBuffer_fixed(out_delay7_right);
  
  out_left = out_left - hp1.eval_tpt_monopole(out_left);
  out_right = out_right - hp2.eval_tpt_monopole(out_right);
);


freemem = 0;
pattern_size = max_segments * max_effects;
freemem = (pattern_buffer = freemem) + pattern_size * max_stored_patterns;

BUF_SIZE = 96000 * 60;
freemem = (l_buffer = freemem) + BUF_SIZE;
freemem = (r_buffer = freemem) + BUF_SIZE;
l_buffer.initBuffer(l_buffer, l_buffer + BUF_SIZE);
r_buffer.initBuffer(r_buffer, r_buffer + BUF_SIZE);
beatmem.initBuffer(r_buffer, r_buffer + .5*BUF_SIZE);
freemem = verb.init_reverb(freemem);

interpolator_init();
pattern_update();
init_playhead();

@slider

@block
interpolators_block();

@serialize
loaded = 1;
file_var(0, version);
file_mem(0, pattern_buffer, pattern_size * max_stored_patterns);
file_var(0, selected_details);

file_var(0, gate_enabled);
file_var(0, gate_start);
file_var(0, gate_stop);
file_var(0, gate_atk);
file_var(0, gate_decay);
file_var(0, gate_sustain);

file_var(0, verb_diffusion);
file_var(0, verb_decay);
file_var(0, verb_mod_depth);
file_var(0, verb_mod_rate);
file_var(0, verb_lowpass);
file_var(0, verb_highpass);
file_var(0, verb_dry);
file_var(0, verb_wet);
file_var(0, verb_gate_atk);
file_var(0, verb_gate_decay);
file_var(0, verb_gate_sustain);

@sample
sample_clock += 1;

verb.update_reverb_settings(verb_diffusion, verb_decay, verb_mod_depth, verb_mod_rate, verb_lowpass, verb_highpass);

function jump_to_target()
local()
global(current_playhead, playhead_0, playhead_1,
       target_position,
       x_fade_position, crossfade_samples, 
       too_fast, jumps)
(
  jumps += 1;

  // Initiate the crossfade
  x_fade_position != 0 ? too_fast = 100;
  x_fade_position = crossfade_samples;
  
  // Which playhead are we moving away from?
  current_playhead == 0 ? (
    playhead_1 = target_position + crossfade_samples;
  ) : (
    playhead_0 = target_position + crossfade_samples;
  );
  
  current_playhead = 1 - current_playhead;
);

function schedule_jump(offset)
local(already_set)
global()
instance(j1, j2, j3, j4, j5)
(
  already_set = (offset == j1) || (offset == j2) || (offset == j3) || (offset == j4) || (offset == j5);

  !already_set ? (
    (offset < j1) ? (
      j5 = j4;
      j4 = j3;
      j3 = j2;
      j2 = j1;
      j1 = offset;
    ) : (offset < j2) ? (
      j5 = j4;
      j4 = j3;
      j3 = j2;
      j2 = offset;
    ) : (offset < j3) ? (
      j5 = j4;
      j4 = j3;
      j3 = offset;
    ) : (offset < j4) ? (
      j5 = j4;
      j4 = offset;
    ) : ( j5 = offset );
  );
);

function reset_jump()
instance(j1, j2, j3, j4, j5, current)
(
  current = 0;
  j1 = j2 = j3 = j4 = j5 = 10000000000000000;
);

function eval_jump()
local()
global()
instance(j1, j2, j3, j4, j5, current)
(
  (j1 - current) == 0 ? (
    jump_to_target();
    j1 = j2;
    j2 = j3;
    j4 = j5;
    j5 = 0;
  );
  
  current += 1;
);

function update_time_info()
(
  samples_per_beat = (srate * 60) / tempo / current_speed;
  pattern_length = n_segments * samples_per_beat;
  to_index = n_segments / pattern_length;
);

function update_envelope_simple(target)
instance(k_rise, k_decay, env_attack_samples, tEnvelope, env, m_sustain)
global()
local()
(
  tEnvelope < 1 ? (
    // Rise until we're up
    env < 0.95 * target ? (
      env += k_rise * (target - env);
    ) : (
      tEnvelope = 1;
    );
  ) : (
   // Decay
   env += k_decay * (m_sustain * target - env);
  );
);

function process_filter()
(
  current_drive = clamp(drive_interpolator.interpolate(), -6, 48);
  
  sample_clock % 16 == 0 ? (
    filter_envelope.calc_times(cutoff_atk, cutoff_decay, cutoff_sustain);
  );
  
  current_cutoff = cutoff_start + filter_envelope.update_envelope(filter_target) * (cutoff_final - cutoff_start);
  sample_clock % 4 == 0 ? (
    filter.init_filter(filter_type, current_cutoff, current_cutoff, morph, morph, resonance);
    preamp      = exp(log10d20_conversion*current_drive);
    inv_preamp  = exp(-log10d20_conversion*current_drive);
  );
  
  ssl *= preamp;
  ssr *= preamp;
  filter.processSample(filter_type);
  ssl *= inv_preamp;
  ssr *= inv_preamp;
);

function process_gate()
(
  sample_clock % 16 == 0 ? (
    gate_envelope.calc_times(gate_atk, gate_decay, gate_sustain);
  );
  
  current_gate = gate_start + gate_envelope.update_envelope(gate_target) * (gate_stop - gate_start);
  gatemul = exp(log10d20_conversion*current_gate);
  ssl *= gatemul;
  ssr *= gatemul;
);

function process_verb()
(
  sample_clock % 16 == 0 ? (
    verb_envelope.calc_times(verb_gate_atk, verb_gate_decay, verb_gate_sustain);
    verb_drymul = exp(log10d20_conversion*verb_dry);
    verb_wetmul = exp(log10d20_conversion*verb_wet);
    post_gate ? verb_wetmul * current_verb_gate;
  );
  
  current_verb_gate = verb_envelope.update_envelope(reverb_target);

  verb.eval_reverb(ssl * current_verb_gate, ssr * current_verb_gate);
  ssl = verb_drymul * ssl + verb_wetmul * verb.out_right;
  ssr = verb_drymul * ssl + verb_wetmul * verb.out_left;
);

update_time_info();
current_sample += 1;
target_position += 1; /* Target position moves with the track */
current_sample > pattern_length ? current_sample -= pattern_length;
sequencer_index = floor(to_index * current_sample);

reset_sample = current_sample + crossfade_samples;
reset_sample > pattern_length ? reset_sample -= pattern_length;
reset_index = floor(to_index * reset_sample);

// Delayed sequences to accomodate for crossfades
(reset_index != last_reset_index) ? (
  jump_schedule.reset_jump();
  
  reset_enabled ? (
    reset = reset_values[reset_index];
    reset > 0 ? (
      // New target position is now
      target_position = 0;
      jump_schedule.schedule_jump(0);
    );
  );
  
  retrigger_enabled ? (
    retrig = retrig_values[reset_index];
    retrig == 1 ? ( jump_schedule.schedule_jump(); )
    : (retrig == 2) ? ( jump_schedule.schedule_jump(); jump_schedule.schedule_jump(floor(0.5 * samples_per_beat)); )
    : (retrig == 3) ? ( jump_schedule.jump_to_target(); jump_schedule.schedule_jump(floor(0.33333 * samples_per_beat)); jump_schedule.schedule_jump(floor(0.66666 * samples_per_beat)); )
    : (retrig == 4) ? ( jump_schedule.jump_to_target(); jump_schedule.schedule_jump(floor(0.25 * samples_per_beat)); jump_schedule.schedule_jump(floor(0.5 * samples_per_beat));  jump_schedule.schedule_jump(floor(0.75 * samples_per_beat)); )
  );
);

jump_schedule.eval_jump();


// Non delayed sequences
(sequencer_index != last_sequencer_index) ? (
  
  slowdown_enabled ? (
    speed = speed_values[sequencer_index];
    
    // Fractional speed
    speed = (speed == 0) ? 1.0
    : (speed == 1) ? 0.75
    : (speed == 2) ? 0.66
    : (speed == 3) ? 0.5
    : (speed == 4) ? 0.25
  ) : ( speed = 1 );
  
  // Reverse it?
  (reverse_enabled && reverse_values[sequencer_index] == 1) ? speed = -speed;
  
  // Calculate the actual offset speed.
  // This is given by - (relative_speed - speed of incoming audio)
  // Speed of the incoming audio is 1 sample / sample.
  speed = 1.0 - speed;
  
  previous_filter_target = filter_target;
  filter_target = filt_values[sequencer_index];
  
  filter_target != previous_filter_target ? (
    filter_envelope.reset = 0;
    filter_envelope.reset_envelope();
  );
  
  previous_gate_target = gate_target;
  gate_target = gate_values[sequencer_index];
  gate_target != previous_gate_target ? (
    gate_envelope.reset = 0;
    gate_envelope.reset_envelope();
  );
  
  previous_reverb_target = reverb_target;
  reverb_target = reverb_values[sequencer_index];
  reverb_target != previous_reverb_target ? (
    verb_envelope.reset = 0;
    verb_envelope.reset_envelope();
  );
);

last_sequencer_index = sequencer_index;
last_reset_index = reset_index;

l_buffer.writeBuffer(spl0);
r_buffer.writeBuffer(spl1);

// Reference playhead is where the playhead is sent after a "reset" by retrigger.
playhead_0 += speed;
playhead_1 += speed;

// Equal power fades (x^2 + y^2 = 1)
x_fade_position > 0 ? (
  // Which playhead are we moving _towards_
  current_playhead == 0 ? (
    amp1 = sqrt(x_fade_position / crossfade_samples);
    amp0 = sqrt(1.0 - amp1);
    x_fade_position -= 1;
  ) : (
    amp0 = sqrt(x_fade_position / crossfade_samples);
    amp1 = sqrt(1.0 - amp0);
    x_fade_position -= 1;
  );
);

ssl = amp0 * l_buffer.readBuffer(playhead_0) + amp1 * l_buffer.readBuffer(playhead_1);
ssr = amp0 * r_buffer.readBuffer(playhead_0) + amp1 * r_buffer.readBuffer(playhead_1);

filter_enabled ? process_filter();
gate_enabled ? process_gate();
reverb_enabled ? process_verb();

spl0 = ssl;
spl1 = ssr;

@gfx

function draw_logo(x_origin, y_origin, dx, dy)
local(cx, cy, xs, ys)
global(q)
(
  q += .01;
  //q > 2.5 ? q = 2.5;
  
  xs = dx - 2;
  ys = dy - 2;
  cy = y_origin + 0 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.0088999644001424)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.005695977216091136)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.003203987184051264)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.001423994304022784)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.000355998576005696)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.10288358846564613)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.09113563545745818)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.0800996796012816)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06977572089711641)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06016375934496262)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.3645425418298327)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.3421146315414738)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.3203987184051264)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.2993948024207903)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.27910288358846563)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.598433606265575)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5695977216091136)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5414738341046635)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.514061943752225)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.48736205055179777)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 1 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.012815948736205056)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.1153435386258455)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.3876824492702029)); gfx_rect(cx, cy, xs, ys);cx += 4 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.2595229619081524)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.6279814880740477)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 2 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.017443930224279102)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.022783908864364544)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.028835884656461374)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.0355998576005696)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.04307582769668921)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.12851548593805626)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.1423994304022784)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.15699537201851194)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.17230331078675684)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.18832324670701317)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.4115343538625845)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.6279814880740477)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.24065503737985047)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.6582413670345318)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.6892132431470274)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.7208971164115343)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.7532929868280527)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.7864008543965824)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 3 * dy;
  cx = x_origin;
  cx += 4 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.051263794944820223)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.2050551797792809)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.43609825560697757)); gfx_rect(cx, cy, xs, ys);cx += 3 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.598433606265575)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.22249911000355999)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.8202207191171236)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 4 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.10288358846564613)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.09113563545745818)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.0800996796012816)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06977572089711641)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06016375934496262)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.22249911000355999)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.24065503737985047)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.2595229619081524)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.27910288358846563)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.2993948024207903)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.461374154503382)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.48736205055179777)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.514061943752225)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5414738341046635)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5695977216091136)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-1.0)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.9626201495194019)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.9259522961908152)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.8899964400142399)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.854752580989676)); gfx_rect(cx, cy, xs, ys);
);

function setup_theme()
(
  base_r = .1;
  base_g = .1;
  base_b = .1;
  
  BASE_FONT = 1;
  gfx_setfont(BASE_FONT, "Arial", 16);
  font_r = .8;
  font_g = .7;
  font_b = .8;
  
  BAND_FONT = 5;
  gfx_setfont(BAND_FONT, "Arial", floor(16 * (1+fontscaling)));
  
  KNOB_FONT = 6;
  gfx_setfont(KNOB_FONT, "Arial", floor(14 * (1+fontscaling)));
  
  KNOB_FONT2 = 7;
  gfx_setfont(KNOB_FONT2, "Arial", floor(13 * (1+fontscaling)));
  
  HINT_FONT = 8;
  gfx_setfont(HINT_FONT, "Arial", floor(13 * (1+fontscaling)));
  
  TOGGLE_FONT = 9;
  gfx_setfont(TOGGLE_FONT, "Arial", floor(13 * (1+fontscaling)));
  
  scaling = 0;
  style == 0 ? (
    s_FILTER = sprintf(65, "FILTER");
    s_ENVELOPE = sprintf(66, "ENVELOPE");
    s_GATE = sprintf(67, "GATE");
    s_REVERB = sprintf(68, "REVERB");
  ) : ( style == 1 ) ? (
    s_FILTER = sprintf(65, "Filter");
    s_ENVELOPE = sprintf(66, "Envelope");
    s_GATE = sprintf(67, "Gate");
    s_REVERB = sprintf(68, "Reverb");
  ) : ( style == 2 ) ? (
    s_FILTER = sprintf(65, "Filter");
    s_ENVELOPE = sprintf(66, "Envelope");
    s_GATE = sprintf(67, "Gate");
    s_REVERB = sprintf(68, "Reverb");
  );
  
  style == 0 ? (
    font_color_r = .7;
    font_color_g = .6;
    font_color_b = .8;
  ) : (
    font_color_r = .7;
    font_color_g = .7;
    font_color_b = .7;
  );
  dial_animation = 1;
  dial_position_color_r = 0.2;
  dial_position_color_g = 0.7;
  dial_position_color_b = 0.4;
  
  font_color_a = 1;
  knob_font_color_r = 0.9;
  knob_font_color_g = 0.9;
  knob_font_color_b = 0.8;
  knob_font_color_a = 1;
  edge_r = 39/255;
  edge_g = 39/255;
  edge_b = 41/255;
  edge_a = 1.0;
  
  edge_font_r = 0.9;
  edge_font_g = 0.9;
  edge_font_b = 0.8;
  
  mod1_color_r = .3;
  mod1_color_g = .47;
  mod1_color_b = .6;
  mod1_color_a = 1;
  mod2_color_r = .2;
  mod2_color_g = .5;
  mod2_color_b = 1;
  mod2_color_a = 1;
  mod3_color_r = .1;
  mod3_color_g = .6;
  mod3_color_b = 1;
  mod3_color_a = 1;
  
  fontscaling = scaling < -.15 ? scaling : 0;
);
setup_theme();
too_fast > 0 ? too_fast -= 1;

grid_origin_x = 5;
grid_origin_y = 5;
label_width = 150 * (1 + scaling);
block_width = 22.83 * (1 + scaling);
block_spacing = 1 * (1 + scaling);

function nice_rect(x, y, w, h, value, powered)
global(base_r, base_g, base_b,
       font_r, font_g, font_b,
       gfx_x, gfx_y)
local(label, txt_w, txt_h, power_intensity)
(
  power_intensity = 0.2 + 0.8 * powered;
  gfx_set(base_r * power_intensity, base_g * power_intensity, base_b * power_intensity, 1.0);
  gfx_rect(x, y, w, h);
  
  gfx_set(2 * base_r * power_intensity, 2 * base_g * power_intensity, 2 * base_b * power_intensity, 1.0);
  gfx_line(x, y, x + w - 1, y);
  gfx_line(x, y, x, y + h - 1);
  gfx_line(x, y + h - 1, x + w - 1, y + h - 1);
  gfx_line(x + w - 1, y, x + w - 1, y + h - 1);
  
  value > 0 ? (
    gfx_rect(x, y, w, h);
    gfx_x = x;
    gfx_y = y;
    sprintf(label, "%d", value);
    gfx_measurestr(label, txt_w, txt_h);
    gfx_x = x - 0.5 * (txt_w - w);
    gfx_y = y - 0.5 * (txt_h - h);
    gfx_set(font_r, font_g, font_b, 1.0);
    gfx_printf(label);
  );
);

function power_button(x, y, w, h, powered)
global(base_r, base_g, base_b,
       font_r, font_g, font_b,
       gfx_x, gfx_y)
local(ww, hh)
(
  gfx_set(base_r, base_g, base_b, 1.0);
  gfx_rect(x, y, w, h);
  
  gfx_set(2 * base_r, 2 * base_g, 2 * base_b, 1.0);
  gfx_line(x, y, x + w - 1, y);
  gfx_line(x, y, x, y + h - 1);
  gfx_line(x, y + h - 1, x + w - 1, y + h - 1);
  gfx_line(x + w - 1, y, x + w - 1, y + h - 1);
  
  ww = floor(0.5 * w);
  hh = floor(0.5 * h);
  
  powered ? gfx_set(0.2, 0.7, 0.4, 1) : gfx_set(0, 0, 0, 1);
  gfx_circle(x + ww, y + hh, ww/2, 0, 1);
  gfx_circle(x + ww, y + hh, ww/2 + 0.5, 0, 1);
  gfx_line(x + ww, y + .95 * hh, x + ww, y + 0.25 * hh);
  gfx_line(x + ww + 1, y + .85 * hh, x + ww + 1, y + 0.25 * hh);
  gfx_line(x + ww - 1, y + .85 * hh, x + ww - 1, y + 0.25 * hh);
);

function process_effect_row(me, mem, x, y, label, max_value, power_slider)
global(label_width, block_width, block_spacing, selected_details,
       nice_rect,
       n_segments,
       font_r, font_g, font_b,
       gfx_x, gfx_y,
       BASE_FONT
       mouse_cap, mouse_x, mouse_y, last_cap, captured_by)
local(txt_w, txt_h, ptr, idx, target)
instance(mem, start_idx)
(
  nice_rect(x, y, label_width, block_width, 0, slider(power_slider));
  ptr = mem;
  
  // Are we selected?
  (selected_details == me) ? (
    gfx_set(1.0, 1.0, 1.0, 0.15 + 0.1 * sin(3*time_precise()));
    gfx_rect(x, y, label_width, block_width);
  );
  
  gfx_set(font_r, font_r, font_r, 1.0);
  gfx_setfont(BASE_FONT);
  gfx_measurestr(label, txt_w, txt_h);
  gfx_x = x - 0.5 * (txt_w - label_width);
  gfx_y = y - 0.5 * (txt_h - block_width);
  gfx_printf(label);
  
  // Move to the actual sequencer cols
  x += label_width - block_spacing;
  
  power_button(x, y, block_width, block_width, slider(power_slider));
  
  x += block_width + block_spacing;
  ptr = mem;
  target = 0;
  loop(n_segments,
    nice_rect(x, y, block_width, block_width, ptr[], slider(power_slider));
    target == 0 ? (gfx_set(1.0, 1.0, 1.0, 0.05); gfx_rect(x, y, block_width, block_width));
    x += block_spacing + block_width;
    ptr += 1;
    target = (target + 1) % 4;
  );
  
  // Any clicked?
  (1) ? (
    x -= n_segments * (block_width + block_spacing);
    
    idx = min(floor((mouse_x - x) / (block_width + block_spacing)), n_segments);
    (mouse_cap == 1 || mouse_cap == 2) ? (
      // Not captured, start dragging.
      (last_cap == 0) ? (
        // Are we in the positional columns?
        (mouse_y > y) && (mouse_y < (y + block_width)) && (mouse_x > x) && (mouse_x < (x + (n_segments + 1) * (block_width + block_spacing))) ? (
          // Start dragging a region
          start_idx = idx;
          mouse_cap == 1 ? captured_by = me : captured_by = -me;
        ) : (
          (mouse_y > y) && (mouse_y < (y + block_width)) ? (
            ((mouse_x < x) && (mouse_x > x - (block_width + block_spacing))) ? (
              // Toggle the lane power
              slider(power_slider) = 1 - slider(power_slider);
            ) : (mouse_x < x) ? (
              // Select the lane
              selected_details = me;
            );
          );
        );
      ) : ( me == abs(captured_by) ) ? (
        captured_by > 0 ? gfx_set(0, 0, 1, .1) : gfx_set(1, 0, 0, .1);
        ptr = min(start_idx, idx);
        idx = max(start_idx, idx);
        gfx_rect(x + (block_width + block_spacing) * ptr, y, (idx - ptr + 1) * (block_width + block_spacing), block_width, 1);
      );
    ) : ( abs(captured_by) == me ) ? (
      // We dragged an area
      ptr = min(start_idx, idx);
      idx = max(start_idx, idx);
      start_idx = ptr;
      // Left or right mouse drag
      captured_by > 0 ? (
        target = mem[ptr] + 1;
        target > max_value ? target = 0;
      ) : (
        target = mem[ptr] - 1;
        target < 0 ? target = max_value;
      );
      loop(idx - start_idx + 1,
        mem[ptr] = target;
        ptr += 1;
      );
      captured_by = 0;
    );
  );
  
  y += block_width + block_spacing;
);

function draw_scope(scope_w, scope_h)
global(SCOPE,
       current_sample, samples_per_beat, sample_clock,
       block_width, block_spacing, l_buffer.write_ptr,
       gfx_w, gfx_h, gfx_x, gfx_y, gfx_dest)
instance(last_scope_w, last_scope_h, last_samples, iter)
local(lastx, x, s, dx, minacc, maxacc, wave_range, wave_center, x_old, y_old)
(
  SCOPE = 1;
  iter += 1;
  
  ((last_scope_w != scope_w) || (last_scope_h != scope_h)) ? (
    last_scope_w = scope_w;
    last_scope_h = scope_h;
    gfx_setimgdim(1, scope_w, scope_h);
  );

  gfx_dest = 1;
  x_old = gfx_x;
  y_old = gfx_y;
  gfx_x = 0;
  gfx_y = 0;
  
  //(iter % 4) == 0 ? gfx_blurto(scope_w, scope_h);
  gfx_set(0, 0, 0, .005);
  gfx_rect(0, 0, scope_w, scope_h);
  
  wave_range = 0.5 * scope_h;
  wave_center = wave_range;
  x = (block_width + block_spacing) * (current_sample / samples_per_beat);
  dx = (block_width + block_spacing) / samples_per_beat;
  s = 1;
  maxacc = 0;
  minacc = 0;
  gfx_set(0.5, 0.5, 0.5, 0.8);
  loop(sample_clock - last_samples,
    maxacc = max((l_buffer.write_ptr)[s], maxacc);
    minacc = min((l_buffer.write_ptr)[s], minacc);
    
    (floor(lastx) != floor(x)) ? (
      gfx_line(x, wave_center + maxacc * wave_range, x, wave_center + minacc * wave_range);
      lastx = x;
      maxacc = 0;
      minacc = 0;
    );
    x -= dx;
    s -= 1;
  );
  
  last_samples = sample_clock;
  gfx_dest = -1;
  gfx_x = x_old;
  gfx_y = y_old;
  
  1
);

draw_logo(10 * (1+scaling), 10 * (1+scaling), 6 * (1+scaling), 6 * (1+scaling));

scope_w = ceil((block_width + block_spacing) * 32);
scope_h = 35 * (1 + scaling);

gfx_x = grid_origin_x + label_width + block_width + block_spacing;
gfx_y = grid_origin_y;
gfx_blit(draw_scope(scope_w, scope_h), 1, 0);

grid_origin_y += 40;
x_current = grid_origin_x;
y_current = grid_origin_y;

y_s = y_current;
y_current = process_effect_row(1, reset_values, x_current, y_current, "Reset", 1, 10);
y_current = process_effect_row(2, speed_values, x_current, y_current, "Slowdown", 4, 11);
//y_current = process_effect_row(3, dynspeed_values, x_current, y_current, "Dynamic Slow", 4, 12);
y_current = process_effect_row(4, retrig_values, x_current, y_current, "Retrigger", 4, 13);
y_current = process_effect_row(5, reverse_values, x_current, y_current, "Reverse", 1, 14);
y_current = process_effect_row(7, filt_values, x_current, y_current, "Filter", 1, 16);
y_current = process_effect_row(6, gate_values, x_current, y_current, "Gate", 1, 15);
y_current = process_effect_row(8, reverb_values, x_current, y_current, "Reverb", 1, 17);

gfx_set(1, 1, 1, .1);
gfx_rect(grid_origin_x + label_width + (block_width + block_spacing) * floor(current_sample / samples_per_beat + 1), grid_origin_y, block_width, y_current - y_s);

last_cap = mouse_cap;



render_time += .025;

style = 1;
xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
/*widget_r = 35/255;
widget_g = 155/255;
widget_b = 30/255;
widget_a = 1.0;
toggle_r = .5;
toggle_g = 1.6;
toggle_b = .5;
toggle_a = 1.0;*/

panelY = y_current - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;




dial_animation = 0;

cX = x_current;
cY = y_current + 2.25 * knobSize;

dial_animation = 1;
function drawAndProcess(cX, cY, knobSize, label, description, current, modifier1, modifier2, modifier3, default)
instance(vel, mod1, mod2)
(
  this.drawKnob(cX, cY, knobSize, label, description, 1.0);
  
  dial_animation ? (
    this.knob_draw_modifier(current - this.value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    this.knob_draw_modifier(current - this.value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  
  modifier1 ? this.knob_draw_modifier(vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  modifier2 ? this.knob_draw_modifier(mod1, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  modifier3 ? this.knob_draw_modifier(mod2, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
   
  activeModifier == 3 ? ( this.knob_modifier_processMouse(0, mod2) ? ( mod2 = this.value; );
  ) : activeModifier == 2 ? ( this.knob_modifier_processMouse(0, mod1) ? ( mod1 = this.value; );
  ) : activeModifier == 1 ? ( this.knob_modifier_processMouse(0, vel) ? ( vel = this.value; );
  ) : this.knob_processMouse(mouse_x, mouse_y, mouse_cap, default);
);

(selected_details == 7) ? (
  // Filter
  nextPanel = drawPanel(s_FILTER, cX, cY - 1.5 * knobSize, 26.5*knobSpacing, panelHeight, filter_enabled);
  cX += 2 * knobSpacing;
  cX += knobSize;
  gfx_setfont(KNOB_FONT);
  y_move = .45 * knobSize;
  ww = 1.5*knobSize;
  hh = .35 * knobSize;
  FILTER_SELECT_BUTTON = 25;
  y_ref = cY - 0.9*knobSize - 1;
  drawSelectionButton("Lin 2p", cX - 2*knobSize, y_ref, ww, hh, 0, FILTER_SELECT_BUTTON, "2-pole linear state variable filter (12 dB/oct).");
  drawSelectionButton("Lin 4p", cX - 2*knobSize, y_ref + y_move, ww, hh, 2, FILTER_SELECT_BUTTON, "4-pole linear state variable filter (12 dB/oct)");
  drawSelectionButton("Dual", cX - 2*knobSize, y_ref + 2*y_move, ww, hh, 8, FILTER_SELECT_BUTTON, "2 2-pole state variable filters in series\nwhere one is placed at four times the cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Triple", cX - 2*knobSize, y_ref + 3*y_move, ww, hh, 9, FILTER_SELECT_BUTTON, "3 2-pole state variable filters in series.\nCutoff frequencies are at one, two and four times the base cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Rect", cX - 2*knobSize, y_ref + 4*y_move, ww, hh, 14, FILTER_SELECT_BUTTON, "2-pole linear state variable filter where\nthe approximate resonance is rectified.");
  
  drawSelectionButton("MS-20", cX - 0.25*knobSize, y_ref + 0*y_move, ww, hh, 1, FILTER_SELECT_BUTTON, "MS-20 emulation (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("MS-20A", cX - .25*knobSize, y_ref + 1*y_move, ww, hh, 6, FILTER_SELECT_BUTTON, "MS-20 emulation with diode asymmetry (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("Moog", cX - .25*knobSize, y_ref + 2*y_move, ww, hh, 3, FILTER_SELECT_BUTTON, "Moog emulation (24 dB/oct).");
  drawSelectionButton("Ladder", cX - .25*knobSize, y_ref + 3*y_move, ww, hh, 4, FILTER_SELECT_BUTTON, "Ladder filter with two stages (12 dB/oct).");
  drawSelectionButton("303", cX - .25*knobSize, y_ref + 4*y_move, ww, hh, 5, FILTER_SELECT_BUTTON, "Blaukraut's 303 filter emulation");
  
  drawSelectionButton("nlSVF2p", cX + 1.5*knobSize, y_ref + 0*y_move, ww, hh, 10, FILTER_SELECT_BUTTON, "2-pole non-linear state variable filter (12 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("nlSVF4p", cX + 1.5*knobSize, y_ref + 1*y_move, ww, hh, 11, FILTER_SELECT_BUTTON, "4-pole non-linear state variable filter (24 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("Steiner", cX + 1.5*knobSize, y_ref + 2*y_move, ww, hh, 15, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (symmetric) feedback.\nBe warned, over 0.5 this filter goes into hard oscillation.\nThis sounds awful unless there's sufficient drive to choke it.\nResonance loss more dominant at HF.");
  drawSelectionButton("SteinerA", cX + 1.5*knobSize, y_ref + 3*y_move, ww, hh, 16, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (asymmetric) feedback.\nRaising the drive lowers the resonance (chokes it). Resonance loss more dominant at HF.");
  drawSelectionButton("Bent", cX + 1.5*knobSize, y_ref + 4*y_move, ww, hh, 17, FILTER_SELECT_BUTTON, "4-pole non-linear CMOS filter. Sounds extremely non-linear. Can lead a life of its own.");
  
  
  cX += 4.25*knobSize;
  driveKnob.knob_set(sprintf(1, "%.1f dB", drive), filter_enabled, (drive + 6)/54);
  driveKnob.drawAndProcess(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", (drive + 6)/54, 1, 1, 1, 6.001/54) ? ( drive = driveKnob.value * 54 - 6; slider_automate(drive); );
  
  cX += 2.5*knobSize;
  center = .5 * srate * exp( (1-cutoff_start) * log(20/22050) );
  cutoffKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), filter_enabled, cutoff_start);
  cutoffKnob.drawAndProcess(cX, cY, knobSize, "Cutoff Start", "Filter Cutoff", current_cutoff, 1, 1, 1, 0) ? ( cutoff_start = cutoffKnob.value; slider_automate(cutoff_start); );
  
  cX += 2.5*knobSize;
  center = .5 * srate * exp( (1-cutoff_final) * log(20/22050) );
  cutoffEndKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), filter_enabled, cutoff_final);
  cutoffEndKnob.drawAndProcess(cX, cY, knobSize, "Cutoff End", "Filter Cutoff", current_cutoff, 1, 1, 1, 1) ? ( cutoff_final = cutoffEndKnob.value; slider_automate(cutoff_final); );
  
  cX += knobSize*2.5;
  resonanceKnob.knob_set(sprintf(1, "%.1f", resonance), filter_enabled, resonance);
  resonanceKnob.drawAndProcess(cX, cY, knobSize, "Resonance", "Filter Resonance", resonance, 0, 0, 0, 0) ? ( resonance = resonanceKnob.value; slider_automate(resonance); );
   
  cX += knobSize*2.7;
  morphKnob.knob_set("", filter_enabled, morph);
  morphKnob.drawAndProcess(cX, cY, knobSize, "Morph", "Filter Morph", morph, 0, 0, 0, 0) ? ( morph = morphKnob.value; slider_automate(morph); );
  
  gfx_set(1,1,1,1);
  drawKnobLabels(knobSize*1.25, 0, "LP");
  drawKnobLabels(knobSize*1.25, 1/4, "BP");
  drawKnobLabels(knobSize*1.25, 2/4, "HP");
  drawKnobLabels(knobSize*1.25, 3/4, "BR");
  drawKnobLabels(knobSize*1.25, 4/4, "LP");
  
  
  cX += knobSize * 2;
  nextPanel = drawPanel(s_ENVELOPE, cX, cY - 1.5 * knobSize, 11.25*knobSpacing, panelHeight, filter_enabled);
  
  cX += knobSize * 1.35;
  tempo_sync_envelopes ? ( cutoffAttackKnob.knob_set(getFastEnvelopeLabel(cutoff_atk), 1, cutoff_atk);
  ) : cutoffAttackKnob.knob_set(cutoff_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*cutoff_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*cutoff_atk))), filter_enabled, cutoff_atk);
  cutoffAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", cutoff_atk, 0, 0, 0, 0.06) ? ( cutoff_atk = cutoffAttackKnob.value; slider_automate(cutoff_atk); );

  cX += knobSize*2.5;
  tempo_sync_envelopes ? ( cutoffDecayKnob.knob_set(getFastEnvelopeLabel(cutoff_decay), 1, cutoff_decay);
  ) : cutoffDecayKnob.knob_set(cutoff_decay > .5 ? sprintf(19, "%d ms", (30 * 10^(2*cutoff_decay))) : sprintf(19, "%.1f ms", (30 * 10^(2*cutoff_decay))), filter_enabled, cutoff_decay );
  cutoffDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", cutoff_decay, 0, 0, 0, 0.6) ? ( cutoff_decay = cutoffDecayKnob.value; slider_automate(cutoff_decay); );
  
  cX += knobSize*2.5;
  cutoffSustainKnob.knob_set(sprintf(1, "%.1f", cutoff_sustain), filter_enabled, cutoff_sustain);
  cutoffSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", cutoff_sustain, 0, 0, 0, 1.0) ? ( cutoff_sustain = cutoffSustainKnob.value; slider_automate(cutoff_sustain); );
) : ( selected_details == 6 ) ? (
  // Gate
  nextPanel = drawPanel(s_GATE, cX, cY - 1.5 * knobSize, 18.25*knobSpacing, panelHeight, gate_enabled);
  cX += knobSize * 1.35;
  gateStart.knob_set(sprintf(1, "%.1f dB", gate_start), gate_enabled, (gate_start + 48)/96);
  gateStart.drawAndProcess(cX, cY, knobSize, "Closed Level", "Gain when gate is closed.", (current_gate + 48)/96, 1, 1, 1, (gate_start_default + 48)/96) ? ( gate_start = gateStart.value * 96 - 48; slider_automate(gate_start); );
  
  cX += 2.5*knobSize;
  gateEnd.knob_set(sprintf(1, "%.1f dB", gate_stop), gate_enabled, (gate_stop + 48)/96);
  gateEnd.drawAndProcess(cX, cY, knobSize, "Open Level", "Gain level when gate is open.", (current_gate + 48)/96, 1, 1, 1, (gate_stop_default + 48)/96) ? ( gate_stop = gateEnd.value * 96 - 48; slider_automate(gate_stop); );
  
  cX += 2.5*knobSize;  
  tempo_sync_envelopes ? ( gateAttackKnob.knob_set(getFastEnvelopeLabel(gate_atk), 1, gate_atk);
  ) : gateAttackKnob.knob_set(gate_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*gate_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*gate_atk))), gate_enabled, gate_atk);
  gateAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", gate_atk, 0, 0, 0, gate_atk_default) ? ( gate_atk = gateAttackKnob.value; slider_automate(gate_atk); );
  
  cX += knobSize*2.5;
  tempo_sync_envelopes ? ( gateDecayKnob.knob_set(getFastEnvelopeLabel(gate_decay), 1, gate_decay);
  ) : gateDecayKnob.knob_set(gate_decay > .5 ? sprintf(19, "%d ms", (30 * 10^(2*gate_decay))) : sprintf(19, "%.1f ms", (30 * 10^(2*gate_decay))), gate_enabled, gate_decay );
  gateDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", gate_decay, 0, 0, 0, gate_decay_default) ? ( gate_decay = gateDecayKnob.value; slider_automate(gate_decay); );
  
  cX += knobSize*2.5;
  gateSustainKnob.knob_set(sprintf(1, "%.1f", gate_sustain), gate_enabled, gate_sustain);
  gateSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", gate_sustain, 0, 0, 0, gate_sustain_default) ? ( gate_sustain = gateSustainKnob.value; slider_automate(gate_sustain); );
) : ( selected_details == 8 ) ? (
  // Reverb
  nextPanel = drawPanel(s_REVERB, cX, cY - 1.5 * knobSize, 29*knobSpacing, panelHeight, reverb_enabled);
  
  cX += knobSize * 1.35;
  verbDiffusionKnob.knob_set("", reverb_enabled, verb_diffusion);
  verbDiffusionKnob.drawAndProcess(cX, cY, knobSize, "Diffusion", "Reverb Diffusion", verb_diffusion, 1, 1, 1, verb_diffusion_default) ? ( verb_diffusion = verbDiffusionKnob.value; slider_automate(verb_diffusion); );

  cX += 2.5*knobSize;
  verbDecayKnob.knob_set("", reverb_enabled, verb_decay);
  verbDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Reverb decay", verb_decay, 1, 1, 1, verb_decay_default) ? ( verb_decay = verbDecayKnob.value; slider_automate(verb_decay); );
  
  cX += 2.5 * knobSize;
  verbModDepthKnob.knob_set("", reverb_enabled, verb_mod_depth);
  verbModDepthKnob.drawAndProcess(cX, cY, knobSize, "Mod Depth", "Modulation depth", verb_mod_depth, 1, 1, 1, verb_mod_depth_default) ? ( verb_mod_depth = verbModDepthKnob.value; slider_automate(verb_mod_depth); );
  
  cX += 2.5 * knobSize;
  verbModRateKnob.knob_set("", reverb_enabled, verb_mod_rate);
  verbModRateKnob.drawAndProcess(cX, cY, knobSize, "Mod rate", "Mod rate", verb_mod_rate, 1, 1, 1, verb_mod_rate_default) ? ( verb_mod_rate = verbModRateKnob.value; slider_automate(verb_mod_rate); );

  cX += 2.5*knobSize;
  center = .5 * srate * exp( (1-verb_lowpass) * log(20/22050) );
  verbLowPassKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), reverb_enabled, verb_lowpass);
  verbLowPassKnob.drawAndProcess(cX, cY, knobSize, "Damping", "Filter Cutoff inside the feedback loop", verb_lowpass, 1, 1, 1, verb_lowpass_default) ? ( verb_lowpass = verbLowPassKnob.value; slider_automate(verb_lowpass); );
  
  cX += 2.5*knobSize;
  center = .5 * srate * exp( (1-verb_highpass) * log(20/22050) );
  verbHighPassKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), reverb_enabled, verb_highpass);
  verbHighPassKnob.drawAndProcess(cX, cY, knobSize, "Highpass", "Filter Cutoff", verb_highpass, 1, 1, 1, verb_highpass_default) ? ( verb_highpass = verbHighPassKnob.value; slider_automate(verb_highpass); );

  cX += 2.5*knobSize;
  verbDry.knob_set(sprintf(1, "%.1f dB", verb_dry), reverb_enabled, (verb_dry + 64)/64);
  verbDry.drawAndProcess(cX, cY, knobSize, "Dry", "Dry signal level.", (verb_dry + 64)/64, 1, 1, 1, (verb_dry_default + 64)/64) ? ( verb_dry = verbDry.value * 64 - 64; slider_automate(verb_dry); );
  
  cX += 2.5*knobSize;
  verbWet.knob_set(sprintf(1, "%.1f dB", verb_wet), reverb_enabled, (verb_wet + 64)/64);
  verbWet.drawAndProcess(cX, cY, knobSize, "Wet", "Wet signal level.", (verb_wet + 64)/64, 1, 1, 1, (verb_wet_default + 64)/64) ? ( verb_wet = verbWet.value * 64 - 64; slider_automate(verb_wet); );

  cX += knobSize*1.75;
  nextPanel = drawPanel(s_ENVELOPE, cX, cY - 1.5 * knobSize, 11.125*knobSpacing, panelHeight, reverb_enabled);
  
  cX += 1.35*knobSize;  
  tempo_sync_envelopes ? ( verbGateAttackKnob.knob_set(getFastEnvelopeLabel(verb_gate_atk), 1, verb_gate_atk);
  ) : verbGateAttackKnob.knob_set(verb_gate_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*verb_gate_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*verb_gate_atk))), reverb_enabled, verb_gate_atk);
  verbGateAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", verb_gate_atk, 0, 0, 0, verb_gate_atk_default) ? ( verb_gate_atk = verbGateAttackKnob.value; slider_automate(verb_gate_atk); );
  
  cX += knobSize*2.5;
  tempo_sync_envelopes ? ( verbGateDecayKnob.knob_set(getFastEnvelopeLabel(verb_gate_decay), 1, verb_gate_decay);
  ) : verbGateDecayKnob.knob_set(verb_gate_decay > .5 ? sprintf(19, "%d ms", (30 * 10^(2*verb_gate_decay))) : sprintf(19, "%.1f ms", (30 * 10^(2*verb_gate_decay))), reverb_enabled, verb_gate_decay );
  verbGateDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", verb_gate_decay, 0, 0, 0, verb_gate_decay_default) ? ( verb_gate_decay = verbGateDecayKnob.value; slider_automate(verb_gate_decay); );
  
  cX += knobSize*2.5;
  verbGateSustainKnob.knob_set(sprintf(1, "%.1f", verb_gate_sustain), reverb_enabled, verb_gate_sustain);
  verbGateSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", verb_gate_sustain, 0, 0, 0, verb_gate_sustain_default) ? ( verb_gate_sustain = verbGateSustainKnob.value; slider_automate(verb_gate_sustain); );
);


