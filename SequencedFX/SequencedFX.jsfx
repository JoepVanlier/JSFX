desc:Saike Sequenced FX (pre-alpha WIP)
tags: time-based effect
version: 0.02
author: Joep Vanlier
changelog: Set up filter
license: MIT
about:
  # A small effect for doing sequencing of time based stutters, slowdowns and simple effects.
  
slider1:current_speed=4<1,16,1>Current speed
slider10:reset_enabled=1<0,1,1>-Reset enabled
slider11:slowdown_enabled=1<0,1,1>-Slowdown enabled
slider12:dynamic_slowdown_enabled=1<0,1,1>-Dynamic slowdown enabled
slider13:retrigger_enabled=1<0,1,1>-Retrigger enabled
slider14:reverse_enabled=1<0,1,1>-Reverse enabled
slider15:gate_enabled=0<0,1,1>-Gate enabled
slider16:filter_enabled=0<0,1,1>-Filter enabled
slider25:filter_type=1<0,17,1{Linear,MS-20,Linear x2,Moog,Ladder,303,MS-20 asym,DblRes,DualPeak,TriplePeak,svf nl 2p,svf nl 4p,svf nl 2p inc,svf nl 4p inc,rectified resonance,Steiner,SteinerA}>-Filter type
slider26:drive=0<-32,48,1>-Filter Drive (dB)
slider27:cutoff_start=.6<0,1,.0001>-Cutoff Start
slider28:cutoff_final=.6<0,1,.0001>-Cutoff Finish
slider29:resonance=0.7<0,1,.0001>-Resonance
slider30:morph=0<0,1,.0001>-Morph
slider31:cutoff_atk=0<0,1,0.0001>-Envelope Rise
slider32:cutoff_decay=0<0,1,0.0001>-Envelope Decay
slider33:cutoff_sustain=0<0,1,0.0001>-Envelope Sustain
slider63:inertia=60<0,200,.001>-Filter Inertia [ms]

options:maxmem=12000000
in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import Saike_Yutani_Delays.jsfx-inc
import Saike_Yutani_Widgets.jsfx-inc
import Saike_Yutani_filters.jsfx-inc
import Saike_Yutani_envelope.jsfx-inc
import Saike_Yutani_interpolators.jsfx-inc

@init
sample_clock = 0;
oversampling = 1;
pattern_change = 1;
current_sample = 0;
version = 0;
n_segments = 32;
max_segments = 64;
max_effects = 32;
max_stored_patterns = 64;
crossfade_samples = 128;

freemem = 0;
pattern_size = max_segments * max_effects;
freemem = (pattern_buffer = freemem) + pattern_size * max_stored_patterns;

BUF_SIZE = 96000 * 60;
freemem = (l_buffer = freemem) + BUF_SIZE;
freemem = (r_buffer = freemem) + BUF_SIZE;
l_buffer.initBuffer(l_buffer, l_buffer + BUF_SIZE);
r_buffer.initBuffer(r_buffer, r_buffer + BUF_SIZE);

function init_playhead()
(
  current_playhead = 0;
  amp0 = 1;
  amp1 = 0;
);

function pattern_update()
(
  current_pattern = pattern_buffer + current_pattern_index * pattern_size;
  reset_values = current_pattern;
  speed_values = current_pattern + max_segments;
  dynspeed_values = current_pattern + 2 * max_segments;
  retrig_values = current_pattern + 3 * max_segments;
  filt_values = current_pattern + 4 * max_segments;
  reverse_values = current_pattern + 5 * max_segments;
  gate_values = current_pattern + 6 * max_segments;
  
  reset_values[0] = 1;
);

function interpolator_init()
(
  // Set up the interpolators
  drive_interpolator.interpolator_init(26);
  cutoff_start_interpolator.interpolator_init(27);
  cutoff_final_interpolator.interpolator_init(28);
  reso_interpolator.interpolator_init(29);
  morph_interpolator.interpolator_init(30);
     
  (last_inertia != inertia) ? (
    last_inertia = inertia;
    inertia_cutoff = 1000.0/inertia;
    drive_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_start_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_final_interpolator.initialize_smoother(inertia_cutoff);
    reso_interpolator.initialize_smoother(inertia_cutoff);
    morph_interpolator.initialize_smoother(inertia_cutoff);
    
    drive_interpolator.s = slider(26);
    cutoff_start_interpolator.s = slider(27);
    cutoff_final_interpolator.s = slider(28);
    reso_interpolator.s = slider(29);
    morph_interpolator.s = slider(30);
  );
);

function interpolators_block()
(
  drive_interpolator.interpolator_block();
  cutoff_start_interpolator.interpolator_block();
  cutoff_final_interpolator.interpolator_block();
  reso_interpolator.interpolator_block();
  morph_interpolator.interpolator_block();
);

interpolator_init();
pattern_update();
init_playhead();

@slider

@block
interpolators_block();

@serialize
file_var(0, version);
file_mem(0, pattern_buffer, pattern_size * max_stored_patterns);
file_var(0, selected_details);
file_var(0, reset_enabled);
file_var(0, slowdown_enabled);
file_var(0, retrig_enabled);
file_var(0, reverse_enabled);
file_var(0, filter_enabled);

@sample
sample_clock += 1;

function jump_to_target()
local()
global(current_playhead, playhead_0, playhead_1,
       target_position,
       x_fade_position, crossfade_samples, 
       too_fast, jumps)
(
  jumps += 1;

  // Initiate the crossfade
  x_fade_position != 0 ? too_fast = 100;
  x_fade_position = crossfade_samples;
  
  // Which playhead are we moving away from?
  current_playhead == 0 ? (
    playhead_1 = target_position + crossfade_samples;
  ) : (
    playhead_0 = target_position + crossfade_samples;
  );
  
  current_playhead = 1 - current_playhead;
);

function schedule_jump(offset)
local(already_set)
global()
instance(j1, j2, j3, j4, j5)
(
  already_set = (offset == j1) || (offset == j2) || (offset == j3) || (offset == j4) || (offset == j5);

  !already_set ? (
    (offset < j1) ? (
      j5 = j4;
      j4 = j3;
      j3 = j2;
      j2 = j1;
      j1 = offset;
    ) : (offset < j2) ? (
      j5 = j4;
      j4 = j3;
      j3 = j2;
      j2 = offset;
    ) : (offset < j3) ? (
      j5 = j4;
      j4 = j3;
      j3 = offset;
    ) : (offset < j4) ? (
      j5 = j4;
      j4 = offset;
    ) : ( j5 = offset );
  );
);

function reset_jump()
instance(j1, j2, j3, j4, j5, current)
(
  current = 0;
  j1 = j2 = j3 = j4 = j5 = 10000000000000000;
);

function eval_jump()
local()
global()
instance(j1, j2, j3, j4, j5, current)
(
  (j1 - current) == 0 ? (
    jump_to_target();
    j1 = j2;
    j2 = j3;
    j4 = j5;
    j5 = 0;
  );
  
  current += 1;
);

function update_time_info()
(
  samples_per_beat = (srate * 60) / tempo / current_speed;
  pattern_length = n_segments * samples_per_beat;
  to_index = n_segments / pattern_length;
);

function process_filter()
(
  current_drive = clamp(drive_interpolator.interpolate(), -6, 48);
  
  sample_clock % 16 == 0 ? (
    filter_envelope.calc_times(cutoff_atk, cutoff_decay, cutoff_sustain);
  );
  
  current_cutoff = cutoff_start + filter_envelope.update_envelope(filter_target) * (cutoff_final - cutoff_start);
  sample_clock % 4 == 0 ? (
    filter.init_filter(filter_type, current_cutoff, current_cutoff, morph, morph, resonance);
    log10d20_conversion  = 0.11512925464970228420089957273422;
    preamp      = exp(log10d20_conversion*current_drive);
    inv_preamp  = exp(-log10d20_conversion*current_drive);
  );
  
  ssl *= preamp;
  ssr *= preamp;
  filter.processSample(filter_type);
  ssl *= inv_preamp;
  ssr *= inv_preamp;
);

update_time_info();
current_sample += 1;
target_position += 1; /* Target position moves with the track */
current_sample > pattern_length ? current_sample -= pattern_length;
sequencer_index = floor(to_index * current_sample);

reset_sample = current_sample + crossfade_samples;
reset_sample > pattern_length ? reset_sample -= pattern_length;
reset_index = floor(to_index * reset_sample);

// Delayed sequences to accomodate for crossfades
(reset_index != last_reset_index) ? (
  jump_schedule.reset_jump();
  
  reset_enabled ? (
    reset = reset_values[reset_index];
    reset > 0 ? (
      // New target position is now
      target_position = 0;
      jump_schedule.schedule_jump(0);
    );
  );
  
  retrigger_enabled ? (
    retrig = retrig_values[reset_index];
    retrig == 1 ? ( jump_schedule.schedule_jump(); )
    : (retrig == 2) ? ( jump_schedule.schedule_jump(); jump_schedule.schedule_jump(floor(0.5 * samples_per_beat)); )
    : (retrig == 3) ? ( jump_schedule.jump_to_target(); jump_schedule.schedule_jump(floor(0.33333 * samples_per_beat)); jump_schedule.schedule_jump(floor(0.66666 * samples_per_beat)); )
    : (retrig == 4) ? ( jump_schedule.jump_to_target(); jump_schedule.schedule_jump(floor(0.25 * samples_per_beat)); jump_schedule.schedule_jump(floor(0.5 * samples_per_beat));  jump_schedule.schedule_jump(floor(0.75 * samples_per_beat)); )
  );
);

jump_schedule.eval_jump();


// Non delayed sequences
(sequencer_index != last_sequencer_index) ? (
  
  slowdown_enabled ? (
    speed = speed_values[sequencer_index];
    
    // Fractional speed
    speed = (speed == 0) ? 1.0
    : (speed == 1) ? 0.75
    : (speed == 2) ? 0.66
    : (speed == 3) ? 0.5
    : (speed == 4) ? 0.25
  ) : ( speed = 1 );
  
  // Reverse it?
  (reverse_enabled && reverse_values[sequencer_index] == 1) ? speed = -speed;
  
  // Calculate the actual offset speed.
  // This is given by - (relative_speed - speed of incoming audio)
  // Speed of the incoming audio is 1 sample / sample.
  speed = 1.0 - speed;
  
  filter_target = filt_values[sequencer_index];
  filter_envelope.reset = 0;
  filter_envelope.reset_envelope();
);

last_sequencer_index = sequencer_index;
last_reset_index = reset_index;


l_buffer.writeBuffer(spl0);
r_buffer.writeBuffer(spl1);

// Reference playhead is where the playhead is sent after a "reset" by retrigger.
playhead_0 += speed;
playhead_1 += speed;

// Equal power fades (x^2 + y^2 = 1)
x_fade_position > 0 ? (
  // Which playhead are we moving _towards_
  current_playhead == 0 ? (
    amp1 = sqrt(x_fade_position / crossfade_samples);
    amp0 = sqrt(1.0 - amp1);
    x_fade_position -= 1;
  ) : (
    amp0 = sqrt(x_fade_position / crossfade_samples);
    amp1 = sqrt(1.0 - amp0);
    x_fade_position -= 1;
  );
);

ssl = amp0 * l_buffer.readBuffer(playhead_0) + amp1 * l_buffer.readBuffer(playhead_1);
ssr = amp0 * r_buffer.readBuffer(playhead_0) + amp1 * r_buffer.readBuffer(playhead_1);

filter_enabled ? process_filter();

spl0 = ssl;
spl1 = ssr;

@gfx
function setup_theme()
(
  base_r = .1;
  base_g = .1;
  base_b = .1;
  
  BASE_FONT = 1;
  gfx_setfont(BASE_FONT, "Arial", 16);
  font_r = .8;
  font_g = .7;
  font_b = .8;
  
  BAND_FONT = 5;
  gfx_setfont(BAND_FONT, "Arial", floor(16 * (1+fontscaling)));
  
  KNOB_FONT = 6;
  gfx_setfont(KNOB_FONT, "Arial", floor(14 * (1+fontscaling)));
  
  KNOB_FONT2 = 7;
  gfx_setfont(KNOB_FONT2, "Arial", floor(13 * (1+fontscaling)));
  
  HINT_FONT = 8;
  gfx_setfont(HINT_FONT, "Arial", floor(13 * (1+fontscaling)));
  
  TOGGLE_FONT = 9;
  gfx_setfont(TOGGLE_FONT, "Arial", floor(13 * (1+fontscaling)));
  
  scaling = 0;
  style == 0 ? (
    s_FILTER = sprintf(65, "FILTER");
    s_ENVELOPE = sprintf(66, "ENVELOPE");
  ) : ( style == 1 ) ? (
    s_FILTER = sprintf(65, "Filter");
    s_ENVELOPE = sprintf(66, "Envelope");
  ) : ( style == 2 ) ? (
    s_FILTER = sprintf(65, "FILTER");
    s_ENVELOPE = sprintf(66, "Envelope");
  );
  
  style == 0 ? (
    font_color_r = .7;
    font_color_g = .6;
    font_color_b = .8;
  ) : (
    font_color_r = .7;
    font_color_g = .7;
    font_color_b = .7;
  );
  dial_animation = 1;
  dial_position_color_r = 0.2;
  dial_position_color_g = 0.7;
  dial_position_color_b = 0.4;
  
  font_color_a = 1;
  knob_font_color_r = 0.9;
  knob_font_color_g = 0.9;
  knob_font_color_b = 0.8;
  knob_font_color_a = 1;
  edge_r = 39/255;
  edge_g = 39/255;
  edge_b = 41/255;
  edge_a = 1.0;
  
  edge_font_r = 0.9;
  edge_font_g = 0.9;
  edge_font_b = 0.8;
  
  mod1_color_r = .3;
  mod1_color_g = .47;
  mod1_color_b = .6;
  mod1_color_a = 1;
  mod2_color_r = .2;
  mod2_color_g = .5;
  mod2_color_b = 1;
  mod2_color_a = 1;
  mod3_color_r = .1;
  mod3_color_g = .6;
  mod3_color_b = 1;
  mod3_color_a = 1;
  
  fontscaling = scaling < -.15 ? scaling : 0;
);
setup_theme();

too_fast > 0 ? too_fast -= 1;

grid_origin_x = 5;
grid_origin_y = 5;
label_width = 150 * (1 + scaling);
block_width = 22.83 * (1 + scaling);
block_spacing = 1 * (1 + scaling);

function nice_rect(x, y, w, h, value, powered)
global(base_r, base_g, base_b,
       font_r, font_g, font_b,
       gfx_x, gfx_y)
local(label, txt_w, txt_h, power_intensity)
(
  power_intensity = 0.2 + 0.8 * powered;
  gfx_set(base_r * power_intensity, base_g * power_intensity, base_b * power_intensity, 1.0);
  gfx_rect(x, y, w, h);
  
  gfx_set(2 * base_r * power_intensity, 2 * base_g * power_intensity, 2 * base_b * power_intensity, 1.0);
  gfx_line(x, y, x + w - 1, y);
  gfx_line(x, y, x, y + h - 1);
  gfx_line(x, y + h - 1, x + w - 1, y + h - 1);
  gfx_line(x + w - 1, y, x + w - 1, y + h - 1);
  
  value > 0 ? (
    gfx_rect(x, y, w, h);
    gfx_x = x;
    gfx_y = y;
    sprintf(label, "%d", value);
    gfx_measurestr(label, txt_w, txt_h);
    gfx_x = x - 0.5 * (txt_w - w);
    gfx_y = y - 0.5 * (txt_h - h);
    gfx_set(font_r, font_g, font_b, 1.0);
    gfx_printf(label);
  );
);

function power_button(x, y, w, h, powered)
global(base_r, base_g, base_b,
       font_r, font_g, font_b,
       gfx_x, gfx_y)
local(ww, hh)
(
  gfx_set(base_r, base_g, base_b, 1.0);
  gfx_rect(x, y, w, h);
  
  gfx_set(2 * base_r, 2 * base_g, 2 * base_b, 1.0);
  gfx_line(x, y, x + w - 1, y);
  gfx_line(x, y, x, y + h - 1);
  gfx_line(x, y + h - 1, x + w - 1, y + h - 1);
  gfx_line(x + w - 1, y, x + w - 1, y + h - 1);
  
  ww = floor(0.5 * w);
  hh = floor(0.5 * h);
  
  powered ? gfx_set(0.2, 0.7, 0.4, 1) : gfx_set(0, 0, 0, 1);
  gfx_circle(x + ww, y + hh, ww/2, 0, 1);
  gfx_circle(x + ww, y + hh, ww/2 + 0.5, 0, 1);
  gfx_line(x + ww, y + .95 * hh, x + ww, y + 0.25 * hh);
  gfx_line(x + ww + 1, y + .85 * hh, x + ww + 1, y + 0.25 * hh);
  gfx_line(x + ww - 1, y + .85 * hh, x + ww - 1, y + 0.25 * hh);
);

function process_effect_row(me, mem, x, y, label, max_value, power_slider)
global(label_width, block_width, block_spacing, selected_details,
       nice_rect,
       n_segments,
       font_r, font_g, font_b,
       gfx_x, gfx_y,
       BASE_FONT
       mouse_cap, mouse_x, mouse_y, last_cap, captured_by)
local(txt_w, txt_h, ptr, idx, target)
instance(mem, start_idx)
(
  nice_rect(x, y, label_width, block_width, 0, slider(power_slider));
  ptr = mem;
  
  // Are we selected?
  (selected_details == me) ? (
    gfx_set(1.0, 1.0, 1.0, 0.15 + 0.1 * sin(3*time_precise()));
    gfx_rect(x, y, label_width, block_width);
  );
  
  gfx_set(font_r, font_r, font_r, 1.0);
  gfx_setfont(BASE_FONT);
  gfx_measurestr(label, txt_w, txt_h);
  gfx_x = x - 0.5 * (txt_w - label_width);
  gfx_y = y - 0.5 * (txt_h - block_width);
  gfx_printf(label);
  
  // Move to the actual sequencer cols
  x += label_width - block_spacing;
  
  power_button(x, y, block_width, block_width, slider(power_slider));
  
  x += block_width + block_spacing;
  ptr = mem;
  target = 0;
  loop(n_segments,
    nice_rect(x, y, block_width, block_width, ptr[], slider(power_slider));
    target == 0 ? (gfx_set(1.0, 1.0, 1.0, 0.05); gfx_rect(x, y, block_width, block_width));
    x += block_spacing + block_width;
    ptr += 1;
    target = (target + 1) % 4;
  );
  
  // Any clicked?
  ((mouse_y > y) && (mouse_y < (y + block_width))) ? (
    x -= n_segments * (block_width + block_spacing);
    
    idx = min(floor((mouse_x - x) / (block_width + block_spacing)), n_segments);
    (mouse_cap == 1 || mouse_cap == 2) ? (
      // Not captured, start dragging.
      (last_cap == 0) ? (
        // Are we in the positional columns?
        (mouse_x > x) && (mouse_x < (x + (n_segments + 1) * (block_width + block_spacing))) ? (
          // Start dragging a region
          start_idx = idx;
          mouse_cap == 1 ? captured_by = me : captured_by = -me;
        ) : (
          ((mouse_x < x) && (mouse_x > x - (block_width + block_spacing))) ? (
            // Toggle the lane power
            slider(power_slider) = 1 - slider(power_slider);
          ) : (mouse_x < x) ? (
            // Select the lane
            selected_details = me;
          );
        );
      ) : ( me == abs(captured_by) ) ? (
        captured_by > 0 ? gfx_set(0, 0, 1, .1) : gfx_set(1, 0, 0, .1);
        gfx_rect(x + (block_width + block_spacing) * start_idx, y, (idx - start_idx + 1) * (block_width + block_spacing), block_width, 1);
      );
    ) : ( abs(captured_by) == me ) ? (
      // We dragged an area
      ptr = min(start_idx, idx);
      idx = max(start_idx, idx);
      start_idx = ptr;
      // Left or right mouse drag
      captured_by > 0 ? (
        target = mem[ptr] + 1;
        target > max_value ? target = 0;
      ) : (
        target = mem[ptr] - 1;
        target < 0 ? target = max_value;
      );
      loop(idx - start_idx + 1,
        mem[ptr] = target;
        ptr += 1;
      );
      captured_by = 0;
    );
  );
  
  y += block_width + block_spacing;
);

x_current = grid_origin_x;
y_current = grid_origin_y;

y_current = process_effect_row(1, reset_values, x_current, y_current, "Reset", 1, 10);
y_current = process_effect_row(2, speed_values, x_current, y_current, "Slowdown", 4, 11);
//y_current = process_effect_row(3, dynspeed_values, x_current, y_current, "Dynamic Slow", 4, 12);
y_current = process_effect_row(4, retrig_values, x_current, y_current, "Retrigger", 4, 13);
y_current = process_effect_row(5, reverse_values, x_current, y_current, "Reverse", 1, 14);
y_current = process_effect_row(7, filt_values, x_current, y_current, "Filter", 1, 16);
//y_current = process_effect_row(6, gate_values, x_current, y_current, "Gate", 2, 15);

gfx_set(1, 1, 1, .1);
gfx_rect(grid_origin_x + label_width + (block_width + block_spacing) * floor(current_sample / samples_per_beat), grid_origin_y, block_width, max_effects * block_width);

last_cap = mouse_cap;



render_time += .025;

style = 1;
xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
/*widget_r = 35/255;
widget_g = 155/255;
widget_b = 30/255;
widget_a = 1.0;
toggle_r = .5;
toggle_g = 1.6;
toggle_b = .5;
toggle_a = 1.0;*/

panelY = y_current - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;




dial_animation = 0;

cX = x_current;
cY = y_current + 2.25 * knobSize;

dial_animation = 1;
function drawAndProcess(cX, cY, knobSize, label, description, current, modifier1, modifier2, modifier3, default)
instance(vel, mod1, mod2)
(
  this.drawKnob(cX, cY, knobSize, label, description, 1.0);
  
  dial_animation ? (
    this.knob_draw_modifier(current - this.value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    this.knob_draw_modifier(current - this.value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  
  modifier1 ? this.knob_draw_modifier(vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  modifier2 ? this.knob_draw_modifier(mod1, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  modifier3 ? this.knob_draw_modifier(mod2, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
   
  activeModifier == 3 ? ( this.knob_modifier_processMouse(0, mod2) ? ( mod2 = this.value; );
  ) : activeModifier == 2 ? ( this.knob_modifier_processMouse(0, mod1) ? ( mod1 = this.value; );
  ) : activeModifier == 1 ? ( this.knob_modifier_processMouse(0, vel) ? ( vel = this.value; );
  ) : this.knob_processMouse(mouse_x, mouse_y, mouse_cap, default);
);

(selected_details == 7) ? (
  nextPanel = drawPanel(s_FILTER, cX, cY - 1.5 * knobSize, 26.5*knobSpacing, panelHeight, filter_enabled);
  cX += 2 * knobSpacing;
  cX += knobSize;
  gfx_setfont(KNOB_FONT);
  y_move = .45 * knobSize;
  ww = 1.5*knobSize;
  hh = .35 * knobSize;
  FILTER_SELECT_BUTTON = 25;
  y_ref = cY - 0.9*knobSize - 1;
  drawSelectionButton("Lin 2p", cX - 2*knobSize, y_ref, ww, hh, 0, FILTER_SELECT_BUTTON, "2-pole linear state variable filter (12 dB/oct).");
  drawSelectionButton("Lin 4p", cX - 2*knobSize, y_ref + y_move, ww, hh, 2, FILTER_SELECT_BUTTON, "4-pole linear state variable filter (12 dB/oct)");
  drawSelectionButton("Dual", cX - 2*knobSize, y_ref + 2*y_move, ww, hh, 8, FILTER_SELECT_BUTTON, "2 2-pole state variable filters in series\nwhere one is placed at four times the cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Triple", cX - 2*knobSize, y_ref + 3*y_move, ww, hh, 9, FILTER_SELECT_BUTTON, "3 2-pole state variable filters in series.\nCutoff frequencies are at one, two and four times the base cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Rect", cX - 2*knobSize, y_ref + 4*y_move, ww, hh, 14, FILTER_SELECT_BUTTON, "2-pole linear state variable filter where\nthe approximate resonance is rectified.");
  
  drawSelectionButton("MS-20", cX - 0.25*knobSize, y_ref + 0*y_move, ww, hh, 1, FILTER_SELECT_BUTTON, "MS-20 emulation (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("MS-20A", cX - .25*knobSize, y_ref + 1*y_move, ww, hh, 6, FILTER_SELECT_BUTTON, "MS-20 emulation with diode asymmetry (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("Moog", cX - .25*knobSize, y_ref + 2*y_move, ww, hh, 3, FILTER_SELECT_BUTTON, "Moog emulation (24 dB/oct).");
  drawSelectionButton("Ladder", cX - .25*knobSize, y_ref + 3*y_move, ww, hh, 4, FILTER_SELECT_BUTTON, "Ladder filter with two stages (12 dB/oct).");
  drawSelectionButton("303", cX - .25*knobSize, y_ref + 4*y_move, ww, hh, 5, FILTER_SELECT_BUTTON, "Blaukraut's 303 filter emulation");
  
  drawSelectionButton("nlSVF2p", cX + 1.5*knobSize, y_ref + 0*y_move, ww, hh, 10, FILTER_SELECT_BUTTON, "2-pole non-linear state variable filter (12 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("nlSVF4p", cX + 1.5*knobSize, y_ref + 1*y_move, ww, hh, 11, FILTER_SELECT_BUTTON, "4-pole non-linear state variable filter (24 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("Steiner", cX + 1.5*knobSize, y_ref + 2*y_move, ww, hh, 15, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (symmetric) feedback.\nBe warned, over 0.5 this filter goes into hard oscillation.\nThis sounds awful unless there's sufficient drive to choke it.\nResonance loss more dominant at HF.");
  drawSelectionButton("SteinerA", cX + 1.5*knobSize, y_ref + 3*y_move, ww, hh, 16, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (asymmetric) feedback.\nRaising the drive lowers the resonance (chokes it). Resonance loss more dominant at HF.");
  drawSelectionButton("Bent", cX + 1.5*knobSize, y_ref + 4*y_move, ww, hh, 17, FILTER_SELECT_BUTTON, "4-pole non-linear CMOS filter. Sounds extremely non-linear. Can lead a life of its own.");
  
  
  cX += 4.25*knobSize;
  driveKnob.knob_set(sprintf(1, "%.1f dB", drive), filter_enabled, (drive + 6)/54);
  driveKnob.drawAndProcess(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", (drive + 6)/54, 1, 1, 1, 6.001/54) ? ( drive = driveKnob.value * 54 - 6; slider_automate(drive); );
  
  cX += 2.5*knobSize;
  center = .5 * srate * exp( (1-cutoff_start) * log(20/22050) );
  cutoffKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), filter_enabled, cutoff_start);
  cutoffKnob.drawAndProcess(cX, cY, knobSize, "Cutoff Start", "Filter Cutoff", current_cutoff, 1, 1, 1, 0) ? ( cutoff_start = cutoffKnob.value; slider_automate(cutoff_start); );
  
  cX += 2.5*knobSize;
  center = .5 * srate * exp( (1-cutoff_final) * log(20/22050) );
  cutoffEndKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), filter_enabled, cutoff_final);
  cutoffEndKnob.drawAndProcess(cX, cY, knobSize, "Cutoff End", "Filter Cutoff", current_cutoff, 1, 1, 1, 1) ? ( cutoff_final = cutoffEndKnob.value; slider_automate(cutoff_final); );
  
  cX += knobSize*2.5;
  resonanceKnob.knob_set(sprintf(1, "%.1f", resonance), filter_enabled, resonance);
  resonanceKnob.drawAndProcess(cX, cY, knobSize, "Resonance", "Filter Resonance", resonance, 0, 0, 0, 0) ? ( resonance = resonanceKnob.value; slider_automate(resonance); );
   
  cX += knobSize*2.7;
  morphKnob.knob_set("", filter_enabled, morph);
  morphKnob.drawAndProcess(cX, cY, knobSize, "Morph", "Filter Morph", morph, 0, 0, 0, 0) ? ( morph = morphKnob.value; slider_automate(morph); );
  
  gfx_set(1,1,1,1);
  drawKnobLabels(knobSize*1.25, 0, "LP");
  drawKnobLabels(knobSize*1.25, 1/4, "BP");
  drawKnobLabels(knobSize*1.25, 2/4, "HP");
  drawKnobLabels(knobSize*1.25, 3/4, "BR");
  drawKnobLabels(knobSize*1.25, 4/4, "LP");
  
  
  cX += knobSize * 2;
  nextPanel = drawPanel(s_ENVELOPE, cX, cY - 1.5 * knobSize, 11.25*knobSpacing, panelHeight, filter_enabled);
  
  cX += knobSize * 1.35;
  tempo_sync_envelopes ? ( cutoffAttackKnob.knob_set(getFastEnvelopeLabel(cutoff_atk), 1, cutoff_atk);
  ) : cutoffAttackKnob.knob_set(cutoff_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*cutoff_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*cutoff_atk))), filter_enabled, cutoff_atk);
  cutoffAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", cutoff_atk, 0, 0, 0, 0.06) ? ( cutoff_atk = cutoffAttackKnob.value; slider_automate(cutoff_atk); );

  cX += knobSize*2.5;
  tempo_sync_envelopes ? ( cutoffDecayKnob.knob_set(getFastEnvelopeLabel(cutoff_decay), 1, cutoff_decay);
  ) : cutoffDecayKnob.knob_set(cutoff_decay > .5 ? sprintf(19, "%d ms", (30 * 10^(2*cutoff_decay))) : sprintf(19, "%.1f ms", (30 * 10^(2*cutoff_decay))), filter_enabled, cutoff_decay );
  cutoffDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", cutoff_decay, 0, 0, 0, 0.6) ? ( cutoff_decay = cutoffDecayKnob.value; slider_automate(cutoff_decay); );
  
  cX += knobSize*2.5;
  cutoffSustainKnob.knob_set(sprintf(1, "%.1f", cutoff_sustain), filter_enabled, cutoff_sustain);
  cutoffSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", cutoff_sustain, 0, 0, 0, 1.0) ? ( cutoff_sustain = cutoffSustainKnob.value; slider_automate(cutoff_sustain); );
);

