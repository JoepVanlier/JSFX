desc:Saike SEQS (Sequenced FX) (pre-alpha WIP)
tags: time-based effect
version: 0.21
author: Joep Vanlier
changelog: Fix highlight modulator A.
license: MIT
provides:
  seqs_dependencies/*
about:
  # A small effect for doing sequencing of time based stutters, slowdowns and simple effects.

slider1:current_speed=4<1,16,1>Current speed
slider2:current_pattern_index=0<0,63,1>-Current pattern

slider3:dummy=0<0,1,1>-Dummy
slider4:dummy=0<0,1,1>-Dummy
slider5:dummy=0<0,1,1>-Dummy
slider6:dummy=0<0,1,1>-Dummy
slider7:dummy=0<0,1,1>-Dummy
slider8:dummy=0<0,1,1>-Dummy
slider9:dummy=0<0,1,1>-Dummy

slider10:reset_enabled=1<0,1,1>-Reset enabled
slider11:slowdown_enabled=0<0,1,1>-Slowdown enabled
slider12:dynamic_slowdown_enabled=0<0,1,1>-Dynamic slowdown enabled
slider13:retrigger_enabled=0<0,1,1>-Retrigger enabled
slider14:reverse_enabled=0<0,1,1>-Reverse enabled
slider15:gate_enabled=0<0,1,1>-Gate enabled
slider16:filter_enabled=0<0,1,1>-Filter enabled
slider17:reverb_enabled=0<0,1,1>-Reverb enabled
slider18:degrade_enabled=0<0,1,1>-Degrade enabled
slider19:tapestop_enabled=0<0,1,1>-Tapestop enabled
slider20:karplus_enabled=0<0,1,1>-Karplus enabled
slider21:pitch_shifter_enabled=0<0,1,1>-Pitch shifter enabled

slider22:dummy=0<0,1,1>-Dummy
slider23:dummy=0<0,1,1>-Dummy
slider24:dummy=0<0,1,1>-Dummy

slider25:filter_type=1<0,17,1{Linear,MS-20,Linear x2,Moog,Ladder,303,MS-20 asym,DblRes,DualPeak,TriplePeak,svf nl 2p,svf nl 4p,svf nl 2p inc,svf nl 4p inc,rectified resonance,Steiner,SteinerA}>-Filter type
slider26:drive=0<-6,48,1>-Filter Drive (dB)
slider27:cutoff_start=.6<0,1,.0001>-Cutoff Start
slider28:cutoff_final=.6<0,1,.0001>-Cutoff Finish
slider29:resonance=0.7<0,1,.0001>-Resonance
slider30:morph=0<0,1,.0001>-Morph
slider31:cutoff_atk=0<0,1,0.0001>-Envelope Rise
slider32:cutoff_decay=0<0,1,0.0001>-Envelope Decay
slider33:cutoff_sustain=0<0,1,0.0001>-Envelope Sustain
slider34:pitch_shifter_pitch=0<-24,24,.0001>-Pitch Shift

slider63:inertia=60<0,200,.001>-Filter Inertia [ms]
slider64:midi_note_pattern_select=96<0,127,1>-First Pattern

options:maxmem=24000000
in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import saike_seqs_midilib.jsfx-inc
import saike_seqs_delays.jsfx-inc
import saike_seqs_widgets.jsfx-inc
import saike_seqs_filters.jsfx-inc
import saike_seqs_envelope.jsfx-inc
import saike_seqs_interpolators.jsfx-inc
import saike_seqs_pitchlib.jsfx-inc

@init
CURRENT_VERSION = 1;
version = CURRENT_VERSION;

log10d20_conversion  = 0.11512925464970228420089957273422;

sample_clock = 0;
oversampling = 1;
pattern_change = 1;
current_sample = 0;
n_segments = 32;
max_segments = 64;
max_effects = 32;
max_stored_patterns = 64;
crossfade_samples = 128;

function init_knob(sc, minimum, idx, def)
instance(scale, min_value, slider_idx, default, value)
global(loaded)
(
  scale = sc;
  min_value = minimum;
  default = def;
  slider_idx = idx;
  
  // First time load (from reset perhaps?) override all the values
  loaded == 0 ? (
    slider_idx > 0 ? (
      slider(slider_idx) = default;
    );
    
    value = (default - min_value) / scale;
  );
);

function set_value(new_value)
instance(value, scale, min_value)
global()
local()
(
  value = (new_value - min_value) / scale;
);

function knob_read_value()
global()
instance(value, scale, min_value, slider_idx)
local()
(
  value = (slider(slider_idx) - min_value) / scale;
);

function serialize_knob()
instance(value, mod1, mod2, vel, default, min_value, scale)
local()
global(writing)
(
  !writing ? (
    value = (default - min_value) / scale;
    vel = 0;
    mod1 = 0;
    mod2 = 0;
  );
  file_var(0, value);
  file_var(0, vel);
  file_var(0, mod1);
  file_var(0, mod2);
);

DB_SLIDER = 1;
FREQ_SLIDER = 2;
NORMALIZED_SLIDER = 3;
ATTACK_SLIDER = 4;
DECAY_SLIDER = 5;
SCALED_SLIDER = 6;
PITCH_SLIDER = 7;
ROUNDED_PITCH_SLIDER = 8;
CUSTOM_SLIDER = 9;

function knob_set_display(type, in_active)
instance(label, active, value, scale, min_value)
local(center)
global(srate, tempo_sync_envelopes, getFastEnvelopeLabel,
       DB_SLIDER,
       FREQ_SLIDER,
       NORMALIZED_SLIDER,
       ATTACK_SLIDER,
       DECAY_SLIDER,
       OFF_SLIDER
       SCALED_SLIDER,
       PITCH_SLIDER
       ROUNDED_PITCH_SLIDER,
       CUSTOM_SLIDER)
(
  // Type of slider
  type == DB_SLIDER ? (
    // dB
    label = sprintf(1, "%.1f dB", value * scale + min_value);
  ) : ( type == FREQ_SLIDER ) ? (
    // Frequency slider
    center = .5 * srate * exp( (1 - value) * log(20/22050) );
    label = center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000)
  ) : ( type == NORMALIZED_SLIDER ) ? (
    label = sprintf(1, "%.1f", value)
  ) : ( type == ATTACK_SLIDER ) ? (
    label = tempo_sync_envelopes ? ( 
      getFastEnvelopeLabel(value)
    ) : ( 
      (value > .5) ? sprintf(1, "%d ms", (3 * 10^(2*value))) : sprintf(1, "%.1f ms", (3 * 10^(2*value)))
    );
  ) : ( type == DECAY_SLIDER ) ?
  (
    label = tempo_sync_envelopes ? ( 
      getFastEnvelopeLabel(value)
    ) : ( 
      (value > .5) ? sprintf(1, "%d ms", (30 * 10^(2*value))) : sprintf(1, "%.1f ms", (30 * 10^(2*value)))
    )
  ) : ( type == SCALED_SLIDER ) ? (
    label = sprintf(1, "%.1f", scale * value + min_value);
  ) : ( type == ROUNDED_PITCH_SLIDER ) ? (
    label = sprintf(1, "%.2f st", floor(scale * value + min_value));
  ) : ( type == PITCH_SLIDER ) ? (
    label = sprintf(1, "%.2f st", scale * value + min_value);
  ) : (
    // Unknown labels get forwarded (for now)
    label = type;
  );
  
  active = in_active;
);

function getCurrentValue()
instance(scale, min_value, value, mod1, mod2, modulator)
global(modulator1_target, modulator2_target)
local()
(
  (value + modulator1_target * mod1 + modulator2_target * mod2) * scale + min_value
);

function update_current_levels()
(
  current_drive = driveKnob.getCurrentValue();
  current_cutoff_start = cutoffKnob.getCurrentValue();
  current_cutoff_final = cutoffEndKnob.getCurrentValue();
  current_resonance = resonanceKnob.getCurrentValue();
  current_morph = morphKnob.getCurrentValue();
  current_cutoff_atk = cutoffAttackKnob.getCurrentValue();
  current_cutoff_decay = cutoffDecayKnob.getCurrentValue();
  current_cutoff_sustain = cutoffSustainKnob.getCurrentValue();

  current_gate_start = gateStart.getCurrentValue();
  current_gate_stop = gateEnd.getCurrentValue();
  current_gate_atk = gateAttackKnob.getCurrentValue();
  current_gate_decay = gateDecayKnob.getCurrentValue();
  current_gate_sustain = gateSustainKnob.getCurrentValue();
  
  current_verb_diffusion = verbDiffusionKnob.getCurrentValue();
  current_verb_decay = verbDecayKnob.getCurrentValue();
  current_verb_mod_depth = verbModDepthKnob.getCurrentValue();
  current_verb_mod_rate = verbModRateKnob.getCurrentValue();
  current_verb_lowpass = verbLowPassKnob.getCurrentValue();
  current_verb_highpass = verbHighPassKnob.getCurrentValue();
  current_verb_dry = verbDry.getCurrentValue();
  current_verb_wet = verbWet.getCurrentValue();
  current_verb_gate_atk = verbGateAttackKnob.getCurrentValue();
  current_verb_gate_decay = verbGateDecayKnob.getCurrentValue();
  current_verb_gate_sustain = verbGateSustainKnob.getCurrentValue();
  
  current_bitrate = bitrateKnob.getCurrentValue();
  current_samplerate = samplerateKnob.getCurrentValue();
  current_saturate = satKnob.getCurrentValue();
  
  current_tapestop_decay = tapestopSpeedKnob.getCurrentValue();
  
  current_karplus_pitch = karplusPitchKnob.getCurrentValue();
  current_karplus_feedback = karplusFeedback.getCurrentValue();
  current_karplus_cutoff = karplusCutoffKnob.getCurrentValue();
  current_karplus_dry = karplusDry.getCurrentValue();
  current_karplus_wet = karplusWet.getCurrentValue();
  
  current_pitch_shifter_pitch = shifterPitchKnob.getCurrentValue();
  current_shifter_dry = shifterDry.getCurrentValue();
  current_shifter_wet = shifterWet.getCurrentValue();
);

function init_controls()
(
  driveKnob.init_knob(54, -6, 26, 0);
  cutoffKnob.init_knob(1, 0, 27, 0.6);
  cutoffEndKnob.init_knob(1, 0, 28, 0.6);
  resonanceKnob.init_knob(1, 0, 29, 0.7);
  morphKnob.init_knob(1, 0, 30, 0);
  cutoffAttackKnob.init_knob(1, 0, 31, 0);
  cutoffDecayKnob.init_knob(1, 0, 32, 0.6);
  cutoffSustainKnob.init_knob(1, 0, 33, 0.2);
  
  gateStart.init_knob(96, -48, 0, -12);
  gateEnd.init_knob(96, -48, 0, 0);
  gateAttackKnob.init_knob(1, 0, 0, 0.06);
  gateDecayKnob.init_knob(1, 0, 0, 0.6);
  gateSustainKnob.init_knob(1, 0, 0, 1.0);
  
  verbDiffusionKnob.init_knob(1, 0, 0, 0.7);
  verbDecayKnob.init_knob(1, 0, 0, 0.4);
  verbModDepthKnob.init_knob(1, 0, 0, 0.0);
  verbModRateKnob.init_knob(1, 0, 0, 0.5);
  verbLowPassKnob.init_knob(1, 0, 0, 1.0);
  verbHighPassKnob.init_knob(1, 0, 0, 0.3);
  verbDry.init_knob(64, -64, 0, 0);
  verbWet.init_knob(64, -64, 0, -8);
  verbGateAttackKnob.init_knob(1, 0, 0, 0.06);
  verbGateDecayKnob.init_knob(1, 0, 0, 0.6);
  verbGateSustainKnob.init_knob(1, 0, 0, 0.2);
  
  min_degrade = 3;
  bitrateKnob.init_knob(21, 3, 0, 16);
  samplerateKnob.init_knob(1, 0, 0, 1.0);
  satKnob.init_knob(54, -6, 0, -6);
  
  tapestopSpeedKnob.init_knob(1, 0, 0, 0.6);
  
  karplusPitchKnob.init_knob(1, 0, 0, 0.667);
  karplusFeedback.init_knob(1, 0, 0, 0.15);
  karplusCutoffKnob.init_knob(1, 0, 0, 0.7);
  karplusDry.init_knob(96, -48, 0, -48.0);
  karplusWet.init_knob(96, -48, 0, 0.0);
  
  shifterPitchKnob.init_knob(48, -24, 34, 0);
  shifterDry.init_knob(64, -64, 0, -64);
  shifterWet.init_knob(64, -64, 0, 0);
  
  update_current_levels();
);

init_controls();
loaded = 1;

function identify_note(midi_pitch)
local(octave, note, note_label)
global(CUSTOM_SLIDER)
(
  octave = floor((midi_pitch - 12) / 12);
  note = (midi_pitch - 21) % 12;
  note_label = note < 1 ? "A-" : note < 2 ? "A#" : note < 3 ? "B-" : note < 4 ? "C-" : note < 5 ? "C#" : note < 6 ? "D-" : note < 7 ? "D#" : note < 8 ? "E-" : note < 9 ? "F-" : note < 10 ? "F#" : note < 11 ? "G-" : "G#";
  sprintf(CUSTOM_SLIDER, "%s%d", note_label, octave)
);

function init_playhead()
(
  current_playhead = 0;
  amp0 = 1;
  amp1 = 0;
);

function pattern_update()
(
  current_pattern = pattern_buffer + current_pattern_index * pattern_size;
  reset_values = current_pattern;
  speed_values = current_pattern + max_segments;
  dynspeed_values = current_pattern + 2 * max_segments;
  retrig_values = current_pattern + 3 * max_segments;
  filt_values = current_pattern + 4 * max_segments;
  reverse_values = current_pattern + 5 * max_segments;
  gate_values = current_pattern + 6 * max_segments;
  reverb_values = current_pattern + 7 * max_segments;
  degrade_values = current_pattern + 8 * max_segments;
  tapestop_values = current_pattern + 9 * max_segments;
  karplus_values = current_pattern + 10 * max_segments;
  pitch_shifter_values = current_pattern + 11 * max_segments;
  
  modulator1_values = current_pattern + 30 * max_segments;
  modulator2_values = current_pattern + 31 * max_segments;
  
  reset_values[0] = 1;
);

function copy_pattern()
(
  memcpy(copy_buffer, pattern_buffer + current_pattern_index * pattern_size, pattern_size);
);

function paste_pattern()
(
  memcpy(pattern_buffer + current_pattern_index * pattern_size, copy_buffer, pattern_size);
);

/*
function interpolator_init()
(
  // Set up the interpolators
  drive_interpolator.interpolator_init(26);
  cutoff_start_interpolator.interpolator_init(27);
  cutoff_final_interpolator.interpolator_init(28);
  reso_interpolator.interpolator_init(29);
  morph_interpolator.interpolator_init(30);
     
  (last_inertia != inertia) ? (
    last_inertia = inertia;
    inertia_cutoff = 1000.0/inertia;
    drive_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_start_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_final_interpolator.initialize_smoother(inertia_cutoff);
    reso_interpolator.initialize_smoother(inertia_cutoff);
    morph_interpolator.initialize_smoother(inertia_cutoff);
    
    drive_interpolator.s = slider(26);
    cutoff_start_interpolator.s = slider(27);
    cutoff_final_interpolator.s = slider(28);
    reso_interpolator.s = slider(29);
    morph_interpolator.s = slider(30);
  );
);

function interpolators_block()
(
  drive_interpolator.interpolator_block();
  cutoff_start_interpolator.interpolator_block();
  cutoff_final_interpolator.interpolator_block();
  reso_interpolator.interpolator_block();
  morph_interpolator.interpolator_block();
);
*/

function init_allpass(buffer, buffer_size)
instance(buffer)
(
  this.initBuffer(buffer, buffer + buffer_size);
  buffer + buffer_size + 1
);

function eval_allpass(x)
local(ap_sample, delayed_sample)
instance(gain, offset)
(
  delayed_sample = this.readBuffer_fixed(offset);
  ap_sample = x + gain * delayed_sample;
  y = delayed_sample - gain * ap_sample;

  this.writeBuffer(ap_sample);
  
  y
);

function eval_tpt_monopole(x)
instance(s, coeff)
global()
local(y, v)
(
  v = coeff*(x - s);
  y = v + s;
  s = y + v;
  y
);
  
function init_tpt_monopole(cutoff)
instance(coeff)
global(srate)
local(g)
( 
  g = tan($pi*cutoff/srate);
  coeff = g/(1+g);
);

function init_reverb(buffer_position)
global(srate)
local(buffer_size)
instance(diffuser1, diffuser2, diffuser3, diffuser4,
         lfo_diffuser_left, lfo_diffuser_right
         decay_diffuser_left, decay_diffuser_right,
         delay_left_1, delay_right_1,
         delay_left_2, delay_right_2,
         delay_right_2_offset, delay_left_2_offset, 
         delay_left_1_offset, delay_right_1_offset, 
         delay_left_2_offset, delay_right_2_offset,
         srate_scaling,
         out_delay1_left, out_delay2_left, out_delay3_left, out_delay4_left, out_delay5_left, out_delay6_left, out_delay7_left,
         out_delay1_right, out_delay2_right, out_delay3_right, out_delay4_right, out_delay5_right, out_delay6_right, out_delay7_right)
(
  // Datorro Reverb (1997)
  buffer_size = 8192;
  srate_scaling = srate / 29761;
  
  buffer_position = diffuser1.init_allpass(buffer_position, buffer_size);
  diffuser1.offset = 142 * srate_scaling;
  buffer_position = diffuser2.init_allpass(buffer_position, buffer_size);
  diffuser2.offset = 107 * srate_scaling;
  buffer_position = diffuser3.init_allpass(buffer_position, buffer_size);
  diffuser3.offset = 379 * srate_scaling;
  buffer_position = diffuser4.init_allpass(buffer_position, buffer_size);
  diffuser4.offset = 277 * srate_scaling;
  
  buffer_position = lfo_diffuser_left.init_allpass(buffer_position, buffer_size);
  lfo_diffuser_left.offset = 672 * srate_scaling;
  buffer_position = lfo_diffuser_right.init_allpass(buffer_position, buffer_size);
  lfo_diffuser_right.offset = 908 * srate_scaling;
  
  buffer_position = decay_diffuser_left.init_allpass(buffer_position, buffer_size);
  decay_diffuser_left.offset = 1800 * srate_scaling;
  buffer_position = decay_diffuser_right.init_allpass(buffer_position, buffer_size);
  decay_diffuser_right.offset = 2656 * srate_scaling;
  
  buffer_position = delay_left_1.init_allpass(buffer_position, buffer_size);
  buffer_position = delay_right_1.init_allpass(buffer_position, buffer_size);
  buffer_position = delay_left_2.init_allpass(buffer_position, buffer_size);
  buffer_position = delay_right_2.init_allpass(buffer_position, buffer_size);
  
  delay_right_2_offset = 3163 * srate_scaling;
  delay_left_2_offset = 3720 * srate_scaling;
  delay_left_1_offset = 4453 * srate_scaling;
  delay_right_1_offset = 4217 * srate_scaling;
  delay_left_2_offset = 3720 * srate_scaling;
  delay_right_2_offset = 3163 * srate_scaling;
  
  out_delay1_left = 266 * srate_scaling;
  out_delay2_left = 2974 * srate_scaling;
  out_delay3_left = 1913 * srate_scaling;
  out_delay4_left = 1996 * srate_scaling;
  out_delay5_left = 1990 * srate_scaling;
  out_delay6_left = 187 * srate_scaling;
  out_delay7_left = 1066 * srate_scaling;
  
  out_delay1_right = 353 * srate_scaling;
  out_delay2_right = 3627 * srate_scaling;
  out_delay3_right = 1228 * srate_scaling;
  out_delay4_right = 2673 * srate_scaling;
  out_delay5_right = 2111 * srate_scaling;
  out_delay6_right = 335 * srate_scaling;
  out_delay7_right = 121 * srate_scaling;  
  
  buffer_position
);

function update_reverb_settings(diffusion, decay, depth, freq, lowpass, highpass)
instance(diffuser1, diffuser2, diffuser3, diffuser4,
         lfo_diffuser_left, lfo_diffuser_right,
         decay_diffuser_left, decay_diffuser_right, fb,
         mod_depth, mod_rate,
         lp1, hp1, lp2, hp2)
local()
global(srate)
(
  diffuser1.gain = - 0.98684211 * diffusion; /* Decorrelate input signal */
  diffuser2.gain = - 0.98684211 * diffusion; /* Decorrelate input signal */
  diffuser3.gain = - 0.82236842 * diffusion; /* Decorrelate input signal */
  diffuser4.gain = - 0.82236842 * diffusion; /* Decorrelate input signal */
  lfo_diffuser_left.gain = 0.92105263 * diffusion;  /* Tail density */
  lfo_diffuser_right.gain = 0.92105263 * diffusion;  /* Tail density */
  decay_diffuser_left.gain = - 0.65789474 * diffusion;  /* Decorrelate tank signal */
  decay_diffuser_right.gain = - 0.65789474 * diffusion;  /* Decorrelate tank signal */
  fb = decay;
  mod_depth = 32 * depth;
  mod_rate = freq / srate;
  
  lp1.init_tpt_monopole(0.5 * srate * exp( (1.0 - lowpass) * log(20/22050) ));
  lp2.coeff = lp1.coeff;
  hp1.init_tpt_monopole(0.5 * srate * exp( (1.0 - highpass) * log(20/22050) ));
  hp2.coeff = hp1.coeff;
);

function eval_reverb(l, r)
instance(diffuser1, diffuser2, diffuser3, diffuser4,
         lfo_diffuser_left, lfo_diffuser_right,
         decay_diffuser_left, decay_diffuser_right,
         delay_left_1, delay_right_1,
         delay_left_2, delay_right_2,
         delay_right_2_offset, delay_left_2_offset, 
         delay_left_1_offset, delay_right_1_offset, 
         delay_left_2_offset, delay_right_2_offset,
         fb, out_left, out_right, srate_scaling,
         out_delay1_left, out_delay2_left, out_delay3_left, out_delay4_left, out_delay5_left, out_delay6_left, out_delay7_left
         out_delay1_right, out_delay2_right, out_delay3_right, out_delay4_right, out_delay5_right, out_delay6_right, out_delay7_right,
         mod_rate, mod_depth,
         lp1, lp2, hp1, hp2)
local(in, diffused, left_tank, right_tank, l_delay, r_delay, accumulator)
global(sample_clock)
(
  in = 0.5 * (l + r);
  
  diffused = 
    diffuser4.eval_allpass(
      diffuser3.eval_allpass(
        diffuser2.eval_allpass(
          diffuser1.eval_allpass(
            in
          )
        )
      )
    );
  
  left_tank = right_tank = diffused;
  
  // Flipped on purpose!
  left_tank += fb * delay_right_2.readBuffer_fixed(delay_right_2_offset);
  right_tank += fb * delay_left_2.readBuffer_fixed(delay_left_2_offset);
  
  lfo_diffuser_left.offset = (672 + mod_depth * sin(mod_rate * sample_clock)) * srate_scaling;
  lfo_diffuser_right.offset = (908 + mod_depth * sin(mod_rate * sample_clock)) * srate_scaling;

  delay_left_1.writeBuffer(lfo_diffuser_left.eval_allpass(left_tank));
  delay_right_1.writeBuffer(lfo_diffuser_right.eval_allpass(right_tank));
  
  // Damping here
  l_delay = lp1.eval_tpt_monopole(delay_left_1.readBuffer_fixed(delay_left_1_offset));
  r_delay = lp2.eval_tpt_monopole(delay_right_1.readBuffer_fixed(delay_right_1_offset)) ;
  
  l_delay = decay_diffuser_left.eval_allpass(l_delay);
  r_delay = decay_diffuser_right.eval_allpass(r_delay);
  
  delay_left_2.writeBuffer(l_delay);
  delay_right_2.writeBuffer(r_delay);
  
  l_delay = delay_left_2.readBuffer_fixed(delay_left_2_offset);
  r_delay = delay_right_2.readBuffer_fixed(delay_right_2_offset);
  
  // Left output
  accumulator = 0.6 * delay_right_1.readBuffer_fixed(out_delay1_left);
  accumulator += 0.6 * delay_right_1.readBuffer_fixed(out_delay2_left);
  accumulator -= 0.6 * decay_diffuser_right.readBuffer_fixed(out_delay3_left);
  accumulator += 0.6 * delay_right_2.readBuffer_fixed(out_delay4_left);
  accumulator -= 0.6 * delay_left_1.readBuffer_fixed(out_delay5_left);
  accumulator -= 0.6 * decay_diffuser_left.readBuffer_fixed(out_delay6_left);
  out_left = accumulator - 0.6 * delay_left_2.readBuffer_fixed(out_delay7_left);

  accumulator = 0.6 * delay_left_1.readBuffer_fixed(out_delay1_right);
  accumulator += 0.6 * delay_left_1.readBuffer_fixed(out_delay2_right);
  accumulator -= 0.6 * decay_diffuser_left.readBuffer_fixed(out_delay3_right);
  accumulator += 0.6 * delay_left_2.readBuffer_fixed(out_delay4_right);
  accumulator -= 0.6 * delay_right_1.readBuffer_fixed(out_delay5_right);
  accumulator -= 0.6 * decay_diffuser_right.readBuffer_fixed(out_delay6_right);
  out_right = accumulator - 0.6 * delay_right_2.readBuffer_fixed(out_delay7_right);
  
  out_left = out_left - hp1.eval_tpt_monopole(out_left);
  out_right = out_right - hp2.eval_tpt_monopole(out_right);
);


freemem = 0;
pattern_size = max_segments * max_effects;
freemem = (pattern_buffer = freemem) + pattern_size * max_stored_patterns;
freemem = (copy_buffer = freemem) + pattern_size;
freemem = (midimem = freemem) + 32768;
freemem = (note_history = freemem) + 32768;
midi.initializeMIDI(midimem, note_history, 1, 1);
midi.notesOn = 0;

current_shifter_mode = -1;
pitch_block_size = 2*4096; /* We have 64 blocks of this */
freemem = (fftmem1 = freemem) + pitch_block_size;
freemem = (fftmem2 = freemem) + pitch_block_size;
freemem = (pitch_shift_buffer = freemem) + pitch_block_size;

function update_shifter()
global(current_shifter_mode, shifter.pitchShifter, shifter_mode,
       pitch_shift_buffer, shifter_buffer_size, fftmem1, fftmem2)
local(transition_region, shifter_buffer_size)
(
  current_shifter_mode != shifter_mode ? (
    current_shifter_mode = shifter_mode;
    transition_region = shifter_mode ? 1024 : 256;
    shifter_buffer_size = 4 * transition_region;
    shifter.pitchShifter(1, pitch_shift_buffer, shifter_buffer_size, fftmem1, fftmem2, transition_region, 1);
  );
);
update_shifter();

BUF_SIZE = 96000 * 60;
freemem = (l_buffer = freemem) + BUF_SIZE;
freemem = (r_buffer = freemem) + BUF_SIZE;
freemem = (beat_buffer = freemem) + .5 * BUF_SIZE;
freemem = (karplus_buffer_l = freemem) + .5 * BUF_SIZE;
freemem = (karplus_buffer_r = freemem) + .5 * BUF_SIZE;
l_buffer.initBuffer(l_buffer, l_buffer + BUF_SIZE);
r_buffer.initBuffer(r_buffer, r_buffer + BUF_SIZE);
beatmem.initBuffer(beat_buffer, beat_buffer + .5*BUF_SIZE);
l_karplus.initBuffer(karplus_buffer_l, karplus_buffer_l + .5*BUF_SIZE);
r_karplus.initBuffer(karplus_buffer_r, karplus_buffer_r + .5*BUF_SIZE);

freemem = verb.init_reverb(freemem);

interpolator_init();
pattern_update();
init_playhead();

@slider
  slidercalled += 1;
  driveKnob.knob_read_value();
  cutoffKnob.knob_read_value();
  cutoffEndKnob.knob_read_value();
  resonanceKnob.knob_read_value();
  morphKnob.knob_read_value();
  cutoffAttackKnob.knob_read_value();
  cutoffDecayKnob.knob_read_value();
  cutoffSustainKnob.knob_read_value();
  shifterPitchKnob.knob_read_value();

  current_drive = driveKnob.getCurrentValue();
  current_cutoff_start = cutoffKnob.getCurrentValue();
  current_cutoff_final = cutoffEndKnob.getCurrentValue();
  current_resonance = resonanceKnob.getCurrentValue();
  current_morph = morphKnob.getCurrentValue();
  current_cutoff_atk = cutoffAttackKnob.getCurrentValue();
  current_cutoff_decay = cutoffDecayKnob.getCurrentValue();
  current_cutoff_sustain = cutoffSustainKnob.getCurrentValue();
  current_pitch_shifter_pitch = shifterPitchKnob.getCurrentValue();

@block
midi.processMIDIBlock();
//interpolators_block();
pattern_update();
time_mode == 2 ? current_sample = beat_position * from_beat;

@serialize
writing = file_avail(0) < 0;
loaded = 1;
file_var(0, version);
file_mem(0, pattern_buffer, pattern_size * max_stored_patterns);
file_var(0, selected_details);

file_var(0, gate_enabled);

file_var(0, gate_start);
file_var(0, gate_stop);
file_var(0, gate_atk);
file_var(0, gate_decay);
file_var(0, gate_sustain);

file_var(0, verb_diffusion);
file_var(0, verb_decay);
file_var(0, verb_mod_depth);
file_var(0, verb_mod_rate);
file_var(0, verb_lowpass);
file_var(0, verb_highpass);
file_var(0, verb_dry);
file_var(0, verb_wet);
file_var(0, verb_gate_atk);
file_var(0, verb_gate_decay);
file_var(0, verb_gate_sustain);

file_var(0, time_mode);
file_var(0, tapestop_decay);
file_var(0, tempo_sync_envelopes);

file_var(0, karplus_feedback);
file_var(0, karplus_cutoff);
file_var(0, karplus_pitch);
file_var(0, karplus_wet);
file_var(0, karplus_dry);
file_var(0, snap_karplus);

file_mem(0, copy_buffer, pattern_size);

file_var(0, snap_shifter);
file_var(0, shifter_dry);
file_var(0, shifter_wet);

file_var(0, shifter_mode);

// Serialize all the parameters in one go. Note that due to version 1, we have to override some later because they are stored earlier.
driveKnob.serialize_knob(); 
cutoffKnob.serialize_knob();
cutoffEndKnob.serialize_knob();
resonanceKnob.serialize_knob();
morphKnob.serialize_knob();
cutoffAttackKnob.serialize_knob();
cutoffDecayKnob.serialize_knob();
cutoffSustainKnob.serialize_knob();
  
gateStart.serialize_knob();
gateEnd.serialize_knob();
gateAttackKnob.serialize_knob();
gateDecayKnob.serialize_knob();
gateSustainKnob.serialize_knob();
  
verbDiffusionKnob.serialize_knob();
verbDecayKnob.serialize_knob();
verbModDepthKnob.serialize_knob();
verbModRateKnob.serialize_knob();
verbLowPassKnob.serialize_knob();
verbHighPassKnob.serialize_knob();
verbDry.serialize_knob();
verbWet.serialize_knob();
verbGateAttackKnob.serialize_knob();
verbGateDecayKnob.serialize_knob();
verbGateSustainKnob.serialize_knob();
  
bitrateKnob.serialize_knob();
samplerateKnob.serialize_knob();
satKnob.serialize_knob();
  
tapestopSpeedKnob.serialize_knob();

karplusPitchKnob.serialize_knob();
karplusFeedback.serialize_knob();
karplusCutoffKnob.serialize_knob();
karplusDry.serialize_knob();
karplusWet.serialize_knob();
  
shifterPitchKnob.serialize_knob();
shifterDry.serialize_knob();
shifterWet.serialize_knob();

// Version 0 compatibility
version == 0 && !writing ? (
  driveKnob.set_value(drive);
  cutoffKnob.set_value(cutoff_start);
  cutoffEndKnob.set_value(cutoff_final);
  resonanceKnob.set_value(resonance);
  morphKnob.set_value(morph);
  cutoffAttackKnob.set_value(cutoff_atk);
  cutoffDecayKnob.set_value(cutoff_decay);
  cutoffSustainKnob.set_value(cutoff_sustain);
    
  gateStart.set_value(gate_start);
  gateEnd.set_value(gate_stop);
  gateAttackKnob.set_value(gate_atk);
  gateDecayKnob.set_value(gate_decay);
  gateSustainKnob.set_value(gate_sustain);
    
  verbDiffusionKnob.set_value(verb_diffusion);
  verbDecayKnob.set_value(verb_decay);
  verbModDepthKnob.set_value(verb_mod_depth);
  verbModRateKnob.set_value(verb_mod_rate);
  verbLowPassKnob.set_value(verb_lowpass);
  verbHighPassKnob.set_value(verb_highpass);
  verbDry.set_value(verb_dry);
  verbWet.set_value(verb_wet);
  verbGateAttackKnob.set_value(verb_gate_atk);
  verbGateDecayKnob.set_value(verb_gate_decay);
  verbGateSustainKnob.set_value(verb_gate_sustain);
    
  /*
  These were forgotten in v1 :o
  bitrateKnob.set_value();
  samplerateKnob.set_value();
  satKnob.set_value();*/
    
  tapestopSpeedKnob.set_value(tapestop_decay);
  
  karplusPitchKnob.set_value(karplus_pitch);
  karplusFeedback.set_value(karplus_feedback);
  karplusCutoffKnob.set_value(karplus_cutoff);
  karplusDry.set_value(karplus_dry);
  karplusWet.set_value(karplus_wet);
    
  shifterPitchKnob.set_value(pitch_shifter_pitch);
  shifterDry.set_value(shifter_dry);
  shifterWet.set_value(shifter_wet);
);

update_current_levels();
version = CURRENT_VERSION; // Update to current version


@sample
function calc_times_universal(atk, decay, sustain)
instance()
(
  tempo_sync_envelopes ? (
    this.calc_times_sync(atk, decay, sustain);
  ) : (
    this.calc_times(atk, decay, sustain);    
  );
);

sample_clock += 1;

function jump_to_target()
local()
global(current_playhead, playhead_0, playhead_1,
       target_position,
       x_fade_position, crossfade_samples, 
       too_fast, jumps)
(
  jumps += 1;

  // Initiate the crossfade
  x_fade_position != 0 ? too_fast = 100;
  x_fade_position = crossfade_samples;
  
  // Which playhead are we moving away from?
  current_playhead == 0 ? (
    playhead_1 = target_position + crossfade_samples;
  ) : (
    playhead_0 = target_position + crossfade_samples;
  );
  
  current_playhead = 1 - current_playhead;
);

function schedule_jump(offset)
local(already_set)
global()
instance(j1, j2, j3, j4, j5)
(
  already_set = (offset == j1) || (offset == j2) || (offset == j3) || (offset == j4) || (offset == j5);

  !already_set ? (
    (offset < j1) ? (
      j5 = j4;
      j4 = j3;
      j3 = j2;
      j2 = j1;
      j1 = offset;
    ) : (offset < j2) ? (
      j5 = j4;
      j4 = j3;
      j3 = j2;
      j2 = offset;
    ) : (offset < j3) ? (
      j5 = j4;
      j4 = j3;
      j3 = offset;
    ) : (offset < j4) ? (
      j5 = j4;
      j4 = offset;
    ) : ( j5 = offset );
  );
);

function reset_jump()
instance(j1, j2, j3, j4, j5, current)
(
  current = 0;
  j1 = j2 = j3 = j4 = j5 = 10000000000000000;
);

function eval_jump()
local()
global()
instance(j1, j2, j3, j4, j5, current)
(
  (j1 - current) == 0 ? (
    jump_to_target();
    j1 = j2;
    j2 = j3;
    j4 = j5;
    j5 = 0;
  );
  
  current += 1;
);

function update_time_info()
(
  samples_per_beat = (srate * 60) / tempo / current_speed;
  pattern_length = n_segments * samples_per_beat;
  to_index = n_segments / pattern_length;
  from_beat = 60 * srate / tempo;
);

function update_envelope_simple(target)
instance(k_rise, k_decay, env_attack_samples, tEnvelope, env, m_sustain)
global()
local()
(
  tEnvelope < 1 ? (
    // Rise until we're up
    env < 0.95 * target ? (
      env += k_rise * (target - env);
    ) : (
      tEnvelope = 1;
    );
  ) : (
   // Decay
   env += k_decay * (m_sustain * target - env);
  );
);

function process_filter()
local()
global(ssl, ssr,
       filter_envelope.update_envelope,
       filter_envelope.calc_times_universal,
       filter.init_filter,
       filter.processSample,
       sample_clock, filter_target,
       log10d20_conversion,
       
       current_drive, current_cutoff,
       
       // Controlled variables
       filter_type, current_morph, current_resonance,
       current_cutoff_start, current_cutoff_final,
       current_cutoff_atk, current_cutoff_decay, current_cutoff_sustain)
instance(preamp, inv_preamp)
(
  sample_clock % 16 == 0 ? (
    filter_envelope.calc_times_universal(current_cutoff_atk, current_cutoff_decay, current_cutoff_sustain);
  );
  
  current_cutoff = current_cutoff_start + filter_envelope.update_envelope(filter_target) * (current_cutoff_final - current_cutoff_start);
  sample_clock % 4 == 0 ? (
    filter.init_filter(filter_type, current_cutoff, current_cutoff, current_morph, current_morph, current_resonance);
    preamp      = exp(log10d20_conversion*current_drive);
    inv_preamp  = exp(-log10d20_conversion*current_drive);
  );
  
  ssl *= preamp;
  ssr *= preamp;
  filter.processSample(filter_type);
  ssl *= inv_preamp;
  ssr *= inv_preamp;
);

function process_gate()
(
  sample_clock % 16 == 0 ? (
    gate_envelope.calc_times_universal(current_gate_atk, current_gate_decay, current_gate_sustain);
  );
  
  current_gate = current_gate_start + gate_envelope.update_envelope(gate_target) * (current_gate_stop - current_gate_start);
  gatemul = exp(log10d20_conversion*current_gate);
  ssl *= gatemul;
  ssr *= gatemul;
);

function process_verb()
local()
global(ssl, ssr,
      verb_envelope.calc_times_universal, verb_envelope.update_envelope,
      
      log10d20_conversion, sample_clock, current_verb_gate,
      reverb_target,

      // User controlled
      post_gate,
      current_verb_diffusion, current_verb_decay, current_verb_mod_depth, current_verb_mod_rate, current_verb_lowpass, current_verb_highpass,
      current_verb_gate_atk, current_verb_gate_decay, current_verb_gate_sustain,
      current_verb_dry, current_verb_wet,
      )
instance(verb_drymul, verb_wetmul)
(
  sample_clock % 16 == 0 ? (
    this.update_reverb_settings(current_verb_diffusion, current_verb_decay, current_verb_mod_depth, current_verb_mod_rate, current_verb_lowpass, current_verb_highpass);
    verb_envelope.calc_times_universal(current_verb_gate_atk, current_verb_gate_decay, current_verb_gate_sustain);
    verb_drymul = exp(log10d20_conversion*current_verb_dry);
    verb_wetmul = exp(log10d20_conversion*current_verb_wet);
    
    post_gate ? verb_wetmul * current_verb_gate;
  );
  
  current_verb_gate = verb_envelope.update_envelope(reverb_target);

  this.eval_reverb(ssl * current_verb_gate, ssr * current_verb_gate);
  ssl = verb_drymul * ssl + verb_wetmul * this.out_left;
  ssr = verb_drymul * ssr + verb_wetmul * this.out_right;
);

function process_karplus()
instance(coeff, ls, rs, karplus_offset, fb, shift, fb_current, cutoff_current, current_wet_gain, current_dry_gain)
local(g, kpr, kpl, lk, rk, v, y, omega, omega_fundamental, max_fb
      midi_pitch, current_pitch)
global(l_karplus, r_karplus,
       l_karplus.readBuffer, r_karplus.readBuffer,
       l_karplus.writeBuffer, r_karplus.writeBuffer,
       current_karplus_feedback, current_karplus_pitch, current_karplus_cutoff,
       current_karplus_wet, current_karplus_dry, log10d20_conversion,
       srate,
       sample_clock,
       ssl, ssr, igain,
       snap_karplus,
       karplus_target
       )
(
  sample_clock % 16 == 0 ? (
    midi_pitch = 45 + 36 * current_karplus_pitch;
    snap_karplus ? midi_pitch = floor(midi_pitch);
    current_pitch = 440 * 2^((midi_pitch - 69)/12);
    
    karplus_offset = srate / current_pitch;
    cutoff_current = 0.98 * cutoff_current + 0.02 * current_karplus_cutoff;
    omega = .99999 * $pi * exp((1.0 - cutoff_current) * log(20/22050));
    g = tan(0.5 * omega);
    coeff = g / (1.0 + g);

    current_wet_gain = 0.9 * current_wet_gain + 0.1 * (karplus_target ? exp(log10d20_conversion * current_karplus_wet) : 0);
    current_dry_gain = 0.9 * current_dry_gain + 0.1 * (karplus_target ? exp(log10d20_conversion * current_karplus_dry) : 1);
    
    max_fb = 0.98;
    fb = 2.0 * max_fb * current_karplus_feedback - max_fb;
    fb = sign(fb) * sqrt(abs(fb));
    
    fb_current = 0.996 * fb_current + 0.004 * fb;
    igain = 2.0 * sqrt(1.0 - abs(fb_current));
    
    // We need to correct for the phase shift incurred due to our lowpass filter
    // otherwise our karplus will detune as we sweep the cutoff.
    omega_fundamental = 2.0 * $pi * current_pitch / srate;
    
    // Phase shift in radians.
    shift = atan(omega_fundamental / omega);
    
    // Convert back to samples for the fundamental.
    shift = - shift / omega_fundamental;
  );
  
  lk = l_karplus.readBuffer(karplus_offset - 2 + shift);
  rk = r_karplus.readBuffer(karplus_offset - 2 + shift);

  v = coeff*(lk - ls);
  y = v + ls;
  ls = y + v;
  lk = y;

  v = coeff*(rk - rs);
  y = v + rs;
  rs = y + v;
  rk = y;

  kpl = fb_current * lk;
  kpr = fb_current * rk;

  l_karplus.writeBuffer(ssl * current_wet_gain + kpl);
  r_karplus.writeBuffer(ssr * current_wet_gain + kpr);
  
  kpl *= igain;
  kpr *= igain;
  
  ssl = ssl * current_dry_gain + kpl;
  ssr = ssr * current_dry_gain + kpr;
);


function interp(x0, frac)
instance(x1, x2, x3)
local(id0, id1, id2, id3)
global()
(
  id0 = x1;
  id1 = 0.5*(x2 - x0);
  id2 = x0 - 2.5*x1 + 2*x2 - 0.5*x3;
  id3 = 0.5*(x3 - x0) + 1.5 * (x1 - x2);
  
  x3 = x2;
  x2 = x1;
  x1 = x0;
  
  ((id3*frac+id2)*frac+id1)*frac+id0
);

function hist(x0)
instance(x1, x2, x3)
local()
global()
(
  x3 = x2;
  x2 = x1;
  x1 = x0;
);

function process_degrade()
instance(factor,
         ib_factor, b_factor,
         cpos, degrade_pos,
         from_l, from_r, to_l, to_r,
         l_hist, r_hist, preamp)
local(target)
global(sample_clock, ssl, ssr, current_bitrate, current_samplerate, srate, degrade_target, current_saturate, log10d20_conversion)
(
  sample_clock % 16 == 0 ? (
    b_factor = 2^(current_bitrate - 1);
    ib_factor = 1/b_factor;
    
    target = srate * exp( (1-current_samplerate) * log(1000/44100) );
    factor = (srate / target);
  );
  
  degrade_pos += 1;
  
  degrade_target ? (
    ssl = ib_factor * floor(ssl * b_factor);
    ssr = ib_factor * floor(ssr * b_factor);
    
    // "S&H"
    degrade_pos > factor ? (
      while(
        degrade_pos -= factor;
        cpos > factor
      );
      
      from_l = to_l;
      from_r = to_r;
      to_l = l_hist.interp(ssl, cpos);
      to_r = r_hist.interp(ssr, cpos);
    ) : (
      l_hist.hist(ssl);
      r_hist.hist(ssr);
    );
    
    ssl = to_l;
    ssr = to_r;
    
    current_saturate > -6 ? (
      preamp = exp(log10d20_conversion*current_saturate);
      ssl = tanh(preamp*ssl)/preamp;
      ssr = tanh(preamp*ssr)/preamp;
    );
  );
);

function process_pitch_shifter()
local()
global(pitch_shifter_target,
       shifter.setPitchShifterSpeed,
       shifter.pitchShifterUpdate,
       shifter.outL, shifter.outR,
       sample_clock, shift_pitch,
       ssl, ssr,
       snap_shifter,
       update_shifter,

       current_pitch_shifter_pitch,
       current_shifter_dry, current_shifter_wet,
       log10d20_conversion)
instance(dry, wet)
(
  pitch_shifter_target ? (
    sample_clock % 4 == 0 ? (
      update_shifter();
      shift_pitch = (snap_shifter ? floor(current_pitch_shifter_pitch) : current_pitch_shifter_pitch) / 12;
      shifter.setPitchShifterSpeed(2*((2^(shift_pitch))-1.0));
      
      dry = exp(log10d20_conversion*current_shifter_dry);
      wet = exp(log10d20_conversion*current_shifter_wet);
    );
    
    shifter.pitchShifterUpdate(ssl, ssr);
    ssl = ssl * dry + shifter.outL * wet;
    ssr = ssr * dry + shifter.outR * wet;
  );
);

mmsg = midi.processMIDISample();
mmsg ? (
  // Are we recording a new reference note?
  (midi_rec_toggle.value == 1) ? (
    
    midi_rec_toggle.value = 0;
    midi_note_pattern_select = midi.lastNote;
  ) : (
    midi.lastNote >= midi_note_pattern_select ? (
      current_pattern_index = midi.lastNote - midi_note_pattern_select;
      slider_automate(current_pattern_index);
    );
    
    mmsg == 1 ? (
      current_sample = 0;
      reset_sample = 0;
    );
  );
);

update_time_info();
target_position += 1; /* Target position moves with the track */

current_sample += 1;
current_sample > pattern_length ? 
(
  while(
    current_sample -= pattern_length;
    current_sample > pattern_length
  );
);
sequencer_index = floor(to_index * current_sample);

reset_sample = current_sample + crossfade_samples;
reset_sample > pattern_length ? reset_sample -= pattern_length;
reset_index = floor(to_index * reset_sample);

// SEQUENCER HANDLING
function seek_next(position, continue_until, max_value)
local(idx)
global(chunk_duration_b)
(
  idx = 0;
  while(
    idx += 1;
    position += 1;
    (idx < max_value) && (position[] == continue_until)
  );
  
  idx
);


// Delayed sequences to accomodate for crossfades
(reset_index != last_reset_index) ? (
  reset_enabled ? (
    reset = abs(reset_values[reset_index]);
    reset > 0 ? (
      // New target position is now
      target_position = 0;
      jump_schedule.reset_jump();
      jump_schedule.schedule_jump(0);
    );
  );
  
  retrigger_enabled ? (
    // If positive, seek to last negative with the same value.
    retrig = retrig_values[reset_index];
    
    retrig > 0 ? (
      jump_schedule.reset_jump();
      chunk_duration = seek_next(retrig_values + reset_index, -retrig, 64);
      block_len = samples_per_beat * chunk_duration;
    );
    
    retrig == 1 ? ( jump_schedule.schedule_jump(); )
    : (retrig == 2) ? ( jump_schedule.schedule_jump(); jump_schedule.schedule_jump(floor(0.5 * block_len)); )
    : (retrig == 3) ? ( jump_schedule.jump_to_target(); jump_schedule.schedule_jump(floor(0.33333 * block_len)); jump_schedule.schedule_jump(floor(0.66666 * block_len)); )
    : (retrig == 4) ? ( jump_schedule.jump_to_target(); jump_schedule.schedule_jump(floor(0.25 * block_len)); jump_schedule.schedule_jump(floor(0.5 * block_len));  jump_schedule.schedule_jump(floor(0.75 * block_len)); )
  );
);

jump_schedule.eval_jump();

// Non delayed sequences
(sequencer_index != last_sequencer_index) ? (
  
  slowdown_enabled ? (
    speed = abs(speed_values[sequencer_index]);
    
    // Fractional speed
    speed = (speed == 0) ? 1.0
    : (speed == 1) ? 0.75
    : (speed == 2) ? 0.66
    : (speed == 3) ? 0.5
    : (speed == 4) ? 0.25
  ) : ( speed = 1 );
  
  // Reverse it?
  (reverse_enabled && abs(reverse_values[sequencer_index]) == 1) ? speed = -speed;
  
  // Calculate the actual offset speed.
  // This is given by - (relative_speed - speed of incoming audio)
  // Speed of the incoming audio is 1 sample / sample.
  speed = 1.0 - speed;
  
  previous_filter_target = filter_target;
  filter_target = filt_values[sequencer_index];
  filter_target == 1 ? (
    filter_envelope.reset = 0;
    filter_envelope.reset_envelope();
  );
  filter_target = abs(filter_target);
  
  gate_target = gate_values[sequencer_index];
  gate_target == 1 ? (
    gate_envelope.reset = 0;
    gate_envelope.reset_envelope();
  );
  gate_target = abs(gate_target);
  
  reverb_target = reverb_values[sequencer_index];
  reverb_target == 1 ? (
    verb_envelope.reset = 0;
    verb_envelope.reset_envelope();
  );
  reverb_target = abs(reverb_target);
  
  degrade_target = abs(degrade_values[sequencer_index]);
  
  tapestop_target = tapestop_enabled ? tapestop_values[sequencer_index] : 0;
  tapestop_target == 1 ? (
    tapestop_envelope.calc_times_universal(current_tapestop_decay, current_tapestop_decay, 0);
    stop_factor = 1;
    t_stop = 0;
    t_stop_length = tapestop_envelope.env_attack_samples;
  );
  tapestop_target = abs(tapestop_target);
  
  karplus_target = abs(karplus_values[sequencer_index]);
  pitch_shifter_target = abs(pitch_shifter_values[sequencer_index]);
  
  dyn_speed = speed;
  
  modulator1_target = modulator1_values[sequencer_index];
  modulator2_target = modulator2_values[sequencer_index];
  update_current_levels();
);

tapestop_target ? (
  move_mode == 0 ? (
    stop_factor = (1.0 - tapestop_envelope.k_decay) * stop_factor;
    dyn_speed = 1.0 - (stop_factor * (1.0 - speed));
  ) : (
    stop_factor = stop_factor + tapestop_envelope.k_decay * ((t_stop > 10 * tapestop_envelope.env_attack_samples) - stop_factor);
    t_stop += 1.0;
    dyn_speed = 1.0 - (stop_factor * (1.0 - speed));
  );
);

last_sequencer_index = sequencer_index;
last_reset_index = reset_index;

l_buffer.writeBuffer(spl0);
r_buffer.writeBuffer(spl1);

// Reference playhead is where the playhead is sent after a "reset" by retrigger.
playhead_0 += dyn_speed;
playhead_1 += dyn_speed;

// Equal power fades (x^2 + y^2 = 1)
x_fade_position > 0 ? (
  // Which playhead are we moving _towards_
  current_playhead == 0 ? (
    amp1 = sqrt(x_fade_position / crossfade_samples);
    amp0 = sqrt(1.0 - amp1);
    x_fade_position -= 1;
  ) : (
    amp0 = sqrt(x_fade_position / crossfade_samples);
    amp1 = sqrt(1.0 - amp0);
    x_fade_position -= 1;
  );
);

ssl = amp0 * l_buffer.readBuffer(playhead_0) + amp1 * l_buffer.readBuffer(playhead_1);
ssr = amp0 * r_buffer.readBuffer(playhead_0) + amp1 * r_buffer.readBuffer(playhead_1);

pitch_shifter_enabled ? process_pitch_shifter();
degrade_enabled ? process_degrade();
filter_enabled ? filter.process_filter();
gate_enabled ? process_gate();
reverb_enabled ? verb.process_verb();
karplus_enabled ? karplus.process_karplus();

spl0 = ssl;
spl1 = ssr;

@gfx


function convert_tempos(target_sync_mode)
local()
instance()
global(converted, cutoff_atk, cutoff_decay, gate_atk, gate_decay, verb_gate_atk, verb_gate_decay, tapestop_decay)
(
  target_sync_mode ? (
    cutoff_atk = to_synced(cutoff_atk, 1.0);
    cutoff_decay = to_synced(cutoff_decay, 0.1);
    gate_atk = to_synced(gate_atk, 1.0);
    gate_decay = to_synced(gate_decay, 0.1);
    verb_gate_atk = to_synced(verb_gate_atk, 1.0);
    verb_gate_decay = to_synced(verb_gate_decay, 0.1);
    tapestop_decay = to_synced(tapestop_decay, 0.1);
  ) : (
    cutoff_atk = to_non_synced(cutoff_atk, 1.0);
    cutoff_decay = to_non_synced(cutoff_decay, 0.1);
    gate_atk = to_non_synced(gate_atk, 1.0);
    gate_decay = to_non_synced(gate_decay, 0.1);
    verb_gate_atk = to_non_synced(verb_gate_atk, 1.0);
    verb_gate_decay = to_non_synced(verb_gate_decay, 0.1);
    tapestop_decay = to_non_synced(tapestop_decay, 0.1);
  );
);

function draw_logo(x_origin, y_origin, dx, dy)
local(cx, cy, xs, ys)
global(q)
(
  q += .01;
  //q > 2.5 ? q = 2.5;
  
  xs = dx - 2;
  ys = dy - 2;
  cy = y_origin + 0 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.0088999644001424)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.005695977216091136)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.003203987184051264)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.001423994304022784)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.000355998576005696)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.10288358846564613)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.09113563545745818)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.0800996796012816)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06977572089711641)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06016375934496262)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.3645425418298327)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.3421146315414738)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.3203987184051264)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.2993948024207903)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.27910288358846563)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.598433606265575)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5695977216091136)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5414738341046635)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.514061943752225)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.48736205055179777)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 1 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.012815948736205056)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.1153435386258455)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.3876824492702029)); gfx_rect(cx, cy, xs, ys);cx += 4 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.2595229619081524)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.6279814880740477)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 2 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.017443930224279102)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.022783908864364544)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.028835884656461374)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.0355998576005696)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.04307582769668921)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.12851548593805626)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.1423994304022784)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.15699537201851194)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.17230331078675684)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.18832324670701317)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.4115343538625845)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.6279814880740477)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.24065503737985047)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.6582413670345318)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.6892132431470274)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.7208971164115343)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.7532929868280527)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.7864008543965824)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 3 * dy;
  cx = x_origin;
  cx += 4 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.051263794944820223)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.2050551797792809)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.43609825560697757)); gfx_rect(cx, cy, xs, ys);cx += 3 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.598433606265575)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.22249911000355999)); gfx_rect(cx, cy, xs, ys);cx += 6 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.8202207191171236)); gfx_rect(cx, cy, xs, ys);
  cy = y_origin + 4 * dy;
  cx = x_origin;
  gfx_set(0.4, 0.2, 0.8, (q-0.10288358846564613)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.09113563545745818)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.0800996796012816)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06977572089711641)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.06016375934496262)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.22249911000355999)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.24065503737985047)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.2595229619081524)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.27910288358846563)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.2993948024207903)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-0.461374154503382)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.48736205055179777)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.514061943752225)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5414738341046635)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.5695977216091136)); gfx_rect(cx, cy, xs, ys);cx += 2 * dx;gfx_set(0.4, 0.2, 0.8, (q-1.0)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.9626201495194019)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.9259522961908152)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.8899964400142399)); gfx_rect(cx, cy, xs, ys);cx += dx;gfx_set(0.4, 0.2, 0.8, (q-0.854752580989676)); gfx_rect(cx, cy, xs, ys);
);

function setup_theme()
(
  base_r = .1;
  base_g = .1;
  base_b = .1;
  
  BASE_FONT = 1;
  gfx_setfont(BASE_FONT, "Arial", 16);
  font_r = .8;
  font_g = .7;
  font_b = .8;
  
  BAND_FONT = 5;
  gfx_setfont(BAND_FONT, "Arial", floor(16 * (1+fontscaling)));
  
  KNOB_FONT = 6;
  gfx_setfont(KNOB_FONT, "Arial", floor(14 * (1+fontscaling)));
  
  KNOB_FONT2 = 7;
  gfx_setfont(KNOB_FONT2, "Arial", floor(13 * (1+fontscaling)));
  
  HINT_FONT = 8;
  gfx_setfont(HINT_FONT, "Arial", floor(13 * (1+fontscaling)));
  
  TOGGLE_FONT = 9;
  gfx_setfont(TOGGLE_FONT, "Arial", floor(13 * (1+fontscaling)));
  
  scaling = 0;
  style == 0 ? (
    s_FILTER = sprintf(65, "FILTER");
    s_ENVELOPE = sprintf(66, "ENVELOPE");
    s_GATE = sprintf(67, "VOLUME ENVELOPE");
    s_REVERB = sprintf(68, "REVERB");
    s_DEGRADE = sprintf(69, "DEGRADE");
    s_TAPESTOP = sprintf(70, "TAPE STOP");
    s_KARPLUS = sprintf(71, "PITCHED DELAY");
    s_PITCH = sprintf(72, "PITCH SHIFTER");
  ) : ( style == 1 ) ? (
    s_FILTER = sprintf(65, "Filter");
    s_ENVELOPE = sprintf(66, "Envelope");
    s_GATE = sprintf(67, "Volume Envelope");
    s_REVERB = sprintf(68, "Reverb");
    s_DEGRADE = sprintf(69, "Degrade");
    s_TAPESTOP = sprintf(70, "Tape Stop");
    s_KARPLUS = sprintf(71, "Pitched Delay");
    s_PITCH = sprintf(72, "Pitch Shifter");
  ) : ( style == 2 ) ? (
    s_FILTER = sprintf(65, "Filter");
    s_ENVELOPE = sprintf(66, "Envelope");
    s_GATE = sprintf(67, "Volume Envelope");
    s_REVERB = sprintf(68, "Reverb");
    s_DEGRADE = sprintf(69, "Degrade");
    s_TAPESTOP = sprintf(70, "Tape Stop");
    s_KARPLUS = sprintf(71, "Pitched Delay");
    s_PITCH = sprintf(72, "Pitch Shifter");
  );

  style == 0 ? (
    font_color_r = .7;
    font_color_g = .6;
    font_color_b = .8;
  ) : (
    font_color_r = .7;
    font_color_g = .7;
    font_color_b = .7;
  );
  dial_animation = 1;
  dial_position_color_r = 0.2;
  dial_position_color_g = 0.7;
  dial_position_color_b = 0.4;
  
  font_color_a = 1;
  knob_font_color_r = 0.9;
  knob_font_color_g = 0.9;
  knob_font_color_b = 0.8;
  knob_font_color_a = 1;
  edge_r = 39/255 * .5;
  edge_g = 39/255 * .5;
  edge_b = 41/255 * .5;
  edge_a = 1.0;
  
  edge_font_r = 0.9;
  edge_font_g = 0.9;
  edge_font_b = 0.8;
  
  widget_r = 35/255;
  widget_g = 155/255;
  widget_b = 30/255;
  widget_a = 1.0;
  toggle_r = .5;
  toggle_g = 1.6;
  toggle_b = .5;
  toggle_a = 1.0;
  
  fontscaling = scaling < -.15 ? scaling : 0;
);
setup_theme();
too_fast > 0 ? too_fast -= 1;

grid_origin_x = 5;
grid_origin_y = 5;
label_width = 150 * (1 + scaling);
block_width = 22.83 * (1 + scaling);
block_spacing = 1 * (1 + scaling);

function nice_rect_color(x, y, w, h, label, base_r, base_g, base_b, edge_r, edge_g, edge_b)
local(label, txt_w, txt_h)
global(font_r, font_g, font_b, gfx_x, gfx_y)
(
  gfx_set(base_r, base_g, base_b, 1.0);
  gfx_rect(x, y, w, h);
  
  gfx_set(edge_r, edge_g, edge_b, 1.0);
  gfx_line(x, y, x + w - 1, y);
  gfx_line(x, y, x, y + h - 1);
  gfx_line(x, y + h - 1, x + w - 1, y + h - 1);
  gfx_line(x + w - 1, y, x + w - 1, y + h - 1);
  
  label > 0 ? (
    gfx_measurestr(label, txt_w, txt_h);
    gfx_x = x - 0.5 * (txt_w - w);
    gfx_y = y - 0.5 * (txt_h - h);
    gfx_set(font_r, font_g, font_b, 1.0);
    gfx_printf(label);
  );
);

function nice_rect(x, y, w, h, value, powered, base_r, base_g, base_b)
global()
local(label, txt_w, txt_h, power_intensity, power_intensity, rr, gg, bb, er, eg, eb, p2, pv)
(
 power_intensity = (0.2 + 0.8 * powered);
  p2 = (1.5 + 0.25 * (value==0)) * power_intensity;
  er = base_r * p2;
  eg = base_g * p2;
  eb = base_b * p2;
  pv = power_intensity;
  rr = base_r * pv;
  gg = base_g * pv;
  bb = base_b * pv;
  this.nice_rect_color(x, y, w, h, value != 0 ? sprintf(1, "%d", value) : 0, rr, gg, bb, er, eg, eb);
);

function connecting_rect(x, y, w, h, value, powered, base_r, base_g, base_b)
local(pv, rr, gg, bb, er, eg, eb, p2, power_intensity)
global()
(
  power_intensity = (0.2 + 0.8 * powered);
  
  pv = power_intensity;
  rr = base_r * pv;
  gg = base_g * pv;
  bb = base_b * pv;
  gfx_set(rr, gg, bb, 1.0);
  gfx_rect(x, y, w, h, 1, 0);
  
  p2 = (1.5 + 0.25 * (value==0)) * power_intensity;
  er = base_r * p2;
  eg = base_g * p2;
  eb = base_b * p2;
  gfx_set(er, eg, eb, 1.0);
  gfx_line(x, y-1, x+w, y-1);
  gfx_line(x, y+h-1, x+w, y+h-1);
);

function power_button(x, y, w, h, powered)
global(base_r, base_g, base_b,
       font_r, font_g, font_b,
       gfx_x, gfx_y)
local(ww, hh)
(
  gfx_set(base_r, base_g, base_b, 1.0);
  gfx_rect(x, y, w, h);
  
  gfx_set(2 * base_r, 2 * base_g, 2 * base_b, 1.0);
  gfx_line(x, y, x + w - 1, y);
  gfx_line(x, y, x, y + h - 1);
  gfx_line(x, y + h - 1, x + w - 1, y + h - 1);
  gfx_line(x + w - 1, y, x + w - 1, y + h - 1);
  
  ww = floor(0.5 * w);
  hh = floor(0.5 * h);
  
  powered ? gfx_set(0.2, 0.7, 0.4, 1) : gfx_set(0, 0, 0, 1);
  gfx_circle(x + ww, y + hh, ww/2, 0, 1);
  gfx_circle(x + ww, y + hh, ww/2 + 0.5, 0, 1);
  gfx_line(x + ww, y + .95 * hh, x + ww, y + 0.25 * hh);
  gfx_line(x + ww + 1, y + .85 * hh, x + ww + 1, y + 0.25 * hh);
  gfx_line(x + ww - 1, y + .85 * hh, x + ww - 1, y + 0.25 * hh);
);

function select_colormap(rows)
local()
global(colormap_scaling)
(
  colormap_scaling = 4 / rows;
);

function set_row_color(idx)
local(n)
global(colormap_scaling,
       row_color_r, row_color_g, row_color_b
       panel_label_r, panel_label_g, panel_label_b,
       edge_r, edge_g, edge_b,
       dial_position_color_r, dial_position_color_g, dial_position_color_b,
       selection_button_r, selection_button_g, selection_button_b)
(
  n = colormap_scaling * idx;
  row_color_r = min(max(min(n-1.5,-n+4.5),0),1) * 0.4 + 0.1;
  row_color_g = min(max(min(n-0.5,-n+3.5),0),1) * 0.4 + 0.1;
  row_color_b = min(max(min(n+0.5,-n+2.5),0),1) * 0.4 + 0.1;
  
  panel_label_r = row_color_r;
  panel_label_g = row_color_g;
  panel_label_b = row_color_b;
  
  selection_button_r = edge_r = 0.15 * row_color_r;
  selection_button_g = edge_g = 0.15 * row_color_g;
  selection_button_b = edge_b = 0.15 * row_color_b;

  dial_position_color_r = 1.1 * row_color_r;
  dial_position_color_g = 1.1 * row_color_g;
  dial_position_color_b = 1.1 * row_color_b;
);

function process_effect_row(row_index, me, mem, x, y, label, max_value, power_slider, hint)
global(label_width, block_width, block_spacing, selected_details,
       nice_rect,
       n_segments,
       font_r, font_g, font_b,
       gfx_x, gfx_y,
       BASE_FONT
       mouse_cap, mouse_x, mouse_y, last_cap, captured_by,
       hinter.updateHintTime,
       retrig_toggle.value
       base_r, base_g, base_b,
       row_color_r, row_color_g, row_color_b, printed_value,
       selected_row)
local(txt_w, txt_h, ptr, idx, target, y_over, last, current, active_r, active_g, active_b)
instance(mem, start_idx)
(
  set_row_color(row_index);
  nice_rect(x, y, label_width - 1, block_width, 0, slider(power_slider), row_color_r * .8, row_color_g * .8, row_color_b * .8);
  ptr = mem;
  
  // Are we selected?
  (selected_details == me) ? (
    selected_row = row_index;
    gfx_set(1.0, 1.0, 1.0, 0.15 + 0.1 * sin(3*time_precise()));
    gfx_rect(x, y, label_width, block_width);
  );
  
  gfx_set(font_r, font_r, font_r, 1.0);
  gfx_setfont(BASE_FONT);
  gfx_measurestr(label, txt_w, txt_h);
  gfx_x = x - 0.5 * (txt_w - label_width);
  gfx_y = y - 0.5 * (txt_h - block_width);
  gfx_printf(label);
  
  // Move to the actual sequencer cols
  x += label_width - block_spacing;
  
  power_button(x, y, block_width, block_width, slider(power_slider));
  
  x += block_width + block_spacing;
  ptr = mem;
  target = 0;
  loop(n_segments,
    current = ptr[];
    abs(current) > 0 ? (
      active_r = row_color_r;
      active_g = row_color_g;
      active_b = row_color_b;
      printed_value = max_value > 1 && slider(power_slider) ? abs(current) : 0;
    ) : (
      active_r = base_r;
      active_g = base_g;
      active_b = base_b;
      printed_value = 0;
    );
    (abs(last) == abs(current)) && (current < 0) ? (
      nice_rect(x, y, block_width, block_width, printed_value, slider(power_slider), active_r, active_g, active_b);
      connecting_rect(x-2, y + 1, 4, block_width - 1, printed_value, slider(power_slider), active_r, active_g, active_b);
    ) : (
      nice_rect(x, y, block_width, block_width, printed_value, slider(power_slider), active_r, active_g, active_b);
    );
    target == 0 ? (gfx_set(1.0, 1.0, 1.0, 0.05); gfx_rect(x, y, block_width, block_width));
    x += block_spacing + block_width;
    ptr += 1;
    target = (target + 1) % 4;
    last = current;
  );
  
  y_over = (mouse_y > y) && (mouse_y < (y + block_width));
  
  mouse_x < x && y_over ? hinter.updateHintTime(hint);
  
  // Process events
  x -= n_segments * (block_width + block_spacing);
  idx = min(floor((mouse_x - x) / (block_width + block_spacing)), n_segments);
  (mouse_cap == 1 || mouse_cap == 2) ? (
    // Not captured, start dragging.
    (last_cap == 0) ? (
      // Are we in the positional columns?
      y_over && (mouse_x > x) && (mouse_x < (x + (n_segments + 1) * (block_width + block_spacing))) ? (
        // Start dragging a region
        start_idx = idx;
        mouse_cap == 1 ? captured_by = me : captured_by = -me;
      ) : (
        y_over ? (
          ((mouse_x < x) && (mouse_x > x - (block_width + block_spacing))) ? (
            // Toggle the lane power
            slider(power_slider) = 1 - slider(power_slider);
          ) : (mouse_x < x) ? (
            // Select the lane
            selected_details = me;
          );
        );
      );
    ) : ( me == abs(captured_by) ) ? (
      captured_by > 0 ? gfx_set(0, 0, 1, .1) : gfx_set(1, 0, 0, .1);
      ptr = min(start_idx, idx);
      idx = max(start_idx, idx);
      gfx_rect(x + (block_width + block_spacing) * ptr, y, (idx - ptr + 1) * (block_width + block_spacing), block_width, 1);
    );
  ) : ( abs(captured_by) == me ) ? (
    // We dragged an area
    ptr = min(start_idx, idx);
    idx = max(start_idx, idx);
    start_idx = ptr;
    // Left or right mouse drag
    captured_by > 0 ? (
      target = abs(mem[ptr]) + 1;
      target > max_value ? target = 0;
    ) : (
      target = abs(mem[ptr]) - 1;
      target < 0 ? target = max_value;
    );
    // Negative values mean a continuation
    mem[ptr] = target;
    ptr += 1;
    target = retrig_toggle.value ? target : - target;
    loop(idx - start_idx,
      mem[ptr] = target;
      ptr += 1;
    );
    captured_by = 0;
  );
  
  y += block_width + block_spacing;
);

function draw_scope(scope_w, scope_h)
global(SCOPE,
       current_sample, samples_per_beat, sample_clock,
       block_width, block_spacing, l_buffer.write_ptr,
       gfx_w, gfx_h, gfx_x, gfx_y, gfx_dest)
instance(last_scope_w, last_scope_h, last_samples, iter)
local(lastx, x, s, dx, minacc, maxacc, wave_range, wave_center, x_old, y_old)
(
  SCOPE = 1;
  iter += 1;
  
  ((last_scope_w != scope_w) || (last_scope_h != scope_h)) ? (
    last_scope_w = scope_w;
    last_scope_h = scope_h;
    gfx_setimgdim(1, scope_w, scope_h);
  );

  gfx_dest = 1;
  x_old = gfx_x;
  y_old = gfx_y;
  gfx_x = 0;
  gfx_y = 0;
  
  //(iter % 4) == 0 ? gfx_blurto(scope_w, scope_h);
  gfx_set(0, 0, 0, .005);
  gfx_rect(0, 0, scope_w, scope_h);
  
  wave_range = 0.5 * scope_h;
  wave_center = wave_range;
  x = (block_width + block_spacing) * (current_sample / samples_per_beat);
  dx = (block_width + block_spacing) / samples_per_beat;
  s = 1;
  maxacc = 0;
  minacc = 0;
  gfx_set(0.5, 0.5, 0.5, 0.8);
  loop(sample_clock - last_samples,
    maxacc = max((l_buffer.write_ptr)[s], maxacc);
    minacc = min((l_buffer.write_ptr)[s], minacc);
    
    (floor(lastx) != floor(x)) ? (
      gfx_line(x, wave_center + maxacc * wave_range, x, wave_center + minacc * wave_range);
      lastx = x;
      maxacc = 0;
      minacc = 0;
    );
    x -= dx;
    s -= 1;
  ); 
  
  last_samples = sample_clock;
  gfx_dest = -1;
  gfx_x = x_old;
  gfx_y = y_old;
  
  1
);

function process_modulation_row(row_index, modulator_index, mem, x, y, h, label, hint)
global(label_width, block_width, block_spacing, selected_details,
       nice_rect,
       n_segments,
       font_r, font_g, font_b,
       gfx_x, gfx_y,
       BASE_FONT
       mouse_cap, mouse_x, mouse_y, last_cap, captured_by,
       hinter.updateHintTime,
       retrig_toggle.value
       base_r, base_g, base_b,
       row_color_r, row_color_g, row_color_b, printed_value,
       activeModifier)
local(txt_w, txt_h, ptr, idx, target, y_over, last, current, active_r, active_g, active_b, offset)
instance(mem, start_idx)
(
  set_row_color(row_index);
  nice_rect(x, y, label_width - 1, h, 0, 1, row_color_r, row_color_g, row_color_b);
  nice_rect(x + label_width, y, block_width - 1, h, 0, 1, base_r, base_g, base_b);
  ptr = mem;
  
  // Are we selected?
  (activeModifier == modulator_index) ? (
    gfx_set(1.0, 1.0, 1.0, 0.15 + 0.1 * sin(3*time_precise()));
    gfx_rect(x, y, label_width, h);
  );
  
  gfx_set(font_r, font_r, font_r, 1.0);
  gfx_setfont(BASE_FONT);
  gfx_measurestr(label, txt_w, txt_h);
  gfx_x = x - 0.5 * (txt_w - label_width);
  gfx_y = y - 0.5 * (txt_h - block_width);
  gfx_printf(label);
  
  // Move to the actual sequencer cols
  x += label_width - block_spacing;
  x += block_width + block_spacing;
  ptr = mem;
  target = 0;
  loop(n_segments,
    current = ptr[];
    nice_rect(x, y, block_width, h, printed_value, 1, base_r, base_g, base_b);
    offset = floor(current * h);
    nice_rect(x, y + h - offset, block_width, offset, printed_value, 1, 1.5 * row_color_r, 1.5 * row_color_g, 1.5 * row_color_b);
    
    target == 0 ? (gfx_set(1.0, 1.0, 1.0, 0.05); gfx_rect(x, y, block_width, h));
    x += block_spacing + block_width;
    ptr += 1;
    target = (target + 1) % 4;
    last = current;
  );
  
  y_over = (mouse_y > y) && (mouse_y < (y + h));
  
  mouse_x < x && y_over ? (
    hinter.updateHintTime(hint);
    (mouse_cap == 1) && (last_cap == 0) ? (
      // Select row
      activeModifier = activeModifier == modulator_index ? 0 : modulator_index;
    );
  );
  
  // Process events
  x -= n_segments * (block_width + block_spacing);
  idx = min(floor((mouse_x - x) / (block_width + block_spacing)), n_segments);
  y_over && (idx >= 0) && (idx < n_segments) ? (
    mouse_cap == 1 ? (
      mem[idx] = 1.0 - clamp((mouse_y - y) / h, 0, 1);
    );
  );
  
  y += h + block_spacing;
);

draw_logo(12 * (1+scaling), 10 * (1+scaling), 6 * (1+scaling), 6 * (1+scaling));

scope_w = ceil((block_width + block_spacing) * 33);
scope_h = 35 * (1 + scaling);

gfx_x = grid_origin_x + label_width + block_width + block_spacing;
gfx_y = grid_origin_y;
gfx_blit(draw_scope(scope_w, scope_h), 1, 0);

grid_origin_y += 40;
x_current = grid_origin_x;
y_current = grid_origin_y;

select_colormap(12);

y_s = y_current;
y_current = process_effect_row(0, 1, reset_values, x_current, y_current, "Reset", 1, 10, "Reset the playhead to the current position.\n\nThis is often useful after a slowdown effect to\nmake sure we catch up to the current position.");
y_current = process_effect_row(1, 2, speed_values, x_current, y_current, "Slowdown", 4, 11, "Slow down playback.");
y_current = process_effect_row(2, 10, tapestop_values, x_current, y_current, "Tape Stop", 1, 19, "Tape stop effect.");
y_current = process_effect_row(3, 4, retrig_values, x_current, y_current, "Retrigger", 4, 13, "Retrigger last block N times.");
y_current = process_effect_row(4, 12, pitch_shifter_values, x_current, y_current, "Pitch Shifter", 1, 21, "Apply a pitch shifter.");
y_current = process_effect_row(5, 5, reverse_values, x_current, y_current, "Reverse", 1, 14, "Reverse playhead playing a reversed\nversion of the last block.");
y_current = process_effect_row(6, 11, karplus_values, x_current, y_current, "Pitched Delay", 1, 20, "Apply a pitched delay effect");
y_current = process_effect_row(7, 9, degrade_values, x_current, y_current, "Degrade", 1, 18, "Apply degradation effects such as bit\nrate reduction, samplerate reduction\nor saturation to the audio.");
y_current = process_effect_row(8, 7, filt_values, x_current, y_current, "Filter", 1, 16, "Choose from various (non-)linear filters to apply to the audio.");
y_current = process_effect_row(9, 6, gate_values, x_current, y_current, "Volume Envelope", 1, 15, "Gate the audio.");
y_current = process_effect_row(10, 8, reverb_values, x_current, y_current, "Reverb", 1, 17, "Apply reverb to the audio.");

y_current = process_modulation_row(3, 2, modulator1_values, x_current, y_current, 2 * block_width, "Modulator A", "Modulator");
mod2_color_r = row_color_r * 2;
mod2_color_g = row_color_g * 2;
mod2_color_b = row_color_b * 2;
mod2_color_a = 1.0;

y_current = process_modulation_row(11, 3, modulator2_values, x_current, y_current, 2 * block_width, "Modulator B", "Modulator");
mod3_color_r = row_color_r * 2;
mod3_color_g = row_color_g * 2;
mod3_color_b = row_color_b * 2;
mod3_color_a = 1.0;

gfx_set(1, 1, 1, .1);
gfx_rect(grid_origin_x + label_width + (block_width + block_spacing) * floor(current_sample / samples_per_beat + 1), grid_origin_y, block_width, y_current - y_s);

// Control strip
function selection_button(me, cx, cy, width, height, label, br, bg, bb, hint)
local(over)
global(gfx_x, gfx_y, base_r, base_g, base_b, mouse_x, mouse_y, mouse_cap, last_cap,
       hinter.updateHintTime)
instance(value)
(
  value == me ? (
    br *= 2;
    bg *= 2;
    bb *= 2;
  );
  
  over = (mouse_x > cx) && (mouse_x < (cx + width)) && (mouse_y > cy) && (mouse_y < (cy + height));
  
  hint > -1 && over ? (
    hinter.updateHintTime(hint);
  );
  
  nice_rect_color(cx, cy, width, height, label, br, bg, bb, 2 * br, 2 * bg, 2 * bb);
  (last_cap & 1 == 0) && 
  (mouse_cap & 1 == 1) && 
  over ? 
  (
    value = me;
  );
  
  cx += width + 2;
);
nice_rect_color(grid_origin_x, y_current, scope_w + label_width - 3, block_width, 0, 0.2*base_r, 0.2 * base_g, 0.2 * base_b, 2 * base_r, 2*base_g, 2*base_b);

time_mode.value = time_mode;
cx = grid_origin_x + 2;
cx = time_mode.selection_button(0, cx, y_current + 2, 2 * block_width, block_width - 4, "Free", 0.05, 0.2, 0.1, "Run sequencer in free running mode.\nSequencer resets when playback is reset\nor when seeking to new position.");
cx = time_mode.selection_button(1, cx, y_current + 2, 2 * block_width, block_width - 4, "MIDI", 0.05, 0.2, 0.1, "Run sequencer in MIDI mode.\nPattern resets on incoming MIDI note.");
cx = time_mode.selection_button(2, cx, y_current + 2, 2 * block_width, block_width - 4, "Host", 0.05, 0.2, 0.1, "Run sequencer based on host\nplayback position.");
time_mode = time_mode.value;

tempo_sync_envelopes.value = tempo_sync_envelopes;
cx += block_width;
cx = tempo_sync_envelopes.selection_button(0, cx, y_current + 2, 2 * block_width, block_width - 4, "Time", 0.2, 0.1, 0.05, "Show envelope times in milliseconds.");
cx = tempo_sync_envelopes.selection_button(1, cx, y_current + 2, 2 * block_width, block_width - 4, "Beats", 0.2, 0.1, 0.05, "Show envelope times in beats.");

tempo_sync_envelopes != tempo_sync_envelopes.value ? (
  tempo_sync_envelopes = tempo_sync_envelopes.value;
  convert_tempos(tempo_sync_envelopes);
);

pattern_toggle.value = -1;
cx += block_width;
cx = pattern_toggle.selection_button(0, cx, y_current + 2, block_width, block_width - 4, "<", 0.3, 0.1, 0.05, "Decrease pattern index.");
cx = pattern_toggle.selection_button(1, cx, y_current + 2, 1.5 * block_width, block_width - 4, sprintf(3, "%d", current_pattern_index), 0.3, 0.1, 0.05, 0);
cx = pattern_toggle.selection_button(2, cx, y_current + 2, block_width, block_width - 4, ">", 0.3, 0.1, 0.05, "Increase pattern index.");

cx = midi_rec_toggle.selection_button(1, cx, y_current + 2, 2 * block_width, block_width - 4, identify_note(midi_note_pattern_select), 0.3, 0.1, 0.05, "Set reference note used for pattern selection via MIDI.\n\nOnce clicked this button lights up and the plugin listens\nfor an incoming MIDI note. This note is then set as the\nreference note.\n\nAny subsequent note will compute a pattern index to jump to\nassuming the reference note to correspond to pattern zero.");

cx = pattern_toggle.selection_button(3, cx + block_width, y_current + 2, 2 * block_width, block_width - 4, "Copy", 0.3, 0.2, 0.00, "Copy pattern.");
cx = pattern_toggle.selection_button(4, cx, y_current + 2, 2 * block_width, block_width - 4, "Paste", 0.3, 0.2, 0.05, "Paste pattern.");
pattern_toggle.value == 0 ? ( 
  current_pattern_index -= 1;
  current_pattern_index < 0 ? (
    current_pattern_index = max_stored_patterns - 1;
  );
  
  slider_automate(current_pattern_index);  
) 
: ( pattern_toggle.value == 2 ) ? (
  current_pattern_index += 1;
  ( current_pattern_index >= max_stored_patterns ) ? (
    current_pattern_index = 0;
  );
  
  slider_automate(current_pattern_index);
) 
: ( pattern_toggle.value == 3 ) ? ( copy_pattern() ) :
( pattern_toggle.value == 4 ) ? ( paste_pattern() );

cx += block_width;
cx = retrig_toggle.selection_button(0, cx, y_current + 2, 2 * block_width, block_width - 4, "Legato", 0.12, 0.15, 0.22, "Draw legato blocks.\n\nLegato blocks work differently from retriggered\nblocks. The exact effect depends on the effect\nrow.\n\nFor retrigger, legato will space the retriggers \nout over the entire block whereas retrigger mode \nwill place the number of retriggers on each block.\n\nFor tapestop, the stopping is reset for each \nnode when using retriggered \nblocks.\n\nFor envelope-based effects, legato mode does not\nrestart the envelope, whereas retriggered mode\ndoes.");
cx = retrig_toggle.selection_button(1, cx, y_current + 2, 2 * block_width, block_width - 4, "Retrig", 0.12, 0.15, 0.22, "Draw retriggered blocks.\n\nLegato blocks work differently from retriggered\nblocks. The exact effect depends on the effect\nrow.\n\nFor retrigger, legato will space the retriggers \nout over the entire block whereas retrigger mode \nwill place the number of retriggers on each block.\n\nFor tapestop, the stopping is reset for each \nnode when using retriggered \nblocks.\n\nFor envelope-based effects, legato mode does not\nrestart the envelope, whereas retriggered mode\ndoes.");

y_current += block_width;

render_time += .025;

style = 1;
xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
panelY = y_current - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;

dial_animation = 0;

cX = x_current;
cY = y_current + 2.25 * knobSize;

dial_animation = 1;
function drawAndProcess(cX, cY, knobSize, label, description, current, modifier1, modifier2, modifier3)
instance(vel, mod1, mod2, default, slider_idx, value, scale, min_value, newValue)
global(mouse_x, mouse_y, mouse_cap,
       dial_animation, bipolar, activeModifier,
       dial_position_color_r, dial_position_color_g, dial_position_color_b
       mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a,
       mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a,
       mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a,
       current_mod1, current_mod2)
local(norm_current)
(
  this.drawKnob(cX, cY, knobSize, label, description, 1.0);
  
  dial_animation ? (
    norm_current = (current - min_value) / scale;
    this.knob_draw_modifier(norm_current - value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -0.1);
    this.knob_draw_modifier(norm_current - value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, 0.1);
  );
  
  modifier1 ? this.knob_draw_modifier(vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  modifier2 ? this.knob_draw_modifier(mod1, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  modifier3 ? this.knob_draw_modifier(mod2, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
   
  activeModifier == 3 ? (
    this.knob_modifier_processMouse(0, mod2) ? ( mod2 = newValue; update_current_levels(); );
  ) : activeModifier == 2 ? ( 
    this.knob_modifier_processMouse(0, mod1) ? ( mod1 = newValue; update_current_levels(); );
  ) : activeModifier == 1 ? ( 
    this.knob_modifier_processMouse(0, vel) ? ( vel = newValue; update_current_levels(); );
  ) : (
    this.knob_processMouse(mouse_x, mouse_y, mouse_cap, default) ? (
      slider_idx > 0 ? (
        slider(slider_idx) = scale * value + min_value;
        slider_automate(slider_idx);
      );
      update_current_levels(); 
    );
  );
);

set_row_color(selected_row);
(selected_details == 7) ? (
  // Filter
  nextPanel = drawPanel(s_FILTER, cX, cY - 1.5 * knobSize, 26.5*knobSpacing, panelHeight, filter_enabled);
  cX += 2 * knobSpacing;
  cX += knobSize;
  gfx_setfont(KNOB_FONT);
  y_move = .45 * knobSize;
  ww = 1.5*knobSize;
  hh = .35 * knobSize;
  FILTER_SELECT_BUTTON = 25;
  y_ref = cY - 0.9*knobSize - 1;
  drawSelectionButton("Lin 2p", cX - 2*knobSize, y_ref, ww, hh, 0, FILTER_SELECT_BUTTON, "2-pole linear state variable filter (12 dB/oct).");
  drawSelectionButton("Lin 4p", cX - 2*knobSize, y_ref + y_move, ww, hh, 2, FILTER_SELECT_BUTTON, "4-pole linear state variable filter (12 dB/oct)");
  drawSelectionButton("Dual", cX - 2*knobSize, y_ref + 2*y_move, ww, hh, 8, FILTER_SELECT_BUTTON, "2 2-pole state variable filters in series\nwhere one is placed at four times the cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Triple", cX - 2*knobSize, y_ref + 3*y_move, ww, hh, 9, FILTER_SELECT_BUTTON, "3 2-pole state variable filters in series.\nCutoff frequencies are at one, two and four times the base cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Rect", cX - 2*knobSize, y_ref + 4*y_move, ww, hh, 14, FILTER_SELECT_BUTTON, "2-pole linear state variable filter where\nthe approximate resonance is rectified.");
  
  drawSelectionButton("MS-20", cX - 0.25*knobSize, y_ref + 0*y_move, ww, hh, 1, FILTER_SELECT_BUTTON, "MS-20 emulation (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("MS-20A", cX - .25*knobSize, y_ref + 1*y_move, ww, hh, 6, FILTER_SELECT_BUTTON, "MS-20 emulation with diode asymmetry (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("Moog", cX - .25*knobSize, y_ref + 2*y_move, ww, hh, 3, FILTER_SELECT_BUTTON, "Moog emulation (24 dB/oct).");
  drawSelectionButton("Ladder", cX - .25*knobSize, y_ref + 3*y_move, ww, hh, 4, FILTER_SELECT_BUTTON, "Ladder filter with two stages (12 dB/oct).");
  drawSelectionButton("303", cX - .25*knobSize, y_ref + 4*y_move, ww, hh, 5, FILTER_SELECT_BUTTON, "Blaukraut's 303 filter emulation");
  
  drawSelectionButton("nlSVF2p", cX + 1.5*knobSize, y_ref + 0*y_move, ww, hh, 10, FILTER_SELECT_BUTTON, "2-pole non-linear state variable filter (12 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("nlSVF4p", cX + 1.5*knobSize, y_ref + 1*y_move, ww, hh, 11, FILTER_SELECT_BUTTON, "4-pole non-linear state variable filter (24 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("Steiner", cX + 1.5*knobSize, y_ref + 2*y_move, ww, hh, 15, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (symmetric) feedback.\nBe warned, over 0.5 this filter goes into hard oscillation.\nThis sounds awful unless there's sufficient drive to choke it.\nResonance loss more dominant at HF.");
  drawSelectionButton("SteinerA", cX + 1.5*knobSize, y_ref + 3*y_move, ww, hh, 16, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (asymmetric) feedback.\nRaising the drive lowers the resonance (chokes it). Resonance loss more dominant at HF.");
  drawSelectionButton("Bent", cX + 1.5*knobSize, y_ref + 4*y_move, ww, hh, 17, FILTER_SELECT_BUTTON, "4-pole non-linear CMOS filter. Sounds extremely non-linear. Can lead a life of its own.");
  
  cX += 4.25*knobSize;
  driveKnob.knob_set_display(DB_SLIDER, filter_enabled);
  driveKnob.drawAndProcess(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", current_drive, 1, 1, 1);
  
  cX += 2.5*knobSize;
  cutoffKnob.knob_set_display(FREQ_SLIDER, filter_enabled);
  cutoffKnob.drawAndProcess(cX, cY, knobSize, "Cutoff Start", "Filter Cutoff", current_cutoff, 1, 1, 1);
  
  cX += 2.5*knobSize;
  cutoffEndKnob.knob_set_display(FREQ_SLIDER, filter_enabled);
  cutoffEndKnob.drawAndProcess(cX, cY, knobSize, "Cutoff End", "Filter Cutoff", current_cutoff, 1, 1, 1);
  
  cX += knobSize*2.5;
  resonanceKnob.knob_set_display(NORMALIZED_SLIDER, filter_enabled);
  resonanceKnob.drawAndProcess(cX, cY, knobSize, "Resonance", "Filter Resonance", current_resonance, 1, 1, 1);
   
  cX += knobSize*2.7;
  morphKnob.knob_set_display("", filter_enabled);
  morphKnob.drawAndProcess(cX, cY, knobSize, "Morph", "Filter Morph", current_morph, 1, 1, 1);
  
  gfx_set(1,1,1,1);
  drawKnobLabels(knobSize*1.25, 0, "LP");
  drawKnobLabels(knobSize*1.25, 1/4, "BP");
  drawKnobLabels(knobSize*1.25, 2/4, "HP");
  drawKnobLabels(knobSize*1.25, 3/4, "BR");
  drawKnobLabels(knobSize*1.25, 4/4, "LP");
  
  cX += knobSize * 2;
  nextPanel = drawPanel(s_ENVELOPE, cX, cY - 1.5 * knobSize, 11.25*knobSpacing, panelHeight, filter_enabled);
  
  cX += knobSize * 1.35;
  cutoffAttackKnob.knob_set_display(ATTACK_SLIDER, filter_enabled);
  cutoffAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", current_cutoff_atk, 1, 1, 1);

  cX += knobSize*2.5;
  cutoffDecayKnob.knob_set_display(DECAY_SLIDER, filter_enabled);
  cutoffDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", current_cutoff_decay, 1, 1, 1);
  
  cX += knobSize*2.5;
  cutoffSustainKnob.knob_set_display(NORMALIZED_SLIDER, filter_enabled);
  cutoffSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", current_cutoff_sustain, 1, 1, 1);
) : ( selected_details == 6 ) ? (
  // Gate
  nextPanel = drawPanel(s_GATE, cX, cY - 1.5 * knobSize, 18.25*knobSpacing, panelHeight, gate_enabled);
  cX += knobSize * 1.35;
  gateStart.knob_set_display(DB_SLIDER, gate_enabled);
  gateStart.drawAndProcess(cX, cY, knobSize, "Closed Level", "Gain when gate is closed.", current_gate, 1, 1, 1);
  
  cX += 2.5*knobSize;
  gateEnd.knob_set_display(DB_SLIDER, gate_enabled);
  gateEnd.drawAndProcess(cX, cY, knobSize, "Open Level", "Gain level when gate is open.", current_gate, 1, 1, 1);
  
  cX += 2.5*knobSize;  
  gateAttackKnob.knob_set_display(ATTACK_SLIDER, gate_enabled);
  gateAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", current_gate_atk, 1, 1, 1);
  
  cX += knobSize*2.5;
  gateDecayKnob.knob_set_display(DECAY_SLIDER, gate_enabled );
  gateDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", current_gate_decay, 1, 1, 1);
  
  cX += knobSize*2.5;
  gateSustainKnob.knob_set_display(NORMALIZED_SLIDER, gate_enabled);
  gateSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", current_gate_sustain, 1, 1, 1);
) : ( selected_details == 8 ) ? (
  // Reverb
  nextPanel = drawPanel(s_REVERB, cX, cY - 1.5 * knobSize, 29*knobSpacing, panelHeight, reverb_enabled);
  
  cX += knobSize * 1.35;
  verbDiffusionKnob.knob_set_display("", reverb_enabled);
  verbDiffusionKnob.drawAndProcess(cX, cY, knobSize, "Diffusion", "Reverb Diffusion", current_verb_diffusion, 1, 1, 1);

  cX += 2.5*knobSize;
  verbDecayKnob.knob_set_display("", reverb_enabled);
  verbDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Reverb decay", current_verb_decay, 1, 1, 1);
  
  cX += 2.5 * knobSize;
  verbModDepthKnob.knob_set_display("", reverb_enabled);
  verbModDepthKnob.drawAndProcess(cX, cY, knobSize, "Mod Depth", "Modulation depth", current_verb_mod_depth, 1, 1, 1);
  
  cX += 2.5 * knobSize;
  verbModRateKnob.knob_set_display("", reverb_enabled);
  verbModRateKnob.drawAndProcess(cX, cY, knobSize, "Mod rate", "Mod rate", current_verb_mod_rate, 1, 1, 1);

  cX += 2.5*knobSize;
  verbLowPassKnob.knob_set_display(FREQ_SLIDER, reverb_enabled);
  verbLowPassKnob.drawAndProcess(cX, cY, knobSize, "Damping", "Filter Cutoff inside the feedback loop", current_verb_lowpass, 1, 1, 1);
  
  cX += 2.5*knobSize;
  verbHighPassKnob.knob_set_display(FREQ_SLIDER, reverb_enabled);
  verbHighPassKnob.drawAndProcess(cX, cY, knobSize, "Highpass", "Filter Cutoff", current_verb_highpass, 1, 1, 1);

  cX += 2.5*knobSize;
  verbDry.knob_set_display(DB_SLIDER, reverb_enabled);
  verbDry.drawAndProcess(cX, cY, knobSize, "Dry", "Dry signal level.", current_verb_dry, 1, 1, 1);
  
  cX += 2.5*knobSize;
  verbWet.knob_set_display(DB_SLIDER, reverb_enabled);
  verbWet.drawAndProcess(cX, cY, knobSize, "Wet", "Wet signal level.", current_verb_wet, 1, 1, 1);

  cX += knobSize*1.75;
  nextPanel = drawPanel(s_ENVELOPE, cX, cY - 1.5 * knobSize, 11.125*knobSpacing, panelHeight, reverb_enabled);
  
  cX += 1.35*knobSize;  
  verbGateAttackKnob.knob_set_display(ATTACK_SLIDER, reverb_enabled);
  verbGateAttackKnob.drawAndProcess(cX, cY, knobSize, "Attack", "Envelope Attack", current_verb_gate_atk, 1, 1, 1);
  
  cX += knobSize*2.5;
  verbGateDecayKnob.knob_set_display(ATTACK_SLIDER, reverb_enabled);
  verbGateDecayKnob.drawAndProcess(cX, cY, knobSize, "Decay", "Envelope Decay", current_verb_gate_decay, 1, 1, 1);
  
  cX += knobSize*2.5;
  verbGateSustainKnob.knob_set_display(NORMALIZED_SLIDER, reverb_enabled);
  verbGateSustainKnob.drawAndProcess(cX, cY, knobSize, "Sustain", "Envelope Sustain", current_verb_gate_sustain, 1, 1, 1);
) : ( selected_details == 9 ) ? (
  // Degrade
  min_degrade = 3;
  nextPanel = drawPanel(s_DEGRADE, cX, cY - 1.5 * knobSize, 11.25*knobSpacing, panelHeight, degrade_enabled);
  
  cX += knobSize * 1.35;
  bitrateKnob.knob_set_display(SCALED_SLIDER, degrade_enabled);
  bitrateKnob.drawAndProcess(cX, cY, knobSize, "Bit rate", "Bit rate", current_bitrate, 1, 1, 1);

  cX += 2.5*knobSize;
  samplerateKnob.knob_set_display(FREQ_SLIDER, degrade_enabled);
  samplerateKnob.drawAndProcess(cX, cY, knobSize, "Sample rate", "Sample rate", current_samplerate, 1, 1, 1);
  
  cX += 2.5*knobSize;
  satKnob.knob_set_display(satKnob.value < .00001 ? "OFF" : DB_SLIDER, degrade_enabled);
  satKnob.drawAndProcess(cX, cY, knobSize, "Saturation", "Saturation.", current_saturate, 1, 1, 1);
) : ( selected_details == 10 ) ? (
  // Tape stop
  min_degrade = 3;
  nextPanel = drawPanel(s_TAPESTOP, cX, cY - 1.5 * knobSize, 4*knobSpacing, panelHeight, tapestop_enabled);
  
  cX += knobSize * 1.35;
  tapestopSpeedKnob.knob_set_display(DECAY_SLIDER, tapestop_enabled);
  tapestopSpeedKnob.drawAndProcess(cX, cY, knobSize, "Time", "How fast does the tape stop", current_tapestop_decay, 1, 1, 1);
) : ( selected_details == 11 ) ? (
  // Tonal delay
  min_degrade = 3;
  nextPanel = drawPanel(s_KARPLUS, cX, cY - 1.5 * knobSize, 18.25*knobSpacing, panelHeight, karplus_enabled);
  
  cX += knobSize * 1.35;
  midi_pitch = (45 + 36 * current_karplus_pitch);
  snap_karplus ? midi_pitch = floor(midi_pitch);
  note_fractional = midi_pitch - floor(midi_pitch);
  
  note_fractional > 0.025 ? (
    sprintf(CUSTOM_SLIDER, "%s (+%.1f)", identify_note(midi_pitch), note_fractional);
  ) : (
    identify_note(midi_pitch);
  );

  karplusPitchKnob.knob_set_display(CUSTOM_SLIDER, karplus_enabled);
  karplusPitchKnob.drawAndProcess(cX, cY, knobSize, "Pitch", "", current_karplus_pitch, 1, 1, 1);
  
  pitchSnapToggle.drawToggle(cX - knobSize, cY - knobSize, 0.15*knobSize, 0.15*knobSize, snap_karplus, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Snap pitch to full semitones.");
  snap_karplus = pitchSnapToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX += knobSize * 2.5;
  karplusFeedback.knob_set_display("", karplus_enabled);
  karplusFeedback.drawAndProcess(cX, cY, knobSize, "- Feedback +", "Feedback.\n\nNegative feedback leads to pipe-like sounds.\nPositive feedback to string like sounds.", current_karplus_feedback, 1, 1, 1);
  
  cX += knobSize * 2.5;
  karplusCutoffKnob.knob_set_display(FREQ_SLIDER, karplus_enabled);
  karplusCutoffKnob.drawAndProcess(cX, cY, knobSize, "Damping", "Filter cutoff of the filter in the feedback path.", current_karplus_cutoff, 1, 1, 1);
  
  cX += 2.5*knobSize;
  karplusDry.knob_set_display(DB_SLIDER, karplus_enabled);
  karplusDry.drawAndProcess(cX, cY, knobSize, "Dry", "Dry level when delay is active.", current_karplus_dry, 1, 1, 1);
  
  cX += 2.5*knobSize;
  karplusWet.knob_set_display(DB_SLIDER, karplus_enabled);
  karplusWet.drawAndProcess(cX, cY, knobSize, "Wet", "Wet level when delay is active.", current_karplus_wet, 1, 1, 1);
) : ( selected_details == 12 ) ? (
  // Pitch shifter
  min_degrade = 3;
  nextPanel = drawPanel(s_PITCH, cX, cY - 1.5 * knobSize, 14.125*knobSpacing, panelHeight, pitch_shifter_enabled);
  
  cX += knobSize * 1.35;
  shifterSnapToggle.drawToggle(cX - knobSize, cY - knobSize, 0.15*knobSize, 0.15*knobSize, snap_shifter, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Snap pitch to full semitones.");
  snap_shifter = shifterSnapToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  shifterPitchKnob.knob_set_display(snap_shifter ? ROUNDED_PITCH_SLIDER : PITCH_SLIDER, pitch_shifter_enabled);
  shifterPitchKnob.drawAndProcess(cX, cY, knobSize, "Pitch", "", current_pitch_shifter_pitch, 1, 1, 1);
  
  cX += 2.5*knobSize;
  shifterDry.knob_set_display(DB_SLIDER, pitch_shifter_enabled);
  shifterDry.drawAndProcess(cX, cY, knobSize, "Dry", "Dry signal level.", current_shifter_dry, 1, 1, 1);
  
  cX += 2.5*knobSize;
  shifterWet.knob_set_display(DB_SLIDER, pitch_shifter_enabled);
  shifterWet.drawAndProcess(cX, cY, knobSize, "Wet", "Wet signal level.", current_shifter_wet, 1, 1, 1);
  
  cx += 1.5 * knobSize;
  shifterSelect.value = shifter_mode;
  shifterSelect.selection_button(0, cX, cY - .7 * knobSize, 2.5 * block_width, block_width - 4, "Transients", edge_r, edge_g, edge_b, "Uses shorter window sizes.");
  shifterSelect.selection_button(1, cX, cY + .3 * knobSize, 2.5 * block_width, block_width - 4, "Melody", edge_r, edge_g, edge_b, "Uses longer window sizes.\nLeads to better phase alignment, but poor transient preservation.");
  shifter_mode = shifterSelect.value;
);

hinter.drawHint_draw();

last_cap = mouse_cap;

