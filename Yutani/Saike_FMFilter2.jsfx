desc:Saike FM Filter 2
tags: audio-rate filters
version: 0.06
author: Joep Vanlier
changelog: fix issue with midi notes not being handled properly when playback is stopped
license: MIT
about:
  # An FM filter plugin
  [Screenshot](https://user-images.githubusercontent.com/19836026/110242715-998d7900-7f57-11eb-8c6e-48b825b8f47e.gif)
  ### Features:
  - Anti-aliased oscillators.
  - 15 filters, from well behaved linear models, to gnarly analog modelled nastiness.
  - Audio and MIDI controllable filters.
  - Audio and MIDI controllable gate.
  - Three LFOs.
  - Modwheel and MIDI velocity support.
  - Stereo widening effect.
  - Distortion module.

  Attribution: Moog filter implementation was based on the paper:
  S. D'Angelo and V. Vaelimaeki, "Generalized Moog Ladder Filter: Part II - Explicit Non linear Model through a Novel Delay-Free
  Loop Implementation Method". IEEE Trans. Audio,Speech, and Lang. Process., vol. 22, no. 12, pp. 1873-1883, December 2014.
  303 emulation is Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
  minBLEP methodology Eli Brandt, "Hard Sync Without Aliasing"

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:placeholder=0<0,1,1>-Deprecated
slider2:placeholder=0<0,1,1>-Deprecated
slider3:placeholder=0<0,1,1>-Deprecated
slider4:placeholder=0<0,1,1>-Deprecated
slider5:placeholder=0<0,1,1>-Deprecated
slider6:placeholder=0<0,1,1>-Deprecated
slider7:placeholder=0<0,1,1>-Deprecated
slider8:placeholder=0<0,1,1>-Deprecated
slider9:glide_time=.4<0,1,.00001>-Deprecated
slider10:amplitude_envelope_mode=0<0,3,1{Off,MIDI,Threshold,Proportional}>-Amplitude Envelope Mode
slider11:filter_envelope_mode=0<0,3,1{Off,MIDI,Threshold,Proportional}>-Filter Envelope Mode
slider12:placeholder=0<0,1,1>-Deprecated
slider13:placeholder=0<0,1,1>-Deprecated
slider14:placeholder=0<0,1,1>-Deprecated
slider15:placeholder=0<0,1,1>-Deprecated
slider16:placeholder=0<0,1,1>-Deprecated
slider17:placeholder=0<0,1,1>-Deprecated
slider18:placeholder=0<0,1,1>-Deprecated
slider19:placeholder=0<0,1,1>-Deprecated
slider20:placeholder=0<0,1,1>-Deprecated
slider21:placeholder=0<0,1,1>-Deprecated
slider22:placeholder=0<0,1,1>-Deprecated
slider23:placeholder=0<0,1,1>-Deprecated
slider24:placeholder=0<0,1,1>-Deprecated
slider25:filter_type=1<0,17,1{Linear,MS-20,Linear x2,Moog,Ladder,303,MS-20 asym,DblRes,DualPeak,TriplePeak,svf nl 2p,svf nl 4p,svf nl 2p inc,svf nl 4p inc,rectified resonance,Steiner,SteinerA}>-Filter type
slider26:drive=0<-32,48,1>-Filter Drive (dB)
slider27:boost=0<-6,48,1>-Post Boost (dB)
slider28:cutoff=.6<0,1,.0001>-Cutoff
slider29:resonance=0.7<0,1,.0001>-Resonance
slider30:morph=0<0,1,.0001>-Morph

slider31:m_lfo_amnt=0<0,1,.00001>-Morph LFO amount
slider32:m_lfo_speed=0<0,20,.001>-Morph LFO speed [-]
slider33:m_lfo_phase=0<-1,1,.001>-Morph LFO phase
slider34:c_lfo_amnt=0<0,1,.00001>-Cutoff LFO amount
slider35:c_lfo_speed=0<0,20,.001>-Cutoff LFO speed [-]
slider36:c_lfo_phase=0<-1,1,.001>-Cutoff LFO phase

slider37:fm_mode=0<0,5,1{MIDI sin,MIDI square,Self,Self Abs,Audio Stereo 3/4,Audio Mono 3/4}>-FM mode
slider38:fm_amnt=0<0,1,.0001>-FM level
slider39:fm_factor=<-8,8,1>-FM rate factor
slider40:fm_spread=<0,1,.001>-FM spread
slider41:key_follow=0<0,1,.0001>-Key Follow
slider42:fm_cutoff=1<0,1,.0001>-FM Cutoff

slider43:env_amnt=0<-1,1,.0001>-Envelope Amount
slider44:cutoff_atk=0.5<0,1,.0001>-Cutoff Attack
slider45:cutoff_decay=0.5<0,1,.0001>-Cutoff Decay
slider46:cutoff_sustain=0<0,1,.0001>-Cutoff Sustain

slider47:placeholder=0<0,1,1>-Placeholder

slider48:current_ceiling=0<0,48,1>-Distortion level [dB]
slider49:warmth=0<-12,12,1>-Warmth

slider50:placeholder=0<0,1,1>-Deprecated
slider51:placeholder=0<0,1,1>-Deprecated
slider52:placeholder=0<0,1,1>-Deprecated

slider53:fb=0<0, 1, .000001>-Feedback

slider54:placeholder=0<0,1,1>-Deprecated
slider55:placeholder=0<0,1,1>-Deprecated
slider56:placeholder=0<0,1,1>-Deprecated
slider57:placeholder=0<0,1,1>-Deprecated
slider58:placeholder=0<0,1,1>-Deprecated

slider59:f_lfo_amnt=0<0,1,.00001>-Free LFO amount
slider60:f_lfo_speed=0<0,20,.001>-Free LFO speed [-]

slider61:fm_fine=0<0,1,.00001>-fine tune FM

slider62:fix_dc=1<0,1,1>Fix DC
slider63:inertia=60<0,200,.001>-Filter Inertia [ms]
slider64:oversampling=1<1,8,1>-Oversampling

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import Saike_Yutani_midilib.jsfx-inc
import Saike_Yutani_distortion.jsfx-inc
import Saike_Yutani_Envelope.jsfx-inc
import Saike_Yutani_interpolators.jsfx-inc
import Saike_Yutani_filters.jsfx-inc
import Saike_Yutani_oversampling.jsfx-inc
import Saike_Yutani_upsamplers.jsfx-inc
import Saike_Yutani_widgets.jsfx-inc
import Saike_Yutani_sample_delay_buffer.jsfx-inc
import Saike_Yutani_LFOs.jsfx-inc
import Saike_Yutani_Delays.jsfx-inc

@init
style = 1;
lastOversample = 0;

two_pi = 2 * $pi;
freemem = 0;

freemem = (midimem = freemem) + 32768;
freemem = (note_history = freemem) + 32768;
midi.initializeMIDI(midimem, note_history, 1, 1);
midi.notesOn = 0;

/* Oversampling memory */
freemem = (sinc_hist1 = freemem) + 10000;
freemem = (sinc_hist2 = freemem) + 10000;
freemem = (sinc_flt = freemem) + 10000;
freemem = (sinc_flt2 = freemem) + 10000;
freemem = (sinc_flt3 = freemem) + 10000;
freemem = (sinc_flt4 = freemem) + 10000;
freemem = (sinc_tmp = freemem) + 10000;

freemem = (l_buffer = freemem) + 2001;
freemem = (r_buffer = freemem) + 2001;

// Chorus materials
l_delay.initBuffer(l_buffer, l_buffer + 2000);
r_delay.initBuffer(r_buffer, r_buffer + 2000);
l_delay_filt.init_linearSVF_absolute(340, 0);
r_delay_filt.init_linearSVF_absolute(340, 0);

function initialize_interpolators()
(
  // Set up the interpolators
  cutoff_interpolator.interpolator_init(28);
  reso_interpolator.interpolator_init(29);
  morph_interpolator.interpolator_init(30);
  drive_interpolator.interpolator_init(26);
  gain_interpolator.interpolator_init(27);
  morph_phase_interpolator.interpolator_init(33);
  cutoff_phase_interpolator.interpolator_init(36);
    
  current_ceiling_interpolator.interpolator_init(48);
  warmth_interpolator.interpolator_init(49);
     
  (last_inertia != inertia) ? (
    last_inertia = inertia;
    inertia_cutoff = 1000.0/inertia;
    cutoff_interpolator.initialize_smoother(inertia_cutoff);
    reso_interpolator.initialize_smoother(inertia_cutoff);
    morph_interpolator.initialize_smoother(inertia_cutoff);
    drive_interpolator.initialize_smoother(inertia_cutoff);
    gain_interpolator.initialize_smoother(inertia_cutoff);
    morph_phase_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_phase_interpolator.initialize_smoother(inertia_cutoff);
    current_ceiling_interpolator.initialize_smoother(inertia_cutoff);
    warmth_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_interpolator.s = slider(28);
    reso_interpolator.s = slider(29);
    morph_interpolator.s = slider(30);
    drive_interpolator.s = slider(26);
    gain_interpolator.s = slider(27);
    morph_phase_interpolator.s = slider(33);
    cutoff_phase_interpolator.s = slider(36);
    current_ceiling_interpolator.s = slider(45);
    warmth_interpolator.s = slider(46);
  );
);

function updateFMFilter()
local()
global(FM_filter.init_linearSVF, FM_filter2.init_linearSVF, fm_cutoff, last_fm_cutoff)
instance()
(
  (fm_cutoff != last_fm_cutoff) ? (
    FM_filter.init_linearSVF(fm_cutoff, 0);
    FM_filter2.init_linearSVF(fm_cutoff, 0);
    last_fm_cutoff = fm_cutoff;
  );
);

function updateSlider()
(
  current_safety_moog = (1.0 - log(safety_limit_moog * oversampling) / log(20/22050));
  initialize_interpolators();
  check_safety();
);

function updateTempo()
(
  cutoff_LFO.envelopeTempo((c_lfo_speed+c_lfo_speed_velmod + c_lfo_speed_mod * mod_level + c_lfo_speed_flfo * free_lfo)/20);
  morph_LFO.envelopeTempo((m_lfo_speed+m_lfo_speed_velmod + m_lfo_speed_mod * mod_level)/20);
  free_LFO.envelopeTempo((f_lfo_speed+f_lfo_speed_velmod + f_lfo_speed_mod * mod_level)/20);
);

last_fm_cutoff = -1;
UpdateFMFilter();

@serialize
file_var(0, 1); // Version
file_var(0, m_lfo_sync);
file_var(0, c_lfo_sync);
file_var(0, shaper);
file_var(0, higain);
file_var(0, reset);
file_var(0, cutoff_reset);

file_var(0, cutoff_vel);
file_var(0, reso_vel);
file_var(0, morph_vel);

file_var(0, fm_amnt_vel);
file_var(0, fm_spread_vel);
    
file_var(0, cutoff_atk_vel);
file_var(0, cutoff_decay_vel);
file_var(0, cutoff_sustain_vel);
     
file_var(0, amp_atk_vel);
file_var(0, amp_decay_vel);
file_var(0, amp_sustain_vel);
file_var(0, env_amnt_vel);

file_var(0, drive_vel);
file_var(0, boost_vel);

file_var(0, c_lfo_reset);
file_var(0, m_lfo_reset);

file_var(0, fb_mode);
file_var(0, fb_vel);

file_var(0, m_lfo_center_phase);
file_var(0, c_lfo_center_phase);

file_var(0, m_lfo_type);
file_var(0, c_lfo_type);

file_var(0, c_lfo_amnt_vel);
file_var(0, c_lfo_speed_vel);
file_var(0, m_lfo_amnt_vel);
file_var(0, m_lfo_speed_vel);

file_var(0, c_lfo_enabled);
file_var(0, m_lfo_enabled);
file_var(0, randomness_level);

file_var(0, cutoff_mod);
file_var(0, reso_mod);
file_var(0, fm_amnt_mod);

file_var(0, c_lfo_amnt_mod);
file_var(0, m_lfo_amnt_mod);
file_var(0, c_lfo_speed_mod);
file_var(0, m_lfo_speed_mod);

file_var(0, chorus_enabled);
file_var(0, tempo_sync_envelopes);

file_var(0, f_lfo_type);
file_var(0, f_lfo_sync);
file_var(0, f_lfo_reset);
file_var(0, f_lfo_enabled);
file_var(0, f_lfo_amnt_mod);
file_var(0, f_lfo_amnt_vel);
file_var(0, f_lfo_speed_mod);
file_var(0, f_lfo_speed_vel);
file_var(0, f_lfo_center_phase);

file_var(0, cutoff_flfo);
file_var(0, reso_flfo);
file_var(0, fm_amnt_flfo);
file_var(0, c_lfo_amnt_flfo);
file_var(0, c_lfo_speed_flfo);

loop(199,
  file_var(0, 0);
);

@slider
updateSlider();

@block
israte = 1.0 / srate;
israte_radian = 2.0*$pi*israte;
vib_factor = 16 * $pi * israte;
midi.processMIDIBlock(); 

cutoff_interpolator.interpolator_block();
reso_interpolator.interpolator_block();
morph_interpolator.interpolator_block();
drive_interpolator.interpolator_block();
gain_interpolator.interpolator_block();
morph_phase_interpolator.interpolator_block();
cutoff_phase_interpolator.interpolator_block();
current_ceiling_interpolator.interpolator_block();
warmth_interpolator.interpolator_block();


oversampling_method = 1;

oversampling_method == 1 ? (
  curFIRdelay = getFIRdelay(oversampling); 
  (pdc_delay != curFIRdelay) ? (
    pdc_top_ch = 2;
    pdc_bot_ch = 0;
    pdc_delay = curFIRdelay;
    lastOversample = oversampling;
  );
) : (
  // Memory for the sincs is located at sinc_tmp, sinc_flt, sinc_flt2, sinc_flt3 and sinc_flt4
  (pdc_delay != 7) ? (
    sincFilterL.updateSincFilter(oversampling, 8, sinc_flt,  sinc_tmp);
    sincFilterR.updateSincFilter(oversampling, 8, sinc_flt2, sinc_tmp);
    nTapSinc = oversampling < 5 ? 16 : oversampling*4;
    sincDownL.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist1, sinc_flt3);
    sincDownR.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist2, sinc_flt4);
    pdc_top_ch = 2;
    pdc_bot_ch = 0;
    pdc_delay = 7;
  );
);

@sample
function updateCurrentVelocitySettings()
(
  shouldUpdateCurrentVelocitySettings = 0;

  cutoff_velmod = cutoff_vel * midi.lastVel;
  reso_velmod = reso_vel * midi.lastVel;
  morph_velmod = morph_vel * midi.lastVel;
    
  current_fm_amnt = fm_amnt + fm_amnt_vel * midi.lastVel + fm_amnt_mw;
  current_fm_spread = fm_spread + fm_spread_vel * midi.lastVel;
  current_env_amnt = clamp(env_amnt + env_amnt_vel * midi.lastVel, -1, 1);
     
  drive_velmod = drive_vel * midi.lastVel;
  boost_velmod = boost_vel * midi.lastVel;
    
  c_lfo_amnt_velmod = c_lfo_amnt_vel * midi.lastVel;
  m_lfo_amnt_velmod = m_lfo_amnt_vel * midi.lastVel;
  f_lfo_amnt_velmod = f_lfo_amnt_vel * midi.lastVel;
  c_lfo_speed_velmod = c_lfo_speed_vel * midi.lastVel;
  m_lfo_speed_velmod = m_lfo_speed_vel * midi.lastVel;
  f_lfo_speed_velmod = f_lfo_speed_vel * midi.lastVel;
    
  current_fb = .99 * cl01(fb + fb_vel * midi.lastVel);
  
  current_amp_atk = cl01(amp_atk + amp_atk_vel * midi.lastVel);
  current_amp_decay = cl01(amp_decay + amp_decay_vel * midi.lastVel);
  current_amp_sustain = cl01(amp_sustain + amp_sustain_vel * midi.lastVel);
  
  current_cutoff_atk = cl01(cutoff_atk + cutoff_atk_vel * midi.lastVel);
  current_cutoff_decay = cl01(cutoff_decay + cutoff_decay_vel * midi.lastVel);
  current_cutoff_sustain = cl01(cutoff_sustain + cutoff_sustain_vel * midi.lastVel);
  
  tempo_sync_envelopes ? (
    amp_env.calc_times_sync(current_amp_atk, current_amp_decay, current_amp_sustain);
    cutoff_env.calc_times_sync(current_cutoff_atk, current_cutoff_decay, current_cutoff_sustain);
  ) : (
    amp_env.calc_times(current_amp_atk, current_amp_decay, current_amp_sustain);
    cutoff_env.calc_times(current_cutoff_atk, current_cutoff_decay, current_cutoff_sustain);
  );
);

// Force an update when knobs are touched
shouldUpdateCurrentVelocitySettings ? updateCurrentVelocitySettings();

shaper ? (
  cur_ceiling = clamp(current_ceiling_interpolator.interpolate() + current_ceiling_vel * midi.lastVel, 0, 48);
  sat_slider_update(cur_ceiling, warmth_interpolator.interpolate(), oversampling);
);

lf_update_step += 1;
lf_update_step % 8 == 0 ? (
  updateTempo();
  
  mod_level = midi.smoothWheel;
  
  cutoff_mw = cutoff_mod * mod_level + cutoff_flfo * free_lfo;
  reso_mw = reso_mod * mod_level + reso_flfo * free_lfo;
  fm_amnt_mw = fm_amnt_mod * mod_level + fm_amnt_flfo * free_lfo;
  current_fm_amnt = fm_amnt + fm_amnt_vel * midi.lastVel + fm_amnt_mw;
  c_lfo_amnt_mw = c_lfo_amnt_mod * mod_level + c_lfo_amnt_flfo * free_lfo;
  m_lfo_amnt_mw = m_lfo_amnt_mod * mod_level;
  f_lfo_amnt_mw = f_lfo_amnt_mod * mod_level;
  
  lf_update_step = 0;
  
  current_c_lfo_speed_slider = (c_lfo_speed + c_lfo_speed_velmod + c_lfo_speed_mod * mod_level + c_lfo_speed_flfo * free_lfo)*0.06666666666666666666666666666667;
  current_m_lfo_speed_slider = (m_lfo_speed + m_lfo_speed_velmod + m_lfo_speed_mod * mod_level)*0.06666666666666666666666666666667;
  current_f_lfo_speed_slider = (f_lfo_speed + f_lfo_speed_velmod + f_lfo_speed_mod * mod_level)*0.06666666666666666666666666666667;
  
  current_c_lfo_speed = 10^(current_c_lfo_speed_slider) - 1;
  current_m_lfo_speed = 10^(current_m_lfo_speed_slider) - 1;
  current_f_lfo_speed = 10^(current_f_lfo_speed_slider) - 1;
);

(mmsg = midi.processMIDISample()) ? (
  midiChange = 1;
  
  FM_t = 0;
  pitch = 2^((midi.lastNote - 69)/12);
  keyfollow_mod = log(pitch) / log(20/22050);
  
  current_note_played =  midi.lastNote - 69;
 
  new_trigger = (note_mode == 0) ? ( midi.notesOn > 0 && ((midi.notesOn == midi.lastNotesOn) || midi.lastNotesOn == 0) )
  : (note_mode == 1) ? ( 1 );
 
  new_trigger && mmsg == 1 ? (
    updateCurrentVelocitySettings();
    
    c_lfo_reset ? c_lfo_time = c_lfo_center_phase;
    m_lfo_reset ? m_lfo_time = m_lfo_center_phase;
    f_lfo_reset ? f_lfo_time = f_lfo_center_phase;
    
    amp_env.reset_envelope(reset && amp_before_filter);
    cutoff_env.reset_envelope(cutoff_reset);
    !cutoff_reset ? cutoff_env.k_rise = .25*cutoff_env.k_rise;
  );
);

// TODO: Only update when a change is made
current_fm_spread = fm_spread + fm_spread_vel * midi.lastVel;
current_env_amnt = clamp(env_amnt + env_amnt_vel * midi.lastVel, -1, 1);
tempo_sync_envelopes ? (
  amp_env.calc_times_sync(cl01(amp_atk + amp_atk_vel), cl01(amp_decay + amp_decay_vel), cl01(amp_sustain + amp_sustain_vel));
  cutoff_env.calc_times_sync(cl01(cutoff_atk + cutoff_atk_vel), cl01(cutoff_decay + cutoff_decay_vel), cl01(cutoff_sustain + cutoff_sustain_vel));
) : (
  amp_env.calc_times(cl01(amp_atk + amp_atk_vel), cl01(amp_decay + amp_decay_vel), cl01(amp_sustain + amp_sustain_vel));
  cutoff_env.calc_times(cl01(cutoff_atk + cutoff_atk_vel), cl01(cutoff_decay + cutoff_decay_vel), cl01(cutoff_sustain + cutoff_sustain_vel));
);
// END TODO

m_notes_on = midi.notesOn > 0;

amp_envelope = 
  (amplitude_envelope_mode == 0) ? 1 :
  (amplitude_envelope_mode == 1) ? amp_env.update_envelope(m_notes_on) : 
  (amplitude_envelope_mode == 2) ? amp_env.follower(max(abs(spl0), abs(spl1)) > amp_sustain) : 0;

cutoff_envelope = 
  (filter_envelope_mode == 0) ? 0 :
  (filter_envelope_mode == 1) ? cutoff_env.update_envelope(m_notes_on) :
  (filter_envelope_mode == 2) ? cutoff_env.follower(max(abs(spl0), abs(spl1)) > cutoff_sustain) : 0;


// Filter modulation section
  sliderCutoffL = sliderCutoffR = cutoff_interpolator.interpolate() + cutoff_velmod + cutoff_mw + .1*faux_analog;
  sliderReso = clamp(reso_interpolator.interpolate() + reso_velmod + reso_mw, 0, 1);
  sliderMorphL = sliderMorphR = morph_interpolator.interpolate() + morph_velmod;
  morph_phase = morph_phase_interpolator.interpolate();
  cutoff_phase = cutoff_phase_interpolator.interpolate();

  sliderCutoffL += cutoff_envelope * current_env_amnt;
  sliderCutoffR += cutoff_envelope * current_env_amnt;
  sliderCutoffL -= key_follow * keyfollow_mod;
  sliderCutoffR -= key_follow * keyfollow_mod;

  function naiveTri(t)
  (
    t -= floor(t);
    t <= 0.5 ? (
      (4.0 * t - 1.0)
    ) : (
      (3.0 - 4.0 * t)
    )
  );
  
  function naiveSqr(t)
  (
    t -= floor(t);
    (2.0 * (t > 0.5) - 1.0)
  );

  // FM modulation of the filter
  current_fm_amnt != 0 ? (
    updateFMFilter();
    FM_t += (2^(floor(fm_factor)))*(1+fudge)*440*israte*pitch;
    fm_mode == 0 ? (
      fm_mod1 = sin(two_pi*FM_t);
      fm_mod2 = sin(two_pi*FM_t+$pi*current_fm_spread);
    ) : ( fm_mode == 1 ) ? (
      fm_mod1 = abs(sin(two_pi*FM_t)) * 2 - 1;
      fm_mod2 = abs(sin(two_pi*FM_t+$pi*current_fm_spread)) * 2 - 1;
    ) : ( fm_mode == 2 ) ? (
      avg = .5 * (spl0 + spl1);
      side = .5 * (spl0 - spl1);
      fm_mod1 = FM_filter.eval_linearSVF_LP(avg + 2 * current_fm_spread * side);
      fm_mod2 = FM_filter2.eval_linearSVF_LP(avg - 2 * current_fm_spread * side);
    ) : ( fm_mode == 3 ) ? (
      avg = .5 * (spl0 + spl1);
      side = .5 * (spl0 - spl1);
      fm_mod1 = FM_filter.eval_linearSVF_LP(avg + 2 * current_fm_spread * side);
      fm_mod2 = FM_filter2.eval_linearSVF_LP(avg - 2 * current_fm_spread * side);
    ) : ( fm_mode == 4 ) ? (
      fm_mod1 = naiveTri(FM_t);
      fm_mod2 = naiveTri(FM_t + .5*current_fm_spread);
    ) : ( fm_mode == 5 ) ? (
      fm_mod1 = naiveSqr(FM_t);
      fm_mod2 = naiveSqr(FM_t + .5*current_fm_spread);
    );
  );
  
  c_lfo_enabled ? (
    c_lfo_sync ? (
      c_lfo_time += israte * cutoff_LFO.cRate;
    ) : (
      c_lfo_time += israte * current_c_lfo_speed;    
    );
    current_c_lfo_amnt = c_lfo_amnt + c_lfo_amnt_velmod + c_lfo_amnt_mw;
    sliderCutoffL = sliderCutoffL + current_c_lfo_amnt * c_left.lfo_modulator(c_lfo_type, c_lfo_time + cutoff_phase);
    sliderCutoffR = sliderCutoffR + current_c_lfo_amnt * c_right.lfo_modulator(c_lfo_type, c_lfo_time);
    c_lfo_type == 17 && cutoff_phase == 0 ? (
      sliderCutoffR = sliderCutoffL;
    );
  );
  
  m_lfo_enabled > 0 ? (
    m_lfo_sync ? (
      m_lfo_time += israte * morph_LFO.cRate;
    ) : (
      m_lfo_time += israte * current_m_lfo_speed;    
    );
    current_m_lfo_amnt = m_lfo_amnt + m_lfo_amnt_velmod + m_lfo_amnt_mw;
    sliderMorphL = sliderMorphL + current_m_lfo_amnt * m_left.lfo_modulator(m_lfo_type, m_lfo_time + morph_phase);
    sliderMorphR = sliderMorphR + current_m_lfo_amnt * m_right.lfo_modulator(m_lfo_type, m_lfo_time);
    c_lfo_type == 17 && morph_phase == 0 ? (
      sliderMorphL = sliderMorphR;
    );
  );
  
  f_lfo_enabled > 0 ? (
    f_lfo_sync ? (
      f_lfo_time += israte * free_LFO.cRate;
    ) : (
      f_lfo_time += israte * current_f_lfo_speed;    
    );
    current_f_lfo_amnt = cl01(f_lfo_amnt + f_lfo_amnt_velmod + f_lfo_amnt_mw);
    free_lfo = current_f_lfo_amnt * f_lfo.lfo_modulator(f_lfo_type, f_lfo_time + f_lfo_phase);
  ) : free_lfo = current_f_lfo_amnt = 0;
  
  sliderMorphL = clamp(sliderMorphL, 0, 1);
  sliderMorphR = clamp(sliderMorphR, 0, 1);
  
  sliderCutoffL = clamp(sliderCutoffL + current_fm_amnt * fm_mod1, 0, .99);
  sliderCutoffR = clamp(sliderCutoffR + current_fm_amnt * fm_mod2, 0, .99);

  filter.init_filter(filter_type, sliderCutoffL, sliderCutoffR, sliderMorphL, sliderMorphR, sliderReso);
  
  // Gain setup
  log10d20_conversion  = .11512925464970228420089957273422;
  
  current_drive = clamp(drive_interpolator.interpolate() + drive_velmod, -6, 48);
  current_boost = clamp(gain_interpolator.interpolate() + boost_velmod, -6, 48);
  preamp      = exp(log10d20_conversion*current_drive);
  inv_preamp  = exp(-log10d20_conversion*current_drive);
  final_boost = exp(log10d20_conversion*current_boost);
  
  yl = spl0 * preamp;
  yr = spl1 * preamp;
  
  fb_mode == 0 ? (
    fb ? (
      !(filter_type == 0 || filter_type == 2) ? (
        filter_type == 5 ? (
          fb_factor = current_fb * (1-cutoff);
          yl += fb_factor * last_yl;
          yr += fb_factor * last_yr;
          gc = 1/(1+2*fb_factor);
          yl *= gc;
          yr *= gc; 
        ) : (filter_type == 1 || filter_type == 6) ? (
          yl += current_fb * last_yl;
          yr += current_fb * last_yr;
          gc = 1/(1+1.5*current_fb);
          yl *= gc;
          yr *= gc;      
        ) : (
          yl -= current_fb * last_yl;
          yr -= current_fb * last_yr;
          gc = 1/(1+1.25*current_fb);
          yl *= gc;
          yr *= gc;
        );
      );
    );
  ) : (
    !(filter_type == 0 || filter_type == 2) ? (
      yl += current_fb * lyl;
      yr += current_fb * lyr;
  
      lyl = yl;
      lyr = yr;
    );
  );
  
  hotness_rmsq = .9999 * hotness_rms + .0001 * yl * yl;
  
  amp_before_filter ? (
    yl *= amp_envelope;
    yr *= amp_envelope;
  );
  
  // Oversampled processing
  ( oversampling > 1 ) ? (
    ( oversampling_method == 1 ) ? (
      upsampleL.updateUpHist(overSampling, yl);
      upsampleR.updateUpHist(overSampling, yr);
      
      f = 0;
      loop(overSampling,
        f += 1;
        ssl = overSampling*upsampleL.upSample(overSampling);
        ssr = overSampling*upsampleR.upSample(overSampling);
      
        filter.processSample(filter_type);
        ssl *= inv_preamp;
        ssr *= inv_preamp;
        shaper ? processShaper();
        
        downL.updateDownHist(overSampling, ssl);
        downR.updateDownHist(overSampling, ssr);
        
        ( f == 1 ) ? (
          spl0 = downL.downSample(overSampling);
          spl1 = downR.downSample(overSampling);
        );
      );
    ) : (
      sincFilterL.advanceSinc(yl);
      sincFilterR.advanceSinc(yr);
      
      loop( oversampling,
        ssl = sincFilterL.getSubSample();
        ssr = sincFilterR.getSubSample();
        
        filter.processSample(filter_type);
        ssl *= inv_preamp;
        ssr *= inv_preamp;
        shaper ? processShaper();
        
        sincDownL.advanceHist(ssl);
        sincDownR.advanceHist(ssr);
      );
      
      spl0 = sincDownL.sincDownSample();
      spl1 = sincDownR.sincDownSample();
    );
  ) : (
    ssr = yr;
    ssl = yl;
    
    filter.processSample(filter_type);
    ssl *= inv_preamp;
    ssr *= inv_preamp;
    shaper ? processShaper();
    
    spl0 = ssl;
    spl1 = ssr;
  );
  
  last_yl = spl0;
  last_yr = spl1;
  
  spl0 *= final_boost;
  spl1 *= final_boost;
  
  !amp_before_filter ? (
    spl0 *= amp_envelope;
    spl1 *= amp_envelope;
  );
  
  fix_dc ? (
    spl0 = dc2.eval_HP6(spl0);
    spl1 = dc3.eval_HP6(spl1);
  );
  
  fb_mode ? (
    spl0 = spl0 / (1+exp(fb));
    spl1 = spl1 / (1+exp(fb));
  );
  
  chorus_enabled > .01 ? (
    // Subtle bass preserving chorus
    l_delay.writeBuffer(l_delay_filt.eval_linearSVF_HP(spl0));
    r_delay.writeBuffer(r_delay_filt.eval_linearSVF_HP(spl1));
    
    csample += 1;
    
    chorus_tri = naiveTri(csample * israte * .25);
    ch_cur = chorus_enabled * .001 + ch_cur * .999;
    l_offset = ch_cur * (0.0075 + 0.002 * chorus_tri) * srate;
    r_offset = ch_cur * (0.0075 - 0.002 * chorus_tri) * srate;
    
    spl0 = spl0 - .5 * r_delay.readBuffer(r_offset);
    spl1 = spl1 - .5 * l_delay.readBuffer(l_offset);
  );

@gfx 1510 600
style != 0 ? (
  size_fraction = gfx_w/1210;
) : (
  size_fraction = gfx_w/1510;
);
size_fraction > 1 ? size_fraction = 1;
scaling = size_fraction - 1;

render_time += .025;
style == 0 ? gfx_set(21/255, 20/255, 21/255, 1.0);
style == 1 ? gfx_set(9/255, 10/255, 9/255, 1.0);
style == 2 ? gfx_set(0, 10/255, 0, 1.0);
gfx_rect(0, 0, gfx_w, gfx_h);

t_anim += .005;
t_desync = 0.5*$pi;
t_ref = 0;
loop(50,
  tp = t_anim + t_ref;
  xx = .5*gfx_h+gfx_w*sin(tp);
  yy = .35*gfx_h+gfx_h*cos(tp);
  xx2 = .25*gfx_h+gfx_w*sin(tp + t_desync);
  yy2 = .25*gfx_h+gfx_h*cos(tp + t_desync);
  gfx_set(.5, 1, .5, min(1.0, .04+.1*abs(sin(render_time))));
  gfx_line(xx2, yy2, xx, yy, 3);
  t_ref += .01 + .1 * abs(sin(.065272*render_time));
);

xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
widget_r = 35/255;
widget_g = 155/255;
widget_b = 30/255;
widget_a = 1.0;
toggle_r = .5;
toggle_g = 1.6;
toggle_b = .5;
toggle_a = 1.0;

cY = w1y + w1h + .4*(gfx_h-w1h);
panelY = cY - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;

style == 0 ? (
  xOrigin = 75*(1+scaling);
  yOrigin = 65*(1+scaling);
  panelSpacing = knobSize;
  
  s_DRIVE = sprintf(64, "DRIVE");
  s_FILTER = sprintf(65, "FILTER");
  s_FFM = sprintf(66, "FM");
  s_DIST = sprintf(67, "DISTORTION");
  s_FB = sprintf(68, "FEEDBACK");
  s_AMP_ENV = sprintf(69, "AMP ENV");
  s_FILT_ENV = sprintf(70, "FILTER ENV  ");
  s_CLFO = sprintf(71, "CUTOFF LFO");
  s_MLFO = sprintf(72, "MORPH LFO");
  s_PITCHOD = sprintf(73, "PITCH MOD");
  s_FX = sprintf(75, "FX");
  s_OPTS = sprintf(76, "OPTIONS");
  s_FLFO = sprintf(78, "FREE LFO");
) : ( style == 1 ) ? (
  xOrigin = 60*(1+scaling);
  yOrigin = 82*(1+scaling);
  panelSpacing = .15*knobSize;
  
  s_DRIVE = sprintf(64, "Drive");
  s_FILTER = sprintf(65, "Filter");
  s_FFM = sprintf(66, "Filter FM");
  s_DIST = sprintf(67, "Distortion");
  s_FB = sprintf(68, "Feedback");
  s_AMP_ENV = sprintf(69, "Amplitude Envelope");
  s_FILT_ENV = sprintf(70, "Filter Envelope");
  s_CLFO = sprintf(71, "Cutoff LFO");
  s_MLFO = sprintf(72, "Morph LFO");
  s_PITCHOD = sprintf(73, "Pitch modulation");
  s_FX = sprintf(75, "Effects");
  s_OPTS = sprintf(76, "Options");
  s_FLFO = sprintf(78, "Free LFO");
) : ( style == 2 ) ? (
  xOrigin = 60*(1+scaling);
  yOrigin = 82*(1+scaling);
  panelSpacing = .15*knobSize;
  
  s_DRIVE = sprintf(64, "DRIVE");
  s_FILTER = sprintf(65, "FILTER");
  s_FFM = sprintf(66, "FILTER FM");
  s_DIST = sprintf(67, "DISTORTION");
  s_FB = sprintf(68, "FEEDBACK");
  s_AMP_ENV = sprintf(69, "AMP ENVELOPE");
  s_FILT_ENV = sprintf(70, "FILTER ENVELOPE");
  s_CLFO = sprintf(71, "CUTOFF LFO");
  s_MLFO = sprintf(72, "MORPH LFO");
  s_PITCHOD = sprintf(73, "PITCH MOD");
  s_FX = sprintf(75, "EFFECTS");
  s_OPTS = sprintf(76, "OPTIONS");
  s_FLFO = sprintf(78, "FREE LFO");
);

style == 0 ? (
  font_color_r = .7;
  font_color_g = .6;
  font_color_b = .8;
) : (
  font_color_r = .7;
  font_color_g = .7;
  font_color_b = .7;
);
dial_animation = 1;
dial_position_color_r = 0.2;
dial_position_color_g = 0.7;
dial_position_color_b = 0.4;

font_color_a = 1;
knob_font_color_r = 0.9;
knob_font_color_g = 0.9;
knob_font_color_b = 0.8;
knob_font_color_a = 1;
edge_r = 39/255;
edge_g = 39/255;
edge_b = 41/255;
edge_a = 1.0;

edge_font_r = 0.9;
edge_font_g = 0.9;
edge_font_b = 0.8;

mod1_color_r = .3;
mod1_color_g = .47;
mod1_color_b = .6;
mod1_color_a = 1;
mod2_color_r = .2;
mod2_color_g = .5;
mod2_color_b = 1;
mod2_color_a = 1;
mod3_color_r = .1;
mod3_color_g = .6;
mod3_color_b = 1;
mod3_color_a = 1;

fontscaling = scaling < -.15 ? scaling : 0;


FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", floor(16 * (1+fontscaling)));

BAND_FONT = 5;
gfx_setfont(BAND_FONT, "Arial", floor(16 * (1+fontscaling)));

KNOB_FONT = 6;
gfx_setfont(KNOB_FONT, "Arial", floor(14 * (1+fontscaling)));

KNOB_FONT2 = 7;
gfx_setfont(KNOB_FONT2, "Arial", floor(13 * (1+fontscaling)));

HINT_FONT = 8;
gfx_setfont(HINT_FONT, "Arial", floor(13 * (1+fontscaling)));

TOGGLE_FONT = 9;
gfx_setfont(TOGGLE_FONT, "Arial", floor(13 * (1+fontscaling)));

cX = xOrigin;
cY = yOrigin;

nextPanel = drawPanel(s_DRIVE, cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 7.75*knobSpacing, panelHeight, 1);

style == 0 ? (
  hotness_meter = tanh(54*sqrt(hotness_rmsq));
  gfx_set(hotness_meter+.1, .1, .1, hotness_meter);
  gfx_rect(cX - 2.5*knobSpacing+1, cY - .28*panelHeight, 9, 9);
);

driveKnob.knob_set(sprintf(1, "%.1f dB", drive), 1, (drive + 6)/54);
driveKnob.drawKnob(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", 1.0);
dial_animation ? (
  driveKnob.knob_draw_modifier((current_drive - drive) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  driveKnob.knob_draw_modifier((current_drive - drive) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
driveKnob.knob_draw_modifier(drive_vel / 54, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( driveKnob.knob_modifier_processMouse(0, drive_vel / 54) ? ( drive_vel = driveKnob.value * 54; );
) : driveKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? ( drive = driveKnob.value * 54 - 6; slider_automate(drive); );
 
cX += 2.5 * knobSize;

postBoost.knob_set(sprintf(1, "%.1f dB", boost), 1, (boost + 6)/54);
postBoost.drawKnob(cX, cY, knobSize, "Output Gain", "Output Gain", 1.0);
dial_animation ? (
  postBoost.knob_draw_modifier((current_boost - boost) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  postBoost.knob_draw_modifier((current_boost - boost) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
postBoost.knob_draw_modifier(boost_vel / 54, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( postBoost.knob_modifier_processMouse(0, boost_vel / 54) ? ( boost_vel = postBoost.value * 54; );
) : postBoost.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? ( boost = postBoost.value * 54 - 6; slider_automate(boost); );

cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_FILTER, cX, cY - .53*panelHeight + .2*knobSize, 22.75*knobSpacing, panelHeight, 1);

cX += 2 * knobSpacing;
cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .45 * knobSize;
ww = 1.5*knobSize;
hh = .35 * knobSize;
FILTER_SELECT_BUTTON = 25;
y_ref = cY - 0.9*knobSize - 1;
drawSelectionButton("Lin 2p", cX - 2*knobSize, y_ref, ww, hh, 0, FILTER_SELECT_BUTTON, "2-pole linear state variable filter (12 dB/oct).");
drawSelectionButton("Lin 4p", cX - 2*knobSize, y_ref + y_move, ww, hh, 2, FILTER_SELECT_BUTTON, "4-pole linear state variable filter (12 dB/oct)");
drawSelectionButton("Dual", cX - 2*knobSize, y_ref + 2*y_move, ww, hh, 8, FILTER_SELECT_BUTTON, "2 2-pole state variable filters in series\nwhere one is placed at four times the cutoff.\nResonance peak is saturated (approximate).");
drawSelectionButton("Triple", cX - 2*knobSize, y_ref + 3*y_move, ww, hh, 9, FILTER_SELECT_BUTTON, "3 2-pole state variable filters in series.\nCutoff frequencies are at one, two and four times the base cutoff.\nResonance peak is saturated (approximate).");
drawSelectionButton("Rect", cX - 2*knobSize, y_ref + 4*y_move, ww, hh, 14, FILTER_SELECT_BUTTON, "2-pole linear state variable filter where\nthe approximate resonance is rectified.");

drawSelectionButton("MS-20", cX - 0.25*knobSize, y_ref + 0*y_move, ww, hh, 1, FILTER_SELECT_BUTTON, "MS-20 emulation (12 dB/oct LP, BP, 6 dB/oct HP).");
drawSelectionButton("MS-20A", cX - .25*knobSize, y_ref + 1*y_move, ww, hh, 6, FILTER_SELECT_BUTTON, "MS-20 emulation with diode asymmetry (12 dB/oct LP, BP, 6 dB/oct HP).");
drawSelectionButton("Moog", cX - .25*knobSize, y_ref + 2*y_move, ww, hh, 3, FILTER_SELECT_BUTTON, "Moog emulation (24 dB/oct).");
drawSelectionButton("Ladder", cX - .25*knobSize, y_ref + 3*y_move, ww, hh, 4, FILTER_SELECT_BUTTON, "Ladder filter with two stages (12 dB/oct).");
drawSelectionButton("303", cX - .25*knobSize, y_ref + 4*y_move, ww, hh, 5, FILTER_SELECT_BUTTON, "Blaukraut's 303 filter emulation");

drawSelectionButton("nlSVF2p", cX + 1.5*knobSize, y_ref + 0*y_move, ww, hh, 10, FILTER_SELECT_BUTTON, "2-pole non-linear state variable filter (12 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
drawSelectionButton("nlSVF4p", cX + 1.5*knobSize, y_ref + 1*y_move, ww, hh, 11, FILTER_SELECT_BUTTON, "4-pole non-linear state variable filter (24 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
drawSelectionButton("Steiner", cX + 1.5*knobSize, y_ref + 2*y_move, ww, hh, 15, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (symmetric) feedback.\nBe warned, over 0.5 this filter goes into hard oscillation.\nThis sounds awful unless there's sufficient drive to choke it.\nResonance loss more dominant at HF.");
drawSelectionButton("SteinerA", cX + 1.5*knobSize, y_ref + 3*y_move, ww, hh, 16, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (asymmetric) feedback.\nRaising the drive lowers the resonance (chokes it). Resonance loss more dominant at HF.");
drawSelectionButton("Bent", cX + 1.5*knobSize, y_ref + 4*y_move, ww, hh, 17, FILTER_SELECT_BUTTON, "4-pole non-linear CMOS filter. Sounds extremely non-linear. Can lead a life of its own.");

cX += 4.25*knobSize;

center = .5 * srate * exp( (1-cutoff) * log(20/22050) );
cutoffKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), 1, cutoff);
cutoffKnob.drawKnob(cX, cY, knobSize, "Cutoff", "Filter Cutoff", 1.0);

dial_animation ? (
  cutoffKnob.knob_draw_modifier(sliderCutoffL - cutoff, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  cutoffKnob.knob_draw_modifier(sliderCutoffR - cutoff, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);

cutoffKnob.knob_draw_modifier(cutoff_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
cutoffKnob.knob_draw_modifier(cutoff_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
cutoffKnob.knob_draw_modifier(cutoff_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);

activeModifier == 3 ? ( cutoffKnob.knob_modifier_processMouse(0, cutoff_flfo) ? ( cutoff_flfo = cutoffKnob.value; );
) : activeModifier == 2 ? ( cutoffKnob.knob_modifier_processMouse(0, cutoff_mod) ? ( cutoff_mod = cutoffKnob.value; );
) : activeModifier == 1 ? ( cutoffKnob.knob_modifier_processMouse(0, cutoff_vel) ? ( cutoff_vel = cutoffKnob.value; );
) : cutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff = cutoffKnob.value; slider_automate(cutoff); check_safety(); );

cX += knobSize*2.5;
resonanceKnob.knob_set(sprintf(1, "%.1f", resonance), 1, resonance);
resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Filter Resonance", 1.0);
dial_animation ? (
  resonanceKnob.knob_draw_modifier(sliderReso - resonance, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  resonanceKnob.knob_draw_modifier(sliderReso - resonance, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
resonanceKnob.knob_draw_modifier(reso_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
resonanceKnob.knob_draw_modifier(reso_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
resonanceKnob.knob_draw_modifier(reso_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
activeModifier == 3 ? ( resonanceKnob.knob_modifier_processMouse(0, reso_flfo) ? ( reso_flfo = resonanceKnob.value; );
) : activeModifier == 2 ? ( resonanceKnob.knob_modifier_processMouse(0, reso_mod) ? ( reso_mod = resonanceKnob.value; );
) : activeModifier == 1 ? ( resonanceKnob.knob_modifier_processMouse(0, reso_vel) ? ( reso_vel = resonanceKnob.value; );
) : resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( resonance = resonanceKnob.value; slider_automate(resonance); );
 
cX += knobSize*2.7;

morphKnob.knob_set("", 1, morph);
morphKnob.drawKnob(cX, cY, knobSize, "Morph", "Filter Morph", 1.0);

dial_animation ? (
  morphKnob.knob_draw_modifier(sliderMorphL - morph, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  morphKnob.knob_draw_modifier(sliderMorphR - morph, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);

morphKnob.knob_draw_modifier(morph_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( morphKnob.knob_modifier_processMouse(0, morph_vel) ? ( morph_vel = morphKnob.value; );
) : morphKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( morph = morphKnob.value; slider_automate(morph); );


gfx_set(1,1,1,1);
drawKnobLabels(knobSize*1.25, 0, "LP");
drawKnobLabels(knobSize*1.25, 1/4, "BP");
drawKnobLabels(knobSize*1.25, 2/4, "HP");
drawKnobLabels(knobSize*1.25, 3/4, "BR");
drawKnobLabels(knobSize*1.25, 4/4, "LP");


cX += knobSize*2.65;

keyFollowKnob.active = 1;
keyFollowKnob.value = key_follow;
keyFollowKnob.drawKnob(cX, cY, knobSize, "Follow", "Follow MIDI pitch", 1.0);

keyFollowKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  key_follow = keyFollowKnob.value;
  slider_automate(key_follow);
);

cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_FFM, cX, cY - .53*panelHeight + .2*knobSize, 13.5*knobSpacing, panelHeight, 1);
cX += 2.375*knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
FM_MODE_BUTTON = 37;
drawSelectionButton("MIDI Sin", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, FM_MODE_BUTTON, -1);
drawSelectionButton("MIDI |Sin|", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 1, FM_MODE_BUTTON, -1);
drawSelectionButton("MIDI Tri", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 4, FM_MODE_BUTTON, -1);
drawSelectionButton("Self", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 2, FM_MODE_BUTTON, -1);
drawSelectionButton("Self Abs", cX - 2*knobSize, cY-1.1*knobSize + 5*y_move, ww, hh, 3, FM_MODE_BUTTON, -1);
drawSelectionButton("MIDI Sqr", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 5, FM_MODE_BUTTON, -1);
cX += .65*knobSize;

fmlevelKnob.knob_set("", 1, fm_amnt);
fmLevelKnob.drawKnob(cX, cY, knobSize, "FM Level", "FM Level\nLevel of FM modulation", 1.0);
dial_animation ? (
  fmlevelKnob.knob_draw_modifier(current_fm_amnt - fm_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  fmlevelKnob.knob_draw_modifier(current_fm_amnt - fm_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
fmLevelKnob.knob_draw_modifier(fm_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
fmLevelKnob.knob_draw_modifier(fm_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
fmLevelKnob.knob_draw_modifier(fm_amnt_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
activeModifier == 3 ? ( fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_flfo) ? ( fm_amnt_flfo = fmLevelKnob.value; );
) : activeModifier == 2 ? ( fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_mod) ? ( fm_amnt_mod = fmLevelKnob.value; );
) : activeModifier == 1 ? ( fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_vel) ? ( fm_amnt_vel = fmLevelKnob.value; );
) : fmLevelKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( fm_amnt = fmLevelKnob.value; slider_automate(fm_amnt); );
 

cX += 2.5 * knobSize;

fm_mode == 2 || fm_mode == 3 ? (
  fmCutoffKnob.active = 1;
  fmCutoffKnob.value = fm_cutoff;
  center = .5 * srate * exp( (1-fm_cutoff) * log(20/22050) );
  center < 1000 ? (
    fmCutoffKnob.label = sprintf(1, "%d Hz", center);
  ) : (
    fmCutoffKnob.label = sprintf(1, "%.1f kHz", center/1000);
  );
  fmCutoffKnob.drawKnob(cX, cY, knobSize, "FM cutoff", "FM Cutoff\n\nCutoff used to filter signal that\ncontrols the cutoff.", .5);
  fmCutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? (
    fm_cutoff = fmCutoffKnob.value;
    slider_automate(fm_cutoff);
  );
) : (
  fmRateKnob.active = 1;
  fmRateKnob.value = (fm_factor+8)/16;
  fmRateKnob.label = sprintf(1, "%.1f x", 2^floor(fm_factor));
  fmRateKnob.drawKnob(cX, cY, knobSize, "FM factor", "FM factor.\n\nFilter cutoff will oscillate with\nthis factor times the MIDI pitch's\nfrequency.", .5);
  fmRateKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    fm_factor = fmRateKnob.value * 16 - 8;
    slider_automate(fm_factor);
  );
);
cX += 2.5 * knobSize;

fmPhaseKnob.knob_set("", 1, fm_spread);
fmPhaseKnob.drawKnob(cX, cY, knobSize, "FM Spread", "FM Phase difference", 1.0);
dial_animation ? (
  fmPhaseKnob.knob_draw_modifier((current_fm_spread - fm_spread), bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  fmPhaseKnob.knob_draw_modifier((current_fm_spread - fm_spread), bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
fmPhaseKnob.knob_draw_modifier(fm_spread_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( fmPhaseKnob.knob_modifier_processMouse(0, fm_spread_vel) ? ( fm_spread_vel = fmPhaseKnob.value; );
) : fmPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( fm_spread = fmPhaseKnob.value; slider_automate(fm_spread); );

cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_FB, cX, cY - .53*panelHeight + .2*knobSize, 4.15*knobSpacing, panelHeight, 1);

cX += 1.4 * knobSize;
feedbackTwoToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, fb_mode, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Direct feedback mode. Directly routes output to drive. Can be used to massively distort the input.");
fb_mode = feedbackTwoToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

feedbackKnob.active = !(filter_type == 0 || filter_type == 2);
feedbackKnob.value = fb;
feedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Are you crazy?", 0);
dial_animation ? (
  feedbackKnob.knob_draw_modifier(current_fb - fb, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  feedbackKnob.knob_draw_modifier(current_fb - fb, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
feedbackKnob.knob_draw_modifier(fb_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( feedbackKnob.knob_modifier_processMouse(0, fb_vel) ? ( fb_vel = feedbackKnob.value; );
) : feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( fb = feedbackKnob.value; slider_automate(fb); );

cX = xOrigin - 2*knobSpacing;
cY = cY + 4 * knobSize;

// FILTER ENVELOPE
nextPanel = drawPanel(s_FILT_ENV, cX, cY - .53*panelHeight + .2*knobSize, 17.5*knobSpacing, panelHeight, 1);

style == 0 ? (
  gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
  gfx_rect(cX - 2.5*knobSpacing + 1, cY - .4*panelHeight - 1, 9 * (1+scaling), 9 * (1+scaling));
) : (
  sz = 10 * (1+scaling);
  xref = cX + .5 * knobSpacing;
  yref = cY - .54*panelHeight;
  gfx_set(.1, midiChange*.7+.1, .1, midiChange); midiChange *= .95;
  gfx_rect(xref - .5 * sz, yref - .5 * sz - 1, sz, sz);
  
  r = 20*(1+scaling);
  loop(12,
    r -= 2*(1+scaling);
    gfx_set(.5, 1, .5, .5*midiChange / r);
    gfx_circle(xref - 1, yref - 3, r, 1);
  );
);

cX += 2 * knobSpacing + knobSize;

FILTER_MODE_SELECT_BUTTON = 11;
gfx_setfont(KNOB_FONT);
y_ref = cY - 1.25*knobSize - 1;
drawSelectionButton("Off", cX - 2*knobSize, y_ref + 0.5*y_move, ww, hh, 0, FILTER_MODE_SELECT_BUTTON, "No filter modulation.");
drawSelectionButton("MIDI", cX - 2*knobSize, y_ref + 1.5*y_move, ww, hh, 1, FILTER_MODE_SELECT_BUTTON, "Enable envelope by MIDI.");
drawSelectionButton("Thresh", cX - 2*knobSize, y_ref + 2.5*y_move, ww, hh, 2, FILTER_MODE_SELECT_BUTTON, "Thresholded.");
//drawSelectionButton("RMS", cX - 2*knobSize, y_ref + 3.5*y_move, ww, hh, 3, FILTER_MODE_SELECT_BUTTON, "Proportional to input RMS.");

cX += 1.25 * knobSpacing;

envAmountKnob.knob_set(sprintf(4, "   %d %%%%", 100*env_amnt), filter_envelope_mode > 0, env_amnt * .5 + .5);
envAmountKnob.drawKnob(cX, cY, knobSize, "- Amount +", "Envelope Amount", 1.0);
dial_animation ? (
  envAmountKnob.knob_draw_modifier((current_env_amnt - env_amnt)*.5, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  envAmountKnob.knob_draw_modifier((current_env_amnt - env_amnt)*.5, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
envAmountKnob.knob_draw_modifier(env_amnt_vel * .5, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( envAmountKnob.knob_modifier_processMouse(0, env_amnt_vel * .5) ? ( env_amnt_vel = envAmountKnob.value * 2; );
) : envAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? ( env_amnt = envAmountKnob.value * 2 - 1; slider_automate(env_amnt); );


cX += knobSize*2.5;
tempo_sync_envelopes ? ( envAttackKnob.knob_set(getFastEnvelopeLabel(cutoff_atk), filter_envelope_mode > 0, cutoff_atk);
) : envAttackKnob.knob_set(cutoff_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*cutoff_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*cutoff_atk))), filter_envelope_mode > 0, cutoff_atk);
envAttackKnob.drawKnob(cX, cY, knobSize, "Attack", "Attack Time", 1.0);
dial_animation ? (
  envAttackKnob.knob_draw_modifier(current_cutoff_atk - cutoff_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  envAttackKnob.knob_draw_modifier(current_cutoff_atk - cutoff_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
envAttackKnob.knob_draw_modifier(cutoff_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( envAttackKnob.knob_modifier_processMouse(0, cutoff_atk_vel) ? ( cutoff_atk_vel = envAttackKnob.value; );
) : envAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff_atk = envAttackKnob.value; slider_automate(cutoff_atk); );

cutoffResetToggle.inactive = filter_envelope_mode == 0;
cutoffResetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, cutoff_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on note.\n\nTurning this off changes the mode to a mode where\nthe amplitude no longer goes to 90%% in the set time.\n\nThis means that consecutive hits get increasingly higher\ncutoff values. The 303 is one of the classic synths that\nhad this characteristic.");
cutoff_reset = cutoffResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += knobSize*2.5;
tempo_sync_envelopes ? ( envDecayKnob.knob_set(getFastEnvelopeLabel(cutoff_decay), filter_envelope_mode > 0, cutoff_decay);
) : envDecayKnob.knob_set(cutoff_decay > .5 ? sprintf(19, "%d ms", (30 * 10^(2*cutoff_decay))) : sprintf(19, "%.1f ms", (30 * 10^(2*cutoff_decay))), filter_envelope_mode > 0, cutoff_decay );
envDecayKnob.drawKnob(cX, cY, knobSize, "Decay", "Decay Time", 1.0);
dial_animation ? (
  envDecayKnob.knob_draw_modifier(current_cutoff_decay - cutoff_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  envDecayKnob.knob_draw_modifier(current_cutoff_decay - cutoff_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
envDecayKnob.knob_draw_modifier(cutoff_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( envDecayKnob.knob_modifier_processMouse(0, cutoff_decay_vel) ? ( cutoff_decay_vel = envDecayKnob.value; );
) : envDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff_decay = envDecayKnob.value; slider_automate(cutoff_decay); );

cX += 2.5 * knobSize;

envSustainKnob.knob_set("", filter_envelope_mode > 0, cutoff_sustain);

( filter_envelope_mode < 2 ) ? envSustainKnob.drawKnob(cX, cY, knobSize, "Sustain", "Sustain %", 1.0)
: ( filter_envelope_mode == 2 ) ? envSustainKnob.drawKnob(cX, cY, knobSize, "Threshold", "Threshold [V]", 1.0);

dial_animation ? (
  envSustainKnob.knob_draw_modifier(current_cutoff_sustain - cutoff_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  envSustainKnob.knob_draw_modifier(current_cutoff_sustain - cutoff_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
envSustainKnob.knob_draw_modifier(cutoff_sustain_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( envSustainKnob.knob_modifier_processMouse(0, cutoff_sustain_vel) ? ( cutoff_sustain_vel = envSustainKnob.value; );
) : envSustainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff_sustain = envSustainKnob.value; slider_automate(cutoff_sustain); );

cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_CLFO, cX, cY - .53*panelHeight + .2*knobSize, 9.65*knobSpacing, panelHeight, c_lfo_enabled);

cX += 2 * knobSpacing;

cutoffLFOAmountKnob.active = c_lfo_enabled;
cutoffLFOAmountKnob.value = c_lfo_amnt;
cutoffLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount.\n\nPress RMB to toggle forward.\nGo backwards by pressing LMB while still\nholding RMB from the forward toggle.\nPress LMB and drag to change amount.", 1.0);
draw_lfo(cX - 15*(1+scaling), cY - 10*(1+scaling), 30*(1+scaling), 20*(1+scaling), c_lfo_type, c_lfo_center_phase, c_lfo_time);
dial_animation ? (
  cutoffLFOAmountKnob.knob_draw_modifier(current_c_lfo_amnt - c_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  cutoffLFOAmountKnob.knob_draw_modifier(current_c_lfo_amnt - c_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
cutoffLFOAmountKnob.knob_draw_modifier(c_lfo_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
cutoffLFOAmountKnob.knob_draw_modifier(c_lfo_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
cutoffLFOAmountKnob.knob_draw_modifier(c_lfo_amnt_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
activeModifier == 3 ? ( cutoffLFOAmountKnob.knob_modifier_processMouse(0, c_lfo_amnt_flfo) ? ( c_lfo_amnt_flfo = cutoffLFOAmountKnob.value; );
) : activeModifier == 2 ? ( cutoffLFOAmountKnob.knob_modifier_processMouse(0, c_lfo_amnt_mod) ? ( c_lfo_amnt_mod = cutoffLFOAmountKnob.value; );
) : activeModifier == 1 ? ( cutoffLFOAmountKnob.knob_modifier_processMouse(0, c_lfo_amnt_vel) ? ( c_lfo_amnt_vel = cutoffLFOAmountKnob.value; );
) : (
  mouse_cap == 2 && lcap == 0 ? (
    cutoffLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
      c_lfo_type += 1;
      c_lfo_type > max_lfo_types ? c_lfo_type = 0;
    );
  ) : ( mouse_cap == 3 && lcap == 2 ) ? (
    cutoffLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
      c_lfo_type -= 1;
      c_lfo_type < 0 ? c_lfo_type = max_lfo_types - 1;
      cutoffLFOAmountKnob.lastLeftClick = -10000; /* Prevent double click from triggering from this */
    );
  ) : (
    cutoffLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      c_lfo_amnt = cutoffLFOAmountKnob.value;
      slider_automate(c_lfo_amnt);
    );
  );
);

cutoffLfoEnabledToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_enabled, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable LFO.");
c_lfo_enabled = cutoffLfoEnabledToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cutoffLfoResetToggle.inactive = !c_lfo_enabled;
cutoffLfoResetToggle.drawToggle(cX+knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
c_lfo_reset = cutoffLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += 2.5 * knobSize;
cutoffSyncToggle.inactive = !c_lfo_enabled;
cutoffSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync rate to tempo.");
c_lfo_sync = cutoffSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cutoffLFOSpeedKnob.active = c_lfo_enabled;
cutoffLFOSpeedKnob.value = c_lfo_speed / 20;
cutoffLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
c_lfo_sync ? (
  cutoffLFOSpeedKnob.label = cutoff_LFO.tempoLabel;
) : (
  cutoffLFOSpeedKnob.label = sprintf(3, "%.1f Hz", 10^(c_lfo_speed/15) - 1);
);
dial_animation ? (
  cutoffLFOSpeedKnob.knob_draw_modifier((current_c_lfo_speed_slider*15 - c_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  cutoffLFOSpeedKnob.knob_draw_modifier((current_c_lfo_speed_slider*15 - c_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
cutoffLFOSpeedKnob.knob_draw_modifier(c_lfo_speed_vel / 20, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
cutoffLFOSpeedKnob.knob_draw_modifier(c_lfo_speed_mod / 20, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
cutoffLFOSpeedKnob.knob_draw_modifier(c_lfo_speed_flfo / 20, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
activeModifier == 3 ? ( cutoffLFOSpeedKnob.knob_modifier_processMouse(0, c_lfo_speed_flfo / 20) ? ( c_lfo_speed_flfo = cutoffLFOSpeedKnob.value * 20; );
) : activeModifier == 2 ? ( cutoffLFOSpeedKnob.knob_modifier_processMouse(0, c_lfo_speed_mod / 20) ? ( c_lfo_speed_mod = cutoffLFOSpeedKnob.value * 20; );
) : activeModifier == 1 ? ( cutoffLFOSpeedKnob.knob_modifier_processMouse(0, c_lfo_speed_vel / 20) ? ( c_lfo_speed_vel = cutoffLFOSpeedKnob.value * 20; );
) : (
  cutoffLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    c_lfo_speed = cutoffLFOSpeedKnob.value * 20;
    updateTempo();
    slider_automate(c_lfo_speed);
  );
);

cX += 1.85 * knobSize;
cutoffLFOLRPhaseKnob.active = c_lfo_enabled;
cutoffLFOLRPhaseKnob.value = (c_lfo_phase + 1) * .5;
cutoffLFOLRPhaseKnob.drawKnob(cX, cY + .65*knobSize, .5*knobSize, "", "Cutoff LFO Pan Phase", 1.0);
cutoffLFOLRPhaseKnob.label = "LR";
cutoffLFOLRPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  c_lfo_phase = 2 * cutoffLFOLRPhaseKnob.value - 1;
  slider_automate(c_lfo_phase);
);


cutoffLFOPhaseKnob.active = c_lfo_enabled;
cutoffLFOPhaseKnob.value = (c_lfo_center_phase + 1) * .5;
cutoffLFOPhaseKnob.drawKnob(cX, cY - .6*knobSize, .5*knobSize, "", "Cutoff LFO Phase", 1.0);
cutoffLFOPhaseKnob.label = "Φ";
cutoffLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  c_lfo_center_phase = 2 * cutoffLFOPhaseKnob.value - 1;
  slider_automate(c_lfo_center_phase);
);

cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_MLFO, cX, cY - .53*panelHeight + .2*knobSize, 9.65*knobSpacing, panelHeight, m_lfo_enabled);
cX += 2 * knobSpacing;
morphLFOAmountKnob.active = m_lfo_enabled;
morphLFOAmountKnob.value = m_lfo_amnt;
morphLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Morph LFO Amount.\n\nPress RMB to toggle forward.\nGo backwards by pressing LMB while still\nholding RMB from the forward toggle.\nPress LMB and drag to change amount.", 1.0);
draw_lfo(cX - 15*(1+scaling), cY - 10*(1+scaling), 30*(1+scaling), 20*(1+scaling), m_lfo_type, m_lfo_center_phase, m_lfo_time);
dial_animation ? (
  morphLFOAmountKnob.knob_draw_modifier(current_m_lfo_amnt - m_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  morphLFOAmountKnob.knob_draw_modifier(current_m_lfo_amnt - m_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
morphLFOAmountKnob.knob_draw_modifier(m_lfo_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
morphLFOAmountKnob.knob_draw_modifier(m_lfo_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
activeModifier == 2 ? ( morphLFOAmountKnob.knob_modifier_processMouse(0, m_lfo_amnt_mod) ? ( m_lfo_amnt_mod = morphLFOAmountKnob.value; );
) : activeModifier == 1 ? ( morphLFOAmountKnob.knob_modifier_processMouse(0, m_lfo_amnt_vel) ? ( m_lfo_amnt_vel = morphLFOAmountKnob.value; );
) : (
  mouse_cap == 2 && lcap == 0 ? (
    morphLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
      m_lfo_type += 1;
      m_lfo_type > max_lfo_types ? m_lfo_type = 0;
    );
  ) : ( mouse_cap == 3 && lcap == 2 ) ? (
    morphLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
      m_lfo_type -= 1;
      m_lfo_type < 0 ? m_lfo_type = max_lfo_types - 1;
      morphLFOAmountKnob.lastLeftClick = -10000;
    );
  ) : (
    morphLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( m_lfo_amnt = morphLFOAmountKnob.value; slider_automate(m_lfo_amnt); );
  );
);

morphLfoEnabledToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_enabled, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable LFO.");
m_lfo_enabled = morphLfoEnabledToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

morphLfoResetToggle.inactive = !m_lfo_enabled;
morphLfoResetToggle.drawToggle(cX+knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
m_lfo_reset = morphLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += 2.5 * knobSize;
morphSyncToggle.inactive = !m_lfo_enabled;
morphSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync rate to tempo.");
m_lfo_sync = morphSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

morphLFOSpeedKnob.active = m_lfo_enabled;
morphLFOSpeedKnob.value = m_lfo_speed / 20;
morphLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Morph LFO frequency", 1.0);
m_lfo_sync ? (
  morphLFOSpeedKnob.label = morph_LFO.tempoLabel;
) : (
  morphLFOSpeedKnob.label = sprintf(5, "%d Hz", 10^(m_lfo_speed/15) - 1);
);
dial_animation ? (
  morphLFOSpeedKnob.knob_draw_modifier((current_m_lfo_speed_slider*15 - m_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  morphLFOSpeedKnob.knob_draw_modifier((current_m_lfo_speed_slider*15 - m_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
morphLFOSpeedKnob.knob_draw_modifier(m_lfo_speed_vel / 20, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
morphLFOSpeedKnob.knob_draw_modifier(m_lfo_speed_mod / 20, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
activeModifier == 2 ? ( morphLFOSpeedKnob.knob_modifier_processMouse(0, m_lfo_speed_mod/20) ? ( m_lfo_speed_mod = morphLFOSpeedKnob.value * 20; );
) : activeModifier == 1 ? ( morphLFOSpeedKnob.knob_modifier_processMouse(0, m_lfo_speed_vel/20) ? ( m_lfo_speed_vel = morphLFOSpeedKnob.value * 20; );
) : (
  morphLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    m_lfo_speed = morphLFOSpeedKnob.value * 20;
    updateTempo();
    slider_automate(m_lfo_speed);
  );
);

cX += 1.85 * knobSize;

morphLFOLRPhaseKnob.active = m_lfo_enabled;
morphLFOLRPhaseKnob.value = (m_lfo_phase + 1) * .5;
morphLFOLRPhaseKnob.drawKnob(cX, cY + .65*knobSize, .5*knobSize, "", "Morph Pan LFO Phase", 1.0);
morphLFOLRPhaseKnob.label = "LR";
morphLFOLRPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  m_lfo_phase = 2 * morphLFOLRPhaseKnob.value - 1;
  slider_automate(m_lfo_phase);
);

morphLFOPhaseKnob.active = m_lfo_enabled;
morphLFOPhaseKnob.value = (m_lfo_center_phase + 1) * .5;
morphLFOPhaseKnob.drawKnob(cX, cY - .6 * knobSize, .5*knobSize, "", "Morph LFO Phase", 1.0);
morphLFOPhaseKnob.label = "Φ";
morphLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  m_lfo_center_phase = 2 * morphLFOPhaseKnob.value - 1;
  slider_automate(m_lfo_center_phase);
);

cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_FLFO, cX, cY - .53*panelHeight + .2*knobSize, 9.65*knobSpacing, panelHeight, c_lfo_enabled);

cX += 2 * knobSpacing;

freeLFOAmountKnob.active = f_lfo_enabled;
freeLFOAmountKnob.value = f_lfo_amnt;
freeLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount.\n\nPress RMB to toggle forward.\nGo backwards by pressing LMB while still\nholding RMB from the forward toggle.\nPress LMB and drag to change amount.", 1.0);
draw_lfo(cX - 15*(1+scaling), cY - 10*(1+scaling), 30*(1+scaling), 20*(1+scaling), f_lfo_type, f_lfo_center_phase, f_lfo_time);
dial_animation ? (
  freeLFOAmountKnob.knob_draw_modifier(current_f_lfo_amnt - f_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  freeLFOAmountKnob.knob_draw_modifier(current_f_lfo_amnt - f_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
freeLFOAmountKnob.knob_draw_modifier(f_lfo_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
freeLFOAmountKnob.knob_draw_modifier(f_lfo_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
activeModifier == 2 ? ( freeLFOAmountKnob.knob_modifier_processMouse(0, f_lfo_amnt_mod) ? ( f_lfo_amnt_mod = freeLFOAmountKnob.value; );
) : activeModifier == 1 ? ( freeLFOAmountKnob.knob_modifier_processMouse(0, f_lfo_amnt_vel) ? ( f_lfo_amnt_vel = freeLFOAmountKnob.value; );
) : (
  mouse_cap == 2 && lcap == 0 ? (
    freeLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
      f_lfo_type += 1;
      f_lfo_type > max_lfo_types ? f_lfo_type = 0;
    );
  ) : ( mouse_cap == 3 && lcap == 2 ) ? (
    freeLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
      f_lfo_type -= 1;
      f_lfo_type < 0 ? f_lfo_type = max_lfo_types - 1;
      freeLFOAmountKnob.lastLeftClick = -10000; /* Prevent double click from triggering from this */
    );
  ) : (
    freeLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      f_lfo_amnt = freeLFOAmountKnob.value;
      slider_automate(f_lfo_amnt);
    );
  );
);

freeLfoEnabledToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, f_lfo_enabled, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
f_lfo_enabled = freeLfoEnabledToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

freeLfoResetToggle.inactive = !f_lfo_enabled;
freeLfoResetToggle.drawToggle(cX+knobSize, cy-knobSize, .15*knobSize, .15*knobSize, f_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
f_lfo_reset = freeLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += 2.5 * knobSize;
freeSyncToggle.inactive = !f_lfo_enabled;
freeSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, f_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync rate to tempo.");
f_lfo_sync = freeSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

freeLFOSpeedKnob.active = f_lfo_enabled;
freeLFOSpeedKnob.value = f_lfo_speed / 20;
f_lfo_sync ? (
  freeLFOSpeedKnob.label = free_LFO.tempoLabel;
) : (
  freeLFOSpeedKnob.label = sprintf(3, "%.1f Hz", 10^(f_lfo_speed/15) - 1);
);
freeLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
dial_animation ? (
  freeLFOSpeedKnob.knob_draw_modifier((current_f_lfo_speed_slider*15 - f_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  freeLFOSpeedKnob.knob_draw_modifier((current_f_lfo_speed_slider*15 - f_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
freeLFOSpeedKnob.knob_draw_modifier(f_lfo_speed_vel / 20, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
freeLFOSpeedKnob.knob_draw_modifier(f_lfo_speed_mod / 20, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod1_color_a, 2);
activeModifier == 2 ? ( freeLFOSpeedKnob.knob_modifier_processMouse(0, f_lfo_speed_mod / 20) ? ( f_lfo_speed_mod = freeLFOSpeedKnob.value * 20; );
) : activeModifier == 1 ? ( freeLFOSpeedKnob.knob_modifier_processMouse(0, f_lfo_speed_vel / 20) ? ( f_lfo_speed_vel = freeLFOSpeedKnob.value * 20; );
) : (
  freeLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    f_lfo_speed = freeLFOSpeedKnob.value * 20;
    updateTempo();
    slider_automate(f_lfo_speed);
  );
);

cX += 1.85 * knobSize;

freeLFOPhaseKnob.active = f_lfo_enabled;
freeLFOPhaseKnob.value = (f_lfo_center_phase + 1) * .5;
freeLFOPhaseKnob.drawKnob(cX, cY - .6*knobSize, .5*knobSize, "", "Cutoff LFO Phase", 1.0);
freeLFOPhaseKnob.label = "Φ";
freeLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  f_lfo_center_phase = 2 * freeLFOPhaseKnob.value - 1;
  slider_automate(f_lfo_center_phase);
);

handleModifier("LINK", cX - .5 * knobSize, cY + .65 * knobSize, knobSize, knobSize, 3);

cX = xOrigin - 2*knobSpacing;
cY = cY + 4 * knobSize;

nextPanel = drawPanel(s_AMP_ENV, cX, cY - .53*panelHeight + .2*knobSize, 17.5*knobSpacing, panelHeight, 1);

style == 0 ? (
  gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
  gfx_rect(cX - 2.5*knobSpacing + 1, cY - .4*panelHeight - 1, 9 * (1+scaling), 9 * (1+scaling));
) : (
  sz = 10 * (1+scaling);
  xref = cX + 0.5*knobSpacing;
  yref = cY - .54*panelHeight;
  gfx_set(.1, midiChange*.7+.1, .1, midiChange); midiChange *= .95;
  gfx_rect(xref - .5 * sz, yref - .5 * sz - 1, sz, sz);
  
  r = 20*(1+scaling);
  loop(12,
    r -= 2*(1+scaling);
    gfx_set(.5, 1, .5, .5*midiChange / r);
    gfx_circle(xref - 1, yref - 3, r, 1);
  );
);

cX += 2 * knobSpacing + knobSize;

AMPLITUDE_SELECT_BUTTON = 10;
gfx_setfont(KNOB_FONT);
y_ref = cY - 1.25*knobSize - 1;

drawSelectionButton("Off", cX - 2*knobSize, y_ref + 0.5*y_move, ww, hh, 0, AMPLITUDE_SELECT_BUTTON, "No amplitude modulation.");
drawSelectionButton("MIDI", cX - 2*knobSize, y_ref + 1.5*y_move, ww, hh, 1, AMPLITUDE_SELECT_BUTTON, "Enable envelope by MIDI.");
drawSelectionButton("Thresh", cX - 2*knobSize, y_ref + 2.5*y_move, ww, hh, 2, AMPLITUDE_SELECT_BUTTON, "Thresholded.");
//drawSelectionButton("RMS", cX - 2*knobSize, y_ref + 3.5*y_move, ww, hh, 3, AMPLITUDE_SELECT_BUTTON, "Proportional to input RMS.");

cX += 1.25 * knobSpacing;

ampAccentKnob.active = amplitude_envelope_mode > 0;
ampAccentKnob.value = (amp_accent + 1) / 2;
ampAccentKnob.drawKnob(cX, cY, knobSize, "- Accent +", "Accent", 1.0);
ampAccentKnob.label = sprintf(16, "   %d %%%%", 100*amp_accent);
ampAccentKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  amp_accent = ampAccentKnob.value * 2 - 1;
  slider_automate(amp_accent);
);

preampToggle.inactive = amplitude_envelope_mode == 0;
preampToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, amp_before_filter, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enabling this places the amplitude envelope before the filter.\nThis takes away some control over the amplitude envelope,\nbut allows you to hear the filter decay.\n");
amp_before_filter = preampToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += knobSize*2.5;
resetToggle.inactive = amplitude_envelope_mode == 0;
resetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on note.");
reset = resetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

tempo_sync_envelopes ? ( ampAttackKnob.knob_set(getFastEnvelopeLabel(amp_atk), amplitude_envelope_mode > 0, amp_atk);
) : ampAttackKnob.knob_set(amp_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*amp_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*amp_atk))), amplitude_envelope_mode > 0, amp_atk);
ampAttackKnob.drawKnob(cX, cY, knobSize, "Attack", "Attack Time", 1.0);
dial_animation ? (
  ampAttackKnob.knob_draw_modifier(current_amp_atk - amp_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  ampAttackKnob.knob_draw_modifier(current_amp_atk - amp_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
ampAttackKnob.knob_draw_modifier(amp_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( ampAttackKnob.knob_modifier_processMouse(0, amp_atk_vel) ? ( amp_atk_vel = ampAttackKnob.value; );
) : ampAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( amp_atk = ampAttackKnob.value; slider_automate(amp_atk); );


cX += knobSize*2.5;

tempo_sync_envelopes ? ( ampDecayKnob.knob_set(getFastEnvelopeLabel(amp_decay), amplitude_envelope_mode > 0, amp_decay);
) : ampDecayKnob.knob_set(amp_decay > .5 ? sprintf(1, "%d ms", (30 * 10^(2*amp_decay))) : sprintf(1, "%.1f ms", (30 * 10^(2*amp_decay))), amplitude_envelope_mode > 0, amp_decay);
ampDecayKnob.drawKnob(cX, cY, knobSize, "Decay", "Decay Time", 1.0);
dial_animation ? (
  ampDecayKnob.knob_draw_modifier(current_amp_decay - amp_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  ampDecayKnob.knob_draw_modifier(current_amp_decay - amp_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
ampDecayKnob.knob_draw_modifier(amp_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( ampDecayKnob.knob_modifier_processMouse(0, amp_decay_vel) ? ( amp_decay_vel = ampDecayKnob.value; );
) : ampDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( amp_decay = ampDecayKnob.value; slider_automate(amp_decay); );
 

cX += 2.5 * knobSize;

ampSustainKnob.knob_set("", amplitude_envelope_mode > 0, amp_sustain);
( amplitude_envelope_mode < 2 ) ? ampSustainKnob.drawKnob(cX, cY, knobSize, "Sustain", "Sustain %", 1.0)
: ( amplitude_envelope_mode == 2 ) ? ampSustainKnob.drawKnob(cX, cY, knobSize, "Threshold", "Threshold [V]", 1.0);

dial_animation ? (
  ampSustainKnob.knob_draw_modifier(current_amp_sustain - amp_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  ampSustainKnob.knob_draw_modifier(current_amp_sustain - amp_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
ampSustainKnob.knob_draw_modifier(amp_sustain_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( ampSustainKnob.knob_modifier_processMouse(0, amp_sustain_vel) ? ( amp_sustain_vel = ampSustainKnob.value; );
) : ampSustainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( amp_sustain = ampSustainKnob.value; slider_automate(amp_sustain); );


cX = nextPanel + panelSpacing;

nextPanel = drawPanel(s_DIST, cX, cY - .53*panelHeight + .2*knobSize, 7.7*knobSpacing, panelHeight, shaper);
cX += 2.05 * knobSpacing;
shaperToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, shaper, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable waveshaper.");
shaper = shaperToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

higainToggle.inactive = !shaper;
higainToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, higain, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "High gain mode.");
higain = higainToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

distKnob.knob_set(sprintf(1, "%.1f dB", current_ceiling), shaper, current_ceiling / 48);
distKnob.drawKnob(cX, cY, knobSize, "Distortion", "Distortion level\n\nDistortion applied post-filter.", 0);
dial_animation ? (
  distKnob.knob_draw_modifier((cur_ceiling - current_ceiling) / 48, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
  distKnob.knob_draw_modifier((cur_ceiling - current_ceiling) / 48, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
);
distKnob.knob_draw_modifier(current_ceiling_vel / 48, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 1 ? ( distKnob.knob_modifier_processMouse(0, current_ceiling_vel / 48) ? ( current_ceiling_vel = distKnob.value * 48; );
) : distKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( current_ceiling = distKnob.value * 48; slider_automate(current_ceiling); );
 
cX += 2.5 * knobSize;

warmthKnob.active = shaper;
warmthKnob.value = (warmth + 12) / 24;
warmthKnob.drawKnob(cX, cY, knobSize, "Warmth", "Distortion warmth.\n\nApplies pre- and post-emphasis filters.", .5);
warmthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  warmth = warmthKnob.value * 24 - 12;
  slider_automate(warmth);
);

cX = nextPanel + panelSpacing;

// Effects panel
nextPanel = drawPanel(s_FX, cX, cY - .53*panelHeight + .2*knobSize, 4.125*knobSpacing, panelHeight, 1);

cX += 1.375 * knobSize;
chorusKnob.knob_set("", 1, chorus_enabled / 2);
chorusKnob.drawKnob(cX, cY, knobSize, "Space", "Bass preserving spatializer (pairs well with delay!)", 1.0);
chorusKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  chorus_enabled = chorusKnob.value * 2;
);
  
showOptions = 1;
showOptions ? (
  cX = nextPanel + panelSpacing;
  
  nextPanel = drawPanel(s_OPTS, cX, cY - .53*panelHeight + .2*knobSize, 7.75*knobSpacing, panelHeight, 1);
  cX += 2*knobSpacing;
  
  tempoSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, tempo_sync_envelopes, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use tempo synced envelopes.");
  tempo_sync_envelopes_tmp = tempoSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  tempo_sync_envelopes != tempo_sync_envelopes_tmp ? (
    tempo_sync_envelopes = tempo_sync_envelopes_tmp;
    tempo_sync_envelopes ? (
      amp_atk = to_synced(amp_atk, 1.0);
      amp_decay = to_synced(amp_decay, 0.1);
      cutoff_atk = to_synced(cutoff_atk, 1.0);
      cutoff_decay = to_synced(cutoff_decay, 0.1);
    ) : (
      amp_atk = to_non_synced(amp_atk, 1.0);
      amp_decay = to_non_synced(amp_decay, 0.1);
      cutoff_atk = to_non_synced(cutoff_atk, 1.0);
      cutoff_decay = to_non_synced(cutoff_decay, 0.1);
    );
  );
  
  
  oversamplingKnob.active = 1;
  oversampling != floor(oversamplingKnob.value * 7 + 1) ? (
    oversamplingKnob.value = (oversampling - 1) / 7;
  );
  oversamplingKnob.drawKnob(cX, cY, knobSize, "Oversampling", "Change the oversampling ratio. Some filters need this for stability.\nNote that it severely affects CPU cost though.", 1.0);
  oversamplingKnob.label = sprintf(7, "x%d", oversampling);
  oversamplingKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    newOversampling = floor(oversamplingKnob.value * 7 + 1);
    floor(newOversampling) != overSampling ? (
      oversampling = newOversampling;
      slider_automate(oversampling);
      updateSlider();
    );
  );
  
  cX += 2.5 * knobSize;
  inertiaKnob.active = 1;
  inertiaKnob.value = inertia / 200;
  inertiaKnob.label = sprintf(8, "%d ms", inertia);
  inertiaKnob.drawKnob(cX, cY, knobSize, "Inertia", "Sets how quickly parameters respond to changes.", 1.0);
  inertiaKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 60/200) ? (
    inertia = inertiaKnob.value * 200;
    slider_automate(inertia);
  );
);

cX += 2.25 * knobSize;

handleModifier("VEL", cX, cY - 1.15 * knobSize, knobSize, knobSize, 1);
handleModifier("MOD", cX, cY + .5 * knobSize, knobSize, knobSize, 2);


cX = xOrigin;
cY += 2.2 * knobSize;


gfx_set(0, 0, 0, 0);
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_set(1, 1, 1, 1);

warning > 0 ? (
  gfx_set(1,1,1,1);
  gfx_x = 0;
  gfx_y = 0;
  gfx_a = warning / 75;
  gfx_printf("Warning, cutoff clamped! Without oversampling, this non-linear filter cannot safely go to higher cutoff frequencies.");
  warning -= 1;
);

lcap = mouse_cap;

hinter.drawHint_draw();

gfx_x = cX;
gfx_y = cY + .3 * knobSize;
gfx_printf("ALPHA / WORK IN PROGRESS! If you make a sound you really like, make sure you freeze it as the filter is still subject to change!");
gfx_printf(" %d", midi.activeNoteMem[0]);
gfx_printf(" %d", midi.activeNoteMem[1]);
gfx_printf(" %d", midi.activeNoteMem[2]);
gfx_printf(" %d", midi.activeNoteMem[3]);
gfx_printf(" %d", midi.activeNoteMem[4]);
last_mouse_x = mouse_x;
last_mouse_y = mouse_y;

style == 2 ? (
  crt_t += .1;
  cy = 0;
  loop(gfx_h / 3,
    gfx_set(0, 0, 0, .3 + .15 * sin(.1*cy+crt_t));
    gfx_line(0, cy, gfx_w, cy);
    gfx_line(0, cy+1, gfx_w, cy+1);
    cy += 3;
  );
);
