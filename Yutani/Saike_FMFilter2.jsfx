desc:Saike FM Filter 2
tags: audio-rate filters
version: 0.23
author: Joep Vanlier
changelog: Support touch automation
license: MIT
about:
  # An FM filter plugin
  [Screenshot](https://user-images.githubusercontent.com/19836026/110242715-998d7900-7f57-11eb-8c6e-48b825b8f47e.gif)
  ### Features:
  - Anti-aliased oscillators.
  - 15 filters, from well behaved linear models, to gnarly analog modelled nastiness.
  - Audio and MIDI controllable filters.
  - Audio and MIDI controllable gate.
  - Three LFOs.
  - Modwheel and MIDI velocity support.
  - Stereo widening effect.
  - Distortion module.

  Attribution: Moog filter implementation was based on the paper:
  S. D'Angelo and V. Vaelimaeki, "Generalized Moog Ladder Filter: Part II - Explicit Non linear Model through a Novel Delay-Free
  Loop Implementation Method". IEEE Trans. Audio,Speech, and Lang. Process., vol. 22, no. 12, pp. 1873-1883, December 2014.
  303 emulation is Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
  minBLEP methodology Eli Brandt, "Hard Sync Without Aliasing"

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:placeholder=0<0,1,1>-Deprecated
slider2:placeholder=0<0,1,1>-Deprecated
slider3:placeholder=0<0,1,1>-Deprecated
slider4:placeholder=0<0,1,1>-Deprecated
slider5:placeholder=0<0,1,1>-Deprecated
slider6:placeholder=0<0,1,1>-Deprecated
slider7:placeholder=0<0,1,1>-Deprecated
slider8:placeholder=0<0,1,1>-Deprecated
slider9:glide_time=.4<0,1,.00001>-Deprecated
slider10:amplitude_envelope_mode=0<0,3,1{Off,MIDI Legato,Threshold,MIDI Triggered,Proportional}>-Amplitude Envelope Mode
slider11:filter_envelope_mode=0<0,4,1{Off,MIDI Legato,Threshold,MIDI Triggered,Proportional}>-Filter Envelope Mode
slider12:reset_fm_on_release=0<0,1,1>-reset_fm_on_release
slider13:placeholder=0<0,1,1>-Deprecated
slider14:placeholder=0<0,1,1>-Deprecated
slider15:placeholder=0<0,1,1>-Deprecated
slider16:placeholder=0<0,1,1>-Deprecated
slider17:placeholder=0<0,1,1>-Deprecated
slider18:placeholder=0<0,1,1>-Deprecated
slider19:placeholder=0<0,1,1>-Deprecated
slider20:placeholder=0<0,1,1>-Deprecated
slider21:placeholder=0<0,1,1>-Deprecated
slider22:placeholder=0<0,1,1>-Deprecated
slider23:placeholder=0<0,1,1>-Deprecated
slider24:placeholder=0<0,1,1>-Deprecated
slider25:filter_type=1<0,28,1{Linear,MS-20,Linear x2,Moog,Ladder,303,MS-20 asym,DblRes,DualPeak,TriplePeak,svf nl 2p,svf nl 4p,svf nl 2p inc,svf nl 4p inc,rectified resonance,Steiner,SteinerA,Muck,Pill2p,Pill4p,Pill2p Aggro,Pill4p Aggro,Pill2p Stacc,Pill4p Stacc,Ladder3,Ladder6,HLadder,SVF2,SVF4}>-Filter type
slider26:drive=0<-32,48,1>-Filter Drive (dB)
slider27:boost=0<-6,48,1>-Post Boost (dB)
slider28:cutoff=.6<0,1,.0001>-Cutoff
slider29:resonance=0.7<0,1,.0001>-Resonance
slider30:morph=0<0,1,.0001>-Morph

slider31:m_lfo_amnt=0<0,1,.00001>-Morph LFO amount
slider32:m_lfo_speed=0<0,20,.001>-Morph LFO speed [-]
slider33:m_lfo_phase=0<-1,1,.001>-Morph LFO phase
slider34:c_lfo_amnt=0<0,1,.00001>-Cutoff LFO amount
slider35:c_lfo_speed=0<0,20,.001>-Cutoff LFO speed [-]
slider36:c_lfo_phase=0<-1,1,.001>-Cutoff LFO phase

slider37:fm_mode=0<0,5,1{MIDI sin,MIDI square,Self,Self Abs,Audio Stereo 3/4,Audio Mono 3/4}>-FM mode
slider38:fm_amnt=0<0,1,.0001>-FM level
slider39:fm_factor=<-8,8,1>-FM rate factor
slider40:fm_spread=<0,1,.001>-FM spread
slider41:key_follow=0<0,1,.0001>-Key Follow
slider42:fm_cutoff=1<0,1,.0001>-FM Cutoff

slider43:env_amnt=0<-1,1,.0001>-Envelope Amount
slider44:cutoff_atk=0.5<0,1,.0001>-Cutoff Attack
slider45:cutoff_decay=0.5<0,1,.0001>-Cutoff Decay
slider46:cutoff_sustain=0<0,1,.0001>-Cutoff Sustain

slider47:cutoff_low_thresh=0<0,1,0.000001>-Cutoff lower threshold (RMS mode only)

slider48:current_ceiling=0<0,48,1>-Distortion level [dB]
slider49:warmth=0<-12,12,1>-Warmth

slider50:amplitude_low_thresh=0<0,1,1>-Amplitude lower threshold (RMS mode only)
slider51:placeholder=0<0,1,1>-Deprecated
slider52:placeholder=0<0,1,1>-Deprecated

slider53:fb=0<0, 1, .000001>-Feedback

slider54:placeholder=0<0,1,1>-Deprecated
slider55:amp_atk=0<0,1,0.000001>-Amplitude Envelope Attack
slider56:amp_decay=0<0,1,0.000001>-Amplitude Envelopep Decay
slider57:amp_sustain=0<0,1,0.00001>-Amplitude Envelope Sustain
slider58:pitchBendRange=0<0,12,1>-Pitch bend range

slider59:f_lfo_amnt=0<0,1,.00001>-Free LFO amount
slider60:f_lfo_speed=0<0,20,.001>-Free LFO speed [-]

slider61:fm_fine=0<0,1,.00001>-fine tune FM

slider62:fix_dc=1<0,1,1>-Fix DC
slider63:inertia=60<0,200,.001>-Filter Inertia [ms]
slider64:oversampling=1<1,8,1>-Oversampling

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import Saike_Yutani_midilib.jsfx-inc
import Saike_Yutani_distortion.jsfx-inc
import Saike_Yutani_Envelope.jsfx-inc
import Saike_Yutani_interpolators.jsfx-inc
import Saike_Yutani_filters.jsfx-inc
import Saike_Yutani_oversampling.jsfx-inc
import Saike_Yutani_upsamplers.jsfx-inc
import Saike_Yutani_widgets.jsfx-inc
import Saike_Yutani_sample_delay_buffer.jsfx-inc
import Saike_Yutani_LFOs.jsfx-inc
import Saike_Yutani_Delays.jsfx-inc

@init
TENSION_FACTOR = log(2) * 4;
gfx_ext_retina == 0 ? gfx_ext_retina = 1;
style = 1;
lastOversample = 0;

two_pi = 2 * $pi;
freemem = 0;

function init_tresh_window(freemem, buffer_size)
instance()
local()
global()
(
  this.initBuffer(freemem, freemem + buffer_size);
  
  freemem + buffer_size + 2
);

function update_thresh_window(thresh, env)
instance(read_ptr, write_ptr)
local()
global()
(
  read_ptr = write_ptr;
  this.writeBuffer(thresh);
  this.writeBuffer(env);
);

function init_rms_window(buffer, max_samples)
local()
instance(current_samples, buffer_start, buffer_end, current_window, write_ptr, running_tally)
global()
(
  write_ptr = buffer_start = buffer;
  buffer_end = buffer_start + max_samples;
  current_window = -1; // Force reinit
  running_tally = 0;
  
  buffer_start 
);

function rms_window(sample, target_window)
instance(buffer_start, buffer_end, write_ptr, current_window, running_tally)
local(read_ptr)
global()
(
  target_window = floor(target_window);
  (target_window != current_window) ? (
    current_window = target_window;
    // Rerun window
    read_ptr = write_ptr - current_window;
    read_ptr < buffer_start ? read_ptr += buffer_end - buffer_start;
    
    running_tally = 0;
    loop(current_window,
      running_tally += read_ptr[];
      read_ptr += 1;
      read_ptr == buffer_end ? read_ptr = buffer_start;
    );
  );

  read_ptr = write_ptr - current_window;
  read_ptr < buffer_start ? read_ptr += buffer_end - buffer_start;
  running_tally += sample - read_ptr[];

  write_ptr[] = sample;
  write_ptr += 1;
  write_ptr == buffer_end ? write_ptr = buffer_start;

  sqrt(running_tally / current_window)
);

function checkline(x, ty, w, h, label)
local(tol, over, ww, hh)
global(mouse_cap, mouse_x, mouse_y, gfx_x, gfx_y)
instance()
(
  tol = 6;
  gfx_set(0.3, 0.3, 1, 1);
  gfx_line(x, ty, x + w, ty);
  gfx_line(x, ty - 1, x + w, ty - 1);
  
  label ? (
    gfx_measurestr(label, ww, hh);
    gfx_x = x;
    gfx_y = ty - hh - 2;
    gfx_printf(label);
  );
  
  over = (mouse_x > x) && (mouse_x < (x + w)) && (mouse_y > (ty - tol)) && (mouse_y < (ty + tol));
  over ? (
    gfx_set(0.5, 0.4, 1, 1.0 * abs(sin(3 * time_precise())));
    gfx_line(x, ty + 1, x + w, ty + 1);
    gfx_line(x, ty - 2, x + w, ty - 2);
  );
  
  over
);

// Unfortunately, the second threshold is handled based on a instance side effect. The second
// threshold only appears when normalized_lower_thresh is set to a value < 10. When doing so, 
// it will emit a value in the instance variable lower_thresh_changed when changed. The same 
// rules apply, if the value is below 10, then it was changed.
function draw_thresh_window(x, y, w, h, normalized_thresh_value, normalized_lower_thresh)
instance(buffer, buffer_max, read_ptr, grabbed, last_cap, last_mouse_y, lower_thresh_changed)
local(samples_per_pixel, sample_count, ptr, acc_thresh, acc_env, icount, thresh_last, env_last,
      xp, yp, min_val, max_val, scale, loga,
      transformed_thresh_value, over, over_lower,
      new_value, transformed_lower_thresh_value)
global(mouse_cap, mouse_y)
(
  new_value = normalized_thresh_value;
  lower_thresh_changed = 10; // zero means it was unchanged
  sample_count = 20000;
  samples_per_pixel = max(1, floor(sample_count / w));
  icount = 1.0 / samples_per_pixel;
  
  gfx_set(0, 0, 0, 0.7);
  gfx_rect(x, y, w, h);
  
  loga = 1;
  loga ? (
    min_val = -32;
    max_val = 0;
    scale = h / (max_val - min_val);
    
    transformed_thresh_value = 10 * log10(normalized_thresh_value) -  min_val;
    transformed_lower_thresh_value = normalized_lower_thresh < 10 ? 10 * log10(normalized_lower_thresh) -  min_val : 10;
  ) : (
    min_val = 0;
    max_val = 1;
    scale = h;
    transformed_thresh_value = normalized_thresh_value;
    transformed_lower_thresh_value = normalized_lower_thresh < 10 ? normalized_lower_thresh : 10;
  );
  
  
  grabbed ? (
    (mouse_cap & 1) == 0 ? (
      grabbed = 0;
    ) : (
      (grabbed == 1) ? (
        new_value = transformed_thresh_value - (mouse_y - last_mouse_y) / scale;
        new_value = min(max_val - min_val, max(0, new_value));
        loga ? (
          new_value = pow(10, (new_value + min_val) / 10);
        );
      ) : (grabbed == 2) ? (
        lower_thresh_changed = transformed_lower_thresh_value - (mouse_y - last_mouse_y) / scale;
        lower_thresh_changed = min(max_val - min_val, max(0, lower_thresh_changed));
        loga ? (
          lower_thresh_changed = pow(10, (lower_thresh_changed + min_val) / 10);
        );
      );
    );
  );
  
  over = checkline(x, y + h - scale * transformed_thresh_value, w, h, 0);
  over_lower = (normalized_lower_thresh < 10) ? checkline(x, y + h - scale * transformed_lower_thresh_value, w, h, " Low");
  (mouse_cap & 1 == 1) && (last_cap == 0) ? (
    over ? (
      grabbed = 1;
    ) : ( over_lower ) ? (
      grabbed = 2;
    );
  );
  
  ptr = read_ptr - 4;
  thresh_last =  max(0, min(h, loga ? scale * (10 * log10(ptr[0]) - min_val) : scale * ptr[0]));
  env_last = ptr[1] * h;
  xp = x + w;
  loop(w,
    acc_thresh = 0;
    acc_env = 0;
    
    loop(samples_per_pixel,
      acc_thresh = max(acc_thresh, ptr[]);
      acc_env += ptr[1];
      ptr -= 2;
      ptr < buffer ? ptr += (buffer_max - buffer) - 1;
    );
    acc_env *= icount * h;
    
    acc_thresh = loga ? scale * (10 * log10(acc_thresh) - min_val) : scale * acc_thresh;
    acc_thresh = max(0, min(h, acc_thresh));
    
    gfx_set(0.2, 1.0, 0.2, 0.1);
    gfx_line(xp, y + h, xp - 1, y + h - acc_env, 1);
    gfx_set(0.2, 1.0, 0.2, 1.0);
    gfx_line(xp, y + h - env_last, xp - 1, y + h - acc_env, 1);
    gfx_line(xp, y + h - env_last - 1, xp - 1, y + h - acc_env - 1, 1);
    gfx_set(1.0, 0.2, 1.0, 0.1);
    gfx_line(xp, y + h, xp - 1, y + h - acc_thresh, 1);
    gfx_set(1.0, 0.2, 1.0, 1.0);
    gfx_line(xp, y + h - thresh_last, xp - 1, y + h - acc_thresh, 1);
    gfx_line(xp, y + h - thresh_last - 1, xp - 1, y + h - acc_thresh - 1, 1);
    xp -= 1;
    
    thresh_last = acc_thresh;
    env_last = acc_env;
  );
  
  
  
  //gfx_set(0.1, 0.3, 0.1, 1.0);
  //gfx_rect(x - 1, y - 1, w + 2, h + 2, 0);
  
  last_cap = mouse_cap;
  last_mouse_y = mouse_y;
  
  new_value
);

freemem = (midimem = freemem) + 32768;
freemem = (note_history = freemem) + 32768;
midi.initializeMIDI(midimem, note_history, 1, 1);
midi.notesOn = 0;

/* Oversampling memory */
freemem = (sinc_hist1 = freemem) + 10000;
freemem = (sinc_hist2 = freemem) + 10000;
freemem = (sinc_flt = freemem) + 10000;
freemem = (sinc_flt2 = freemem) + 10000;
freemem = (sinc_flt3 = freemem) + 10000;
freemem = (sinc_flt4 = freemem) + 10000;
freemem = (sinc_tmp = freemem) + 10000;

freemem = (l_buffer = freemem) + 2001;
freemem = (r_buffer = freemem) + 2001;

freemem = filter_thresh.init_tresh_window(freemem, 50000);
freemem = amplitude_thresh.init_tresh_window(freemem, 50000);

rms_buffer_size = 0.4 * 96000;
freemem = filter_rms.init_rms_window(freemem, rms_buffer_size);
freemem = amplitude_rms.init_rms_window(freemem, rms_buffer_size);

// Chorus materials
l_delay.initBuffer(l_buffer, l_buffer + 2000);
r_delay.initBuffer(r_buffer, r_buffer + 2000);
l_delay_filt.init_linearSVF_absolute(340, 0);
r_delay_filt.init_linearSVF_absolute(340, 0);

function initialize_interpolators()
(
  // Set up the interpolators
  cutoff_interpolator.interpolator_init(28);
  reso_interpolator.interpolator_init(29);
  morph_interpolator.interpolator_init(30);
  drive_interpolator.interpolator_init(26);
  gain_interpolator.interpolator_init(27);
  morph_phase_interpolator.interpolator_init(33);
  cutoff_phase_interpolator.interpolator_init(36);
    
  current_ceiling_interpolator.interpolator_init(48);
  warmth_interpolator.interpolator_init(49);
     
  (last_inertia != inertia) ? (
    last_inertia = inertia;
    inertia_cutoff = 1000.0/inertia;
    cutoff_interpolator.initialize_smoother(inertia_cutoff);
    reso_interpolator.initialize_smoother(inertia_cutoff);
    morph_interpolator.initialize_smoother(inertia_cutoff);
    drive_interpolator.initialize_smoother(inertia_cutoff);
    gain_interpolator.initialize_smoother(inertia_cutoff);
    morph_phase_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_phase_interpolator.initialize_smoother(inertia_cutoff);
    current_ceiling_interpolator.initialize_smoother(inertia_cutoff);
    warmth_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_interpolator.s = slider(28);
    reso_interpolator.s = slider(29);
    morph_interpolator.s = slider(30);
    drive_interpolator.s = slider(26);
    gain_interpolator.s = slider(27);
    morph_phase_interpolator.s = slider(33);
    cutoff_phase_interpolator.s = slider(36);
    current_ceiling_interpolator.s = slider(45);
    warmth_interpolator.s = slider(46);
  );
);

function updateFMFilter()
local()
global(FM_filter.init_linearSVF, FM_filter2.init_linearSVF, fm_cutoff, last_fm_cutoff)
instance()
(
  (fm_cutoff != last_fm_cutoff) ? (
    FM_filter.init_linearSVF(fm_cutoff, 0);
    FM_filter2.init_linearSVF(fm_cutoff, 0);
    last_fm_cutoff = fm_cutoff;
  );
);

function updateSlider()
(
  current_safety_moog = (1.0 - log(safety_limit_moog * oversampling) / log(20/22050));
  initialize_interpolators();
  check_safety();
);

function updateTempo()
(
  cutoff_LFO.envelopeTempo((c_lfo_speed+c_lfo_speed_velmod + c_lfo_speed_mod * mod_level + c_lfo_speed_flfo * free_lfo)/20);
  morph_LFO.envelopeTempo((m_lfo_speed+m_lfo_speed_velmod + m_lfo_speed_mod * mod_level)/20);
  free_LFO.envelopeTempo((f_lfo_speed+f_lfo_speed_velmod + f_lfo_speed_mod * mod_level)/20);
);

last_fm_cutoff = -1;
updateSlider();
UpdateFMFilter();

@serialize
file_var(0, 1); // Version
file_var(0, m_lfo_sync);
file_var(0, c_lfo_sync);
file_var(0, shaper);
file_var(0, higain);
file_var(0, reset);
file_var(0, cutoff_reset);

file_var(0, cutoff_vel);
file_var(0, reso_vel);
file_var(0, morph_vel);

file_var(0, fm_amnt_vel);
file_var(0, fm_spread_vel);
    
file_var(0, cutoff_atk_vel);
file_var(0, cutoff_decay_vel);
file_var(0, cutoff_sustain_vel);
     
file_var(0, amp_atk_vel);
file_var(0, amp_decay_vel);
file_var(0, amp_sustain_vel);
file_var(0, env_amnt_vel);

file_var(0, drive_vel);
file_var(0, boost_vel);

file_var(0, c_lfo_reset);
file_var(0, m_lfo_reset);

file_var(0, fb_mode);
file_var(0, fb_vel);

file_var(0, m_lfo_center_phase);
file_var(0, c_lfo_center_phase);

file_var(0, m_lfo_type);
file_var(0, c_lfo_type);

file_var(0, c_lfo_amnt_vel);
file_var(0, c_lfo_speed_vel);
file_var(0, m_lfo_amnt_vel);
file_var(0, m_lfo_speed_vel);

file_var(0, c_lfo_enabled);
file_var(0, m_lfo_enabled);
file_var(0, randomness_level);

file_var(0, cutoff_mod);
file_var(0, reso_mod);
file_var(0, fm_amnt_mod);

file_var(0, c_lfo_amnt_mod);
file_var(0, m_lfo_amnt_mod);
file_var(0, c_lfo_speed_mod);
file_var(0, m_lfo_speed_mod);

file_var(0, chorus_enabled);
file_var(0, tempo_sync_envelopes);

file_var(0, f_lfo_type);
file_var(0, f_lfo_sync);
file_var(0, f_lfo_reset);
file_var(0, f_lfo_enabled);
file_var(0, f_lfo_amnt_mod);
file_var(0, f_lfo_amnt_vel);
file_var(0, f_lfo_speed_mod);
file_var(0, f_lfo_speed_vel);
file_var(0, f_lfo_center_phase);

file_var(0, cutoff_flfo);
file_var(0, reso_flfo);
file_var(0, fm_amnt_flfo);
file_var(0, c_lfo_amnt_flfo);
file_var(0, c_lfo_speed_flfo);

file_var(0, eco);

loop(198,
  file_var(0, 0);
);

@slider
updateSlider();

@block
current_filter_rms_window = 0.003 * 10^(2*cutoff_atk) * srate;
current_amplitude_rms_window = 0.003 * 10^(2*amp_atk) * srate;

sampling_ratio = legacy_mode ? 1 : 44100 / srate;
sampling_factor = oversampling / sampling_ratio;
isampling_factor = 1 / sampling_factor;

israte = 1.0 / srate;
israte_radian = 2.0*$pi*israte;
vib_factor = 16 * $pi * israte;
reference_frequency = 440 * israte;
pitch_bend_factor = floor(pitchBendRange) * 0.08333333333333333333333333333333333;

midi.processMIDIBlock(); 

cutoff_interpolator.interpolator_block();
reso_interpolator.interpolator_block();
morph_interpolator.interpolator_block();
drive_interpolator.interpolator_block();
gain_interpolator.interpolator_block();
morph_phase_interpolator.interpolator_block();
cutoff_phase_interpolator.interpolator_block();
current_ceiling_interpolator.interpolator_block();
warmth_interpolator.interpolator_block();


oversampling_method = 1;

oversampling_method == 1 ? (
  curFIRdelay = getFIRdelay(oversampling); 
  (pdc_delay != curFIRdelay) ? (
    pdc_top_ch = 2;
    pdc_bot_ch = 0;
    pdc_delay = curFIRdelay;
    lastOversample = oversampling;
  );
) : (
  // Memory for the sincs is located at sinc_tmp, sinc_flt, sinc_flt2, sinc_flt3 and sinc_flt4
  (pdc_delay != 7) ? (
    sincFilterL.updateSincFilter(oversampling, 8, sinc_flt,  sinc_tmp);
    sincFilterR.updateSincFilter(oversampling, 8, sinc_flt2, sinc_tmp);
    nTapSinc = oversampling < 5 ? 16 : oversampling*4;
    sincDownL.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist1, sinc_flt3);
    sincDownR.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist2, sinc_flt4);
    pdc_top_ch = 2;
    pdc_bot_ch = 0;
    pdc_delay = 7;
  );
);

@sample
function updateCurrentVelocitySettings()
(
  shouldUpdateCurrentVelocitySettings = 0;

  cutoff_velmod = cutoff_vel * midi.lastVel;
  reso_velmod = reso_vel * midi.lastVel;
  morph_velmod = morph_vel * midi.lastVel;
    
  current_fm_amnt = fm_amnt + fm_amnt_vel * midi.lastVel + fm_amnt_mw;
  current_fm_spread = fm_spread + fm_spread_vel * midi.lastVel;
  current_env_amnt = clamp(env_amnt + env_amnt_vel * midi.lastVel, -1, 1);
     
  drive_velmod = drive_vel * midi.lastVel;
  boost_velmod = boost_vel * midi.lastVel;
    
  c_lfo_amnt_velmod = c_lfo_amnt_vel * midi.lastVel;
  m_lfo_amnt_velmod = m_lfo_amnt_vel * midi.lastVel;
  f_lfo_amnt_velmod = f_lfo_amnt_vel * midi.lastVel;
  c_lfo_speed_velmod = c_lfo_speed_vel * midi.lastVel;
  m_lfo_speed_velmod = m_lfo_speed_vel * midi.lastVel;
  f_lfo_speed_velmod = f_lfo_speed_vel * midi.lastVel;
    
  current_fb = .99 * cl01(fb + fb_vel * midi.lastVel);
  
  current_amp_atk = cl01(amp_atk + amp_atk_vel * midi.lastVel);
  current_amp_decay = cl01(amp_decay + amp_decay_vel * midi.lastVel);
  current_amp_sustain = cl01(amp_sustain + amp_sustain_vel * midi.lastVel);
  
  current_cutoff_atk = cl01(cutoff_atk + cutoff_atk_vel * midi.lastVel);
  current_cutoff_decay = cl01(cutoff_decay + cutoff_decay_vel * midi.lastVel);
  current_cutoff_sustain = cl01(cutoff_sustain + cutoff_sustain_vel * midi.lastVel);
  
  tempo_sync_envelopes ? (
    amp_env.calc_times_sync(current_amp_atk, current_amp_decay, current_amp_sustain);
    cutoff_env.calc_times_sync(current_cutoff_atk, current_cutoff_decay, current_cutoff_sustain);
  ) : (
    amp_env.calc_times(current_amp_atk, current_amp_decay, current_amp_sustain);
    cutoff_env.calc_times(current_cutoff_atk, current_cutoff_decay, current_cutoff_sustain);
  );
  !cutoff_reset ? cutoff_env.k_rise = .25*cutoff_env.k_rise;
);

// Force an update when knobs are touched
shouldUpdateCurrentVelocitySettings ? updateCurrentVelocitySettings();

shaper ? (
  cur_ceiling = clamp(current_ceiling_interpolator.interpolate() + current_ceiling_vel * midi.lastVel, 0, 48);
  sat_slider_update(cur_ceiling, warmth_interpolator.interpolate(), oversampling);
);

lf_update_step += 1;
lf_update_step % 8 == 0 ? (
  updateTempo();
  
  mod_level = midi.smoothWheel;
  
  cutoff_mw = cutoff_mod * mod_level + cutoff_flfo * free_lfo;
  reso_mw = reso_mod * mod_level + reso_flfo * free_lfo;
  fm_amnt_mw = fm_amnt_mod * mod_level + fm_amnt_flfo * free_lfo;
  current_fm_amnt = fm_amnt + fm_amnt_vel * midi.lastVel + fm_amnt_mw;
  c_lfo_amnt_mw = c_lfo_amnt_mod * mod_level + c_lfo_amnt_flfo * free_lfo;
  m_lfo_amnt_mw = m_lfo_amnt_mod * mod_level;
  f_lfo_amnt_mw = f_lfo_amnt_mod * mod_level;
  
  lf_update_step = 0;
  
  current_c_lfo_speed_slider = (c_lfo_speed + c_lfo_speed_velmod + c_lfo_speed_mod * mod_level + c_lfo_speed_flfo * free_lfo)*0.06666666666666666666666666666667;
  current_m_lfo_speed_slider = (m_lfo_speed + m_lfo_speed_velmod + m_lfo_speed_mod * mod_level)*0.06666666666666666666666666666667;
  current_f_lfo_speed_slider = (f_lfo_speed + f_lfo_speed_velmod + f_lfo_speed_mod * mod_level)*0.06666666666666666666666666666667;
  
  current_c_lfo_speed = 10^(current_c_lfo_speed_slider) - 1;
  current_m_lfo_speed = 10^(current_m_lfo_speed_slider) - 1;
  current_f_lfo_speed = 10^(current_f_lfo_speed_slider) - 1;
);

(mmsg = midi.processMIDISample()) ? (
  midiChange = 1;
  
  (midi.newNote || reset_fm_on_release) ? ( FM_t = 0; );
  pitch = 2^((midi.lastNote - 69)/12);
  keyfollow_mod = log(pitch) / log(20/22050);
  
  current_note_played =  midi.lastNote - 69;
 
  new_trigger = (note_mode == 0) ? ( midi.notesOn > 0 && ((midi.notesOn == midi.lastNotesOn) || midi.lastNotesOn == 0) )
  : (note_mode == 1) ? ( 1 );
 
  new_trigger && mmsg == 1 ? (
    updateCurrentVelocitySettings();
    
    c_lfo_reset ? c_lfo_time = c_lfo_center_phase;
    m_lfo_reset ? m_lfo_time = m_lfo_center_phase;
    f_lfo_reset ? f_lfo_time = f_lfo_center_phase;
    
    amp_env.reset_envelope(reset && amp_before_filter);
    cutoff_env.reset_envelope(cutoff_reset);
  );
);

// TODO: Only update when a change is made
current_fm_spread = fm_spread + fm_spread_vel * midi.lastVel;
current_env_amnt = clamp(env_amnt + env_amnt_vel * midi.lastVel, -1, 1);
tempo_sync_envelopes ? (
  amp_env.calc_times_sync(cl01(amp_atk + amp_atk_vel), cl01(amp_decay + amp_decay_vel), cl01(amp_sustain + amp_sustain_vel));
  cutoff_env.calc_times_sync(cl01(cutoff_atk + cutoff_atk_vel), cl01(cutoff_decay + cutoff_decay_vel), cl01(cutoff_sustain + cutoff_sustain_vel));
) : (
  amp_env.calc_times(cl01(amp_atk + amp_atk_vel), cl01(amp_decay + amp_decay_vel), cl01(amp_sustain + amp_sustain_vel));
  cutoff_env.calc_times(cl01(cutoff_atk + cutoff_atk_vel), cl01(cutoff_decay + cutoff_decay_vel), cl01(cutoff_sustain + cutoff_sustain_vel));
);
// END TODO

m_notes_on = midi.notesOn > 0;

amp_envelope = 
  (amplitude_envelope_mode == 0) ? 1 :
  (amplitude_envelope_mode == 1) ? amp_env.update_envelope(m_notes_on) : 
  (amplitude_envelope_mode == 2) ? (
    amp_meter = max(abs(spl0), abs(spl1));
    amplitude_env = amp_env.follower(amp_meter > amp_sustain);
    
    amplitude_thresh.update_thresh_window(amp_meter, amplitude_env);
    amp_env
  ) : (amplitude_envelope_mode == 3) ? (
    midi.newNote ? amp_env.tEnvelope = 0;
    amp_env.update_envelope(m_notes_on)
  ) : (amplitude_envelope_mode == 4) ? (
    amp_meter = amplitude_rms.rms_window(spl0 * spl0 + spl1 * spl1, current_amplitude_rms_window);
    amp_env = max(0.0, min(1.0, (amp_meter - amplitude_low_thresh) / (current_amp_sustain - amplitude_low_thresh)));
    
    amp_env = pow(amp_env, exp(TENSION_FACTOR * (current_amp_decay - 0.5)));
    amplitude_thresh.update_thresh_window(amp_meter, amp_env);
    amp_env
  ) : 0;

cutoff_envelope = 
  (filter_envelope_mode == 0) ? 0 :
  (filter_envelope_mode == 1) ? cutoff_env.update_envelope(m_notes_on) :
  (filter_envelope_mode == 2) ? (
    filt_meter = max(abs(spl0), abs(spl1));
    filt_env = cutoff_env.follower(filt_meter > cutoff_sustain);
    
    filter_thresh.update_thresh_window(filt_meter, filt_env);
    filt_env
  ) : 
  (filter_envelope_mode == 3) ? (
    midi.newNote ? cutoff_env.tEnvelope = 0;
    cutoff_env.update_envelope(m_notes_on)
  ) : (filter_envelope_mode == 4) ? (
    filt_meter = filter_rms.rms_window(spl0 * spl0 + spl1 * spl1, current_filter_rms_window);
    
    filt_env = max(0.0, min(1.0, (filt_meter - cutoff_low_thresh) / (current_cutoff_sustain - cutoff_low_thresh)));
    filt_env = pow(filt_env, exp(TENSION_FACTOR * (current_cutoff_decay - 0.5)));
    
    filter_thresh.update_thresh_window(filt_meter, filt_env);
    filt_env
  ) : 0;


// Filter modulation section
  sliderCutoffL = sliderCutoffR = cutoff_interpolator.interpolate() + cutoff_velmod + cutoff_mw;
  sliderReso = clamp(reso_interpolator.interpolate() + reso_velmod + reso_mw, 0, 1);
  sliderMorphL = sliderMorphR = morph_interpolator.interpolate() + morph_velmod;
  morph_phase = morph_phase_interpolator.interpolate();
  cutoff_phase = cutoff_phase_interpolator.interpolate();

  sliderCutoffL += cutoff_envelope * current_env_amnt;
  sliderCutoffR += cutoff_envelope * current_env_amnt;
  sliderCutoffL -= key_follow * keyfollow_mod;
  sliderCutoffR -= key_follow * keyfollow_mod;

  function naiveTri(t)
  (
    t -= floor(t);
    t <= 0.5 ? (
      (4.0 * t - 1.0)
    ) : (
      (3.0 - 4.0 * t)
    )
  );
  
  function naiveSqr(t)
  (
    t -= floor(t);
    (2.0 * (t > 0.5) - 1.0)
  );

  // FM modulation of the filter
  current_fm_amnt != 0 ? (
    updateFMFilter();
    FM_t += (2^(floor(fm_factor) + pitch_bend_factor * midi.pitchBend)) * reference_frequency * pitch;
    
    fm_mode == 0 ? (
      fm_mod1 = sin(two_pi*FM_t);
      fm_mod2 = sin(two_pi*FM_t+$pi*current_fm_spread);
    ) : ( fm_mode == 1 ) ? (
      fm_mod1 = abs(sin(two_pi*FM_t)) * 2 - 1;
      fm_mod2 = abs(sin(two_pi*FM_t+$pi*current_fm_spread)) * 2 - 1;
    ) : ( fm_mode == 2 ) ? (
      avg = .5 * (spl0 + spl1);
      side = .5 * (spl0 - spl1);
      fm_mod1 = FM_filter.eval_linearSVF_LP(avg + 2 * current_fm_spread * side);
      fm_mod2 = FM_filter2.eval_linearSVF_LP(avg - 2 * current_fm_spread * side);
    ) : ( fm_mode == 3 ) ? (
      avg = .5 * (spl0 + spl1);
      side = .5 * (spl0 - spl1);
      fm_mod1 = FM_filter.eval_linearSVF_LP(avg + 2 * current_fm_spread * side);
      fm_mod2 = FM_filter2.eval_linearSVF_LP(avg - 2 * current_fm_spread * side);
    ) : ( fm_mode == 4 ) ? (
      fm_mod1 = naiveTri(FM_t);
      fm_mod2 = naiveTri(FM_t + .5*current_fm_spread);
    ) : ( fm_mode == 5 ) ? (
      fm_mod1 = naiveSqr(FM_t);
      fm_mod2 = naiveSqr(FM_t + .5*current_fm_spread);
    );
  );
  
  c_lfo_enabled ? (
    c_lfo_sync ? (
      c_lfo_time += israte * cutoff_LFO.cRate;
    ) : (
      c_lfo_time += israte * current_c_lfo_speed;    
    );
    current_c_lfo_amnt = c_lfo_amnt + c_lfo_amnt_velmod + c_lfo_amnt_mw;
    sliderCutoffL = sliderCutoffL + current_c_lfo_amnt * c_left.lfo_modulator(c_lfo_type, c_lfo_time + cutoff_phase);
    sliderCutoffR = sliderCutoffR + current_c_lfo_amnt * c_right.lfo_modulator(c_lfo_type, c_lfo_time);
    c_lfo_type == 17 && cutoff_phase == 0 ? (
      sliderCutoffR = sliderCutoffL;
    );
  );
  
  m_lfo_enabled > 0 ? (
    m_lfo_sync ? (
      m_lfo_time += israte * morph_LFO.cRate;
    ) : (
      m_lfo_time += israte * current_m_lfo_speed;    
    );
    current_m_lfo_amnt = m_lfo_amnt + m_lfo_amnt_velmod + m_lfo_amnt_mw;
    sliderMorphL = sliderMorphL + current_m_lfo_amnt * m_left.lfo_modulator(m_lfo_type, m_lfo_time + morph_phase);
    sliderMorphR = sliderMorphR + current_m_lfo_amnt * m_right.lfo_modulator(m_lfo_type, m_lfo_time);
    c_lfo_type == 17 && morph_phase == 0 ? (
      sliderMorphL = sliderMorphR;
    );
  );
  
  f_lfo_enabled > 0 ? (
    f_lfo_sync ? (
      f_lfo_time += israte * free_LFO.cRate;
    ) : (
      f_lfo_time += israte * current_f_lfo_speed;    
    );
    current_f_lfo_amnt = cl01(f_lfo_amnt + f_lfo_amnt_velmod + f_lfo_amnt_mw);
    free_lfo = current_f_lfo_amnt * f_lfo.lfo_modulator(f_lfo_type, f_lfo_time + f_lfo_phase);
  ) : free_lfo = current_f_lfo_amnt = 0;
  
  sliderMorphL = clamp(sliderMorphL, 0, 1);
  sliderMorphR = clamp(sliderMorphR, 0, 1);
  
  sliderCutoffL = clamp(sliderCutoffL + current_fm_amnt * fm_mod1, 0, .99);
  sliderCutoffR = clamp(sliderCutoffR + current_fm_amnt * fm_mod2, 0, .99);

  eco ? (
    c == 0 ? filter.init_filter(filter_type, sliderCutoffL, sliderCutoffR, sliderMorphL, sliderMorphR, sliderReso);
    c += 1;
    c > 4 ? c = 0;
  ) : ( 
    filter.init_filter(filter_type, sliderCutoffL, sliderCutoffR, sliderMorphL, sliderMorphR, sliderReso);
  );
  
  // Gain setup
  log10d20_conversion  = .11512925464970228420089957273422;
  
  current_drive = clamp(drive_interpolator.interpolate() + drive_velmod, -6, 48);
  current_boost = clamp(gain_interpolator.interpolate() + boost_velmod, -6, 48);
  preamp      = exp(log10d20_conversion*current_drive);
  inv_preamp  = exp(-log10d20_conversion*current_drive);
  final_boost = exp(log10d20_conversion*current_boost);
  
  yl = spl0 * preamp;
  yr = spl1 * preamp;
  
  fb_mode == 0 ? (
    fb ? (
      !(filter_type == 0 || filter_type == 2) ? (
        filter_type == 5 ? (
          fb_factor = current_fb * (1-cutoff);
          yl += fb_factor * last_yl;
          yr += fb_factor * last_yr;
          gc = 1/(1+2*fb_factor);
          yl *= gc;
          yr *= gc; 
        ) : (filter_type == 1 || filter_type == 6) ? (
          yl += current_fb * last_yl;
          yr += current_fb * last_yr;
          gc = 1/(1+1.5*current_fb);
          yl *= gc;
          yr *= gc;      
        ) : (
          yl -= current_fb * last_yl;
          yr -= current_fb * last_yr;
          gc = 1/(1+1.25*current_fb);
          yl *= gc;
          yr *= gc;
        );
      );
    );
  ) : (
    !(filter_type == 0 || filter_type == 2) ? (
      yl += current_fb * lyl;
      yr += current_fb * lyr;
  
      lyl = yl;
      lyr = yr;
    );
  );
  
  hotness_rmsq = .9999 * hotness_rms + .0001 * yl * yl;
  
  amp_before_filter ? (
    yl *= amp_envelope;
    yr *= amp_envelope;
  );
  
  // Oversampled processing
  ( oversampling > 1 ) ? (
    ( oversampling_method == 1 ) ? (
      upsampleL.updateUpHist(overSampling, yl);
      upsampleR.updateUpHist(overSampling, yr);
      
      f = 0;
      loop(overSampling,
        f += 1;
        ssl = overSampling*upsampleL.upSample(overSampling);
        ssr = overSampling*upsampleR.upSample(overSampling);
      
        filter.processSample(filter_type);
        ssl *= inv_preamp;
        ssr *= inv_preamp;
        shaper ? processShaper();
        
        downL.updateDownHist(overSampling, ssl);
        downR.updateDownHist(overSampling, ssr);
        
        ( f == 1 ) ? (
          spl0 = downL.downSample(overSampling);
          spl1 = downR.downSample(overSampling);
        );
      );
    ) : (
      sincFilterL.advanceSinc(yl);
      sincFilterR.advanceSinc(yr);
      
      loop( oversampling,
        ssl = sincFilterL.getSubSample();
        ssr = sincFilterR.getSubSample();
        
        filter.processSample(filter_type);
        ssl *= inv_preamp;
        ssr *= inv_preamp;
        shaper ? processShaper();
        
        sincDownL.advanceHist(ssl);
        sincDownR.advanceHist(ssr);
      );
      
      spl0 = sincDownL.sincDownSample();
      spl1 = sincDownR.sincDownSample();
    );
  ) : (
    ssr = yr;
    ssl = yl;
    
    filter.processSample(filter_type);
    ssl *= inv_preamp;
    ssr *= inv_preamp;
    shaper ? processShaper();
    
    spl0 = ssl;
    spl1 = ssr;
  );
  
  last_yl = spl0;
  last_yr = spl1;
  
  spl0 *= final_boost;
  spl1 *= final_boost;
  
  !amp_before_filter ? (
    spl0 *= amp_envelope;
    spl1 *= amp_envelope;
  );
  
  fix_dc ? (
    spl0 = dc2.eval_HP6(spl0);
    spl1 = dc3.eval_HP6(spl1);
  );
  
  fb_mode ? (
    spl0 = spl0 / (1+exp(fb));
    spl1 = spl1 / (1+exp(fb));
  );
  
  chorus_enabled > .01 ? (
    // Subtle bass preserving chorus
    l_delay.writeBuffer(l_delay_filt.eval_linearSVF_HP(spl0));
    r_delay.writeBuffer(r_delay_filt.eval_linearSVF_HP(spl1));
    
    csample += 1;
    
    chorus_tri = naiveTri(csample * israte * .25);
    ch_cur = chorus_enabled * .001 + ch_cur * .999;
    l_offset = ch_cur * (0.0075 + 0.002 * chorus_tri) * srate;
    r_offset = ch_cur * (0.0075 - 0.002 * chorus_tri) * srate;
    
    spl0 = spl0 - .5 * r_delay.readBuffer(r_offset);
    spl1 = spl1 - .5 * l_delay.readBuffer(l_offset);
  );

@gfx 1210 600
style != 0 ? (
  size_fraction = gfx_w / 1210;
) : (
  size_fraction = gfx_w / 1510;
);
(size_fraction - floor(size_fraction) < 0.2) ? size_fraction = floor(size_fraction);
scaling = size_fraction - 1;

render_time += .025;
style == 0 ? gfx_set(21/255, 20/255, 21/255, 1.0);
style == 1 ? gfx_set(9/255, 10/255, 9/255, 1.0);
style == 2 ? gfx_set(0, 10/255, 0, 1.0);
gfx_rect(0, 0, gfx_w, gfx_h);

t_anim += .005;
t_desync = 0.5*$pi;
t_ref = 0;
loop(50,
  tp = t_anim + t_ref;
  xx = .5*gfx_h+gfx_w*sin(tp);
  yy = .35*gfx_h+gfx_h*cos(tp);
  xx2 = .25*gfx_h+gfx_w*sin(tp + t_desync);
  yy2 = .25*gfx_h+gfx_h*cos(tp + t_desync);
  gfx_set(.5, 1, .5, min(1.0, .04+.1*abs(sin(render_time))));
  gfx_line(xx2, yy2, xx, yy, 3);
  t_ref += .01 + .1 * abs(sin(.065272*render_time));
);

xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
widget_r = 35/255;
widget_g = 155/255;
widget_b = 30/255;
widget_a = 1.0;
toggle_r = .5;
toggle_g = 1.6;
toggle_b = .5;
toggle_a = 1.0;

cY = w1y + w1h + .4*(gfx_h-w1h);
panelY = cY - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;

style == 0 ? (
  xOrigin = 75*(1+scaling);
  yOrigin = 65*(1+scaling);
  panelSpacing = knobSize;
  
  s_DRIVE = sprintf(64, "DRIVE");
  s_FILTER = sprintf(65, "FILTER");
  s_FFM = sprintf(66, "FM");
  s_DIST = sprintf(67, "DISTORTION");
  s_FB = sprintf(68, "FEEDBACK");
  s_AMP_ENV = sprintf(69, "AMP ENV");
  s_FILT_ENV = sprintf(70, "FILTER ENV  ");
  s_CLFO = sprintf(71, "CUTOFF LFO");
  s_MLFO = sprintf(72, "MORPH LFO");
  s_PITCHOD = sprintf(73, "PITCH MOD");
  s_FX = sprintf(75, "FX");
  s_OPTS = sprintf(76, "OPTIONS");
  s_FLFO = sprintf(78, "FREE LFO");
) : ( style == 1 ) ? (
  xOrigin = 60*(1+scaling);
  yOrigin = 82*(1+scaling);
  panelSpacing = .15*knobSize;
  
  s_DRIVE = sprintf(64, "Drive");
  s_FILTER = sprintf(65, "Filter");
  s_FFM = sprintf(66, "Filter FM");
  s_DIST = sprintf(67, "Distortion");
  s_FB = sprintf(68, "Feedback");
  s_AMP_ENV = sprintf(69, "Amplitude Envelope");
  s_FILT_ENV = sprintf(70, "Filter Envelope");
  s_CLFO = sprintf(71, "Cutoff LFO");
  s_MLFO = sprintf(72, "Morph LFO");
  s_PITCHOD = sprintf(73, "Pitch modulation");
  s_FX = sprintf(75, "Effects");
  s_OPTS = sprintf(76, "Options");
  s_FLFO = sprintf(78, "Free LFO");
) : ( style == 2 ) ? (
  xOrigin = 60*(1+scaling);
  yOrigin = 82*(1+scaling);
  panelSpacing = .15*knobSize;
  
  s_DRIVE = sprintf(64, "DRIVE");
  s_FILTER = sprintf(65, "FILTER");
  s_FFM = sprintf(66, "FILTER FM");
  s_DIST = sprintf(67, "DISTORTION");
  s_FB = sprintf(68, "FEEDBACK");
  s_AMP_ENV = sprintf(69, "AMP ENVELOPE");
  s_FILT_ENV = sprintf(70, "FILTER ENVELOPE");
  s_CLFO = sprintf(71, "CUTOFF LFO");
  s_MLFO = sprintf(72, "MORPH LFO");
  s_PITCHOD = sprintf(73, "PITCH MOD");
  s_FX = sprintf(75, "EFFECTS");
  s_OPTS = sprintf(76, "OPTIONS");
  s_FLFO = sprintf(78, "FREE LFO");
);

style == 0 ? (
  font_color_r = .7;
  font_color_g = .6;
  font_color_b = .8;
) : (
  font_color_r = .7;
  font_color_g = .7;
  font_color_b = .7;
);
dial_animation = 1;
dial_position_color_r = 0.2;
dial_position_color_g = 0.7;
dial_position_color_b = 0.4;

font_color_a = 1;
knob_font_color_r = 0.9;
knob_font_color_g = 0.9;
knob_font_color_b = 0.8;
knob_font_color_a = 1;
edge_r = 39/255;
edge_g = 39/255;
edge_b = 41/255;
edge_a = 1.0;

edge_font_r = 0.9;
edge_font_g = 0.9;
edge_font_b = 0.8;

mod1_color_r = .3;
mod1_color_g = .47;
mod1_color_b = .6;
mod1_color_a = 1;
mod2_color_r = .2;
mod2_color_g = .5;
mod2_color_b = 1;
mod2_color_a = 1;
mod3_color_r = .1;
mod3_color_g = .6;
mod3_color_b = 1;
mod3_color_a = 1;

fontscaling = size_fraction - 1;

FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", floor(16 * (1+fontscaling)));

BAND_FONT = 5;
gfx_setfont(BAND_FONT, "Arial", floor(16 * (1+fontscaling)));

KNOB_FONT = 6;
gfx_setfont(KNOB_FONT, "Arial", floor(14 * (1+fontscaling)));

KNOB_FONT2 = 7;
gfx_setfont(KNOB_FONT2, "Arial", floor(13 * (1+fontscaling)));

HINT_FONT = 8;
gfx_setfont(HINT_FONT, "Arial", floor(13 * (1+fontscaling)));

TOGGLE_FONT = 9;
gfx_setfont(TOGGLE_FONT, "Arial", floor(13 * (1+fontscaling)));


function drive_panel()
(
  nextPanel = drawPanel(s_DRIVE, cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 7.75*knobSpacing, panelHeight, 1);
  
  style == 0 ? (
    hotness_meter = tanh(54*sqrt(hotness_rmsq));
    gfx_set(hotness_meter+.1, .1, .1, hotness_meter);
    gfx_rect(cX - 2.5*knobSpacing+1, cY - .28*panelHeight, 9, 9);
  );
  
  driveKnob.knob_set(sprintf(1, "%.1f dB", drive), 1, (drive + 6)/54);
  driveKnob.drawKnob(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", 1.0);
  dial_animation ? (
    driveKnob.knob_draw_modifier((current_drive - drive) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    driveKnob.knob_draw_modifier((current_drive - drive) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  driveKnob.knob_draw_modifier(drive_vel / 54, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( driveKnob.knob_modifier_processMouse(0, drive_vel / 54) ? ( drive_vel = driveKnob.value * 54; );
  ) : driveKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? (
    !driveKnob.justReleased ? ( drive = driveKnob.value * 54 - 6; );
    slider_automate(drive, driveKnob.justReleased);
  );
   
  cX += 2.5 * knobSize;
  
  postBoost.knob_set(sprintf(1, "%.1f dB", boost), 1, (boost + 6)/54);
  postBoost.drawKnob(cX, cY, knobSize, "Output Gain", "Output Gain", 1.0);
  dial_animation ? (
    postBoost.knob_draw_modifier((current_boost - boost) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    postBoost.knob_draw_modifier((current_boost - boost) / 54, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  postBoost.knob_draw_modifier(boost_vel / 54, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( postBoost.knob_modifier_processMouse(0, boost_vel / 54) ? ( boost_vel = postBoost.value * 54; );
  ) : postBoost.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? (
    !postBoost.justReleased ? ( boost = postBoost.value * 54 - 6; );
    slider_automate(boost, postBoost.justReleased);
  );

  cX = nextPanel + panelSpacing;
);

function filter_panel()
(
  nextPanel = drawPanel(s_FILTER, cX, cY - .53*panelHeight + .2*knobSize, 25.5*knobSpacing, panelHeight, 1);
  
  cX += 2 * knobSpacing;
  cX += knobSize;
  gfx_setfont(KNOB_FONT);
  y_move = .4 * knobSize;
  ww = 1.5*knobSize;
  hh = .35 * knobSize;
  FILTER_SELECT_BUTTON = 25;
  y_ref = cY - 1.25*knobSize - 1;
  drawSelectionButton("Lin 2p", cX - 2*knobSize, y_ref, ww, hh, 0, FILTER_SELECT_BUTTON, "2-pole linear state variable filter (12 dB/oct).");
  drawSelectionButton("Lin 4p", cX - 2*knobSize, y_ref + y_move, ww, hh, 2, FILTER_SELECT_BUTTON, "4-pole linear state variable filter (12 dB/oct)");
  drawSelectionButton("Dual", cX - 2*knobSize, y_ref + 2*y_move, ww, hh, 8, FILTER_SELECT_BUTTON, "2 2-pole state variable filters in series\nwhere one is placed at four times the cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Triple", cX - 2*knobSize, y_ref + 3*y_move, ww, hh, 9, FILTER_SELECT_BUTTON, "3 2-pole state variable filters in series.\nCutoff frequencies are at one, two and four times the base cutoff.\nResonance peak is saturated (approximate).");
  drawSelectionButton("Rect", cX - 2*knobSize, y_ref + 4*y_move, ww, hh, 14, FILTER_SELECT_BUTTON, "2-pole linear state variable filter where\nthe approximate resonance is rectified.");
  drawSelectionButton("Steiner", cX - 2*knobSize, y_ref + 5*y_move, ww, hh, 15, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (symmetric) feedback.\nBe warned, over 0.5 this filter goes into hard oscillation.\nThis sounds awful unless there's sufficient drive to choke it.\nResonance loss more dominant at HF.");
  drawSelectionButton("SteinerA", cX - 2*knobSize, y_ref + 6*y_move, ww, hh, 16, FILTER_SELECT_BUTTON, "2-pole non-linear Steiner filter with diode clipped (asymmetric) feedback.\nRaising the drive lowers the resonance (chokes it). Resonance loss more dominant at HF.");
  
  drawSelectionButton("MS-20", cX - 0.25*knobSize, y_ref + 0*y_move, ww, hh, 1, FILTER_SELECT_BUTTON, "MS-20 emulation (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("MS-20A", cX - 0.25*knobSize, y_ref + 1*y_move, ww, hh, 6, FILTER_SELECT_BUTTON, "MS-20 emulation with diode asymmetry (12 dB/oct LP, BP, 6 dB/oct HP).");
  drawSelectionButton("Moog", cX - 0.25*knobSize, y_ref + 2*y_move, ww, hh, 3, FILTER_SELECT_BUTTON, "Moog emulation (24 dB/oct).");
  drawSelectionButton("Ladder", cX - 0.25*knobSize, y_ref + 3*y_move, ww, hh, 4, FILTER_SELECT_BUTTON, "Ladder filter with two stages (12 dB/oct).");
  drawSelectionButton("303", cX - 0.25*knobSize, y_ref + 4*y_move, ww, hh, 5, FILTER_SELECT_BUTTON, "Blaukraut's 303 filter emulation");
  drawSelectionButton("nlSVF2p", cX - 0.25*knobSize, y_ref + 5*y_move, ww, hh, 10, FILTER_SELECT_BUTTON, "2-pole non-linear state variable filter (12 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  drawSelectionButton("nlSVF4p", cX - 0.25*knobSize, y_ref + 6*y_move, ww, hh, 11, FILTER_SELECT_BUTTON, "4-pole non-linear state variable filter (24 dB/oct)\nwith asymmetry in the saturation which leads\nto flutter when driven.\n\nSounds nice at low resonances.");
  
  drawSelectionButton("Bent 4p", cX + 1.5*knobSize, y_ref, ww, hh, 17, FILTER_SELECT_BUTTON, "4-pole non-linear CMOS filter. Sounds extremely non-linear. Can lead a life of its own.");
  drawSelectionButton("Pillow2p", cX + 1.5*knobSize, y_ref + 1*y_move, ww, hh, 18, FILTER_SELECT_BUTTON, "2-pole pillowy non-linear filter");
  drawSelectionButton("Pillow4p", cX + 1.5*knobSize, y_ref + 2*y_move, ww, hh, 19, FILTER_SELECT_BUTTON, "4-pole pillowy non-linear filter");
  drawSelectionButton("Pillow2pA", cX + 1.5*knobSize, y_ref + 3*y_move, ww, hh, 20, FILTER_SELECT_BUTTON, "2-pole pillowy non-linear filter w/ clipper in feedback");
  drawSelectionButton("Pillow4pA", cX + 1.5*knobSize, y_ref + 4*y_move, ww, hh, 21, FILTER_SELECT_BUTTON, "4-pole pillowy non-linear filter w/ clipper in feedback");
  drawSelectionButton("Pillow2pS", cX + 1.5*knobSize, y_ref + 5*y_move, ww, hh, 22, FILTER_SELECT_BUTTON, "2-pole pillowy non-linear filter w/ clipper in feedback and crossover dist");
  drawSelectionButton("Pillow4pS", cX + 1.5*knobSize, y_ref + 6*y_move, ww, hh, 23, FILTER_SELECT_BUTTON, "4-pole pillowy non-linear filter w/ clipper in feedback and crossover dist");
  
  drawSelectionButton("Ladder3", cX + 3.25*knobSize, y_ref + 0*y_move, ww, hh, 24, FILTER_SELECT_BUTTON, "Ladder filter");
  drawSelectionButton("Ladder6", cX + 3.25*knobSize, y_ref + 1*y_move, ww, hh, 25, FILTER_SELECT_BUTTON, "Ladder filter");
  drawSelectionButton("LadderAP", cX + 3.25*knobSize, y_ref + 2*y_move, ww, hh, 26, FILTER_SELECT_BUTTON, "2-pole ladder filter with allpass filter for resonance. Drive this one hard.");
  drawSelectionButton("Shriek2p", cX + 3.25*knobSize, y_ref + 3*y_move, ww, hh, 27, FILTER_SELECT_BUTTON, "2-pole SVF filter with antisaturator. Drive this one hard.");
  drawSelectionButton("Shriek4p", cX + 3.25*knobSize, y_ref + 4*y_move, ww, hh, 28, FILTER_SELECT_BUTTON, "4-pole SVF filter with antisaturator. Drive this one hard.");
  
  cX += 6.15*knobSize;
  
  center = .5 * sampling_ratio * srate * exp( (1-clamp(cutoff, 0, .99)) * log(20/22050) );
  cutoffKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), 1, cutoff);
  cutoffKnob.drawKnob(cX, cY, knobSize, "Cutoff", "Filter Cutoff", 1.0);
  
  dial_animation ? (
    cutoffKnob.knob_draw_modifier(sliderCutoffL - cutoff, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    cutoffKnob.knob_draw_modifier(sliderCutoffR - cutoff, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  
  cutoffKnob.knob_draw_modifier(cutoff_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  cutoffKnob.knob_draw_modifier(cutoff_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  cutoffKnob.knob_draw_modifier(cutoff_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
  
  activeModifier == 3 ? ( cutoffKnob.knob_modifier_processMouse(0, cutoff_flfo) ? ( cutoff_flfo = cutoffKnob.value; );
  ) : activeModifier == 2 ? ( cutoffKnob.knob_modifier_processMouse(0, cutoff_mod) ? ( cutoff_mod = cutoffKnob.value; );
  ) : activeModifier == 1 ? ( cutoffKnob.knob_modifier_processMouse(0, cutoff_vel) ? ( cutoff_vel = cutoffKnob.value; );
  ) : cutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !cutoffKnob.justReleased ? (
      cutoff = cutoffKnob.value;
      check_safety();
    );
    
    slider_automate(cutoff, cutoffKnob.justReleased);
  );
  
  cX += knobSize*2.5;
  resonanceKnob.knob_set(sprintf(1, "%.1f", resonance), 1, resonance);
  resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Filter Resonance", 1.0);
  dial_animation ? (
    resonanceKnob.knob_draw_modifier(sliderReso - resonance, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    resonanceKnob.knob_draw_modifier(sliderReso - resonance, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  resonanceKnob.knob_draw_modifier(reso_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  resonanceKnob.knob_draw_modifier(reso_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  resonanceKnob.knob_draw_modifier(reso_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
  activeModifier == 3 ? ( resonanceKnob.knob_modifier_processMouse(0, reso_flfo) ? ( reso_flfo = resonanceKnob.value; );
  ) : activeModifier == 2 ? ( resonanceKnob.knob_modifier_processMouse(0, reso_mod) ? ( reso_mod = resonanceKnob.value; );
  ) : activeModifier == 1 ? ( resonanceKnob.knob_modifier_processMouse(0, reso_vel) ? ( reso_vel = resonanceKnob.value; );
  ) : resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !resonanceKnob.justReleased ? ( resonance = resonanceKnob.value; );
    slider_automate(resonance, resonanceKnob.justReleased);
  );
   
  cX += knobSize*2.7;
  
  morphKnob.knob_set("", 1, morph);
  morphKnob.drawKnob(cX, cY, knobSize, "Morph", "Filter Morph", 1.0);
  
  dial_animation ? (
    morphKnob.knob_draw_modifier(sliderMorphL - morph, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    morphKnob.knob_draw_modifier(sliderMorphR - morph, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  
  morphKnob.knob_draw_modifier(morph_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( morphKnob.knob_modifier_processMouse(0, morph_vel) ? ( morph_vel = morphKnob.value; );
  ) : morphKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !morphKnob.justReleased ? ( morph = morphKnob.value; );
    slider_automate(morph, morphKnob.justReleased);
  );
  
  
  gfx_set(1,1,1,1);
  drawKnobLabels(knobSize*1.25, 0, "LP");
  drawKnobLabels(knobSize*1.25, 1/4, "BP");
  drawKnobLabels(knobSize*1.25, 2/4, "HP");
  drawKnobLabels(knobSize*1.25, 3/4, "BR");
  drawKnobLabels(knobSize*1.25, 4/4, "LP");
  
  cX += knobSize*2.65;
  
  keyFollowKnob.active = 1;
  keyFollowKnob.value = key_follow;
  keyFollowKnob.drawKnob(cX, cY, knobSize, "Follow", "Follow MIDI pitch", 1.0);
  
  keyFollowKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !keyFollowKnob.justReleased ? ( key_follow = keyFollowKnob.value; );
    slider_automate(key_follow, keyFollowKnob.justReleased);
  );
  
  cX = nextPanel + panelSpacing;
);

function fm_panel()
(
  nextPanel = drawPanel(s_FFM, cX, cY - .53*panelHeight + .2*knobSize, 14*knobSpacing, panelHeight, 1);
  cX += 2.375*knobSize;
  gfx_setfont(KNOB_FONT);
  y_move = .4 * knobSize;
  ww = 1.6*knobSize;
  hh = .35 * knobSize;
  FM_MODE_BUTTON = 37;
  drawSelectionButton("MIDI Sin", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, FM_MODE_BUTTON, -1);
  drawSelectionButton("MIDI |Sin|", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 1, FM_MODE_BUTTON, -1);
  drawSelectionButton("MIDI Tri", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 4, FM_MODE_BUTTON, -1);
  drawSelectionButton("Self", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 2, FM_MODE_BUTTON, -1);
  drawSelectionButton("Self Abs", cX - 2*knobSize, cY-1.1*knobSize + 5*y_move, ww, hh, 3, FM_MODE_BUTTON, -1);
  drawSelectionButton("MIDI Sqr", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 5, FM_MODE_BUTTON, -1);
  ww = 1.4*knobSize;
  cX += 1.0 * knobSize;
  
  fmlevelKnob.knob_set("", 1, fm_amnt);
  fmLevelKnob.drawKnob(cX, cY, knobSize, "FM Level", "FM Level\nLevel of FM modulation", 1.0);
  
  resetFmToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, reset_fm_on_release, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on release.\n\nBy default, the FM phase resets on note. This enables\nan additional reset on release as well.");
  reset_fm_on_release = resetFmToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  dial_animation ? (
    fmlevelKnob.knob_draw_modifier(current_fm_amnt - fm_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    fmlevelKnob.knob_draw_modifier(current_fm_amnt - fm_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  fmLevelKnob.knob_draw_modifier(fm_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  fmLevelKnob.knob_draw_modifier(fm_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  fmLevelKnob.knob_draw_modifier(fm_amnt_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
  activeModifier == 3 ? ( fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_flfo) ? ( fm_amnt_flfo = fmLevelKnob.value; );
  ) : activeModifier == 2 ? ( fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_mod) ? ( fm_amnt_mod = fmLevelKnob.value; );
  ) : activeModifier == 1 ? ( fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_vel) ? ( fm_amnt_vel = fmLevelKnob.value; );
  ) : fmLevelKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    !fmLevelKnob.justReleased ? ( fm_amnt = fmLevelKnob.value; );
    slider_automate(fm_amnt, fmLevelKnob.justReleased);
  );
   
  
  cX += 2.5 * knobSize;
  
  fm_mode == 2 || fm_mode == 3 ? (
    fmCutoffKnob.active = 1;
    fmCutoffKnob.value = fm_cutoff;
    center = .5 * srate * exp( (1-fm_cutoff) * log(20/22050) );
    center < 1000 ? (
      fmCutoffKnob.label = sprintf(1, "%d Hz", center);
    ) : (
      fmCutoffKnob.label = sprintf(1, "%.1f kHz", center/1000);
    );
    fmCutoffKnob.drawKnob(cX, cY, knobSize, "FM cutoff", "FM Cutoff\n\nCutoff used to filter signal that\ncontrols the cutoff.", .5);
    fmCutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? (
      !fmCutoffKnob.justReleased ? ( fm_cutoff = fmCutoffKnob.value; );
      slider_automate(fm_cutoff, fmCutoffKnob.justReleased);
    );
  ) : (
    fmRateKnob.active = 1;
    fmRateKnob.value = (fm_factor+8)/16;
    fmRateKnob.label = sprintf(1, "%.1f x", 2^floor(fm_factor));
    fmRateKnob.drawKnob(cX, cY, knobSize, "FM factor", "FM factor.\n\nFilter cutoff will oscillate with\nthis factor times the MIDI pitch's\nfrequency.", .5);
    fmRateKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
      !fmRateKnob.justReleased ? ( fm_factor = fmRateKnob.value * 16 - 8; );
      slider_automate(fm_factor, fmRateKnob.justReleased);
    );
  );
  cX += 2.5 * knobSize;
  
  fmPhaseKnob.knob_set("", 1, fm_spread);
  fmPhaseKnob.drawKnob(cX, cY, knobSize, "FM Spread", "FM Phase difference", 1.0);
  dial_animation ? (
    fmPhaseKnob.knob_draw_modifier((current_fm_spread - fm_spread), bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    fmPhaseKnob.knob_draw_modifier((current_fm_spread - fm_spread), bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  fmPhaseKnob.knob_draw_modifier(fm_spread_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( fmPhaseKnob.knob_modifier_processMouse(0, fm_spread_vel) ? ( fm_spread_vel = fmPhaseKnob.value; );
  ) : fmPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    !fmPhaseKnob.justReleased ? ( fm_spread = fmPhaseKnob.value; );
    slider_automate(fm_spread, fmPhaseKnob.justReleased);
  );
  
  cX = nextPanel + panelSpacing;
);

function feedback_panel()
(
  nextPanel = drawPanel(s_FB, cX, cY - .53*panelHeight + .2*knobSize, 4.15*knobSpacing, panelHeight, 1);
  
  cX += 1.4 * knobSize;
  feedbackTwoToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, fb_mode, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Direct feedback mode. Directly routes output to drive. Can be used to massively distort the input.");
  fb_mode = feedbackTwoToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  feedbackKnob.active = !(filter_type == 0 || filter_type == 2);
  feedbackKnob.value = fb;
  feedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Are you crazy?", 0);
  dial_animation ? (
    feedbackKnob.knob_draw_modifier(current_fb - fb, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    feedbackKnob.knob_draw_modifier(current_fb - fb, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  feedbackKnob.knob_draw_modifier(fb_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( feedbackKnob.knob_modifier_processMouse(0, fb_vel) ? ( fb_vel = feedbackKnob.value; );
  ) : feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    !feedbackKnob.justReleased ? ( fb = feedbackKnob.value; );
    slider_automate(fb, feedbackKnob.justReleased);
  );
  
  cx += 1.65 * knobSize;
);

function filter_envelope_panel()
(
  // FILTER ENVELOPE
  pwidth = 17.5 + 1.65;
  nextPanel = drawPanel(s_FILT_ENV, cX, cY - .53*panelHeight + .2*knobSize, pwidth * knobSpacing, panelHeight, 1);
  
  style == 0 ? (
    gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
    gfx_rect(cX - 2.5*knobSpacing + 1, cY - .4*panelHeight - 1, 9 * (1+scaling), 9 * (1+scaling));
  ) : (
    sz = 10 * (1+scaling);
    xref = cX + .5 * knobSpacing;
    yref = cY - .54*panelHeight;
    gfx_set(.1, midiChange*.7+.1, .1, midiChange); midiChange *= .95;
    gfx_rect(xref - .5 * sz, yref - .5 * sz - 1, sz, sz);
    
    r = 20*(1+scaling);
    loop(12,
      r -= 2*(1+scaling);
      gfx_set(.5, 1, .5, .5*midiChange / r);
      gfx_circle(xref - 1, yref - 3, r, 1);
    );
  );
  
  cX += 2 * knobSpacing + knobSize;
  
  FILTER_MODE_SELECT_BUTTON = 11;
  gfx_setfont(KNOB_FONT);
  y_ref = cY - 1.25*knobSize - 1;
  drawSelectionButton("Off", cX - 2*knobSize, y_ref + 0.5*y_move, ww, hh, 0, FILTER_MODE_SELECT_BUTTON, "No filter modulation.");
  drawSelectionButton("MIDI L", cX - 2*knobSize, y_ref + 1.5*y_move, ww, hh, 1, FILTER_MODE_SELECT_BUTTON, "Enable envelope by MIDI (Legato).\n\nOnly keydown from no keys constitutes a press.");
  drawSelectionButton("MIDI T", cX - 2*knobSize, y_ref + 2.5*y_move, ww, hh, 3, FILTER_MODE_SELECT_BUTTON, "Enable envelope by MIDI (Trigger).\n\nTrigger on all key downs.");
  drawSelectionButton("Thresh", cX - 2*knobSize, y_ref + 3.5*y_move, ww, hh, 2, FILTER_MODE_SELECT_BUTTON, "Thresholded.");
  drawSelectionButton("RMS", cX - 2*knobSize, y_ref + 4.5*y_move, ww, hh, 4, FILTER_MODE_SELECT_BUTTON, "Proportional to input RMS.");
  
  cX += knobSpacing;
  
  envAmountKnob.knob_set(sprintf(4, "   %d %%%%", 100*env_amnt), filter_envelope_mode > 0, env_amnt * .5 + .5);
  envAmountKnob.drawKnob(cX, cY, knobSize, "- Amount +", "Envelope Amount", 1.0);
  dial_animation ? (
    envAmountKnob.knob_draw_modifier((current_env_amnt - env_amnt)*.5, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    envAmountKnob.knob_draw_modifier((current_env_amnt - env_amnt)*.5, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  envAmountKnob.knob_draw_modifier(env_amnt_vel * .5, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( envAmountKnob.knob_modifier_processMouse(0, env_amnt_vel * .5) ? ( env_amnt_vel = envAmountKnob.value * 2; );
  ) : envAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !envAmountKnob.justReleased ? ( env_amnt = envAmountKnob.value * 2 - 1; );
    slider_automate(env_amnt, envAmountKnob.justReleased);
  );
  
  cX += knobSize*2.5;
  tempo_sync_envelopes ? ( envAttackKnob.knob_set(getFastEnvelopeLabel(cutoff_atk), filter_envelope_mode > 0, cutoff_atk);
  ) : envAttackKnob.knob_set(cutoff_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*cutoff_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*cutoff_atk))), filter_envelope_mode > 0, cutoff_atk);
  envAttackKnob.drawKnob(cX, cY, knobSize, filter_envelope_mode == 4 ? "RMS window" : "Attack", filter_envelope_mode == 4 ? "RMS window" : "Attack Time", 1.0);
  dial_animation ? (
    envAttackKnob.knob_draw_modifier(current_cutoff_atk - cutoff_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    envAttackKnob.knob_draw_modifier(current_cutoff_atk - cutoff_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  envAttackKnob.knob_draw_modifier(cutoff_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( envAttackKnob.knob_modifier_processMouse(0, cutoff_atk_vel) ? ( cutoff_atk_vel = envAttackKnob.value; );
  ) : envAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !envAttackKnob.justReleased ? cutoff_atk = envAttackKnob.value;
    slider_automate(cutoff_atk, envAttackKnob.justReleased);
  );
  
  cutoffResetToggle.inactive = filter_envelope_mode == 0;
  cutoffResetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, cutoff_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on note.\n\nTurning this off changes the mode to a mode where\nthe amplitude no longer goes to 90%% in the set time.\n\nThis means that consecutive hits get increasingly higher\ncutoff values. The 303 is one of the classic synths that\nhad this characteristic.");
  cutoff_reset = cutoffResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX += knobSize*2.5;
  tempo_sync_envelopes ? ( envDecayKnob.knob_set(getFastEnvelopeLabel(cutoff_decay), filter_envelope_mode > 0, cutoff_decay);
  ) : envDecayKnob.knob_set(filter_envelope_mode == 4 ? "" : cutoff_decay > .5 ? sprintf(19, "%d ms", (30 * 10^(2*cutoff_decay))) : sprintf(19, "%.1f ms", (30 * 10^(2*cutoff_decay))), filter_envelope_mode > 0, cutoff_decay );
  envDecayKnob.drawKnob(cX, cY, knobSize, filter_envelope_mode == 4 ? "Shape" : "Decay", filter_envelope_mode == 4 ? "Response shape\n\nCenter is neutral (linear)" : "Decay Time", 1.0);
  dial_animation ? (
    envDecayKnob.knob_draw_modifier(current_cutoff_decay - cutoff_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    envDecayKnob.knob_draw_modifier(current_cutoff_decay - cutoff_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  envDecayKnob.knob_draw_modifier(cutoff_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( envDecayKnob.knob_modifier_processMouse(0, cutoff_decay_vel) ? ( cutoff_decay_vel = envDecayKnob.value; );
  ) : envDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !envDecayKnob.justReleased ? ( cutoff_decay = envDecayKnob.value; );
    slider_automate(cutoff_decay, envDecayKnob.justReleased);
  );
  
  cX += 2.5 * knobSize;
  
  envSustainKnob.knob_set("", filter_envelope_mode > 0, cutoff_sustain);
  
  ( (filter_envelope_mode < 2) || filter_envelope_mode == 3 ) ? (
    envSustainKnob.drawKnob(cX, cY, knobSize, "Sustain", "Sustain %", 1.0);
    
    dial_animation ? (
      envSustainKnob.knob_draw_modifier(current_cutoff_sustain - cutoff_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
      envSustainKnob.knob_draw_modifier(current_cutoff_sustain - cutoff_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
    );
    envSustainKnob.knob_draw_modifier(cutoff_sustain_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
    activeModifier == 1 ? ( envSustainKnob.knob_modifier_processMouse(0, cutoff_sustain_vel) ? ( cutoff_sustain_vel = envSustainKnob.value; );
    ) : envSustainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      !envSustainKnob.justReleased ? ( cutoff_sustain = envSustainKnob.value; );
      slider_automate(cutoff_sustain, envSustainKnob.justReleased);
    );
    
  ) : ( filter_envelope_mode == 2 || filter_envelope_mode == 4 ) ? (
    new_sustain = filter_thresh.draw_thresh_window(cX - knobSize, cY - knobSize, knobSize * 3.4, knobSize * 2.4, cutoff_sustain, filter_envelope_mode == 4 ? cutoff_low_thresh : 10);
    (cutoff_sustain != new_sustain) ? (
      slider_automate(cutoff_sustain = new_sustain);
    );
    (filter_thresh.lower_thresh_changed < 10) ? (
      slider_automate(cutoff_low_thresh = filter_thresh.lower_thresh_changed);
    );
    
    
    //envSustainKnob.drawKnob(cX, cY, knobSize, "Threshold", "Threshold [V]", 1.0);
  );
  
  cX = nextPanel + panelSpacing;
);

function amp_envelope_panel()
(
  pwidth = 17.5 + 1.65;
  nextPanel = drawPanel(s_AMP_ENV, cX, cY - .53*panelHeight + .2*knobSize, pwidth*knobSpacing, panelHeight, 1);
  
  style == 0 ? (
    gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
    gfx_rect(cX - 2.5*knobSpacing + 1, cY - .4*panelHeight - 1, 9 * (1+scaling), 9 * (1+scaling));
  ) : (
    sz = 10 * (1+scaling);
    xref = cX + 0.5*knobSpacing;
    yref = cY - .54*panelHeight;
    gfx_set(.1, midiChange*.7+.1, .1, midiChange); midiChange *= .95;
    gfx_rect(xref - .5 * sz, yref - .5 * sz - 1, sz, sz);
    
    r = 20*(1+scaling);
    loop(12,
      r -= 2*(1+scaling);
      gfx_set(.5, 1, .5, .5*midiChange / r);
      gfx_circle(xref - 1, yref - 3, r, 1);
    );
  );
  
  cX += 2 * knobSpacing + knobSize;
  
  AMPLITUDE_SELECT_BUTTON = 10;
  gfx_setfont(KNOB_FONT);
  y_ref = cY - 1.25*knobSize - 1;
  
  drawSelectionButton("Off", cX - 2*knobSize, y_ref + 0.5*y_move, ww, hh, 0, AMPLITUDE_SELECT_BUTTON, "No amplitude modulation.");
  drawSelectionButton("MIDI L", cX - 2*knobSize, y_ref + 1.5*y_move, ww, hh, 1, AMPLITUDE_SELECT_BUTTON, "Enable envelope by MIDI (Legato).\n\nOnly keydown from no keys constitutes a press.");
  drawSelectionButton("MIDI T", cX - 2*knobSize, y_ref + 2.5*y_move, ww, hh, 3, AMPLITUDE_SELECT_BUTTON, "Enable envelope by MIDI (Trigger).\n\nTrigger on all key downs.");
  drawSelectionButton("Thresh", cX - 2*knobSize, y_ref + 3.5*y_move, ww, hh, 2, AMPLITUDE_SELECT_BUTTON, "Thresholded.");
  drawSelectionButton("RMS", cX - 2*knobSize, y_ref + 4.5*y_move, ww, hh, 4, AMPLITUDE_SELECT_BUTTON, "Proportional to input RMS.");
  
  cX += 1 * knobSpacing;
  
  ampAccentKnob.active = amplitude_envelope_mode > 0;
  ampAccentKnob.value = (amp_accent + 1) / 2;
  ampAccentKnob.drawKnob(cX, cY, knobSize, "- Accent +", "Accent", 1.0);
  ampAccentKnob.label = sprintf(16, "   %d %%%%", 100*amp_accent);
  ampAccentKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !ampAccentKnob.justReleased ? ( amp_accent = ampAccentKnob.value * 2 - 1; );
  );
  
  preampToggle.inactive = amplitude_envelope_mode == 0;
  preampToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, amp_before_filter, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enabling this places the amplitude envelope before the filter.\nThis takes away some control over the amplitude envelope,\nbut allows you to hear the filter decay.\n");
  amp_before_filter = preampToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX += knobSize*2.5;
  resetToggle.inactive = amplitude_envelope_mode == 0;
  resetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on note.");
  reset = resetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  tempo_sync_envelopes ? ( ampAttackKnob.knob_set(getFastEnvelopeLabel(amp_atk), amplitude_envelope_mode > 0, amp_atk);
  ) : ampAttackKnob.knob_set(amp_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*amp_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*amp_atk))), amplitude_envelope_mode > 0, amp_atk);
  ampAttackKnob.drawKnob(cX, cY, knobSize, filter_envelope_mode == 4 ? "RMS window" : "Attack", filter_envelope_mode == 4 ? "RMS window" : "Attack Time", 1.0);
  dial_animation ? (
    ampAttackKnob.knob_draw_modifier(current_amp_atk - amp_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    ampAttackKnob.knob_draw_modifier(current_amp_atk - amp_atk, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  ampAttackKnob.knob_draw_modifier(amp_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( ampAttackKnob.knob_modifier_processMouse(0, amp_atk_vel) ? ( amp_atk_vel = ampAttackKnob.value; );
  ) : ampAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !ampAttackKnob.justReleased ? ( amp_atk = ampAttackKnob.value; );
    slider_automate(amp_atk, ampAttackKnob.justReleased);
  );
  
  
  cX += knobSize*2.5;
  
  tempo_sync_envelopes ? ( ampDecayKnob.knob_set(getFastEnvelopeLabel(amp_decay), amplitude_envelope_mode > 0, amp_decay);
  ) : ampDecayKnob.knob_set(amplitude_envelope_mode == 4 ? "" : amp_decay > .5 ? sprintf(1, "%d ms", (30 * 10^(2*amp_decay))) : sprintf(1, "%.1f ms", (30 * 10^(2*amp_decay))), amplitude_envelope_mode > 0, amp_decay);
  ampDecayKnob.drawKnob(cX, cY, knobSize, amplitude_envelope_mode == 4 ? "Shape" : "Decay",  amplitude_envelope_mode == 4 ? "Response shape\n\nCenter is neutral (linear)" : "Decay Time", 1.0);
  dial_animation ? (
    ampDecayKnob.knob_draw_modifier(current_amp_decay - amp_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    ampDecayKnob.knob_draw_modifier(current_amp_decay - amp_decay, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  ampDecayKnob.knob_draw_modifier(amp_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( ampDecayKnob.knob_modifier_processMouse(0, amp_decay_vel) ? ( amp_decay_vel = ampDecayKnob.value; );
  ) : ampDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
    !ampDecayKnob.justReleased ? ( amp_decay = ampDecayKnob.value; );
    slider_automate(amp_decay, ampDecayKnob.justReleased);
  );
   
  
  cX += 2.5 * knobSize;
  
  ampSustainKnob.knob_set("", amplitude_envelope_mode > 0, amp_sustain);
  ( (amplitude_envelope_mode < 2) || amplitude_envelope_mode == 3 ) ? (
    ampSustainKnob.drawKnob(cX, cY, knobSize, "Sustain", "Sustain %", 1.0);
    
    dial_animation ? (
      ampSustainKnob.knob_draw_modifier(current_amp_sustain - amp_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
      ampSustainKnob.knob_draw_modifier(current_amp_sustain - amp_sustain, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
    );
    ampSustainKnob.knob_draw_modifier(amp_sustain_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
    activeModifier == 1 ? ( ampSustainKnob.knob_modifier_processMouse(0, amp_sustain_vel) ? ( amp_sustain_vel = ampSustainKnob.value; );
    ) : ampSustainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      !ampSustainKnob.justReleased ? ( amp_sustain = ampSustainKnob.value; );
      slider_automate(amp_sustain, ampSustainKnob.justReleased);
    );
  ) : ( amplitude_envelope_mode == 2 || amplitude_envelope_mode == 4 ) ? (
    //ampSustainKnob.drawKnob(cX, cY, knobSize, "Threshold", "Threshold [V]", 1.0);
    new_sustain = amplitude_thresh.draw_thresh_window(cX - knobSize, cY - knobSize, knobSize * 3.4, knobSize * 2.4, amp_sustain, amplitude_envelope_mode == 4 ? amplitude_low_thresh : 10);
    (amp_sustain != new_sustain) ? (
      slider_automate(amp_sustain = new_sustain);
    );
    (amplitude_thresh.lower_thresh_changed < 10) ? (
      slider_automate(amplitude_low_thresh = amplitude_thresh.lower_thresh_changed);
    );
  );
  
  cX = nextPanel + panelSpacing;
);

function cutoff_lfo_panel()
(
  nextPanel = drawPanel(s_CLFO, cX, cY - .53*panelHeight + .2*knobSize, 9.65*knobSpacing, panelHeight, c_lfo_enabled);
  
  cX += 2 * knobSpacing;
  
  cutoffLFOAmountKnob.active = c_lfo_enabled;
  cutoffLFOAmountKnob.value = c_lfo_amnt;
  cutoffLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount.\n\nPress RMB to toggle forward.\nGo backwards by pressing LMB while still\nholding RMB from the forward toggle.\nPress LMB and drag to change amount.", 1.0);
  draw_lfo(cX - 15*(1+scaling), cY - 10*(1+scaling), 30*(1+scaling), 20*(1+scaling), c_lfo_type, c_lfo_center_phase, c_lfo_time);
  dial_animation ? (
    cutoffLFOAmountKnob.knob_draw_modifier(current_c_lfo_amnt - c_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    cutoffLFOAmountKnob.knob_draw_modifier(current_c_lfo_amnt - c_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  cutoffLFOAmountKnob.knob_draw_modifier(c_lfo_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  cutoffLFOAmountKnob.knob_draw_modifier(c_lfo_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  cutoffLFOAmountKnob.knob_draw_modifier(c_lfo_amnt_flfo, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
  activeModifier == 3 ? ( cutoffLFOAmountKnob.knob_modifier_processMouse(0, c_lfo_amnt_flfo) ? ( c_lfo_amnt_flfo = cutoffLFOAmountKnob.value; );
  ) : activeModifier == 2 ? ( cutoffLFOAmountKnob.knob_modifier_processMouse(0, c_lfo_amnt_mod) ? ( c_lfo_amnt_mod = cutoffLFOAmountKnob.value; );
  ) : activeModifier == 1 ? ( cutoffLFOAmountKnob.knob_modifier_processMouse(0, c_lfo_amnt_vel) ? ( c_lfo_amnt_vel = cutoffLFOAmountKnob.value; );
  ) : (
    mouse_cap == 2 && lcap == 0 ? (
      cutoffLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
        c_lfo_type += 1;
        c_lfo_type > max_lfo_types ? c_lfo_type = 0;
      );
    ) : ( mouse_cap == 3 && lcap == 2 ) ? (
      cutoffLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
        c_lfo_type -= 1;
        c_lfo_type < 0 ? c_lfo_type = max_lfo_types - 1;
        cutoffLFOAmountKnob.lastLeftClick = -10000; /* Prevent double click from triggering from this */
      );
    ) : (
      cutoffLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
        !cutoffLFOAmountKnob.justReleased ? ( c_lfo_amnt = cutoffLFOAmountKnob.value; );
        slider_automate(c_lfo_amnt, cutoffLFOAmountKnob.justReleased);
      );
    );
  );
  
  cutoffLfoEnabledToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_enabled, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable LFO.");
  c_lfo_enabled = cutoffLfoEnabledToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cutoffLfoResetToggle.inactive = !c_lfo_enabled;
  cutoffLfoResetToggle.drawToggle(cX+knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
  c_lfo_reset = cutoffLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX += 2.5 * knobSize;
  cutoffSyncToggle.inactive = !c_lfo_enabled;
  cutoffSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync rate to tempo.");
  c_lfo_sync = cutoffSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cutoffLFOSpeedKnob.active = c_lfo_enabled;
  cutoffLFOSpeedKnob.value = c_lfo_speed / 20;
  c_lfo_sync ? (
    cutoffLFOSpeedKnob.label = cutoff_LFO.tempoLabel;
  ) : (
    cutoffLFOSpeedKnob.label = sprintf(3, "%.1f Hz", 10^(c_lfo_speed/15) - 1);
  );
  cutoffLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
  dial_animation ? (
    cutoffLFOSpeedKnob.knob_draw_modifier((current_c_lfo_speed_slider*15 - c_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    cutoffLFOSpeedKnob.knob_draw_modifier((current_c_lfo_speed_slider*15 - c_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  cutoffLFOSpeedKnob.knob_draw_modifier(c_lfo_speed_vel / 20, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  cutoffLFOSpeedKnob.knob_draw_modifier(c_lfo_speed_mod / 20, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  cutoffLFOSpeedKnob.knob_draw_modifier(c_lfo_speed_flfo / 20, bipolar, mod3_color_r, mod3_color_g, mod3_color_b, mod3_color_a, 3);
  activeModifier == 3 ? ( cutoffLFOSpeedKnob.knob_modifier_processMouse(0, c_lfo_speed_flfo / 20) ? ( c_lfo_speed_flfo = cutoffLFOSpeedKnob.value * 20; );
  ) : activeModifier == 2 ? ( cutoffLFOSpeedKnob.knob_modifier_processMouse(0, c_lfo_speed_mod / 20) ? ( c_lfo_speed_mod = cutoffLFOSpeedKnob.value * 20; );
  ) : activeModifier == 1 ? ( cutoffLFOSpeedKnob.knob_modifier_processMouse(0, c_lfo_speed_vel / 20) ? ( c_lfo_speed_vel = cutoffLFOSpeedKnob.value * 20; );
  ) : (
    cutoffLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      !cutoffLFOSpeedKnob.justReleased ? (
        c_lfo_speed = cutoffLFOSpeedKnob.value * 20;
        updateTempo();
      );
      slider_automate(c_lfo_speed, cutoffLFOSpeedKnob.justReleased);
    );
  );
  
  cX += 1.85 * knobSize;
  cutoffLFOLRPhaseKnob.active = c_lfo_enabled;
  cutoffLFOLRPhaseKnob.value = (c_lfo_phase + 1) * .5;
  cutoffLFOLRPhaseKnob.drawKnob(cX, cY + .65*knobSize, .5*knobSize, "", "Cutoff LFO Pan Phase", 1.0);
  cutoffLFOLRPhaseKnob.label = "LR";
  cutoffLFOLRPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !cutoffLFOLRPhaseKnob.justReleased ? ( c_lfo_phase = 2 * cutoffLFOLRPhaseKnob.value - 1; );
    slider_automate(c_lfo_phase, cutoffLFOLRPhaseKnob.justReleased);
  );
  
  
  cutoffLFOPhaseKnob.active = c_lfo_enabled;
  cutoffLFOPhaseKnob.value = (c_lfo_center_phase + 1) * .5;
  cutoffLFOPhaseKnob.drawKnob(cX, cY - .6*knobSize, .5*knobSize, "", "Cutoff LFO Phase", 1.0);
  cutoffLFOPhaseKnob.label = "";
  cutoffLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !cutoffLFOPhaseKnob.justReleased ? ( c_lfo_center_phase = 2 * cutoffLFOPhaseKnob.value - 1; );
  );
  
  cX = nextPanel + panelSpacing;
);

function morph_lfo_panel()
(
  nextPanel = drawPanel(s_MLFO, cX, cY - .53*panelHeight + .2*knobSize, 9.65*knobSpacing, panelHeight, m_lfo_enabled);
  cX += 2 * knobSpacing;
  morphLFOAmountKnob.active = m_lfo_enabled;
  morphLFOAmountKnob.value = m_lfo_amnt;
  morphLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Morph LFO Amount.\n\nPress RMB to toggle forward.\nGo backwards by pressing LMB while still\nholding RMB from the forward toggle.\nPress LMB and drag to change amount.", 1.0);
  draw_lfo(cX - 15*(1+scaling), cY - 10*(1+scaling), 30*(1+scaling), 20*(1+scaling), m_lfo_type, m_lfo_center_phase, m_lfo_time);
  dial_animation ? (
    morphLFOAmountKnob.knob_draw_modifier(current_m_lfo_amnt - m_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    morphLFOAmountKnob.knob_draw_modifier(current_m_lfo_amnt - m_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  morphLFOAmountKnob.knob_draw_modifier(m_lfo_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  morphLFOAmountKnob.knob_draw_modifier(m_lfo_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  activeModifier == 2 ? ( morphLFOAmountKnob.knob_modifier_processMouse(0, m_lfo_amnt_mod) ? ( m_lfo_amnt_mod = morphLFOAmountKnob.value; );
  ) : activeModifier == 1 ? ( morphLFOAmountKnob.knob_modifier_processMouse(0, m_lfo_amnt_vel) ? ( m_lfo_amnt_vel = morphLFOAmountKnob.value; );
  ) : (
    mouse_cap == 2 && lcap == 0 ? (
      morphLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
        m_lfo_type += 1;
        m_lfo_type > max_lfo_types ? m_lfo_type = 0;
      );
    ) : ( mouse_cap == 3 && lcap == 2 ) ? (
      morphLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
        m_lfo_type -= 1;
        m_lfo_type < 0 ? m_lfo_type = max_lfo_types - 1;
        morphLFOAmountKnob.lastLeftClick = -10000;
      );
    ) : (
      morphLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
        !morphLFOAmountKnob.justReleased ? ( m_lfo_amnt = morphLFOAmountKnob.value; );
        slider_automate(m_lfo_amnt, morphLFOAmountKnob.justReleased);
      );
    );
  );
  
  morphLfoEnabledToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_enabled, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable LFO.");
  m_lfo_enabled = morphLfoEnabledToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  morphLfoResetToggle.inactive = !m_lfo_enabled;
  morphLfoResetToggle.drawToggle(cX+knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
  m_lfo_reset = morphLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX += 2.5 * knobSize;
  morphSyncToggle.inactive = !m_lfo_enabled;
  morphSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync rate to tempo.");
  m_lfo_sync = morphSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  morphLFOSpeedKnob.active = m_lfo_enabled;
  morphLFOSpeedKnob.value = m_lfo_speed / 20;
  m_lfo_sync ? (
    morphLFOSpeedKnob.label = morph_LFO.tempoLabel;
  ) : (
    morphLFOSpeedKnob.label = sprintf(5, "%.1f Hz", 10^(m_lfo_speed/15) - 1);
  );
  morphLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Morph LFO frequency", 1.0);
  dial_animation ? (
    morphLFOSpeedKnob.knob_draw_modifier((current_m_lfo_speed_slider*15 - m_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    morphLFOSpeedKnob.knob_draw_modifier((current_m_lfo_speed_slider*15 - m_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  morphLFOSpeedKnob.knob_draw_modifier(m_lfo_speed_vel / 20, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  morphLFOSpeedKnob.knob_draw_modifier(m_lfo_speed_mod / 20, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  activeModifier == 2 ? ( morphLFOSpeedKnob.knob_modifier_processMouse(0, m_lfo_speed_mod/20) ? ( m_lfo_speed_mod = morphLFOSpeedKnob.value * 20; );
  ) : activeModifier == 1 ? ( morphLFOSpeedKnob.knob_modifier_processMouse(0, m_lfo_speed_vel/20) ? ( m_lfo_speed_vel = morphLFOSpeedKnob.value * 20; );
  ) : (
    morphLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      !morphLFOSpeedKnob.justReleased ? (
        m_lfo_speed = morphLFOSpeedKnob.value * 20;
        updateTempo();
      );
      slider_automate(m_lfo_speed, morphLFOSpeedKnob.justReleased);
    );
  );
  
  cX += 1.85 * knobSize;
  
  morphLFOLRPhaseKnob.active = m_lfo_enabled;
  morphLFOLRPhaseKnob.value = (m_lfo_phase + 1) * .5;
  morphLFOLRPhaseKnob.drawKnob(cX, cY + .65*knobSize, .5*knobSize, "", "Morph Pan LFO Phase", 1.0);
  morphLFOLRPhaseKnob.label = "LR";
  morphLFOLRPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !morphLFOLRPhaseKnob.justReleased ? ( m_lfo_phase = 2 * morphLFOLRPhaseKnob.value - 1; );
    slider_automate(m_lfo_phase, morphLFOLRPhaseKnob.justReleased);
  );
  
  morphLFOPhaseKnob.active = m_lfo_enabled;
  morphLFOPhaseKnob.value = (m_lfo_center_phase + 1) * .5;
  morphLFOPhaseKnob.drawKnob(cX, cY - .6 * knobSize, .5*knobSize, "", "Morph LFO Phase", 1.0);
  morphLFOPhaseKnob.label = "";
  morphLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !morphLFOPhaseKnob.justReleased ? ( m_lfo_center_phase = 2 * morphLFOPhaseKnob.value - 1; );
  );
  
  cX = nextPanel + panelSpacing;
);

function free_lfo_panel()
(
  nextPanel = drawPanel(s_FLFO, cX, cY - .53*panelHeight + .2*knobSize, 9.65*knobSpacing, panelHeight, c_lfo_enabled);
  
  cX += 2 * knobSpacing;
  
  freeLFOAmountKnob.active = f_lfo_enabled;
  freeLFOAmountKnob.value = f_lfo_amnt;
  freeLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount.\n\nPress RMB to toggle forward.\nGo backwards by pressing LMB while still\nholding RMB from the forward toggle.\nPress LMB and drag to change amount.", 1.0);
  draw_lfo(cX - 15*(1+scaling), cY - 10*(1+scaling), 30*(1+scaling), 20*(1+scaling), f_lfo_type, f_lfo_center_phase, f_lfo_time);
  dial_animation ? (
    freeLFOAmountKnob.knob_draw_modifier(current_f_lfo_amnt - f_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    freeLFOAmountKnob.knob_draw_modifier(current_f_lfo_amnt - f_lfo_amnt, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  freeLFOAmountKnob.knob_draw_modifier(f_lfo_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  freeLFOAmountKnob.knob_draw_modifier(f_lfo_amnt_mod, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a, 2);
  activeModifier == 2 ? ( freeLFOAmountKnob.knob_modifier_processMouse(0, f_lfo_amnt_mod) ? ( f_lfo_amnt_mod = freeLFOAmountKnob.value; );
  ) : activeModifier == 1 ? ( freeLFOAmountKnob.knob_modifier_processMouse(0, f_lfo_amnt_vel) ? ( f_lfo_amnt_vel = freeLFOAmountKnob.value; );
  ) : (
    mouse_cap == 2 && lcap == 0 ? (
      freeLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
        f_lfo_type += 1;
        f_lfo_type > max_lfo_types ? f_lfo_type = 0;
      );
    ) : ( mouse_cap == 3 && lcap == 2 ) ? (
      freeLFOAmountKnob.knob_over(mouse_x, mouse_y) ? (
        f_lfo_type -= 1;
        f_lfo_type < 0 ? f_lfo_type = max_lfo_types - 1;
        freeLFOAmountKnob.lastLeftClick = -10000; /* Prevent double click from triggering from this */
      );
    ) : (
      freeLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
        !freeLFOAmountKnob.justReleased ? ( f_lfo_amnt = freeLFOAmountKnob.value; );
        slider_automate(f_lfo_amnt, freeLFOAmountKnob.justReleased);
      );
    );
  );
  
  freeLfoEnabledToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, f_lfo_enabled, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
  f_lfo_enabled = freeLfoEnabledToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  freeLfoResetToggle.inactive = !f_lfo_enabled;
  freeLfoResetToggle.drawToggle(cX+knobSize, cy-knobSize, .15*knobSize, .15*knobSize, f_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
  f_lfo_reset = freeLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  cX += 2.5 * knobSize;
  freeSyncToggle.inactive = !f_lfo_enabled;
  freeSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, f_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync rate to tempo.");
  f_lfo_sync = freeSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  freeLFOSpeedKnob.active = f_lfo_enabled;
  freeLFOSpeedKnob.value = f_lfo_speed / 20;
  f_lfo_sync ? (
    freeLFOSpeedKnob.label = free_LFO.tempoLabel;
  ) : (
    freeLFOSpeedKnob.label = sprintf(3, "%.1f Hz", 10^(f_lfo_speed/15) - 1);
  );
  freeLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
  dial_animation ? (
    freeLFOSpeedKnob.knob_draw_modifier((current_f_lfo_speed_slider*15 - f_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    freeLFOSpeedKnob.knob_draw_modifier((current_f_lfo_speed_slider*15 - f_lfo_speed)/20, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  freeLFOSpeedKnob.knob_draw_modifier(f_lfo_speed_vel / 20, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  freeLFOSpeedKnob.knob_draw_modifier(f_lfo_speed_mod / 20, bipolar, mod2_color_r, mod2_color_g, mod2_color_b, mod1_color_a, 2);
  activeModifier == 2 ? ( freeLFOSpeedKnob.knob_modifier_processMouse(0, f_lfo_speed_mod / 20) ? ( f_lfo_speed_mod = freeLFOSpeedKnob.value * 20; );
  ) : activeModifier == 1 ? ( freeLFOSpeedKnob.knob_modifier_processMouse(0, f_lfo_speed_vel / 20) ? ( f_lfo_speed_vel = freeLFOSpeedKnob.value * 20; );
  ) : (
    freeLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
      !freeLFOSpeedKnob.justReleased ? (
        f_lfo_speed = freeLFOSpeedKnob.value * 20;
        updateTempo();
      );
      slider_automate(f_lfo_speed, freeLFOSpeedKnob.justReleased);
    );
  );
  
  cX += 1.85 * knobSize;
  
  freeLFOPhaseKnob.active = f_lfo_enabled;
  freeLFOPhaseKnob.value = (f_lfo_center_phase + 1) * .5;
  freeLFOPhaseKnob.drawKnob(cX, cY - .6*knobSize, .5*knobSize, "", "Cutoff LFO Phase", 1.0);
  freeLFOPhaseKnob.label = "";
  freeLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !freeLFOPhaseKnob.justReleased ? ( f_lfo_center_phase = 2 * freeLFOPhaseKnob.value - 1; );
  );
  
  handleModifier("LINK", cX - .5 * knobSize, cY + .5 * knobSize, knobSize, knobSize, 3, "Link LFO");
);

function dist_panel()
(
  nextPanel = drawPanel(s_DIST, cX, cY - .53*panelHeight + .2*knobSize, 7.7*knobSpacing, panelHeight, shaper);
  cX += 2.05 * knobSpacing;
  shaperToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, shaper, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable waveshaper.");
  shaper = shaperToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  higainToggle.inactive = !shaper;
  higainToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, higain, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "High gain mode.");
  higain = higainToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  distKnob.knob_set(sprintf(1, "%.1f dB", current_ceiling), shaper, current_ceiling / 48);
  distKnob.drawKnob(cX, cY, knobSize, "Distortion", "Distortion level\n\nDistortion applied post-filter.", 0);
  dial_animation ? (
    distKnob.knob_draw_modifier((cur_ceiling - current_ceiling) / 48, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    distKnob.knob_draw_modifier((cur_ceiling - current_ceiling) / 48, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  distKnob.knob_draw_modifier(current_ceiling_vel / 48, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( distKnob.knob_modifier_processMouse(0, current_ceiling_vel / 48) ? ( current_ceiling_vel = distKnob.value * 48; );
  ) : distKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    !distKnob.justReleased ? ( current_ceiling = distKnob.value * 48; );
    slider_automate(current_ceiling, distKnob.justReleased);
  );
   
  cX += 2.5 * knobSize;
  
  warmthKnob.active = shaper;
  warmthKnob.value = (warmth + 12) / 24;
  warmthKnob.drawKnob(cX, cY, knobSize, "Warmth", "Distortion warmth.\n\nApplies pre- and post-emphasis filters.", .5);
  warmthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    !warmthKnob.justReleased ? ( warmth = warmthKnob.value * 24 - 12; );
    slider_automate(warmth, warmthKnob.justReleased);
  );
  
  cX = nextPanel + panelSpacing;
);

function effects_panel()
(
  // Effects panel
  nextPanel = drawPanel(s_FX, cX, cY - .53*panelHeight + .2*knobSize, 8.125*knobSpacing, panelHeight, 1);
  
  cX += 1.375 * knobSize;
  chorusKnob.knob_set("", 1, chorus_enabled / 2);
  chorusKnob.drawKnob(cX, cY, knobSize, "Space", "Bass preserving spatializer (pairs well with delay!)", 1.0);
  chorusKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
    chorus_enabled = chorusKnob.value * 2;
  );
  
  cX += 2 * knobSize + knobSpacing;
  feedbackTwoToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, fb_mode, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Direct feedback mode. Directly routes output to drive. Can be used to massively distort the input.");
  fb_mode = feedbackTwoToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  feedbackKnob.active = !(filter_type == 0 || filter_type == 2);
  feedbackKnob.value = fb;
  feedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Are you crazy?", 0);
  dial_animation ? (
    feedbackKnob.knob_draw_modifier(current_fb - fb, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -.1);
    feedbackKnob.knob_draw_modifier(current_fb - fb, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, .1);
  );
  feedbackKnob.knob_draw_modifier(fb_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
  activeModifier == 1 ? ( feedbackKnob.knob_modifier_processMouse(0, fb_vel) ? ( fb_vel = feedbackKnob.value; );
  ) : feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    !feedbackKnob.justReleased ? ( fb = feedbackKnob.value; );
    slider_automate(fb, feedbackKnob.justReleased);
  );
  
  cx += 1.65 * knobSize;
  
  cX = nextPanel + panelSpacing;
);

function options_panel()
(
  showOptions = 1;
  showOptions ? (
    cX = nextPanel + panelSpacing;
    
    nextPanel = drawPanel(s_OPTS, cX, cY - .53*panelHeight + .2*knobSize, 11.25*knobSpacing, panelHeight, 1);
    cX += 2*knobSpacing;
    
    tempoSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, tempo_sync_envelopes, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use tempo synced envelopes.");
    tempo_sync_envelopes_tmp = tempoSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    tempo_sync_envelopes != tempo_sync_envelopes_tmp ? (
      tempo_sync_envelopes = tempo_sync_envelopes_tmp;
      tempo_sync_envelopes ? (
        amp_atk = to_synced(amp_atk, 1.0);
        amp_decay = to_synced(amp_decay, 0.1);
        cutoff_atk = to_synced(cutoff_atk, 1.0);
        cutoff_decay = to_synced(cutoff_decay, 0.1);
      ) : (
        amp_atk = to_non_synced(amp_atk, 1.0);
        amp_decay = to_non_synced(amp_decay, 0.1);
        cutoff_atk = to_non_synced(cutoff_atk, 1.0);
        cutoff_decay = to_non_synced(cutoff_decay, 0.1);
      );
    );
    
    
    oversamplingKnob.active = 1;
    oversampling != floor(oversamplingKnob.value * 7 + 1) ? (
      oversamplingKnob.value = (oversampling - 1) / 7;
    );
    oversamplingKnob.drawKnob(cX, cY, knobSize, "Oversampling", "Change the oversampling ratio. Some filters need this for stability.\nNote that it severely affects CPU cost though.", 1.0);
    oversamplingKnob.label = sprintf(7, "x%d", oversampling);
    oversamplingKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
      newOversampling = floor(oversamplingKnob.value * 7 + 1);
      floor(newOversampling) != overSampling ? (
        oversampling = newOversampling;
        updateSlider();
      );
    );
    
    dcCorrectionToggle.label = sprintf(34, "");
    dcCorrectionToggle.drawToggle(cX + 0.9 * knobSize, cy-knobSize, .15*knobSize, .15*knobSize, fix_dc, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Block DC.");
    fix_dc = dcCorrectionToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    economyToggle.label = sprintf(34, "");
    economyToggle.drawToggle(cX + 0.9 * knobSize, cy + 0.8 * knobSize, .15*knobSize, .15*knobSize, eco, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Economy mode.\n\nEnabling this results in fewer updates\nto the filter coefficients.");
    eco = economyToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    cX += 2.5 * knobSize;
    inertiaKnob.active = 1;
    inertiaKnob.value = inertia / 200;
    inertiaKnob.label = sprintf(8, "%d ms", inertia);
    inertiaKnob.drawKnob(cX, cY, knobSize, "Inertia", "Sets how quickly parameters respond to changes.", 1.0);
    inertiaKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 60/200) ? (
      inertia = inertiaKnob.value * 200;
    );
    
    legacyToggle.drawToggle(cX-knobSize, cY-knobSize, .15*knobSize, .15*knobSize, legacy_mode, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "In previous versions of FM Filter 2,\n the filter range was always mapped\nto the full range from zero to\n0.934 * Nyquist. This meant that\npresets were samplerate dependent.\n\nIn the newer version, the range always\nruns from 0 to 20.6 kHz (irrespective of\nsample rate).\n\nWhen this button is enabled, the\nold mode is returned.");
    legacy_mode = legacyToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    cX += 2.5 * knobSize;
    pitchBendKnob.active = 1;
    pitchBendKnob.value = pitchBendRange / 12;
    pitchBendKnob.label = sprintf(8, "%d st", floor(pitchBendRange));
    pitchBendKnob.drawKnob(cX, cY, knobSize, "Bend range", "Pitch bend range.", 1.0);
    pitchBendKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 60/200) ? (
      pitchBendRange = pitchBendKnob.value * 12;
    );
  );
  
  cX = nextPanel + panelSpacing;
);

cX = xOrigin;
cY = yOrigin;
drive_panel();
filter_panel();
fm_panel();
cX = xOrigin - 2*knobSpacing;
cY = cY + 4 * knobSize;
filter_envelope_panel();
cutoff_lfo_panel();
morph_lfo_panel();
free_lfo_panel();
cX = xOrigin - 2*knobSpacing;
cY = cY + 4 * knobSize;
amp_envelope_panel();
effects_panel();
//feedback_panel();
dist_panel();
options_panel();
cX += 0.1 * knobSize;
handleModifier("VEL", cX, cY - 1.15 * knobSize, knobSize, knobSize, 1, "Link MIDI velocity");
handleModifier("MOD", cX, cY + .5 * knobSize, knobSize, knobSize, 2, "Link Mod Wheel");


cX = xOrigin;
cY += 2.2 * knobSize;


gfx_set(0, 0, 0, 0);
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_set(1, 1, 1, 1);

warning > 0 ? (
  gfx_set(1,1,1,1);
  gfx_x = 0;
  gfx_y = 0;
  gfx_a = warning / 75;
  gfx_printf("Warning, cutoff clamped! Without oversampling, this non-linear filter cannot safely go to higher cutoff frequencies.");
  warning -= 1;
);

lcap = mouse_cap;

hinter.drawHint_draw();

gfx_x = cX;
gfx_y = cY + .3 * knobSize;
gfx_printf("BETA / WORK IN PROGRESS! If you make a sound you really like, make sure you freeze it as the filter is still subject to change!");
gfx_printf(" %d", midi.activeNoteMem[0]);
gfx_printf(" %d", midi.activeNoteMem[1]);
gfx_printf(" %d", midi.activeNoteMem[2]);
gfx_printf(" %d", midi.activeNoteMem[3]);
gfx_printf(" %d", midi.activeNoteMem[4]);
last_mouse_x = mouse_x;
last_mouse_y = mouse_y;

style == 2 ? (
  crt_t += .1;
  cy = 0;
  loop(gfx_h / 3,
    gfx_set(0, 0, 0, .3 + .15 * sin(.1*cy+crt_t));
    gfx_line(0, cy, gfx_w, cy);
    gfx_line(0, cy+1, gfx_w, cy+1);
    cy += 3;
  );
);
