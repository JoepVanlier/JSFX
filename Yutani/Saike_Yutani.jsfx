desc:Yutani Mono Bass Synth [Saike] (WORK IN PROGRESS)
tags: synth bass
version: 0.07
author: Joep Vanlier
changelog: Add velocity reset. Balance fin and triangle a bit more. Fixed note clicking issue with hardsync in freeroam mode.
license: MIT
provides:
  Yutani_Dependencies/*
  bass_presets.rpl

Attribution: Moog filter implementation was based on the paper:
S. D'Angelo and V. Vaelimaeki, "Generalized Moog Ladder Filter: Part II - Explicit Non linear Model through a Novel Delay-Free
Loop Implementation Method". IEEE Trans. Audio,Speech, and Lang. Process., vol. 22, no. 12, pp. 1873-1883, December 2014.
303 emulation is Co pyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
minBLEP methodology Eli Brandt, "Hard Sync Without Aliasing", 

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:osc1_db=-9<-48, 0, .000001>-Oscillator 1 Gain
slider2:osc1_semi=0<-36, 36, .000001>-Oscillator 1 Semitone
slider3:free_osc=0<0, 1, 1>-Reset Osc on note
slider4:osc1_shape=0<0,2,1{Saw,Square,Triangle,Fin}>-Oscillator 1 Shape

slider5:osc2_db=-9<-48, 0, .000001>-Oscillator 2 Gain
slider6:osc2_semi=12<-36, 36, .000001>-Oscillator 2 Semitone
slider7:hardsync=1<0,1,1{Off,On}>-Hard Sync
slider8:osc2_shape=0<0,2,1{Saw,Square,Triangle,Fin}>-Oscillator 2 Shape

slider9:glide_time=.4<0,1,.00001>-Glide time

slider10:amp_accent=0<0, 1, 1>-Amp Accent
slider11:amp_atk=0<0, 1, .000001>-Amp Attack
slider12:amp_decay=1<0, 1, .000001>-Amp Decay
slider13:amp_sustain=1<0, 1, .00001>-Sustain level

slider14:pitch_env=0<-12, 12, .000001>-Pitch envelope level
slider15:pitch_atk=0<0, 1, .000001>-Pitch Attack
slider16:pitch_decay=1<0, 1, .000001>-Pitch Decay
slider17:dummy=0<0,1,1>-Dummy

slider18:multi=1<1, 4, 1>-Active Oscs
slider19:amp2=0<0, 1,.00001>-Voice 2 [%]
slider20:detune2=0<-1, 1, .00001>-Detune [semitones]
slider21:amp3=0<0, 1,.00001>-Voice 3 [%]
slider22:detune3=0<-1, 1, .00001>-Detune [semitones]
slider23:amp4=0<0, 1,.00001>-Voice 4 [%]
slider24:detune4=0<-1, 1, .00001>-Detune [semitones]

slider25:filter_type=1<0,5,1{Linear,MS-20,Linear x2,Moog,Ladder,303}>-Filter type
slider26:drive=0<-32,48,1>-Filter Drive (dB)
slider27:boost=0<-6,48,1>-Post Boost (dB)
slider28:cutoff=.6<0,1,.0001>-Cutoff
slider29:resonance=0.7<0,1,.0001>-Resonance
slider30:morph=0<0,1,.0001>-Morph

slider31:m_lfo_amnt=0<0,1,.00001>-Morph LFO amount
slider32:m_lfo_speed=0<0,20,.001>-Morph LFO speed [-]
slider33:m_lfo_phase=0<0,30,.001>-Morph LFO phase [radian]
slider34:c_lfo_amnt=0<0,1,.00001>-Cutoff LFO amount
slider35:c_lfo_speed=0<0,20,.001>-Cutoff LFO speed [-]
slider36:c_lfo_phase=0<0,36,.001>-Cutoff LFO phase [radian]

slider37:fm_mode=0<0,5,1{MIDI sin,MIDI square,Self,Self Abs,Audio Stereo 3/4,Audio Mono 3/4}>-FM mode
slider38:fm_amnt=0<0,1,.0001>-FM level
slider39:fm_factor=<-8,8,1>-FM rate factor
slider40:fm_spread=<0,1,.001>-FM spread
slider41:key_follow=0<0,1,.0001>-Key Follow
slider42:fm_cutoff=1<0,1,.0001>-FM Cutoff

slider43:env_amnt=0<-1,1,.0001>-Envelope Amount
slider44:cutoff_atk=0.5<0,1,.0001>-Cutoff Attack
slider45:cutoff_decay=0.5<0,1,.0001>-Cutoff Decay
slider46:cutoff_sustain=0<0,1,.0001>-Cutoff Sustain
slider47:dummy=0<0,1,1>-Dummy

slider48:current_ceiling=0<0,48,1>-Distortion level [dB]
slider49:warmth=0<-12,12,1>-Warmth
slider50:pwm_phase=0<0, 1, .000001>-PWM phase
slider51:pwm_depth=0.4<0, 1, .000001>-PWM depth
slider52:pwm_rate=0.85<0, 1, .000001>-PWM rate
slider53:fb=0<0, 1, .000001>-Feedback

slider60:global_offset=0<-10,10,.00000001>-global offset blep
slider61:blep_type=0<0,1,1{MinPhase,Linear (broken)}>-Blep type
slider62:fix_dc=0<0,1,1>Fix DC
slider63:inertia=60<0,200,.001>-Filter Inertia [ms]
slider64:oversampling=1<1,8,1>-Oversampling

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import Saike_Yutani_midilib.jsfx-inc
import Saike_Yutani_distortion.jsfx-inc
import Saike_Yutani_Oscs.jsfx-inc
import Saike_Yutani_Envelope.jsfx-inc
import Saike_Yutani_interpolators.jsfx-inc
import Saike_Yutani_filters.jsfx-inc
import Saike_Yutani_oversampling.jsfx-inc
import Saike_Yutani_widgets.jsfx-inc
import Saike_Yutani_sample_delay_buffer.jsfx-inc

@init
freemem = 0;

freemem = (midimem = freemem) + 32768;
midi.initializeMIDI(midimem, 0, 1);
midi.notesOn = 0;

// Memory layout
freemem = (MINBLEP = freemem) + 32768;
freemem = (MINBLAMP = freemem) + 32768;
init_blep(MINBLEP);
init_blamp(MINBLAMP);
freemem = (LINBLEP = freemem) + 32768;
freemem = (LINBLAMP = freemem) + 32768;
group_delay = init_linear_BLEP_BLAMP(LINBLEP, LINBLAMP);

freemem = (LAG_BUFFER = freemem) + 32768;
lagBuffer.init_sample_delay_buffer(LAG_BUFFER, LAG_BUFFER + 1000, group_delay);

freemem = (bufferloc = freemem) + 32768;
blepBuffer.initBLBuffer(bufferloc);
freemem = (bufferloc = freemem) + 32768;
blampBuffer.initBLBuffer(bufferloc);

/* Oversampling memory */
freemem = (sinc_hist1 = freemem) + 10000;
freemem = (sinc_hist2 = freemem) + 10000;
freemem = (sinc_flt = freemem) + 10000;
freemem = (sinc_flt2 = freemem) + 10000;
freemem = (sinc_flt3 = freemem) + 10000;
freemem = (sinc_flt4 = freemem) + 10000;
freemem = (sinc_tmp = freemem) + 10000;


function initialize_interpolators()
(
  // Set up the interpolators
  cutoff_interpolator.interpolator_init(28);
  reso_interpolator.interpolator_init(29);
  morph_interpolator.interpolator_init(30);
  drive_interpolator.interpolator_init(26);
  gain_interpolator.interpolator_init(27);
  morph_phase_interpolator.interpolator_init(33);
  cutoff_phase_interpolator.interpolator_init(36);
    
  current_ceiling_interpolator.interpolator_init(48);
  warmth_interpolator.interpolator_init(49);
     
  (last_inertia != inertia) ? (
    last_inertia = inertia;
    inertia_cutoff = 1000.0/inertia;
    cutoff_interpolator.initialize_smoother(inertia_cutoff);
    reso_interpolator.initialize_smoother(inertia_cutoff);
    morph_interpolator.initialize_smoother(inertia_cutoff);
    drive_interpolator.initialize_smoother(inertia_cutoff);
    gain_interpolator.initialize_smoother(inertia_cutoff);
    morph_phase_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_phase_interpolator.initialize_smoother(inertia_cutoff);
    current_ceiling_interpolator.initialize_smoother(inertia_cutoff);
    warmth_interpolator.initialize_smoother(inertia_cutoff);
    cutoff_interpolator.s = slider(28);
    reso_interpolator.s = slider(29);
    morph_interpolator.s = slider(30);
    drive_interpolator.s = slider(26);
    gain_interpolator.s = slider(27);
    morph_phase_interpolator.s = slider(33);
    cutoff_phase_interpolator.s = slider(36);
    current_ceiling_interpolator.s = slider(45);
    warmth_interpolator.s = slider(46);
  );
);

function updateFMFilter()
local()
global(FM_filter.init_linearSVF, fm_cutoff, last_fm_cutoff)
instance()
(
  (fm_cutoff != last_fm_cutoff) ? (
    FM_filter.init_linearSVF(fm_cutoff, 0);
    last_fm_cutoff = fm_cutoff;
  );
);

function updateSlider()
(
  current_safety_moog = (1.0 - log(safety_limit_moog * oversampling) / log(20/22050));
  initialize_interpolators();
  check_safety();
);

function updateTempo()
(
  cutoff_LFO.envelopeTempo(c_lfo_speed/20);
  morph_LFO.envelopeTempo(m_lfo_speed/20);
);

last_fm_cutoff = -1;
UpdateFMFilter();

@serialize
file_var(0, 1); // Version
file_var(0, m_lfo_sync);
file_var(0, c_lfo_sync);
file_var(0, shaper);
file_var(0, higain);
file_var(0, reset);
file_var(0, cutoff_reset);
file_var(0, amp_before_filter);

file_var(0, cutoff_vel);
file_var(0, reso_vel);
file_var(0, morph_vel);
    
file_var(0, fm_amnt_vel);
file_var(0, fm_spread_vel);
    
file_var(0, cutoff_atk_vel);
file_var(0, cutoff_decay_vel);
file_var(0, cutoff_sustain_vel);
     
file_var(0, amp_atk_vel);
file_var(0, amp_decay_vel);
file_var(0, amp_sustain_vel);
file_var(0, env_amnt_vel);

file_var(0, pitch_amnt_vel);
file_var(0, pitch_atk_vel);
file_var(0, pitch_decay_vel);

file_var(0, drive_vel);
file_var(0, osc1_db_vel);
file_var(0, osc2_db_vel);
file_var(0, boost_vel);

file_var(0, osc1_semi_vel);
file_var(0, osc2_semi_vel);

file_var(0, pwm_phase_vel);
file_var(0, pwm_depth_vel);
file_var(0, pwm_rate_vel);

file_var(0, c_lfo_reset);
file_var(0, m_lfo_reset);

loop(199,
  file_var(0, 0);
);

@slider
updateSlider();
updateTempo();
israte = 2.0*$pi/srate;

@block
updateTempo();
israte = 2.0*$pi/srate;
midi.processMIDIBlock(); 

cutoff_interpolator.interpolator_block();
reso_interpolator.interpolator_block();
morph_interpolator.interpolator_block();
drive_interpolator.interpolator_block();
gain_interpolator.interpolator_block();
morph_phase_interpolator.interpolator_block();
cutoff_phase_interpolator.interpolator_block();
current_ceiling_interpolator.interpolator_block();
warmth_interpolator.interpolator_block();
    
// Update the oversampling filters when needed.
( oversampling != lastOversample ) ? (
  lastOversample = oversampling;   
  
  // Memory for the sincs is located at sinc_tmp, sinc_flt, sinc_flt2, sinc_flt3 and sinc_flt4
  sincFilterL.updateSincFilter(oversampling, 8, sinc_flt,  sinc_tmp);
  sincFilterR.updateSincFilter(oversampling, 8, sinc_flt2, sinc_tmp);
  nTapSinc = oversampling < 5 ? 16 : oversampling*4;
  sincDownL.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist1, sinc_flt3);
  sincDownR.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist2, sinc_flt4);  
);

osc1_correction = (osc1_shape == 2) || (osc1_shape == 3) ? 1.25 : 1;
osc2_correction = (osc2_shape == 2) || (osc2_shape == 3) ? 1.25 : 1;

@sample
shaper ? (
  cur_ceiling = clamp(current_ceiling_interpolator.interpolate() + current_ceiling_vel, 0, 48);
  sat_slider_update(cur_ceiling, warmth_interpolator.interpolate(), oversampling);
);

lf_update_step += 1;
lf_update_step % 8 == 0 ? (
  o1db = clamp(osc1_db + osc1_db_velmod, -48, 0);
  o2db = clamp(osc2_db + osc2_db_velmod, -48, 0);
  osc1_vol = o1db > -47.8 ? exp(0.11512925464970229 * o1db) * osc1_correction: 0;
  osc2_vol = o2db > -47.8 ? exp(0.11512925464970229 * o2db) * osc2_correction: 0;
  lf_update_step = 0;
  current_c_lfo_speed = 10^(c_lfo_speed/15) - 1;
  current_m_lfo_speed = 10^(m_lfo_speed/15) - 1;
  
  amp_correction = .25 / (1.0 + amp2 + amp3 + amp4);
);

midi.processMIDISample() ? (
  midiChange = 1;
  
  FM_t = 0;
  pitch = 2^((midi.lastNote - 69)/12);
  keyfollow_mod = log(pitch) / log(20/22050);
 
  note_1 = midi.lastNote - 69 + (osc1_semi + osc1_semi_vel * midi.lastVel);
  note_2 = midi.lastNote - 69 + (osc2_semi + osc2_semi_vel * midi.lastVel);
  oscs.oscs_midinote(note_1, note_2, osc1_shape, osc2_shape);
  oscs2.oscs_midinote(note_1+detune2, note_2+detune2, osc1_shape, osc2_shape);
  oscs3.oscs_midinote(note_1+detune3, note_2+detune3, osc1_shape, osc2_shape);
  oscs4.oscs_midinote(note_1+detune4, note_2+detune4, osc1_shape, osc2_shape);
 
  midi.notesOn == 1  ? (
    cutoff_velmod = cutoff_vel * midi.lastVel;
    reso_velmod = reso_vel * midi.lastVel;
    morph_velmod = morph_vel * midi.lastVel;
    
    current_fm_amnt = fm_amnt + fm_amnt_vel * midi.lastVel;
    current_fm_spread = fm_spread + fm_spread_vel * midi.lastVel;
    current_env_amnt = clamp(env_amnt + env_amnt_vel * midi.lastVel, -1, 1);
    current_pitch_env = clamp(pitch_env + pitch_amnt_vel, -12, 12);
    
    osc1_db_velmod = osc1_db_vel * midi.lastVel;
    osc2_db_velmod = osc2_db_vel * midi.lastVel;
    
    drive_velmod = drive_vel * midi.lastVel;
    boost_velmod = boost_vel * midi.lastVel;
  
    c_lfo_reset ? c_lfo_time = 0;
    m_lfo_reset ? m_lfo_time = 0;
  
    amp_env.calc_times(cl01(amp_atk + amp_atk_vel), cl01(amp_decay + amp_decay_vel), cl01(amp_sustain + amp_sustain_vel));
    amp_env.reset_envelope(reset && amp_before_filter);
    pitch_env.calc_times(cl01(pitch_atk + pitch_atk_vel), cl01(pitch_decay + pitch_decay_vel), 0);
    pitch_env.reset_envelope();
    cutoff_env.calc_times(cl01(cutoff_atk + cutoff_atk_vel), cl01(cutoff_decay + cutoff_decay_vel), cl01(cutoff_sustain + cutoff_sustain_vel));
    cutoff_env.reset_envelope(cutoff_reset);
    !cutoff_reset ? cutoff_env.k_rise = .25*cutoff_env.k_rise;
 
     pwm_master_active = slider(OSC1_SELECT) == 4;
     pwm_dt = cl01(pwm_rate + pwm_rate_vel) * 10.0/srate; //.0002;
     pwm_position = cl01(pwm_phase + pwm_phase_vel) * 2.0 * $pi;
     current_pwm_active = (slider(OSC1_SELECT) == 4) || (slider(OSC2_SELECT) == 4);
     current_pwm_depth = 0.5 * cl01(pwm_depth + pwm_depth_vel);
    
    k_glide = 1;
  ) : ( midi.notesOn > 1 ) ? (
    k_glide = calc_k(glide_time);
  );
);

current_pwm_active ? (
  pwm_position += pwm_dt;
  pwm_switch = .5 + current_pwm_depth * sin(pwm_position);
  
  pwm_master_active ? (
    oscs.osc2.t_current > 0 ? oscs.osc2.t_current = pwm_switch;
    oscs2.osc2.t_current > 0 ? oscs2.osc2.t_current = pwm_switch;
    oscs3.osc2.t_current > 0 ? oscs3.osc2.t_current = pwm_switch;
    oscs4.osc2.t_current > 0 ? oscs4.osc2.t_current = pwm_switch;
  );
);

amp_envelope = amp_env.update_envelope(midi.notesOn > 0);
pitch_envelope = pitch_env.update_envelope(midi.notesOn > 0);
cutoff_envelope = cutoff_env.update_envelope(midi.notesOn > 0);

// Oscillator section
  // Pulls in k_glide, hard_sync, amp_envelope, pitch_envelope and pitch_env from global namespace
  oscs.update_oscs_vol(osc1_vol, osc2_vol);
  oscs2.update_oscs_vol(osc1_vol, osc2_vol);
  oscs3.update_oscs_vol(osc1_vol, osc2_vol);
  oscs4.update_oscs_vol(osc1_vol, osc2_vol);
  
  y = 0;
  preamp_gain = amp_before_filter ? amp_envelope : 1;
  y += oscs.update_oscs(preamp_gain);
  multi == 2 ? (
    y += oscs2.update_oscs(preamp_gain)*amp2;
  ) : ( multi == 3 ) ? (
    y += oscs2.update_oscs(preamp_gain)*amp2;
    y += oscs3.update_oscs(preamp_gain)*amp3;
  ) : ( multi == 4 ) ? (
    y += oscs2.update_oscs(preamp_gain)*amp2;
    y += oscs3.update_oscs(preamp_gain)*amp3;
    y += oscs4.update_oscs(preamp_gain)*amp4;
  );
  
  blep_type ? (
    // Delay y by the linear phase delay
    y = lagBuffer.sample_delay_buffer(y);
    blepLevel = blepBuffer.readBLs(LINBLEP);
    blampLevel = blampBuffer.readBLs(LINBLAMP);
  ) : (
    // Add BLEPs
    blepLevel = blepBuffer.readBLs(MINBLEP);
    blampLevel = blampBuffer.readBLs(MINBLAMP);    
  );
  
  y = y + amp_accent*y*abs(y)*amp_envelope;
  y += blepLevel + blampLevel;
  y *= amp_correction;

// Filter modulation section
  sliderCutoffL = sliderCutoffR = cutoff_interpolator.interpolate() + cutoff_velmod;
  sliderReso = clamp(reso_interpolator.interpolate() + reso_velmod, 0, 1);
  sliderMorphL = sliderMorphR = morph_interpolator.interpolate() + morph_velmod;
  morph_phase = morph_phase_interpolator.interpolate();
  cutoff_phase = cutoff_phase_interpolator.interpolate();

  sliderCutoffL += cutoff_envelope * current_env_amnt;
  sliderCutoffR += cutoff_envelope * current_env_amnt;
  sliderCutoffL -= key_follow * keyfollow_mod;
  sliderCutoffR -= key_follow * keyfollow_mod;

  /* FM modulation of the filter */
  current_fm_amnt != 0 ? (
    updateFMFilter();
    FM_t += (2^floor(fm_factor))*440*israte*pitch;
    fm_mode == 0 ? (
      fm_mod1 = sin(FM_t);
      fm_mod2 = sin(FM_t+$pi*current_fm_spread);
    ) : ( fm_mode == 1 ) ? (
      fm_mod1 = abs(sin(FM_t)) * 2 - 1;
      fm_mod2 = abs(sin(FM_t+$pi*current_fm_spread)) * 2 - 1;
    ) : ( fm_mode == 2 ) ? (
      fm_mod2 = fm_mod1 = FM_filter.eval_linearSVF_LP(y);
    ) : ( fm_mode == 3 ) ? (
      fm_mod2 = fm_mod1 = FM_filter.eval_linearSVF_LP(abs(y));
    );
  );
  
  c_lfo_amnt > 0 ? (
    c_lfo_sync ? (
      c_lfo_time += israte * cutoff_LFO.cRate;
    ) : (
      c_lfo_time += israte * current_c_lfo_speed;    
    );
    sliderCutoffL = sliderCutoffL + c_lfo_amnt * sin(c_lfo_time + cutoff_phase);
    sliderCutoffR = sliderCutoffR + c_lfo_amnt * sin(c_lfo_time);
  );
  
  m_lfo_amnt > 0 ? (
    m_lfo_sync ? (
      m_lfo_time += israte * morph_LFO.cRate;
    ) : (
      m_lfo_time += israte * current_m_lfo_speed;    
    );
    sliderMorphL = sliderMorphL + m_lfo_amnt * sin(m_lfo_time + morph_phase);
    sliderMorphR = sliderMorphR + m_lfo_amnt * sin(m_lfo_time);
  );
  sliderMorphL = clamp(sliderMorphL, 0, 1);
  sliderMorphR = clamp(sliderMorphR, 0, 1);
  
  sliderCutoffL = clamp(sliderCutoffL + current_fm_amnt * fm_mod1, 0, .99);
  sliderCutoffR = clamp(sliderCutoffR + current_fm_amnt * fm_mod2, 0, .99);

  filter.init_filter(filter_type, sliderCutoffL, sliderCutoffR, sliderMorphL, sliderMorphR, sliderReso);
  
  // Gain setup
  log10d20_conversion  = .11512925464970228420089957273422;
  
  current_drive = clamp(drive_interpolator.interpolate() + drive_velmod, -6, 48);
  current_boost = clamp(gain_interpolator.interpolate() + boost_velmod, -6, 48);
  preamp      = exp(log10d20_conversion*current_drive);
  inv_preamp  = exp(-log10d20_conversion*current_drive);
  final_boost = exp(log10d20_conversion*current_boost);
  

  //y = dc0.eval_HP6(y);
  //y = dc1.eval_HP6(y);
  
  yr = yl = y *= preamp;
  
  fb ? (
    !(filter_type == 0 || filter_type == 2) ? (
      filter_type == 5 ? (
        fb_factor = .99 * fb * (1-cutoff);
        yl += fb_factor * last_yl;
        yr += fb_factor * last_yr;
        gc = 1/(1+2*fb_factor);
        yl *= gc;
        yr *= gc; 
      ) : filter_type == 1 ? (
        yl += .99 * fb * last_yl;
        yr += .99 * fb * last_yr;
        gc = 1/(1+1.5*fb);
        yl *= gc;
        yr *= gc;      
      ) : (
        yl -= .99 * fb * last_yl;
        yr -= .99 * fb * last_yr;
        gc = 1/(1+1.25*fb);
        yl *= gc;
        yr *= gc;
      );
    );
  );
  
  hotness_rmsq = .9999 * hotness_rms + .0001 * yl * yl;
  
  // Oversampled processing
  ( oversampling > 1 ) ? (
    sincFilterL.advanceSinc(yl);
    sincFilterR.advanceSinc(yr);
    
    loop( oversampling,
      ssl = sincFilterL.getSubSample();
      ssr = sincFilterR.getSubSample();
      
      filter.processSample(filter_type);
      ssl *= inv_preamp;
      ssr *= inv_preamp;
      shaper ? processShaper();
      
      sincDownL.advanceHist(ssl);
      sincDownR.advanceHist(ssr);
    );
    
    spl0 = sincDownL.sincDownSample();
    spl1 = sincDownR.sincDownSample();
  ) : (
    ssr = yr;
    ssl = yl;
    
    filter.processSample(filter_type);
    ssl *= inv_preamp;
    ssr *= inv_preamp;
    shaper ? processShaper();
    
    spl0 = ssl;
    spl1 = ssr;
  );
  
  last_yl = spl0;
  last_yr = spl1;
  
  spl0 *= final_boost;
  spl1 *= final_boost;
  
  !amp_before_filter ? (
    spl0 *= amp_envelope;
    spl1 *= amp_envelope;
  );
  
  fix_dc ? (
    spl0 = dc2.eval_HP6(spl0);
    spl1 = dc3.eval_HP6(spl1);
  );
  

@gfx 1454 505

render_time += .025;
gfx_set(21/255, 20/255, 21/255, 1.0);
gfx_rect(0, 0, gfx_w, gfx_h);

xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
widget_r = 35/255;
widget_g = 155/255;
widget_b = 30/255;
widget_a = 1.0;
toggle_r = .5;
toggle_g = 1.6;
toggle_b = .5;
toggle_a = 1.0;

cY = w1y + w1h + .4*(gfx_h-w1h);
panelY = cY - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;

xOrigin = 75*(1+scaling);
yOrigin = 65*(1+scaling);

font_color_r = .7;
font_color_g = .6;
font_color_b = .8;
font_color_a = 1;
knob_font_color_r = 0.9;
knob_font_color_g = 0.9;
knob_font_color_b = 0.8;
knob_font_color_a = 1;
edge_r = 39/255;
edge_g = 39/255;
edge_b = 41/255;
edge_a = 1.0;

edge_font_r = 0.9;
edge_font_g = 0.9;
edge_font_b = 0.8;

mod1_color_r = .3;
mod1_color_g = .47;
mod1_color_b = .6;
mod1_color_a = 1;
mod2_color_r = .1;
mod2_color_b = .2;
mod2_color_g = 1;
mod2_color_a = 1;


FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", 16 * (1+scaling));

BAND_FONT = 5;
gfx_setfont(BAND_FONT, "Arial", 16 * (1+scaling));

KNOB_FONT = 6;
gfx_setfont(KNOB_FONT, "Arial", 14 * (1+scaling));

KNOB_FONT2 = 7;
gfx_setfont(KNOB_FONT2, "Arial", 13 * (1+scaling));

HINT_FONT = 8;
gfx_setfont(HINT_FONT, "Arial", 13 * (1+scaling));

TOGGLE_FONT = 9;
gfx_setfont(TOGGLE_FONT, "Arial", 13 * (1+scaling));

cX = xOrigin;
cY = yOrigin;

drawPanel("OSCILLATOR 1", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 10*knobSpacing, panelHeight);
cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
OSC1_SELECT = 4;
drawSelectionButton("Saw", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, OSC1_SELECT);
drawSelectionButton("Square", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 1, OSC1_SELECT);
drawSelectionButton("Triangle", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 2, OSC1_SELECT);
drawSelectionButton("Fin", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 3, OSC1_SELECT);
drawSelectionButton("PWM", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 4, OSC1_SELECT);

oscResetToggle.drawToggle(cX-1.85*knobSize, cy+1.1*knobSize, .15*knobSize, .15*knobSize, free_osc, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Hard Sync\n\nReset oscillator 2 when oscillator 1 crosses zero.");
oscResetToggle.label = sprintf(33, " Free");
free_osc = oscResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += .65*knobSize;

osc1AmpKnob.knob_set(sprintf(1, "%.1f dB", osc1_db), 1, (osc1_db + 48)/48);
osc1AmpKnob.drawKnob(cX, cY, knobSize, "Amplitude", "Oscillator 1 gain.", 1.0);
osc1AmpKnob.knob_draw_modifier(osc1_db_vel / 48, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  osc1AmpKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 39/48) ? ( osc1_db = osc1AmpKnob.value * 48 - 48; slider_automate(osc1_db); );
) : osc1AmpKnob.knob_modifier_processMouse(0, osc1_db_vel / 48) ? ( osc1_db_vel = osc1AmpKnob.value * 48; );

cX += 2.5 * knobSize;
semiTonesKnob.knob_set(sprintf(1, "%.2f ", osc1_semi), 1, (osc1_semi + 36)/72);
semiTonesKnob.drawKnob(cX, cY, knobSize, "Tuning", "Oscillator 1 tuning", 1.0);
semiTonesKnob.knob_draw_modifier(osc1_semi_vel / 72, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  semiTonesKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? ( osc1_semi = semiTonesKnob.value * 72 - 36; slider_automate(osc1_semi); );
) : semiTonesKnob.knob_modifier_processMouse(0, osc1_semi_vel / 72) ? ( osc1_semi_vel = semiTonesKnob.value * 72; );

cX += 3.75 * knobSize;

drawPanel("PWM", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 1.9*knobSpacing, panelHeight);
cX -= .75*knobSize;
gfx_setfont(KNOB_FONT);

pwm_active = (slider(OSC1_SELECT) == 4) || (slider(OSC2_SELECT) == 4);
pwmPhaseKnob.knob_set(sprintf(1, "P"), pwm_active, pwm_phase );
pwmPhaseKnob.drawKnob(cX, cY-.85*knobSize, floor(.36*knobSize), "", "PWM Phase.", 1.0);
pwmPhaseKnob.knob_draw_modifier(pwm_phase_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  pwmPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .5) ? ( pwm_phase = cl01(pwmPhaseKnob.value); slider_automate(pwm_phase););
) : pwmPhaseKnob.knob_modifier_processMouse(0, pwm_phase_vel) ? ( pwm_phase_vel = pwmPhaseKnob.value; );

pwmDepthKnob.knob_set(sprintf(1, "D"), pwm_active, pwm_depth);
pwmDepthKnob.drawKnob(cX, cY, floor(.36*knobSize), "", "PWM Depth.", 1.0);
pwmDepthKnob.knob_draw_modifier(pwm_depth_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  pwmDepthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .4) ? ( pwm_depth = cl01(pwmDepthKnob.value); slider_automate(pwm_depth); );
) : pwmDepthKnob.knob_modifier_processMouse(0, pwm_depth_vel) ? ( pwm_depth_vel = pwmDepthKnob.value; );

pwmRateKnob.knob_set(sprintf(1, "R"), pwm_active, pwm_rate);
pwmRateKnob.drawKnob(cX, cY+.85*knobSize, floor(.36*knobSize), "", "PWM Rate.", 1.0);
pwmRateKnob.knob_draw_modifier(pwm_rate_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  pwmRateKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .85) ? ( pwm_rate = cl01(pwmRateKnob.value); slider_automate(pwm_rate); );
) : pwmRateKnob.knob_modifier_processMouse(0, pwm_rate_vel) ? ( pwm_rate_vel = pwmRateKnob.value; );


cX += 3.25 * knobSize;
drawPanel("OSCILLATOR 2", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 11.5*knobSpacing, panelHeight);
cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
OSC2_SELECT = 8;
drawSelectionButton("Saw", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, OSC2_SELECT);
drawSelectionButton("Square", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 1, OSC2_SELECT);
drawSelectionButton("Triangle", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 2, OSC2_SELECT);
drawSelectionButton("Fin", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 3, OSC2_SELECT);
drawSelectionButton("PWM", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 4, OSC2_SELECT);

syncToggle.drawToggle(cX-1.85*knobSize, cy+1.1*knobSize, .15*knobSize, .15*knobSize, hardsync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Hard Sync\n\nReset oscillator 2 when oscillator 1 crosses zero.");
syncToggle.label = sprintf(15, " Sync");
hardsync = syncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += .65*knobSize;

osc2AmpKnob.knob_set(sprintf(1, "%.1f dB", osc2_db), 1, (osc2_db + 48)/48);
osc2AmpKnob.drawKnob(cX, cY, knobSize, "Amplitude", "Oscillator 2 gain.", 1.0);
osc2AmpKnob.knob_draw_modifier(osc2_db_vel / 48, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  osc2AmpKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 39/48) ? ( osc2_db = osc2AmpKnob.value * 48 - 48; slider_automate(osc2_db); );
) : osc2AmpKnob.knob_modifier_processMouse(0, osc2_db_vel / 48) ? ( osc2_db_vel = osc2AmpKnob.value * 48; );

cX += 2.5 * knobSize;
semiTonesKnob2.knob_set(sprintf(1, "%.2f ", osc2_semi), 1, (osc2_semi + 36)/72);
semiTonesKnob2.drawKnob(cX, cY, knobSize, "Tuning", "Oscillator 2 tuning", 1.0);
semiTonesKnob2.knob_draw_modifier(osc2_semi_vel / 72, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  semiTonesKnob2.knob_processMouse(mouse_x, mouse_y, mouse_cap, 48/72) ? ( osc2_semi = semiTonesKnob2.value * 72 - 36; slider_automate(osc2_semi); );
) : semiTonesKnob2.knob_modifier_processMouse(0, osc2_semi_vel / 72) ? ( osc2_semi_vel = semiTonesKnob2.value * 72; );


cX += 1.65 * knobSize;

pitchEnvelopeKnob.knob_set(sprintf(1, "E"), 1, (pitch_env + 12)/24 );
pitchEnvelopeKnob.drawKnob(cX, cY-.85*knobSize, floor(.36*knobSize), "", "Pitch Envelope Amount.", 1.0);
pitchEnvelopeKnob.knob_draw_modifier(pitch_amnt_vel / 24, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  pitchEnvelopeKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .5) ? ( pitch_env = pitchEnvelopeKnob.value * 24 - 12; slider_automate(pitch_env););
) : pitchEnvelopeKnob.knob_modifier_processMouse(0, pitch_amnt_vel / 24) ? ( pitch_amnt_vel = pitchEnvelopeKnob.value * 24; );

pitchAttackKnob.knob_set(sprintf(1, "A"), 1, pitch_atk);
pitchAttackKnob.drawKnob(cX, cY, floor(.36*knobSize), "", "Pitch Attack.", 1.0);
pitchAttackKnob.knob_draw_modifier(pitch_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  pitchAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .5) ? ( pitch_atk = pitchAttackKnob.value; slider_automate(pitch_atk); );
) : pitchAttackKnob.knob_modifier_processMouse(0, pitch_atk_vel) ? ( pitch_atk_vel = pitchAttackKnob.value; );

pitchDecayKnob.knob_set(sprintf(1, "D"), 1, pitch_decay);
pitchDecayKnob.drawKnob(cX, cY+.85*knobSize, floor(.36*knobSize), "", "Pitch Decay.", 1.0);
pitchDecayKnob.knob_draw_modifier(pitch_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  pitchDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .5) ? ( pitch_decay = pitchDecayKnob.value; slider_automate(pitch_decay); );
) : pitchDecayKnob.knob_modifier_processMouse(0, pitch_decay_vel) ? ( pitch_decay_vel = pitchDecayKnob.value; );

cX += 3.25 * knobSize;

drawPanel("AMP ENV", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 14.75*knobSpacing, panelHeight);

gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
gfx_rect(cX - 2.5*knobSpacing, cY - .4*panelHeight, 9, 9);

ampAccentKnob.active = 1;
ampAccentKnob.value = (amp_accent + 1) / 2;
ampAccentKnob.drawKnob(cX, cY, knobSize, "- Accent +", "Accent", 1.0);
ampAccentKnob.label = sprintf(16, "   %d %%%%", 100*amp_accent);
ampAccentKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  amp_accent = ampAccentKnob.value * 2 - 1;
  slider_automate(amp_accent);
);

preampToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, amp_before_filter, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enabling this places the amplitude envelope before the filter.\nThis takes away some control over the amplitude envelope,\nbut allows you to hear the filter decay.\n");
amp_before_filter = preampToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += knobSize*2.5;
resetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on note.");
reset = resetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

ampAttackKnob.knob_set(amp_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*amp_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*amp_atk))), 1, amp_atk);
ampAttackKnob.drawKnob(cX, cY, knobSize, "Attack", "Attack Time", 1.0);
ampAttackKnob.knob_draw_modifier(amp_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  ampAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( amp_atk = ampAttackKnob.value; slider_automate(amp_atk); );
) : ampAttackKnob.knob_modifier_processMouse(0, amp_atk_vel) ? ( amp_atk_vel = ampAttackKnob.value; );


cX += knobSize*2.5;
//holdToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, amp_hold, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Hold while MIDI note is down.");
//amp_hold = holdToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

ampDecayKnob.knob_set(amp_decay > .5 ? sprintf(1, "%d ms", (3 * 10^(2*amp_decay))) : sprintf(1, "%.1f ms", (3 * 10^(2*amp_decay))), 1, amp_decay);
ampDecayKnob.drawKnob(cX, cY, knobSize, "Decay", "Decay Time", 1.0);
ampDecayKnob.knob_draw_modifier(amp_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  ampDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( amp_decay = ampDecayKnob.value; slider_automate(amp_decay); );
) : ampDecayKnob.knob_modifier_processMouse(0, amp_decay_vel) ? ( amp_decay_vel = ampDecayKnob.value; );

cX += 2.5 * knobSize;

ampSustainKnob.knob_set("", 1, amp_sustain);
ampSustainKnob.drawKnob(cX, cY, knobSize, "Sustain", "Sustain %", 1.0);
ampSustainKnob.knob_draw_modifier(amp_sustain_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  ampSustainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( amp_sustain = ampSustainKnob.value; slider_automate(amp_sustain); );
) : ampSustainKnob.knob_modifier_processMouse(0, amp_sustain_vel) ? ( amp_sustain_vel = ampSustainKnob.value; );

cX += 3.75 * knobSize;


drawPanel("BONUS OSC", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 6.825*knobSpacing, panelHeight);

xosc2_percent.active = 1;
xosc2_percent.value = amp2;
xosc2_percent.label = sprintf(35, "   %d %%%%", 100*amp2);
xosc2_percent.drawKnob(cX-.5*knobSize, cY-.6*knobSize, .6*knobSize, "Osc A %", "Fractional level", 1.0);
xosc2_percent.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  amp2 = xosc2_percent.value;
  slider_automate(amp2);
);

xosc2_tune.active = 1;
xosc2_tune.value = (detune2+1)*.5;
xosc2_tune.label = sprintf(1, "%.2f", detune2);
xosc2_tune.drawKnob(cX-.5*knobSize, cY+.8*knobSize, .6*knobSize, "", "Tuning", 1.0);
xosc2_tune.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  detune2 = xosc2_tune.value * 2 - 1;
  slider_automate(detune2);
);

cX += knobSize*1.4;

xosc3_percent.active = 1;
xosc3_percent.value = amp3;
xosc3_percent.label = sprintf(35, "   %d %%%%", 100*amp3);
xosc3_percent.drawKnob(cX-.5*knobSize, cY-.6*knobSize, .6*knobSize, "Osc B %", "Fractional level", 1.0);
xosc3_percent.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  amp3 = xosc3_percent.value;
  slider_automate(amp3);
);

xosc3_tune.active = 1;
xosc3_tune.value = (detune3+1)*.5;
xosc3_tune.label = sprintf(1, "%.2f", detune3);
xosc3_tune.drawKnob(cX-.5*knobSize, cY+.8*knobSize, .6*knobSize, "", "Tuning", 1.0);
xosc3_tune.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  detune3 = xosc3_tune.value * 2 - 1;
  slider_automate(detune3);
);

cX += knobSize*1.4;

xosc4_percent.active = 1;
xosc4_percent.value = amp4;
xosc4_percent.label = sprintf(35, "   %d %%%%", 100*amp4);
xosc4_percent.drawKnob(cX-.5*knobSize, cY-.6*knobSize, .6*knobSize, "Osc B %", "Fractional level", 1.0);
xosc4_percent.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  amp4 = xosc4_percent.value;
  slider_automate(amp4);
);

xosc4_tune.active = 1;
xosc4_tune.value = (detune4+1)*.5;
xosc4_tune.label = sprintf(1, "%.2f", detune4);
xosc4_tune.drawKnob(cX-.5*knobSize, cY+.8*knobSize, .6*knobSize, "", "Tuning", 1.0);
xosc4_tune.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  detune4 = xosc4_tune.value * 2 - 1;
  slider_automate(detune4);
);

new_multi = 1;
amp2 > 0.001 ? new_multi = 2;
amp3 > 0.001 ? new_multi = 3;
amp4 > 0.001 ? new_multi = 4;
multi = new_multi;


cX += 1.5 * knobSize;

cX += 1.5 * knobSize;

drawPanel("GLIDE", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 4.275*knobSpacing, panelHeight);

glideKnob.active = 1;
glideKnob.value = glide_time;
glideKnob.drawKnob(cX, cY, knobSize, "Glide", "Glide", 1.0);
glideKnob.label = sprintf(30, "%.1f ms", (3 * 10^(2*glide_time)));
glideKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  glide_time = glideKnob.value;
  slider_automate(glide_time);
);


cX = xOrigin;
cY = cY + 4 * knobSize;

hotness_meter = tanh(54*sqrt(hotness_rmsq));
gfx_set(hotness_meter+.1, .1, .1, hotness_meter);
gfx_rect(cX - 2.5*knobSpacing+1, cY - .28*panelHeight, 9, 9);

drawPanel("DRIVE", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 10*knobSpacing, panelHeight);
cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
FILTER_SELECT_BUTTON = 25;
drawSelectionButton("Lin 2p", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, FILTER_SELECT_BUTTON);
drawSelectionButton("Lin 4p", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 2, FILTER_SELECT_BUTTON);
drawSelectionButton("MS-20", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 1, FILTER_SELECT_BUTTON);
drawSelectionButton("Moog", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 3, FILTER_SELECT_BUTTON);
drawSelectionButton("Ladder", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 4, FILTER_SELECT_BUTTON);
drawSelectionButton("303", cX - 2*knobSize, cY-1.1*knobSize + 5*y_move, ww, hh, 5, FILTER_SELECT_BUTTON);

cX += .65*knobSize;

driveKnob.knob_set(sprintf(1, "%.1f dB", drive), 1, (drive + 6)/54);
driveKnob.drawKnob(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", 1.0);
driveKnob.knob_draw_modifier(drive_vel / 54, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  driveKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? ( drive = driveKnob.value * 54 - 6; slider_automate(drive); );
) : driveKnob.knob_modifier_processMouse(0, drive_vel / 54) ? ( drive_vel = driveKnob.value * 54; );

//bleedToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, bleed, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.\nGives a more analog feel.");
//bleed = bleedToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

//autokillToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, autokill, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Kill audio after no more input comes in.\nPrevents resonance from singing.");
//autokill = autokillToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += 2.5 * knobSize;

postBoost.knob_set(sprintf(1, "%.1f dB", boost), 1, (boost + 6)/54);
postBoost.drawKnob(cX, cY, knobSize, "Output Gain", "Output Gain", 1.0);
postBoost.knob_draw_modifier(boost_vel / 54, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  postBoost.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? ( boost = postBoost.value * 54 - 6; slider_automate(boost); );
) : postBoost.knob_modifier_processMouse(0, boost_vel / 54) ? ( boost_vel = postBoost.value * 54; );


cX += 2.5 * knobSize;
cX += 1.5 * knobSize;


drawPanel("FILTER", cX - 2.25*knobSpacing, cY - .53*panelHeight + .2*knobSize, 15*knobSpacing, panelHeight);
morphKnob.knob_set("", 1, morph);
morphKnob.drawKnob(cX, cY, knobSize, "Morph", "Filter Morph", 1.0);
morphKnob.knob_draw_modifier(morph_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  morphKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( morph = morphKnob.value; slider_automate(morph); );
) : morphKnob.knob_modifier_processMouse(0, morph_vel) ? ( morph_vel = morphKnob.value; );

gfx_set(1,1,1,1);
drawKnobLabels(knobSize*1.25, 0, "LP");
drawKnobLabels(knobSize*1.25, 1/4, "BP");
drawKnobLabels(knobSize*1.25, 2/4, "HP");
drawKnobLabels(knobSize*1.25, 3/4, "BR");
drawKnobLabels(knobSize*1.25, 4/4, "LP");

cX += knobSize*2.5;

center = .5 * srate * exp( (1-cutoff) * log(20/22050) );
cutoffKnob.knob_set(center < 1000 ? sprintf(1, "%d Hz", center) : sprintf(1, "%.1f kHz", center/1000), 1, cutoff);
cutoffKnob.drawKnob(cX, cY, knobSize, "Cutoff", "Filter Cutoff", 1.0);
cutoffKnob.knob_draw_modifier(cutoff_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  cutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff = cutoffKnob.value; slider_automate(cutoff); check_safety(); );
) : cutoffKnob.knob_modifier_processMouse(0, cutoff_vel) ? ( cutoff_vel = cutoffKnob.value; );

cX += knobSize*2.5;
resonanceKnob.knob_set(sprintf(1, "%.1f", resonance), 1, resonance);
resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Filter Resonance", 1.0);
resonanceKnob.knob_draw_modifier(reso_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( resonance = resonanceKnob.value; slider_automate(resonance); );
) : resonanceKnob.knob_modifier_processMouse(0, reso_vel) ? ( reso_vel = resonanceKnob.value; );

cX += knobSize*2.5;

keyFollowKnob.active = 1;
keyFollowKnob.value = key_follow;
keyFollowKnob.drawKnob(cX, cY, knobSize, "Follow", "Follow MIDI pitch", 1.0);

keyFollowKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  key_follow = keyFollowKnob.value;
  slider_automate(key_follow);
);
cX += 3.675 * knobSize;



drawPanel("FM", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 13.5*knobSpacing, panelHeight);
cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
FM_MODE_BUTTON = 37;
drawSelectionButton("MIDI Sin", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, FM_MODE_BUTTON);
drawSelectionButton("MIDI Sqr", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 1, FM_MODE_BUTTON);
drawSelectionButton("Self", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 2, FM_MODE_BUTTON);
drawSelectionButton("Self Abs", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 3, FM_MODE_BUTTON);
cX += .65*knobSize;

fmlevelKnob.knob_set("", 1, fm_amnt);
fmLevelKnob.drawKnob(cX, cY, knobSize, "FM Level", "FM Level\nLevel of FM modulation", 1.0);
fmLevelKnob.knob_draw_modifier(fm_amnt_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);

activeModifier == 0 ? (
  fmLevelKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( fm_amnt = fmLevelKnob.value; slider_automate(fm_amnt); );
) : fmLevelKnob.knob_modifier_processMouse(0, fm_amnt_vel) ? ( fm_amnt_vel = fmLevelKnob.value; );

cX += 2.5 * knobSize;

fm_mode < 2 ? (
  fmRateKnob.active = 1;
  fmRateKnob.value = (fm_factor+8)/16;
  fmRateKnob.label = sprintf(1, "%.1f x", 2^floor(fm_factor));
  fmRateKnob.drawKnob(cX, cY, knobSize, "FM factor", "FM factor.\n\nFilter cutoff will oscillate with\nthis factor times the MIDI pitch's\nfrequency.", .5);
  fmRateKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    fm_factor = fmRateKnob.value * 16 - 8;
    slider_automate(fm_factor);
  );
) : (
  fmCutoffKnob.active = 1;
  fmCutoffKnob.value = fm_cutoff;
  center = .5 * srate * exp( (1-fm_cutoff) * log(20/22050) );
  center < 1000 ? (
    fmCutoffKnob.label = sprintf(1, "%d Hz", center);
  ) : (
    fmCutoffKnob.label = sprintf(1, "%.1f kHz", center/1000);
  );
  fmCutoffKnob.drawKnob(cX, cY, knobSize, "FM cutoff", "FM Cutoff\n\nCutoff used to filter signal that\ncontrols the cutoff.", .5);
  fmCutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? (
    fm_cutoff = fmCutoffKnob.value;
    slider_automate(fm_cutoff);
  );
);
cX += 2.5 * knobSize;

fmPhaseKnob.knob_set("", 1, fm_spread);
fmPhaseKnob.drawKnob(cX, cY, knobSize, "FM Spread", "FM Phase difference", 1.0);
fmPhaseKnob.knob_draw_modifier(fm_spread_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  fmPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( fm_spread = fmPhaseKnob.value; slider_automate(fm_spread); );
) : fmPhaseKnob.knob_modifier_processMouse(0, fm_spread_vel) ? ( fm_spread_vel = fmPhaseKnob.value; );


showOptions = 1;
showOptions ? (
  cX += 3.75 * knobSize;
  drawPanel("OPTIONS", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 7.75*knobSpacing, panelHeight);
  oversamplingKnob.active = 1;
  oversampling != floor(oversamplingKnob.value * 7 + 1) ? (
    oversamplingKnob.value = (oversampling - 1) / 7;
  );
  oversamplingKnob.drawKnob(cX, cY, knobSize, "Oversampling", "", 1.0);
  oversamplingKnob.label = sprintf(7, "x%d", oversampling);
  oversamplingKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    newOversampling = floor(oversamplingKnob.value * 7 + 1);
    floor(newOversampling) != overSampling ? (
      oversampling = newOversampling;
      slider_automate(oversampling);
      updateSlider();
    );
  );
  
  cX += 2.5 * knobSize;
  inertiaKnob.active = 1;
  inertiaKnob.value = inertia / 200;
  inertiaKnob.label = sprintf(8, "%d ms", inertia);
  inertiaKnob.drawKnob(cX, cY, knobSize, "Inertia", "", 1.0);
  inertiaKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 60/200) ? (
    inertia = inertiaKnob.value * 200;
    slider_automate(inertia);
  );
);



cX = xOrigin;
cY = cY + 4 * knobSize;

drawPanel("FILTER ENV  ", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 14.75*knobSpacing, panelHeight);

gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
gfx_rect(cX - 2.5*knobSpacing + 1, cY - .4*panelHeight, 9, 9);

envAmountKnob.knob_set(sprintf(4, "   %d %%%%", 100*env_amnt), 1 , env_amnt * .5 + .5);
envAmountKnob.drawKnob(cX, cY, knobSize, "- Amount +", "Envelope Amount", 1.0);
envAmountKnob.knob_draw_modifier(env_amnt_vel * .5, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? ( envAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? ( env_amnt = envAmountKnob.value * 2 - 1; slider_automate(env_amnt); );
) : envAmountKnob.knob_modifier_processMouse(0, env_amnt_vel * .5) ? ( env_amnt_vel = envAmountKnob.value * 2; );

cX += knobSize*2.5;
envAttackKnob.knob_set(cutoff_atk > .5 ? sprintf(1, "%d ms", (3 * 10^(2*cutoff_atk))) : sprintf(1, "%.1f ms", (3 * 10^(2*cutoff_atk))), 1, cutoff_atk);
envAttackKnob.drawKnob(cX, cY, knobSize, "Attack", "Attack Time", 1.0);
envAttackKnob.knob_draw_modifier(cutoff_atk_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? ( envAttackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff_atk = envAttackKnob.value; slider_automate(cutoff_atk); );
) : envAttackKnob.knob_modifier_processMouse(0, cutoff_atk_vel) ? ( cutoff_atk_vel = envAttackKnob.value; );

cutoffResetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, cutoff_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset envelope on note.\n\nTurning this off changes the mode to a mode where\nthe amplitude no longer goes to 90%% in the set time.\n\nThis means that consecutive hits get increasingly higher\ncutoff values. The 303 is one of the classic synths that\nhad this characteristic.");
cutoff_reset = cutoffResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += knobSize*2.5;
envDecayKnob.knob_set(env_decay > .5 ? sprintf(19, "%d ms", (3 * 10^(2*cutoff_decay))) : sprintf(19, "%.1f ms", (3 * 10^(2*cutoff_decay))), 1, cutoff_decay );
envDecayKnob.drawKnob(cX, cY, knobSize, "Decay", "Decay Time", 1.0);
envDecayKnob.knob_draw_modifier(cutoff_decay_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? ( envDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff_decay = envDecayKnob.value; slider_automate(cutoff_decay); );
) : envDecayKnob.knob_modifier_processMouse(0, cutoff_decay_vel) ? ( cutoff_decay_vel = envDecayKnob.value; );

cX += 2.5 * knobSize;

envSustainKnob.knob_set("", 1, cutoff_sustain);
envSustainKnob.drawKnob(cX, cY, knobSize, "Sustain", "Sustain %", 1.0);
envSustainKnob.knob_draw_modifier(cutoff_sustain_vel, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? ( envSustainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? ( cutoff_sustain = envSustainKnob.value; slider_automate(cutoff_sustain); );
) : envSustainKnob.knob_modifier_processMouse(0, cutoff_sustain_vel) ? ( cutoff_sustain_vel = envSustainKnob.value; );

cX += 3.675 * knobSize;
drawPanel("CUTOFF LFO", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 11.125*knobSpacing, panelHeight);

cutoffLfoResetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
c_lfo_reset = cutoffLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cutoffLFOAmountKnob.active = 1;
cutoffLFOAmountKnob.value = c_lfo_amnt;
cutoffLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount", 1.0);
cutoffLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  c_lfo_amnt = cutoffLFOAmountKnob.value;
  slider_automate(c_lfo_amnt);
);

cX += 2.5 * knobSize;
cutoffSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.");
c_lfo_sync = cutoffSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cutoffLFOSpeedKnob.active = 1;
cutoffLFOSpeedKnob.value = c_lfo_speed / 20;
cutoffLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
c_lfo_sync ? (
  cutoffLFOSpeedKnob.label = cutoff_LFO.tempoLabel;
) : (
  cutoffLFOSpeedKnob.label = sprintf(3, "%.1f Hz", 10^(c_lfo_speed/15) - 1);
);
cutoffLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  c_lfo_speed = cutoffLFOSpeedKnob.value * 20;
  updateTempo();
  slider_automate(c_lfo_speed);
);

cX += 2.5 * knobSize;
cutoffLFOPhaseKnob.active = 1;
cutoffLFOPhaseKnob.value = c_lfo_phase / 36;
cutoffLFOPhaseKnob.drawKnob(cX, cY, knobSize, "LR Phase", "Cutoff LFO Phase", 1.0);
cutoffLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  c_lfo_phase = cutoffLFOPhaseKnob.value * 36;
  slider_automate(c_lfo_phase);
);



cX += 3.675 * knobSize;
drawPanel("MORPH LFO", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 11.125*knobSpacing, panelHeight);
morphLFOAmountKnob.active = 1;
morphLFOAmountKnob.value = m_lfo_amnt;
morphLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount", 1.0);
morphLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  m_lfo_amnt = morphLFOAmountKnob.value;
  slider_automate(m_lfo_amnt);
);

morphLfoResetToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_reset, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Reset LFO on note on.");
m_lfo_reset = morphLfoResetToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += 2.5 * knobSize;
morphSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.");
m_lfo_sync = morphSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

morphLFOSpeedKnob.active = 1;
morphLFOSpeedKnob.value = m_lfo_speed / 20;
morphLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
m_lfo_sync ? (
  morphLFOSpeedKnob.label = morph_LFO.tempoLabel;
) : (
  morphLFOSpeedKnob.label = sprintf(5, "%d Hz", 10^(m_lfo_speed/15) - 1);
);
morphLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  m_lfo_speed = morphLFOSpeedKnob.value * 20;
  updateTempo();
  slider_automate(m_lfo_speed);
);

cX += 2.5 * knobSize;

morphLFOPhaseKnob.active = 1;
morphLFOPhaseKnob.value = m_lfo_phase / 36;
morphLFOPhaseKnob.drawKnob(cX, cY, knobSize, "LR Phase", "Cutoff LFO Phase", 1.0);
morphLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  m_lfo_phase = morphLFOPhaseKnob.value * 36;
  slider_automate(m_lfo_phase);
);

cX += 3.5 * knobSize;

drawPanel("DISTORTION", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 7.75*knobSpacing, panelHeight);
shaperToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, shaper, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.\nGives a more analog feel.");
shaper = shaperToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

higainToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, higain, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "High gain mode.");
higain = higainToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

distKnob.knob_set(sprintf(1, "%.1f dB", current_ceiling), shaper, current_ceiling / 48);
distKnob.drawKnob(cX, cY, knobSize, "Distortion", "Distortion level\n\nDistortion applied post-filter.", 0);
distKnob.knob_draw_modifier(current_ceiling_vel / 48, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);
activeModifier == 0 ? (
  distKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? ( current_ceiling = distKnob.value * 48; slider_automate(current_ceiling); );
) : distKnob.knob_modifier_processMouse(0, current_ceiling_vel / 48) ? ( current_ceiling_vel = distKnob.value * 48; );

cX += 2.5 * knobSize;

warmthKnob.active = shaper;
warmthKnob.value = (warmth + 12) / 24;
warmthKnob.drawKnob(cX, cY, knobSize, "Warmth", "Distortion warmth.\n\nApplies pre- and post-emphasis filters.", .5);
warmthKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  warmth = warmthKnob.value * 24 - 12;
  slider_automate(warmth);
);

cX += 2.5 * knobSize;
cX += 1.25 * knobSize;

drawPanel("FEEDBACK", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 4.15*knobSpacing, panelHeight);

feedbackKnob.active = !(filter_type == 0 || filter_type == 2);
feedbackKnob.value = fb;
//feedbackKnob.label = sprintf(1, "%.1f dB", current_ceiling);
feedbackKnob.drawKnob(cX, cY, knobSize, "Feedback", "Are you crazy?", 0);
feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  fb = feedbackKnob.value;
  slider_automate(fb);
);

cX += 2.5 * knobSize;

cX = xOrigin;
cY += 2.2 * knobSize;

function handleModifier(str, x, y, w, h, modifierID)
instance()
local(fact, ww, hh, r, g, b, r2, g2, b2, clicked, in_range, cy)
global(KNOB_FONT, edge_r, edge_g, edge_b, edge_a, edge_font_r, edge_font_g, edge_font_b,
       gfx_x, gfx_y, render_time, mouse_x, mouse_y, mouse_cap,
       activeModifier, lcap)
(
  clicked = lcap == 0 && mouse_cap == 1;
  in_range = mouse_x > x && mouse_x < (x+w) && mouse_y > y && mouse_y < (y+h);
  
  cy = 1.0;
  activeModifier == modifierID ? (
    cy = .3 + .2*sin(4*render_time);
    r = 37/255;
    g = 236/255;
    b = 117/255;
    fact = 1.3;
    r2 = fact * edge_r;
    g2 = fact * edge_b;
    b2 = fact * edge_b;
    
    clicked && in_range ? activeModifier = 0;
  ) : (
    fact = 1.6;
    r = fact * edge_r;
    g = fact * edge_b;
    b = fact * edge_b;
    fact = 1.3;
    r2 = fact * edge_r;
    g2 = fact * edge_b;
    b2 = fact * edge_b;
    
    clicked && in_range ? activeModifier = modifierID;
  );
  gfx_set(0, 0, 0, .4);
  gfx_rect(x+5, y+5, w, h, 12, 1);
  
  
  gfx_set(r, g, b, cy);
  gfx_rect(x, y, w, h, 12, 1);
  fact = 1.3;
  gfx_set(r2, g2, b2, cy);
  gfx_rect(x+3, y+3, w-6, h-6, 8, 1);
  
  gfx_set(edge_r, edge_g, edge_b, edge_a);
  gfx_setfont(KNOB_FONT);
  gfx_measurestr(str, ww, hh);
  gfx_x = x + (w-ww)*.5;
  gfx_y = y + (h-hh)*.5;
  gfx_set(edge_font_r, edge_font_g, edge_font_b, 1.0);
  gfx_printf(str);
);



handleModifier("VEL", cX - knobSize, cY, knobSize, knobSize, 1);



gfx_set(0, 0, 0, 0);
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_set(1, 1, 1, 1);

warning > 0 ? (
  gfx_set(1,1,1,1);
  gfx_x = 0;
  gfx_y = 0;
  gfx_a = warning / 75;
  gfx_printf("Warning, cutoff clamped! Without oversampling, this non-linear filter cannot safely go to higher cutoff frequencies.");
  warning -= 1;
);

lcap = mouse_cap;

hinter.drawHint_draw();

gfx_x = 100;
gfx_y = 432;
gfx_printf("ALPHA / WORK IN PROGRESS! If you make a sound you really like, make sure you freeze it as the synth is still subject to change!");
