@init
function colormodel(x)
global(gfx_a)
local(frac)
(
  (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.34901960784313724 + frac * 0.20000000000000007, 0.403921568627451 + frac * -0.09019607843137256, 1.0 + frac * 0.0); )
  : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.5490196078431373 + frac * 0.4509803921568627, 0.3137254901960784 + frac * -0.07450980392156861, 1.0 + frac * -0.21568627450980393); )
  : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(1.0 + frac * 0.0, 0.23921568627450981 + frac * 0.10980392156862742, 0.7843137254901961 + frac * -0.6196078431372549); )
  : ( frac = (4 * x - 3); gfx_set(1.0 + frac * 0.0, 0.34901960784313724 + frac * 0.34509803921568627, 0.16470588235294117 + frac * -0.03529411764705881); )
  
  //x = sqrt(x); gfx_set(1.0 * x, 0.84 * x + 0.44, 1.0 - x, 0.8);
);


// Really dumb sorting algorithm which sorts two lists while shifting duplicate x coordinates
function sort_spline(n_points, xloc, yloc, indices, temp_x, temp_y)
local(idx, eps, change, tmp, shift)
global()
( 
  // First copy it to temp and set up untransformed index array
  memcpy(temp_x, xloc, n_points);
  memcpy(temp_y, yloc, n_points);
  idx = 0;
  loop(n_points,
    indices[idx] = idx;
    idx += 1;
  );
  
  // Simple bubble sort
  change = 1;
  while(change) (
    change = 0;
    idx = 0;
    loop(n_points,
      (temp_x[idx] > temp_x[idx + 1]) ? (
        // Swap elements
        tmp = temp_x[idx];
        temp_x[idx] = temp_x[idx + 1];
        temp_x[idx + 1] = tmp;
        tmp = temp_y[idx];
        temp_y[idx] = temp_y[idx + 1];
        temp_y[idx + 1] = tmp;
        tmp = indices[idx];
        indices[idx] = indices[idx + 1];
        indices[idx + 1] = tmp;
        
        change = 1; // Need another pass
      );
      idx += 1;
    );
  );
  
  // Shift duplicates
  eps = 0.00001;
  idx = 0;
  shift = 0.00001;
  loop(n_points,
    (abs(temp_x[idx + 1] - temp_x[idx]) < eps) ? (
      temp_x[idx + 1] += shift;
    );
    idx += 1;
  );
  
  memcpy(xloc, temp_x, n_points);
  memcpy(yloc, temp_y, n_points);
);

function update_spline(n_points, xloc, yloc, c1, c2, c3, temp_x, temp_y)
local(dx, dydx, tmp, idx,
      dydx_next, dydx_current,
      dx_current, dx_next, avg_dx,
      inv_dx,
      c1_current, cm)
global()
(
  // Initialize coeffs
  memset(c1, 0, n_points);
  memset(c2, 0, n_points);
  memset(c3, 0, n_points);

  // Calculate differences
  dx = temp_x;
  dydx = temp_y;
  
  idx = 0;
  loop(n_points - 1,
    dx[idx] = tmp = xloc[idx + 1] - xloc[idx];
    dydx[idx] = (yloc[idx + 1] - yloc[idx]) / tmp;
    idx += 1;
  );
  
  // Make sure the last node does not go bonkers
  //ptr_to_Y -= 1;
  //ptr_to_Y[] = max(min(5, ptr_to_Y[]), -5);
  
  // Calculate first degree coefficients
  c1[] = dydx[];
  idx = 0;
  loop(n_points - 2,
    dydx_current = dydx[idx];
    dydx_next = dydx[idx + 1];
    
    ( dydx_current * dydx_next <= 0 ) ? ( c1[idx + 1] = 0; ):
    (
      dx_current = dx[idx];
      dx_next = dx[idx + 1];
      avg_dx = dx_current + dx_next;
      
      c1[idx + 1] = 3.0 * avg_dx / ((avg_dx + dx_next) / dydx_current + (avg_dx + dx_current) / dydx_next);
    );
    
    idx += 1;
  );
  c1[idx + 1] = dydx[idx];
  
  // Calculate second degree coefficients
  idx = 0;
  loop(n_points - 1,
    inv_dx = 1 / dx[idx];
    c1_current = c1[idx];
    dydx_current = dydx[idx];
    cm = c1_current + c1[idx + 1] - dydx_current - dydx_current;
    c2[idx] = (dydx_current - c1_current - cm) * inv_dx;
    c3[idx] = cm * inv_dx * inv_dx;
    
    idx += 1;
  );
);

function update_spline()
instance(xloc, yloc, temp_x, temp_y, c1, c2, c3, indices, n_points)
local()
global()
(
  this.sort_spline(n_points, xloc, yloc, indices, temp_x, temp_y);
  this.update_spline(n_points, xloc, yloc, c1, c2, c3, temp_x, temp_y)
);

function set_slider_loc(_start_slider, _count)
global()
local()
instance(start_slider, count)
(
  start_slider = _start_slider;
  count = _count;
);


function read_from_sliders()
local(idx)
instance(x_sliders, y_sliders, start_slider, max_nodes)
global()
(
  idx = 0;
  loop(max_nodes,
    x_sliders[idx] = slider(start_slider + 2 * idx);
    y_sliders[idx] = slider(start_slider + 2 * idx + 1);
    idx += 1;
  );
);

function write_to_sliders()
local(idx)
instance(x_sliders, y_sliders, start_slider, max_nodes)
global()
(
  idx = 0;
  loop(max_nodes,
    (slider(start_slider + 2 * idx) != x_sliders[idx]) ? (
      slider_automate(slider(start_slider + 2 * idx) = x_sliders[idx]);
    );
    (slider(start_slider + 2 * idx + 1) != y_sliders[idx]) ? (
      slider_automate(slider(start_slider + 2 * idx + 1) = y_sliders[idx]);
    );
    idx += 1;
  );
);

function read_data()
local(idx)
instance(x_sliders, y_sliders, max_nodes, xloc, yloc)
global()
(
  // If we are reading to/from sliders, do so here.
  this.read_from_sliders();

  idx = 0;
  loop(max_nodes,
    xloc[idx] = x_sliders[idx];
    yloc[idx] = y_sliders[idx];
    idx += 1;
  );
  
  this.update_spline()
);

function push_data()
local()
global()
instance()
(
  this.write_to_sliders();
);


function eval_spline(x)
instance(xloc, yloc, c1, c2, c3, n_points)
local()
local(diff, diff_sq, idx, x_ptr)
global()
(
  idx = -1;
  x_ptr = xloc - 1;
  
  while(
    idx += 1;
    x_ptr += 1;
    
    x >= x_ptr[] && (idx < n_points)
  );
  
  idx = max(0, idx - 1);
  
  diff = x - xloc[idx];
  diff_sq = diff * diff;
        
  yloc[idx] + c1[idx] * diff + c2[idx] * diff_sq + c3[idx] * diff * diff_sq
);

function handle_mouse(x, y, w, h)
local(min_idx, idx, min_dist, new_dist, dx, dy, prev_slider, next_slider)
global(mouse_x, mouse_y, mouse_cap, mouse_wheel)
instance(x_sliders, y_sliders, xloc, yloc, indices, n_points, start_slider, count, grabbed, over, anim, last_cap, last_x, last_y, should_update, max_nodes)
(
  idx = 0;
  min_dist = 10000000000000;

  loop(n_points,
    dx = (x + w * xloc[idx] - mouse_x);
    dy = (y + h * (1.0 - yloc[idx]) - mouse_y);
    new_dist = dx * dx + dy * dy;
    (new_dist < min_dist) ? (
      min_idx = idx;
      min_dist = new_dist;
    );
    idx += 1;
  );
  
  grabbed ? (
    (mouse_cap == 1) ? (
      should_update = 1;
      x_sliders[grabbed - 1] += (mouse_x - last_x) / w;
      y_sliders[grabbed - 1] -= (mouse_y - last_y) / h;
      this.push_data();
      this.read_data();
      anim += 1;
    ) : (
      grabbed = 0;
    );
  ) : (
    (min_dist < 40) ? (
      over = min_idx;
      anim += 1;
      (last_cap == 0) && (mouse_cap == 1) ? (
        // Grab handle
        grabbed = indices[min_idx] + 1;
      );
      
      (last_cap == 0) && (mouse_cap == 2) ? (
        idx = indices[min_idx];
        x_sliders[idx] = x_sliders[n_points - 1];
        y_sliders[idx] = y_sliders[n_points - 1];
        n_points -= 1;
        
        this.push_data();
        this.read_data();
      );
      
      (mouse_wheel != 0) ? (
        next_slider = 2 * indices[min_idx] + 3;
        prev_slider = 2 * indices[min_idx] - 1;
        should_update = 1;
        /*slider_automate(slider(next_slider) -= 0.01 * mouse_wheel / w);
        slider_automate(slider(prev_slider) += 0.01 * mouse_wheel / w);
        
        this.push_data();
        this.read_data();*/
        
        this.read_data();
        mouse_wheel = 0;
      );

    ) : (
      (last_cap == 0) && (mouse_cap == 2) ? (
        (count < max_nodes) ? (
          x_sliders[n_points] = (mouse_x - x) / w;
          y_sliders[n_points] = 1.0 - (mouse_y - y) / h;
          n_points += 1;

          this.push_data();
          this.read_data();
        );
      );
    
    
      over = -1;
      anim = 0;
    );
  );
  
  last_cap = mouse_cap;
  last_x = mouse_x;
  last_y = mouse_y;
);

function draw(x, y, w, h)
local(cx, cs, ds, x_cur, y_cur, y_new, x_new)
global(gfx_x, gfx_y, gfx_a)
instance(xloc, yloc, n_points, over, anim)
(
  this.handle_mouse(x, y, w, h);

  gfx_x = x;
  gfx_y = y + h * (1.0 - this.eval_spline(0));
  cx = 0;
  cs = 0;
  ds = 1 / w;
  x_cur = x + cx;
  y_cur = y + h * (1.0 - this.eval_spline(cs));
  colormodel(1.0);
  loop(w,
    x_new = x + cx;
    y_new = y + h * (1.0 - this.eval_spline(cs));

    gfx_line(x_cur + 1, y_cur, x_new + 1, y_new);
    gfx_line(x_cur, y_cur + 1, x_new, y_new + 1);
    gfx_line(x_cur, y_cur, x_new, y_new);
    cx += 1;
    cs += ds;
    x_cur = x_new;
    y_cur = y_new;
  );
  
  cx = 0;
  loop(n_points,
    (cx == over) ? (
      colormodel(0.1 + 0.05 * abs(sin(0.2 * anim)));
      gfx_circle(x + w * xloc[cx], y + h * (1.0 - yloc[cx]), 4 + 2 * abs(sin(0.2 * anim)), 1);
      gfx_circle(x + w * xloc[cx], y + h * (1.0 - yloc[cx]), 5 + 2 * abs(sin(0.2 * anim)), 1);
    ) : (
      colormodel(0.0);
      gfx_circle(x + w * xloc[cx], y + h * (1.0 - yloc[cx]), 5, 1);
      colormodel(0.1);
      gfx_circle(x + w * xloc[cx], y + h * (1.0 - yloc[cx]), 4, 1);
      colormodel(0.2);
      gfx_circle(x + w * xloc[cx], y + h * (1.0 - yloc[cx]), 3, 1);
    );
    cx += 1;
  );
  
  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  cx = 0;
  loop(n_points,
    gfx_printf("%f ",xloc[cx]);
    cx += 1;
  );
);

function init_spline(freemem, num_points)
local(SPLINE_SIZE, idx, dx)
global()
instance(x_sliders, y_sliders, xloc, yloc, indices, initialized, temp_x, temp_y, c1, c2, c3, n_points, MAX_NODES)
(
  n_points = num_points;
  SPLINE_SIZE = 128;
  MAX_NODES = 16;
  freemem = (x_sliders = freemem) + SPLINE_SIZE;
  freemem = (y_sliders = freemem) + SPLINE_SIZE;
  
  freemem = (xloc = freemem) + SPLINE_SIZE;
  freemem = (yloc = freemem) + SPLINE_SIZE;
  freemem = (indices = freemem) + SPLINE_SIZE;
  freemem = (temp_x = freemem) + SPLINE_SIZE;
  freemem = (temp_y = freemem) + SPLINE_SIZE;
  freemem = (c1 = freemem) + SPLINE_SIZE;
  freemem = (c2 = freemem) + SPLINE_SIZE;
  freemem = (c3 = freemem) + SPLINE_SIZE;
  
  // Initialize as a straight line
  !initialized ? (
    dx = 0;
    loop(n_points,
      yloc[idx] = xloc[idx] = dx;
      dx += 1.0 / n_points;
      initialized = 1;
      this.update_spline();
    );
  );
);

