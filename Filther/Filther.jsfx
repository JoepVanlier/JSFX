desc:Filther
tags: Filther
version: 0.81
author: Joep Vanlier
changelog: Potatoes, improved kr0g filters, added pregain automation

Copyright (C) 2018 Joep Vanlier
License: MIT

Filter attribution:
LP Diode Ladder (MIT Licensed)
Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
Karlsen Fast Ladder III
Copyright (c) ? Ove Hy Karlsen

slider1:3<0,10,1>-Nodes negative
slider2:2<0,10,1>-Nodes positive

slider3:0.15<0,1,.01>-Pos1x
slider4:0.15<0,1,.01>-Pos1y
slider5:0.25<0,1,.01>-Pos2x
slider6:0.25<0,1,.01>-Pos2y
slider7:0.35<0,1,.01>-Pos3x
slider8:0.35<0,1,.01>-Pos3y
slider9:0.5<0,1,.01> -Pos4x
slider10:0.5<0,1,.01>-Pos4y
slider11:0.6<0,1,.01>-Pos5x
slider12:0.6<0,1,.01>-Pos5y
slider13:0.7<0,1,.01>-Pos6x
slider14:0.7<0,1,.01>-Pos6y
slider15:0.8<0,1,.01>-Pos7x
slider16:0.8<0,1,.01>-Pos7y
slider17:0.9<0,1,.01>-Pos8x
slider18:0.9<0,1,.01>-Pos8y

slider19:0.15<0,1,.01>-Neg1x
slider20:0.15<0,1,.01>-Neg1y
slider21:0.25<0,1,.01>-Neg2x
slider22:0.25<0,1,.01>-Neg2y
slider23:0.35<0,1,.01>-Neg3x
slider24:0.35<0,1,.01>-Neg3y
slider25:0.5<0,1,.01>-Neg4x
slider26:0.5<0,1,.01>-Neg4y
slider27:0.6<0,1,.01>-Neg5x
slider28:0.6<0,1,.01>-Neg5y
slider29:0.7<0,1,.01>-Neg6x
slider30:0.7<0,1,.01>-Neg6y
slider31:0.8<0,1,.01>-Neg7x
slider32:0.8<0,1,.01>-Neg7y
slider33:0.9<0,1,.01>-Neg8x
slider34:0.9<0,1,.01>-Neg8y
slider35:1<0,1,1{Off, On}>-Lookahead
slider36:0<0,16,1>-LFO type
slider37:0<0,1,0.001>-LFO freq
slider38:0<0,1,1>-Reset LFO

slider46:<0,6,1>-Filter Operation Mode
slider47:<0,20,1{OFF, LP RC-C,LP Diode Ladder (303/Non-Linear Dominique Wurtz),Vowel,LP Karlsen Fast Ladder III,LP Karlsen Fast Ladder III (sat),Saike`s Waveshaped Resonance (LP),Saike`s Waveshaped Resonance (HP),Saike`s Waveshaped Resonance (BP),Expensive Moog,Less Expensive Moog (DANGEROUS),Notch filter,Narsty,Modulator,Phaser (OTA),Phaser (FET),Delay Feedbok,Mangler,,MS-20 linear LP, MS-20 linear BP, MS-20 linear HP, MS-20 nonlinear LP, MS-20 nonlinear BP, MS-20 nonlinear HP}>-Filter Type
slider48:<0,1,.001>-Cutoff
slider49:<0,1,.001>-Reso

slider51:0<-1,1,.01>-Pre-Gain/Drive Mod %
slider52:0<-40,40,.01>-PreGain
slider53:0<-40,40,.01>-PostGain
slider54:1<0,8,1>-Oversampling
slider56:0<0,3,{Spline, Tanh, Fast Tanh, None}>-Waveshaping Mode

slider58:1<0,2,1{OFF,Filter,Waveshaper,Both}>-Dynamics
slider59:1<0,1,.001>-Thresh
slider60:1<0,50,.1>-Attack
slider61:1<0.1,50,.1>-Decay
slider62:.5<-1,1,.01>-Filt Cutoff Mod %
slider63:0<-1,1,.01>-Filt Reso Mod %
slider64:.34<0.02,40,0.001>-RMS Integration time

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output
options:no_meter

@init
nFilters = 24;
nModes = 6;
nLFO = 14;

function comboStrings(stridx, curitem)
  local(str)
  global()
  instance()
  (
    str = "";
    (stridx == 0) ?
    (
      ( curitem == 0 ) ? ( str = "OFF"
      ) : ( curitem == 1 ) ? ( str = "LP RC-C"
      ) : ( curitem == 2 ) ? ( str = "Diode Ladder"
      ) : ( curitem == 3 ) ? ( str = "Vowel"
      ) : ( curitem == 4 ) ? ( str = "Karlsen Ladder III (303)"
      ) : ( curitem == 5 ) ? ( str = "Karlsen Ladder IIIs (303)"
      ) : ( curitem == 6 ) ? ( str = "Sai'ke Waveshaped LP"
      ) : ( curitem == 7 ) ? ( str = "Sai'ke Waveshaped HP"
      ) : ( curitem == 8 ) ? ( str = "Sai'ke Waveshaped BP"
      ) : ( curitem == 9 ) ? ( str = "Expensive Moog (ZDF)"
      ) : ( curitem == 10 ) ? ( str = "Cheap Moog (unstable)"
      ) : ( curitem == 11 ) ? ( str = "Notch"
      ) : ( curitem == 12 ) ? ( str = "Narsty"
      ) : ( curitem == 13 ) ? ( str = "Modulator"
      ) : ( curitem == 14 ) ? ( str = "Phaser (OTA)"
      ) : ( curitem == 15 ) ? ( str = "Phaser (FET)"
      ) : ( curitem == 16 ) ? ( str = "Delay Feedbok"
      ) : ( curitem == 17 ) ? ( str = "Phase Mangler"      
      ) : ( curitem == 18 ) ? ( str = "Kr0g MS-20 linear LP (ZDF)"
      ) : ( curitem == 19 ) ? ( str = "Kr0g MS-20 linear BP (ZDF)"
      ) : ( curitem == 20 ) ? ( str = "Kr0g MS-20 linear HP (ZDF)"
      ) : ( curitem == 21 ) ? ( str = "Kr0g MS-20 nonlin LP (ZDF)" 
      ) : ( curitem == 22 ) ? ( str = "Kr0g MS-20 nonlin BP (ZDF)"
      ) : ( curitem == 23 ) ? ( str = "Kr0g MS-20 nonlin HP (ZDF)"
      );
    ) : (stridx == 1) ? 
    (
      ( curitem == 0 ) ? ( str = "Stereo"
      ) : ( curitem == 1 ) ? ( str = "Mono double"
      ) : ( curitem == 2 ) ? ( str = "M1/S2"
      ) : ( curitem == 3 ) ? ( str = "M2/S1"
      ) : ( curitem == 4 ) ? ( str = "Only Side"
      ) : ( curitem == 5 ) ? ( str = "Only Mid"
      );
    ) : (stridx == 2) ?
    (
      ( curitem == 0 ) ? ( str = "OFF"
      ) : ( curitem == 1 ) ? ( str = "Cosine"
      ) : ( curitem == 2 ) ? ( str = "Sine"
      ) : ( curitem == 3 ) ? ( str = "Cos^2"
      ) : ( curitem == 4 ) ? ( str = "Sin^2"
      ) : ( curitem == 5 ) ? ( str = "Ramp up"
      ) : ( curitem == 6 ) ? ( str = "Ramp down"
      ) : ( curitem == 7 ) ? ( str = "Exponential"
      ) : ( curitem == 8 ) ? ( str = "Exp + Atk"
      ) : ( curitem == 9 ) ? ( str = "1-Exponential"
      ) : ( curitem == 10 ) ? ( str = "Random"
      ) : ( curitem == 11 ) ? ( str = "Random Exps"
      ) : ( curitem == 12 ) ? ( str = "Rand Exps + Atk"
      ) : ( curitem == 13 ) ? ( str = "Single Exp"
      ) : ( curitem == 14 ) ? ( str = "Single Exp + Atk"      
      )
    );
    
    str;
  );

function modulator()
  global(srate)
  local()
  instance( invpi2, twopi, invsrate, reset, modvalue, modrate, t )
  (
    modvalue = 0;
    reset = 1;
    invsrate = 1.0/srate;
    invpi2 = .5/$pi;
    twopi = 2*$pi;
  );

function calcGain()
(
  pregain  = 2^((slider52 + 40 * dyn_mod_gain * dynval)/6);
  postgain = 2^(slider53/6);
  gaincompensation = 1/pregain;
);

function setmodrate(val)
  global()
  local()
  instance( invsrate, reset, modvalue, modrate, t )
  (
    modrate = val;
  );
  
modulator.modulator();

function updateModulator()
  instance( invpi2, twopi, invsrate, reset, modvalue, modrate, t, lastt, lastrand )
  global( slider38, slider36 )
  local(ct, st)
  (
    slider36 > 0 ? (
      t = t + modrate*invsrate;
      slider38 && reset == 1 ? ( t = 0; reset = 0 );
      modvalue = slider36 == 1 ? .5 + .5 * cos(twopi*t) 
      : ( slider36==2 )  ? .5 + .5 * sin(twopi*t)
      : ( slider36==3 )  ? ( ct = cos($pi*t); ct*ct )
      : ( slider36==4 )  ? ( st = sin($pi*t); st*st )
      : ( slider36==5 )  ? ( t-floor(t) )
      : ( slider36==6 )  ? ( 1-t+floor(t) )
      : ( slider36==7 )  ? ( exp(-4*(t-floor(t))) )
      : ( slider36==8 )  ? ( min((15*(t-floor(t))),1)*exp(-4*(t-floor(t))) )
      : ( slider36==9 )  ? ( 1-exp(-4*(t-floor(t))) )
      : ( slider36==10 ) ? ( ( t > (lastt+1) ) ? ( lastt = t; lastrand=rand() ); lastrand )
      : ( slider36==11 ) ? ( ( t > (lastt+1) ) ? ( lastt = t; lastrand=rand() ); exp(-4*lastrand*(t-floor(t))) )
      : ( slider36==12 ) ? ( ( t > (lastt+1) ) ? ( lastt = t; lastrand=rand() ); min((15*(.2+.8*lastrand)*(t-floor(t))),1)*exp(-4*lastrand*(t-floor(t))) )
      : ( slider36==13 ) ? ( exp(-t) )    
      : ( slider36==14 ) ? ( min((15*(t-floor(t))),1)*exp(-t) )
    )
  );

function gfx_wrapprint(str, maxlen)
  global(gfx_x, gfx_y)
  local(mp, len, str, lastLineStart, lastWordStart, cpos, tmp, mx, my, xref, yref)
  (
    xref = gfx_x;
    yref = gfx_y;
    len = strlen(str);
    lastLineStart = 0;
    lastWordStart = 0;
    cpos = 0;
    tmp = 1;
    mp = 0;
    loop(len,
      // Found end of a word!
      ( str_getchar(str, cpos) == 32 ) ? (
        // Is the current line too long?
        gfx_measurestr( strcpy_substr( tmp, str, lastLineStart, cpos-lastLineStart ), mx, my );
        ( mx > maxlen ) ? (
          strcpy_substr( tmp, str, lastLineStart+mp, lastWordStart - lastLineStart );
          gfx_printf( tmp );
          // Yeah, terminate here
          lastLineStart = lastWordStart;
          gfx_x = xref;
          gfx_y += my;
          mp = 1;
        ) : (
          // Nope keep going
          lastWordStart = cpos;
        );
      );
      
      cpos += 1;
    );
    strcpy_substr(tmp, str, lastLineStart+mp, cpos - lastLineStart);
    gfx_printf(tmp);
  );

function filterDescription(filter)
global(gfx_x, gfx_y, slider47, wndX, wndY, wndPad)
local(fx, fy, wx, wx2, wy)
(
  fx = 30;
  fy = wndPad*2 + wndY + 3;
  wx = 3*wndX + 2*wndPad;
  wx2 = wx - 10;

  gfx_set(0.1, 0.1, 0.2, .3);
  gfx_rect(fx, fy, wx, 160);
  gfx_x = fx+5;
  gfx_y = fy+5;

  gfx_set(0.6, 0.6, 1.0, 1.0);

  gfx_setfont(2, "Sans Serif", 16);
  ( slider47 == 0 ) ? (
    gfx_printf("Filter: OFF")
  ) : ( slider47 == 1 ) ? (
    gfx_printf("Filter: LP RC-C\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Simple state space filter. This filter does not use internal waveshaping and the output of the filter is waveshaped instead.", wx2);
  ) : ( slider47 == 2 ) ? (  
    gfx_printf("Filter: LP Diode Ladder\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter was based on a model by Dominique Wurtz which modelled the 303 diode ladder. The only modification is that rather than input clipping, the waveshaper is used.", wx2);
  ) : ( slider47 == 3 ) ? (
    gfx_printf("Filter: Vowel filter\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter uses 3 band pass filters to imitate vowel sounds.", wx2);
  ) : ( slider47 == 4 ) ? (  
    gfx_printf("Filter: LP Karlsen Fast Ladder III\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on a 303 diode ladder. The filter uses the waveshaper as non/ideal part rather than just clipping. Note that this filter doesn't completely maintain its tone when using different levels of supersampling.", wx2);
  ) : ( slider47 == 5 ) ? (  
    gfx_printf("Filter: LP Karlsen Fast Ladder III (sat)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter combines the 303 diode ladder filter with a fixed shelf filter. The filter uses the waveshaper as non/ideal part rather than just clipping. Note that this filter doesn't completely maintain its tone when using different levels of supersampling.", wx2);
  ) : ( slider47 == 6 ) ? (  
    gfx_printf("Filter: Saike`s Waveshaped Resonance (LP)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter consists of two first order low-pass filters. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. This filter can get very mean depending on the curve you set for waveshaping. Be careful!", wx2);
  ) : ( slider47 == 7 ) ? (  
    gfx_printf("Filter: Saike`s Waveshaped Resonance (HP)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a waveshaped highpass filter. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again.", wx2);
  ) : ( slider47 == 8 ) ? (
    gfx_printf("Filter: Saike`s Waveshaped Resonance (BP)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a waveshaped bandpass filter. Sort of. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again.", wx2);
  ) : ( slider47 == 9 ) ? (
    gfx_printf("Filter: Physically accurate model of a Moog filter\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on the paper Modeling and measuring a Moog voltage-controlled filter by Paschou et al. Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will bring in higher quality as the non-linearity makes it sensitive to aliasing problems. This version is more stable than the cheap version, but still be careful. Extemely high gain with high resonance can turn this baby into a glitching mess! Best used with the fast Atanh because of performance considerations.", wx2);
  ) : ( slider47 == 10 ) ? (
    gfx_printf("Filter: Approximate physically accurate model of a Moog filter\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on the paper Modeling and measuring a Moog voltage-controlled filter by Paschou et al. Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will bring in higher quality as the non-linearity makes it sensitive to aliasing problems. This version does not correctly compute the Jacobian. This is fine for low cutoffs and/or atanh waveshaper. Be careful though, because it can seriously blow up in your face!", wx2);
  ) : ( slider47 == 11 ) ? (
    gfx_printf("Filter: Basic notch filter\n\n"); gfx_x = fx+5;
  ) : ( slider47 == 12 ) ? (
    gfx_printf("Filter: Narsty\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Saike's make things nasty filter. Combination of 3 filters with varying interacting resonances. No guarantees that this thing won´t blow up in your face. Exclusively meant for basses. Note that this one is not guaranteed to maintain its character when changing the sampling rate.", wx2);
  ) : ( slider47 == 13 ) ? (
    gfx_printf("Filter: Modulator\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Passes a lowpsased version of the signal and modulates it with the signal itself. Second bandpass filtered version is added to provide the resonance peak. This filter is meant for sounds with limited high frequency content as it will sound awful with rich sounds.\n", wx2);
  ) : ( slider47 == 14 ) ? (
    gfx_printf("Filter: Phaser\n\n"); gfx_x = fx+5;
    gfx_wrapprint("4 pass phaser based on operational transconductance amplifiers. Note that this one frequently has problem with spline voltage curves.", wx2);
  ) : ( slider47 == 15 ) ? (
    gfx_printf("Filter: Phaser based on FET\n\n"); gfx_x = fx+5;
    gfx_wrapprint("4 pass phaser based on Field Effect Transistor elements.", wx2);
  ) : ( slider47 == 16 ) ? (
    gfx_printf("Filter: Phaser-like\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Non-linear phaser like filter with relatively long delays and distortion of difference signal.", wx2);
  ) : ( slider47 == 17 ) ? (
    gfx_printf("Filter: Phase mangler\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Magic???", wx2);
  ) : ( slider47 == 18 ) ? (
    gfx_printf("Filter: MS-20 linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation.", wx2);
  ) : ( slider47 == 19 ) ? (
    gfx_printf("Filter: MS-20 linear BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation.", wx2);
  ) : ( slider47 == 20 ) ? (
    gfx_printf("Filter: MS-20 linear HP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation.", wx2);        
  ) : ( slider47 == 21 ) ? (
    gfx_printf("Filter: MS-20 non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper.", wx2);
  ) : ( slider47 == 22 ) ? (
    gfx_printf("Filter: MS-20 non-linear BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially  without waveshaper.", wx2);
  ) : ( slider47 == 23 ) ? (
    gfx_printf("Filter: MS-20 non-linear HP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially  without waveshaper.", wx2);                
  ) : ( slider47 == 24 ) ? (
    gfx_printf("Filter: Multiphase\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Experimental...", wx2);
  )
);

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr        = scopebuffer_in;
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );
  
function initBufferNoReset(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );  

function tanh(s)
local(c)
global()
instance()
(
  c = exp(8*s);
  s = 0.25*(c - 1) / (c + 1);
);

function fasttanh(x)
local()
global()
instance()
(
  x = x / (1 + abs(4*x));
  /*( x < -3 ) ? (
      x = -1;
  ) : ( x > 3 ) ? (
      x = 1;
  ) : ( 
      x = x * ( 27 + x * x ) / ( 27 + 9 * x * x );
    )*/
 // x = (-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*x)*x)*x)/(.2464845986383725+(.0609347197060491+(.1086202599228572+.02874707922475963*x)*x)*x);
);

//----------------------------------------------
// Filter initialization section
//----------------------------------------------
function initRC(freq, q)
  instance(len, v0, v1, a1, c)
  local(r)
  global(srate, slider54)
  (
    c = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    r = pow(0.5, (q*128+24) / 16.0);
    a1 = (1.0-r*c);   
  );

function init303(freq, q)
  local()
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    // This specific filter came from
    // Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
    wc  = .25 * (pow(10, freq)-1)/9 * $pi / (slider54+1);
    wc2 = wc*wc;
    wc3 = wc2*wc;
    wc4 = wc3*wc;
    b   = 1 / ( 1 + 8*wc + 20*wc2 + 16*wc3 + 2*wc4);
    g   = 2 * wc4 * b;
    
    k   = 5*q;
    A   = 1 + 0.5 * k;
    
    b0 = 2*wc+12*wc2+20*wc3+8*wc4;
    a0 = 1+6*wc+10*wc2+4*wc3;
    a1 = 2*wc+8*wc2+6*wc3;
    a2 = 2*wc2+4*wc3;
    a3 = 2*wc3;
    
    b10 = 2*wc2+8*wc3+6*wc4;
    a10 = wc+4*wc2+3*wc3;
    a11 = 1+6*wc+11*wc2+6*wc3;
    a12 = wc+4*wc2+4*wc3;
    a13 = wc2+2*wc3;
    
    b20 = 2*wc3+4*wc4;
    a20 = a13;
    a21 = wc+4*wc2+4*wc3;
    a22 = 1+6*wc+10*wc2+4*wc3;
    a23 = wc+4*wc2+2*wc3;
    
    c2  = a21 - a3;
    c3  = 1+6*wc+9*wc2+2*wc3;
  ); 
  
function reset303()
  local(Kbig)
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    z1 = z2 = z3 = 0;
    y1 = y2 = y3 = y4 = 0;
  );

function initmoog(freq, q)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    cutoff = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    res = .1 * q;
    
    f  = (cutoff+cutoff);
    p  = f*(1.8-0.8*f);
    k  = 2.0 * sin(cutoff * $pi * 0.5) - 1.0;
    
    t  = (1.-p)*1.386249;
    t2 = 12.+t*t;
    r  = res*(t2+6.*t)/(t2-6.*t);
  );

function resetmoog()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    oldy1=oldy2=oldy3=y1=y2=y3=y4=oldx=0;
  );

// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = 0;
  );   
  
// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen_sat(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen_sat()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = b_lfcut = b_lf = b_lf1hp = b_lfhp = b_lfgain = 0;
  );
  
function initdualfilt(freq, res)
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    f = (pow(10, freq)-1)/9 * $pi / (slider54+1);
    q = res;
    
    //set feedback amount given f and q between 0 and 1
    fb = q + q/(1.0 - f);
  );
  
function resetdualfilt()
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    d0 = d1 = 0.0000001;
  );

  
function initfancymoog(freq, q)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3, VT, fs                   
        )
  global(srate, slider54, tmp)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, ftarget)
  (
    fs      = (slider54+1) * srate;
    //ftarget = 24*(pow(10, freq)-1)/9; //24
    
    ftarget   = .5*(srate/1000)*(pow(10, freq)-1)/9;
    //ftarget = 6*freq;
    VT      = 26/1000;
    A       = 0.5 * VT;
    hA      = 0.5 * A;
    T       = 1.0/fs;
    wc      = 4*$pi*ftarget*srate;
    wcT     = wc*T;
    g       = wcT*hA;
    k       = q*4; // [0..4]
  );

function resetfancymoog()
  local()
  global()
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    y0 = y1 = y2 = y3 = y4 = d0 = d1 = d2 = d3 = d4 = 0;
  );
  
function bootvowel()
  instance( c, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, d0, d1, d2, d3, d4, d5, d6, d7, d8, d9 )
  local(ptr)
  global(vowel_A, vowel_E, vowel_I, vowel_O, vowel_U, vowel_EE)
  (
  vowel_EE = 909090;
    c[0] = vowel_A;
    c[1] = vowel_E;
    c[2] = vowel_I;
    c[3] = vowel_O;
    c[4] = vowel_U;
    c[5] = vowel_EE;
    
    // 34 39 57
    ptr = vowel_A;
    ptr[] = 660;        ptr += 1;
    ptr[] = 1700;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-15/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr = vowel_E;
    ptr[] = 530;        ptr += 1;
    ptr[] = 1850;       ptr += 1;
    ptr[] = 2500;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_I;
    ptr[] = 400;        ptr += 1;
    ptr[] = 2000;       ptr += 1;
    ptr[] = 2550;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_O;
    ptr[] = 300;        ptr += 1;
    ptr[] = 870;        ptr += 1;
    ptr[] = 2250;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_U;
    ptr[] = 640;        ptr += 1;
    ptr[] = 1200;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-11/6);  ptr += 1; // gain
    ptr[] = 2^(-13/6);   ptr += 1; // gain
    ptr[] = 9;          ptr += 1; // Q
    ptr[] = 10;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr   = vowel_EE; // These are correct
    ptr[] = 207;        ptr += 1; // freq
    ptr[] = 2300;       ptr += 1; // freq
    ptr[] = 3000;       ptr += 1; // freq
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q
);

function rfn(q,qq)
(
  q * (1+2*qq);
);

function initvowel(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(ampfac, idx, ptr, loc, rloc, fact, fr1, fr2, fr3, q1, q2, q3, w0, cw, sw, alpha, a0, a0i, Q )
  global(slider54, srate, rfn)
  (
    loc   = 5 * freq;
    idx   = floor( loc - 0.0001 );
    rloc  = loc-idx;
    rloc  = 1.0 - rloc;
    fact  = 2 * $pi / ( srate * ( max(1,slider54) ) );
    
    ampfac = 6;
    ptr   = c[idx];
    fr1   = ptr[]*rloc; ptr+=1;
    fr2   = ptr[]*rloc; ptr+=1;
    fr3   = ptr[]*rloc; ptr+=1;
    amp1  = ampfac*ptr[]*rloc; ptr+=1;
    amp2  = ampfac*ptr[]*rloc; ptr+=1;
    amp3  = ampfac*ptr[]*rloc; ptr+=1;
    q1    = ptr[]*rloc; ptr+=1;
    q2    = ptr[]*rloc; ptr+=1;
    q3    = ptr[]*rloc; ptr+=1;
  
    ptr   = c[idx+1];    
    rloc  = 1 - rloc;
    fr1   += ptr[]*rloc; ptr+=1;
    fr2   += ptr[]*rloc; ptr+=1;
    fr3   += ptr[]*rloc; ptr+=1;
    amp1  += ampfac*ptr[]*rloc; ptr+=1;
    amp2  += ampfac*ptr[]*rloc; ptr+=1;
    amp3  += ampfac*ptr[]*rloc; ptr+=1;
    q1    += ptr[]*rloc; ptr+=1;
    q2    += ptr[]*rloc; ptr+=1;
    q3    += ptr[]*rloc; ptr+=1;
  
    // Biquads RBJ BP
    Q     = rfn(q1, qin);
    w0    = fr1 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = rfn(q2, qin);
    w0    = fr2 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = rfn(q3, qin);
    w0    = fr3 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

// Biquads RBJ Notch
function initnotch(freq, q)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local( out, w0, cw, sw, alpha, a0, a0i )
  global(srate, slider54)
  (
    w0    = (pow(10, freq)-1)/9 * $pi / (slider54+1);
    q     = q*0.9 + .1;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    b0    = 1 * a0i;
    b1    = -2 * cw * a0i;
    b2    = a0i;
    a1    = -2 * cw * a0i;
    a2    = (1 - alpha) * a0i;
  );

function initsai0(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / (slider54+1);
    w0c   = .1*(pow(10, freq)-1)/9 * $pi * fact + .025*5*fact;
    qav   = qin*1.5 + .5;
  
    amp1  = 1;
    amp2  = 1;
    amp3  = 1;
      
    // Biquads RBJ BP
    Q     = qav*8;
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = qav*12;
    w0    = w0c*2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = qav*12;
    w0    = w0c/2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

function resetsai0()
  global()
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local( )
  (
    c = amp1 = amp2 = amp3 = Ab0 = Ab1 = Ab2 = Aa1 = Aa2 = Bb0 = Bb1 = Bb2 = Ba1 = Ba2 = Cb0 = Cb1 = Cb2 = Ca1 = Ca2 = d1x = d2x = d1yA = d2yA = d1yB = d2yB = d1yC = d2yC = 0;
  );

function initmodulator(freq, qin)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / (max(slider54,1));
    w0c   = .1*(pow(10, freq)-1)/9 * $pi * fact + .25*fact;
    Q     = qin*15 + 20;
    amp   = qin*2;
    
    // Biquads RBJ BP
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0   = Q * alpha * a0i;
    Ab1   = 0 * a0i;
    Ab2   = - alpha * Q * a0i;
    Aa1   = -2 * cw * a0i;
    Aa2   = (1 - alpha) * a0i;
  
    Q     = 5+qin*15;
    fact  = $pi / ( srate * ( max(1,slider54) ) );
    w0    = w0c*.25;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = 0.5*(1-cw)*a0i;
    Bb1    = (1-cw)*a0i;
    Bb2    = 0.5*(1-cw)*a0i;
    Ba1    = -2*cw*a0i;
    Ba2    = (1 - alpha)*a0i;
  );
  
function resetmodulator()
  global()
  local()
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  (
    c = Ab0 = Ab1 = Ab2 = Aa1 = Aa2 = Bb0 = Bb1 = Bb2 = Ba1 = Ba2 = d1x = d2x = d1yA = d2yA = d1yB = d2yB = amp = 0;
  );

function initphaserOTA(freq, reso)
  global(slider54)
  local(Rf, g)
  instance(C1, C2, dw, dx, sq)
  (
    Rf = 25/1000;
    g = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    sq = .2*reso;
    // Rf = R1*Vt/R2
    C1 = Rf * g;
    C2 = - 1 / Rf;
  );
  
function resetphaserOTA()
  global()
  local()
  instance(C1, C2, dw, dx, sq)
  (
    dw = dx = 0;
  );

// Trapezoidal integrator
function TPT_step(g, x)
  local()
  global()
  instance(s, y)
  (
    y = g * x + s;
    s = y + g * x;
    
    y;
  );

function init_MS20lin(freq, reso)
  global(slider54)
  local(fg, invTerm, smallg, Gsq, norm)
  instance(a0, a1, a2, s1, s2, G, k)
  (
//    fg      = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    smallg  = .5 * (pow(10, freq)-1)/9 * $pi / (slider54+1);
    k       = 2*reso;
    invTerm = 1.0 / ( 1.0 + smallg );
    G       = smallg * invTerm;
    Gsq     = G*G;
    norm    = 1.0 / ( 1.0 + Gsq * k - G * k );
    
    a0      = Gsq * norm;
    a1      = G * norm;
    a2      = norm;
  ); 
    
function init_MS20(freq, reso)
  global(slider54)
  local(fg, invTerm, smallg)
  instance(s1, s2, G, Gsq, Gsqk, Gk, k)
  (
//    fg      = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    smallg  = .5 * (pow(10, freq)-1)/9 * $pi / (slider54+1);
    k       = 2*reso;
    invTerm = 1.0 / ( 1.0 + smallg );
    G       = smallg * invTerm;
    Gsq     = G*G;
    Gsqk    = Gsq * k;
    Gk      = G*k;
  ); 
  
  
function init_MS20_nonlin(freq, reso)
  global(slider54)
  local()
  instance(y1, y2, d1, d2, h, hh, k)
  (
    h  = .5 * (pow(10, freq)-1)/9 * $pi / (slider54+1);
    hh = 0.5 * h;
    k  = 2*reso;
    
    //f1 = wcT * ( y1 - d1 + (h*(atan(d1 -  x + g(d2*k)) + atan(y1 - x + g(k*y2))))/2 );
  );
    
  
function resetrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local()
  global()
  (
    c = b0 = b1 = b2 = a1 = a2 = d1x = d2x = d1y = d2y = 0;
  );  
  
function initphaserFET(freq, reso)
  global(srate, slider54)
  local(IDSS, Vt, Vp, Fs, Vg, Rp, Q1, g )
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    /*IDSS = .001;  // 1 mA
    Vt   = 0.025; // 25mV
    Vp   = -3;
    Vg   = - 2 - reso;
    Rp   = 1; // ?
     
    iVpsq = 1 / (Vp * Vp);
    Q1 = 2 * IDSS * (Vg-Vt) * iVpsq; 
    C2 = 1 / Rp;
    g  = 1  - exp( - 2 * $pi * freq/max(slider54,1) );
  
    thresh = Vg - Vp;
    IDSSdivVpSq = IDSS * iVpsq;
      
    // We seek C1.
    // Q1*C1 - C2*C1 = g; Eq. 24 from the paper
    C1 = g / (Q1-C2);*/
    
    C1=.5*freq/max(1,slider54);C2=1;
  );  

function resetphaserFET()
  global()
  local()
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    dw = dx = 0;
  );
  
function updateActiveFilters()
  (
    filterDynamics ? (
      modval = dynval + modulator.modvalue;
      filterFreq = max( 0, min( 1, slider48 + dyn_mod_filt * modval ) );
      filterReso = max( 0, min( 1, slider49 + dyn_mod_reso * modval ) );
    ) : (
      filterFreq = slider48 + dyn_mod_filt * modulator.modvalue;
      filterReso = slider49 + dyn_mod_reso * modulator.modvalue;
    );
    
    calcGain();
   
    ( slider47 == 1 ) ? (
      L.rc_filter.initRC(filterFreq, filterReso);
      R.rc_filter.initRC(filterFreq, filterReso);
    ) : ( slider47 == 2 ) ? (
      L.filter_303.init303(filterFreq, filterReso);
      R.filter_303.init303(filterFreq, filterReso);
    ) : ( slider47 == 3 ) ? (
      L.filter_vowel.initvowel(filterFreq, filterReso);
      R.filter_vowel.initvowel(filterFreq, filterReso);
    ) : ( slider47 == 4 ) ? (
      L.filter_karlsen.initkarlsen(filterFreq, filterReso);
      R.filter_karlsen.initkarlsen(filterFreq, filterReso);
    ) : ( slider47 == 5 ) ? (
      L.filter_karlsen_sat.initkarlsen_sat(filterFreq, filterReso);
      R.filter_karlsen_sat.initkarlsen_sat(filterFreq, filterReso);
    ) : ( slider47 == 6 ) ? (
      L.filter_dualfilt.initdualfilt(filterFreq, filterReso);
      R.filter_dualfilt.initdualfilt(filterFreq, filterReso);
    ) : ( slider47 == 7 ) ? (
      L.filter_dualfiltHP.initdualfilt(filterFreq, filterReso);
      R.filter_dualfiltHP.initdualfilt(filterFreq, filterReso);
    ) : ( slider47 == 8 ) ? (
      L.filter_dualfiltBP.initdualfilt(filterFreq, filterReso);
      R.filter_dualfiltBP.initdualfilt(filterFreq, filterReso);
    ) : ( slider47 == 9 || slider47 == 10 ) ? (
      ( slider54 < 2 ) ? ( 
        slider54 = 2;
        slider_automate(slider54);
        forceUpdate = 1;
        ); 
      ( slider56 == 0 ) ? (
        slider56 = 3;
        slider_automate(slider56);
        forceUpdate = 1;
      );
      L.filter_fancymoog.initfancymoog(filterFreq, filterReso);
      R.filter_fancymoog.initfancymoog(filterFreq, filterReso);
    ) : ( slider47 == 11 ) ? (
      L.filter_notch.initnotch(filterFreq, filterReso);
      R.filter_notch.initnotch(filterFreq, filterReso);
    ) : ( slider47 == 12 ) ? (
      L.filter_sai0.initsai0(filterFreq, filterReso);
      R.filter_sai0.initsai0(filterFreq, filterReso);
      ( slider56 == 3 ) ? (
        slider56 = 1;
        slider_automate(slider56);
        forceUpdate = 1;
      );
    ) : ( slider47 == 13 ) ? (
      L.filter_modulator.initmodulator(filterFreq, filterReso);
      R.filter_modulator.initmodulator(filterFreq, filterReso);      
    ) : ( slider47 == 14 ) ? (
      L.filter_phaser.initphaserOTA(filterFreq, filterReso);
      L.filter_phaser2.initphaserOTA(filterFreq*2, filterReso);
      L.filter_phaser3.initphaserOTA(filterFreq/2, filterReso);
      L.filter_phaser4.initphaserOTA(filterFreq/3, filterReso);
      R.filter_phaser.initphaserOTA(filterFreq, filterReso);
      R.filter_phaser2.initphaserOTA(filterFreq*2, filterReso);
      R.filter_phaser3.initphaserOTA(filterFreq/2, filterReso);
      R.filter_phaser4.initphaserOTA(filterFreq/3, filterReso);      
    ) : ( slider47 == 15 ) ? (
      L.filter_phaser.initphaserFET(filterFreq, filterReso);
      L.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
      L.filter_phaser3.initphaserFET(filterFreq/2, filterReso);
      L.filter_phaser4.initphaserFET(filterFreq/3, filterReso);
      R.filter_phaser.initphaserFET(filterFreq, filterReso);
      R.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
      R.filter_phaser3.initphaserFET(filterFreq/2, filterReso);
      R.filter_phaser4.initphaserFET(filterFreq/3, filterReso);
    ) : ( slider47 == 16 ) ? (
      L.filter_dualfilt.initdualfilt(filterFreq, filterReso);
      R.filter_dualfilt.initdualfilt(filterFreq, filterReso);
      filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq * 1000);
      filter_delay2.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*filterReso * 2000);
    ) : ( slider47 == 17 ) ? (
      L.filter_dualfilt.initdualfilt(filterFreq, filterReso);
      R.filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq*(1000+4000*filterReso));
    ) : ( slider47 == 18 ) ? (
      L.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
      R.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
    ) : ( slider47 == 19 ) ? (
      L.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
      R.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
    ) : ( slider47 == 20 ) ? (
      L.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
      R.filter_ms20lin.init_MS20lin(filterFreq, filterReso);            
    ) : ( slider47 == 21 ) ? (
      L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
    ) : ( slider47 == 22 ) ? (
      L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
    ) : ( slider47 == 23 ) ? (
      L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);      
    );
  );
 
function resetActiveFilters()
  (
    ( slider47 == 1 ) ? (
      gfx_printf( " " );
    ) : ( slider47 == 2 ) ? (
      L.filter_303.reset303();
      R.filter_303.reset303();
    ) : ( slider47 == 3 ) ? (
      L.filter_moog.resetmoog();
      R.filter_moog.resetmoog();
    ) : ( slider47 == 4 ) ? (
      L.filter_karlsen.resetkarlsen();
      R.filter_karlsen.resetkarlsen();      
    ) : ( slider47 == 5 ) ? (
      L.filter_karlsen_sat.resetkarlsen_sat();
      R.filter_karlsen_sat.resetkarlsen_sat();      
    ) : ( slider47 == 6 ) ? (
      L.filter_dualfilt.resetdualfilt();
      R.filter_dualfilt.resetdualfilt();      
    ) : ( slider47 == 7 ) ? (
      L.filter_dualfiltHP.resetdualfilt();
      R.filter_dualfiltHP.resetdualfilt();      
    ) : ( slider48 == 8 ) ? (
      L.filter_dualfiltBP.resetdualfilt();
      R.filter_dualfiltBP.resetdualfilt();      
    ) : ( slider47 == 9 ) ? (
      L.filter_fancymoog.resetfancymoog();
      R.filter_fancymoog.resetfancymoog();      
    ) : ( slider47 == 10 ) ? (
      L.filter_fancymoog.resetfancymoog();
      R.filter_fancymoog.resetfancymoog();
    ) : ( slider47 == 11 ) ? (
      L.filter_notch.resetrbj();
      R.filter_notch.resetrbj();      
    ) : ( slider47 == 12 ) ? (
      L.filter_sai0.resetsai0(sample);
      R.filter_sai0.resetsai0(sample);      
    ) : ( slider47 == 13 ) ? (
      L.filter_modulator.resetmodulator();
      R.filter_modulator.resetmodulator();      
    ) : ( slider47 == 14 ) ? (
      os = 0; jnk = 0;
      L.filter_phaser.resetphaserOTA();
      R.filter_phaser.resetphaserOTA();      
    ) : ( slider47 == 15 ) ? (
      os = 0;
      L.filter_phaser.resetphaserFET();
      R.filter_phaser.resetphaserFET();
    ) : ( slider47 == 16 ) ? (
      os1 = os2 = ys1 = 0;
    ) : ( slider47 == 17 ) ? (
      os1 = os2 = os3 = 0;
    );
  );

itm1=itm2=otm1=otm2=0;
forceUpdate=0;

movavgLN = 0;
movavgLP = 0;
movavgRN = 0;
movavgRP = 0;

updateActiveFilters();
  
function updateFilter(newlen)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (Q, sc, pos, cpos, spos, alpha)
  global ()
  (  
    ( newlen != len ) ?
    (
      len   = newlen;
      Q     = 0.707;
      pos   = 0.85 / len * $pi;
      cpos  = cos(pos);
      spos  = sin(pos);
      alpha = spos/(2.0*Q);
       
      sc    = 1.0 / (1+alpha);
      a1    = -2 * cpos * sc;
      a2    = (1-alpha) * sc;
      b1    = (1-cpos) * sc;
      b2    = b0 = b1 * 0.5;
    
      // Input taps
      d1 = d2 = d3 = d4 = 0;
      
      // Output taps
      o1 = o2 = o3 = o4 = 0;
    )
  );

function inputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out  = sample*b0 + d1*b1 + d2*b2 - d3*a1 - d4*a2;
    d2   = d1;
    d1   = sample;
    d4   = d3;
    d3   = out;
  );
  
function outputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out = sample*b0 + o1*b1 + o2*b2 - o3*a1 - o4*a2;
    o2  = o1;
    o1  = sample;
    o4  = o3;
    o3  = out;
  );

function setN(S, N)
local()
global(slider1, slider2)
(
  ( S == 1 ) ? (
    slider1=N; slider_automate(slider1);
  )
  : ( S == 2) ? (
    slider2=N; slider_automate(slider2);
  );
);

function manipulateXYSliders(S, i, x, y)
(
  // gfx_set(1,1,1,1);
  // gfx_x=0;
  // gfx_y=50;
  // gfx_printf("HEY %d, %d, %f, %f", S, i, x, y);
  (S == 2) ? (
     (i==1) ? ( slider3=x;  slider_automate(slider3);  slider4=y;  slider_automate(slider4);  )
    :(i==2) ? ( slider5=x;  slider_automate(slider5);  slider6=y;  slider_automate(slider6);  )
    :(i==3) ? ( slider7=x;  slider_automate(slider7);  slider8=y;  slider_automate(slider8);  )
    :(i==4) ? ( slider9=x;  slider_automate(slider9);  slider10=y; slider_automate(slider10); )
    :(i==5) ? ( slider11=x; slider_automate(slider11); slider12=y; slider_automate(slider12); )
    :(i==6) ? ( slider13=x; slider_automate(slider13); slider14=y; slider_automate(slider14); )
    :(i==7) ? ( slider15=x; slider_automate(slider15); slider16=y; slider_automate(slider16); )
    :(i==8) ? ( slider17=x; slider_automate(slider17); slider18=y; slider_automate(slider18); )
  )
  : ( S==1 ) ? (
     (i==1) ? ( slider19=x; slider_automate(slider19); slider20=y; slider_automate(slider20); )
    :(i==2) ? ( slider21=x; slider_automate(slider21); slider22=y; slider_automate(slider22); )
    :(i==3) ? ( slider23=x; slider_automate(slider23); slider24=y; slider_automate(slider24); )
    :(i==4) ? ( slider25=x; slider_automate(slider25); slider26=y; slider_automate(slider26); )
    :(i==5) ? ( slider27=x; slider_automate(slider27); slider28=y; slider_automate(slider28); )
    :(i==6) ? ( slider29=x; slider_automate(slider29); slider30=y; slider_automate(slider30); )
    :(i==7) ? ( slider31=x; slider_automate(slider31); slider32=y; slider_automate(slider32); )
    :(i==8) ? ( slider33=x; slider_automate(slider33); slider34=y; slider_automate(slider34); )
  );
  
  forceUpdate = 1;
);

// Really dumb sorting algorithm
function sort_spline()
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(last, mini, iter, tmp)
  global(gfx_x, gfx_y)
( 
  // First copy it to temp 
  ptr_from_X  = xloc_write;
  ptr_from_Y  = yloc_write;
  ptr_to_X    = tempx;
  ptr_to_Y    = tempy;
  ptr_to_Z    = tempz;
  iter        = 0;
  loop(N,
    ptr_to_X[] = ptr_from_X[];
    ptr_to_X += 1; ptr_from_X += 1;
    ptr_to_Y[] = ptr_from_Y[];
    ptr_to_Y += 1; ptr_from_Y += 1;
    ptr_to_Z[] = iter;
    ptr_to_Z += 1;
    iter += 1;
  );
  
  // Sort it
  ptr_to_X = xloc_write;
  ptr_to_Y = yloc_write;
  ptr_to_Z = indices;
  last = -1;
  loop(N,
    ptr_from_X = tempx;
    ptr_from_Y = tempy;
    ptr_from_Z = tempz;
    mini = 1000;
    loop(N,
      ( ( ptr_from_X[] > last ) && ( ptr_from_X[] < mini ) ) ?
      (
        mini       = ptr_from_X[];
        ptr_to_X[] = mini;
        ptr_to_Y[] = ptr_from_Y[];
        ptr_to_Z[] = ptr_from_Z[];
      );
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;      
    );
    last = mini;
    ptr_to_X += 1;
    ptr_to_Y += 1;
    ptr_to_Z += 1;
  );
  
  tmp = xloc_read;
  xloc_read = xloc_write;
  xloc_write = tmp;
  
  tmp = yloc_read;
  yloc_read = yloc_write;
  yloc_write = tmp;  
);

function update_spline()
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(cc1, m, mNext, cm, dx, dxNext, invdx, tmp)
  global(gfx_x, gfx_y)
  (
    // Calculate differences
    ptr_from_X  = xloc_read;
    ptr_from_Y  = yloc_read;
    ptr_to_X    = tempx;
    ptr_to_Y    = tempy;
    
    // tempx contains dxs, tempy the slopes (dy/dx)    
    loop(N-1,
      ptr_to_X[]  = ptr_from_X[1] - ptr_from_X[];
      ptr_to_Y[]  = ( ptr_from_Y[1] - ptr_from_Y[] ) / ptr_to_X[];
      ptr_to_X    += 1;
      ptr_to_Y    += 1;
      ptr_from_X  += 1;
      ptr_from_Y  += 1;
    );
    
    // calculate first degree coefficients
    ptr_from_X  = tempx; // dx
    ptr_from_Y  = tempy; // dy/dx (ms)
    ptr_to_X    = c1_write;
    
    ptr_to_X[]  = ptr_from_Y[];
    ptr_to_X   += 1;
    loop(N-2,
      m     = ptr_from_Y[];
      mNext = ptr_from_Y[1];
      ( m * mNext <= 0 ) ? ( ptr_to_X[] = 0; ):
      (
        dx = ptr_from_X[];
        dxNext = ptr_from_X[1];
        cm = dx + dxNext;
        ptr_to_X[] = 3.0*cm/((cm+dxNext)/m + (cm+dx)/mNext);
      );
      ptr_to_X   += 1;
      ptr_from_X += 1;
      ptr_from_Y += 1;
    );
    ptr_to_X[] = ptr_from_Y[];
    
    // calculate second degree coefficients
    ptr_from_X = tempx; // dx
    ptr_from_Y = tempy; // dy/dx (ms)
    ptr_from_Z = c1_write;    // c1s
    ptr_to_X   = c2_write;
    ptr_to_Y   = c3_write;
    loop(N-1,
      invdx = 1 / ptr_from_X[];
      cc1 = ptr_from_Z[];
      m = ptr_from_Y[];
      cm = cc1 + ptr_from_Z[1] - m - m;
      ptr_to_X[] = (m - cc1 - cm)*invdx;
      ptr_to_Y[] = cm*invdx*invdx;
      
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;
      ptr_to_X   += 1;
      ptr_to_Y   += 1;
    );
    
    tmp = c1_read;
    c1_read = c1_write;
    c1_write = tmp;
    
    tmp = c2_read;
    c2_read = c2_write;
    c2_write = tmp;
    
    tmp = c3_read;
    c3_read = c3_write;
    c3_write = tmp;    
  );

function evalSplineBin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    // Out of bounds means return 1
    (x > 1) ? out = yloc_read[N-1] : 
    (
      ( x < 0 ) ? out = 0 :
      (
        // Search for the correct interval by binary search
        low       = 0;
        high      = N;
        while(
          mid = floor( 0.5*(low+high) );
          xHere = xloc_read[mid];
          
          ( xHere < x ) ? low = mid + 1 :
          ( // else
            ( xHere > x ) ? high = mid - 1 :
              ( //else 
                high = yloc_read[mid];
                low = high+1; // Manual termination
              );
          );
          
          low <= high;
        );
        
        i = max( 0, high );        
        
        diff    = x - xloc_read[i];
        diffSq  = diff * diff;

        out = yloc_read[i] + c1_read[i]*diff + c2_read[i]*diffSq + c3_read[i]*diff*diffSq;
      )
    );
    
    out;
  );
  
function evalSplineLin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    i = -1;
    xHere = xloc_read-1;
    
    while(
      i += 1;
      xHere += 1;
      
      x >= xHere[] && ( i < N )
    );
        
    i = max( 0, i-1 );        
        
    diff    = x - xloc_read[i];
    diffSq  = diff * diff;
    out = yloc_read[i] + c1_read[i]*diff + c2_read[i]*diffSq + c3_read[i]*diff*diffSq;
    
    out;
  );  
  
function evalSplineAudioBin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio)
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_read[N-1] : 
    (
      ( x < 0 ) ? out = 0 :
      (
        // Search for the correct interval by binary search
        lowAudio       = 0;
        highAudio      = N;
        while(
          midAudio = floor( 0.5*(lowAudio+highAudio) );
          xHereAudio = xloc_read[midAudio];
          
          ( xHereAudio < x ) ? lowAudio = midAudio + 1 :
          ( // else
            ( xHereAudio > x ) ? highAudio = midAudio - 1 :
              ( //else 
                highAudio = yloc_read[midAudio];
                lowAudio = highAudio+1; // Manual termination
              );
          );
          
          lowAudio <= highAudio;
        );
        
        iAudio = max( 0, highAudio );        
          
        diffAudio    = x - xloc_read[iAudio];
        diffSqAudio  = diffAudio * diffAudio;
          
        out = yloc_read[iAudio] + c1_read[iAudio]*diffAudio + c2_read[iAudio]*diffSqAudio + c3_read[iAudio]*diffAudio*diffSqAudio;
      )
    );
    
    out;
  );    
  
function evalSplineAudioLin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio)
  global(gfx_x, gfx_y)
  (
    iAudio = -1;
    xHereAudio = xloc_read-1;
    
    while(
      iAudio += 1;
      xHereAudio += 1;
      
      x >= xHereAudio[] && ( iAudio < N )
    );
    
    iAudio       = max(0, iAudio-1);
    diffAudio    = x - xloc_read[iAudio];
    diffSqAudio  = diffAudio * diffAudio;
          
    out = yloc_read[iAudio] + c1_read[iAudio]*diffAudio + c2_read[iAudio]*diffSqAudio + c3_read[iAudio]*diffAudio*diffSqAudio;
    
    out;
  );  

function evalSplineAudioDiff(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, interpAudio, xHereAudio, diffAudio, out, midAudio)
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_read[N-1] : 
    (
      ( x < 0 ) ? out = 0 :
      ( 
        iAudio = max( 0, highAudio );
        diffAudio    = x - xloc_read[iAudio];
        out = c1_read[iAudio] + diffAudio*(2*c2_read[iAudio] + 3*diffAudio*c3_read[iAudio]);
      )
    );
    
    out;
  );  

// Plot the spline nodes
function plot_spline(x, y, w, h)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(xx, res, lastx, lasty, dx, yout, nx, ny, epsx, epsy, xc, yc, yout)
  global(gfx_x, gfx_y, distortPlot, slider56, dynval)
  (
    epsx = 3;
    epsy = 3;
    ptr_from_X = xloc_read;
    ptr_from_Y = yloc_read;
    ptr_from_Z = indices;
    
    gfx_set( .7, .7, .7, .7 );
    gfx_x = 0;
    gfx_y = 0;
    ( slider56 == 0 ) ? (
      loop(N,
        xc = x + w*ptr_from_X[] - epsx;
        yc = y + h*(1-ptr_from_Y[]) - epsy;
        gfx_rect(xc, yc, epsx, epsy);
        gfx_x = xc;
        gfx_y = yc-14;
        gfx_printf("%d", ptr_from_Z[]);
        ptr_from_X += 1;
        ptr_from_Y += 1;
        ptr_from_Z += 1;
      );
    );
    
    xx = 0;
    res = 500;
    lastx = x;
    lasty = y+h;
    dx = 1.0/res;
    loop(res,
      xx = xx + dx;
      ( slider56 == 0 ) ? (
        yout = this.evalSplineLin(xx);
      ) : ( slider56 == 1 ) ? ( 
        yout = tanh(xx);
      ) : ( slider56 == 2 ) ? (
        yout = fasttanh(xx);
      ) : (
        yout = xx;
      );
      //        distortionDynamics ? s = (1-dynval) * os + dynval * s;
      
//      yout = distortPlot(xx);
      nx = x + w*xx - 1;
      ny = y + h*(1-yout) - 1;
      gfx_line(lastx, lasty, nx, ny, 0);
      lastx = nx;
      lasty = ny;
    );
  );
  
function evalDist(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineLin(xx);
  );  
  
function evalDistAudio(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioLin(xx);
  );
  
function evalDiff(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioDiff(xx);
  );  
  
//NODE_PROXIMITY = 5;
function findNearest(x, y)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(minDist, best, dx, dy, dist, left, i, right)
  global()
(
    // Find nearest point that may have been clicked
    i = 0;
    minDist = 100000000000000;
    best = -1;
    loop(N,
      dx = (x - xloc_read[i]);
      dy = ((1-y) - yloc_read[i]);
      dist = dx*dx + dy*dy;          
      ( dist < minDist ) ? 
      (
        minDist = dist;
        best = i;
       );
       i = i + 1;
     );
             
    // Found a point, then we change the capture mode
    ( minDist < .001 ) ? ( drag_node = best; ) : drag_node = -1;
);

//NODE_PROXIMITY = 5;
function killNode(i)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(i)
  global()
  (
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N-2))&&(i<(N+1))
    );
    
    manipulateXYSliders(splineIdx, indices[drag_node], xloc_read[i], yloc_read[i]);
    setN(splineIdx, N-1);
  );
  
function addNode(x, y)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(i)
  global()
  (
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N-1))&&(i<(N+2))
    );

    manipulateXYSliders(splineIdx, indices[N], xloc_read[i], yloc_read[i]);  
    manipulateXYSliders(splineIdx, indices[N-1], x, y);
    setN(splineIdx, N+1);
  );  

//NODE_PROXIMITY = 5;
function processMouse(x, y, dx, dy, mc)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(left, right, i)
  global(manipulateXYSliders, gfx_x, gfx_y)
  (
    left  = mc & 1;
    right = mc & 2;
  
    ( left ) ? 
    (
      ( cap_mode == 0 ) ?
      (
        this.findNearest(x, y);
        ( drag_node > -1 ) ? ( drag_node = indices[drag_node]; cap_mode = 1; )
      ) : ( cap_mode == 1 ) ? (
        // We've already selected a node.
        x = max( min( x, .9999 ), 0.00001 );
        y = max( min( y, .9999 ), 0.00001 );
        manipulateXYSliders(splineIdx, drag_node, x, (1-y));
      );
    ) : (
      ( right ) ?
      (
        ( cap_mode == 0 ) ?
        (
          this.findNearest(x, y);
          // Are we clicking an existing one?
          ( drag_node > -1 ) ? 
          (
            // Kill it!
            ( N > 1 ) ? (
              this.killNode(drag_node);
              cap_mode = 2;
            )
          ):(
            // Add one?
            ( N < 9 ) ? (
              ( x > 0 && y > 0 && x < 1 && y < 1 ) ? (
              this.addNode(x, 1-y);
              cap_mode = 2; )
            );
          );
        );
      ) : ( cap_mode = 0; )
    )
  );

// Generate a spline object
function gen_spline(N_in, splineIdx_in, xloc_in, yloc_in, xloc_in2, yloc_in2, indices_in, tempx_in, tempy_in, tempz_in, c1_in, c2_in, c3_in, c1_in2, c2_in2, c3_in2)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  global()
(
  N          = N_in;
  xloc_read  = xloc_in;
  yloc_read  = yloc_in;
  xloc_write = xloc_in2;
  yloc_write = yloc_in2;  
  indices    = indices_in;
  tempx      = tempx_in;
  tempy      = tempy_in; 
  tempz      = tempz_in;
  c1_read    = c1_in;
  c2_read    = c2_in;
  c3_read    = c3_in;
  c1_write   = c1_in2;
  c2_write   = c2_in2;
  c3_write   = c3_in2;    

  splineIdx  = splineIdx_in;
  cap_mode   = 0;
);

function setN(N_new)
  local()
  global()
  instance(N, splineIdx, xloc, yloc, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  (
    N = N_new;
  );

function setN(N_new)
  local()
  global()
  instance(x, y, w, h, spline)
  (
    spline.setN(N_new)
  );

function groupWidget(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in)
  local()
  global()
  instance(x, y, w, h, r, g, b, a, label)
  (
    x       = x_in-2;
    y       = y_in-6;
    w       = w_in+4;
    h       = h_in+4;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
  );
  
function groupWidget_draw()
  local(siz, jnk)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, label)
  (
    gfx_set( r, g, b, .05 );
    gfx_rect( x, y, w, h );
    
    gfx_setfont(1, "Sans Serif", 12);
    gfx_set( r, g, b, 1.0);
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + 8;
    gfx_y = y - .5*jnk + 1;
    gfx_printf(label);
    gfx_set( r, g, b, .4 );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+5, y);
    gfx_line(x+siz+10, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
  );

function toggleLight(x_in, y_in, w_in, h_in, label_in, align_in, r_in, g_in, b_in, a_in, active_in)
  local(jnk, jnk1)
  global()
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    x       = x_in;
    y       = y_in;
    w       = w_in;
    h       = h_in;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
    align   = align_in;
    active  = active_in;
    lastleft = 0;
  );

function toggleLight_processMouse(xx, yy, mc)
  local(left)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    left = mc & 1;
    left ? (
      ( (lastleft ~= 1 ) && ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ) ? ( 
        active = 1 - active;
      );
    );
    
    lastleft = left;
  );
  
function toggleLight_draw()
  local(jnk, siz)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    gfx_set( r, g, b, .2 + .5*active );
    gfx_rect( x, y, w, h );
  
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    ( align == 0 ) ?
    (
      gfx_x = x+15;
      gfx_y = y+2;
    ) : (
      gfx_measurestr(label, siz, jnk);
      gfx_x = x - siz-3;
      gfx_y = y+1;
    );
    gfx_printf( label );  
  );  
  
function selectionButton(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in)
  local()
  global()
  instance(x, y, w, h, r, g, b, a, active, label, lastleft)
  (
      x       = x_in;
      y       = y_in;
      w       = w_in;
      h       = h_in;
      r       = r_in;
      g       = g_in;
      b       = b_in;
      a       = a_in;
      label   = label_in;
      lastleft = 0;
  );
  
function selectionButton_draw()
  local(jnk, siz)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, lastleft)
  (
    gfx_set( r, g, b, .2 + .5*active );
    gfx_rect( x, y, w, h );
  
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + .5 * (w-siz);
    gfx_y = y - .5*(jnk-h) + 1;
    gfx_printf( label );  
  );
  
function selectionButton_processMouse(xx, yy, mc)
  local(left, change)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    change = 0;
    left = mc & 1;
    left ? (
      ( (lastleft ~= 1 ) && ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ) ? ( 
        active = 1 - active;
        change = 1;
      );
    );
    
    lastleft = left;
    change
  );
  
function selectionButton_setActive(active_in)
  local()
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    active = active_in;
  );  

function combobox(x_in, y_in, w_in, h_in, r_in, g_in, b_in, a_in, nitems_in, stridx_in, goup_in )
  local()
  global()
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, hasfocus, goup)
  (
      x             = x_in;
      y             = y_in+1;
      w             = w_in;
      h             = h_in-2;
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      nitems        = nitems_in;
      cap           = 0;
      curitem       = 0;
      hover         = 8;
      open          = 0;
      stridx        = stridx_in;
      lastleft      = 0;
      hasfocus      = 0;
      goup          = goup_in;
  );
  
function combobox_setcuritem( item )
  local(i, xtxt)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus)
  (
    curitem = item;
  );
  
function combobox_draw()
  local(i, xtxt, x1, x2, x3, y1, y2, y3, pad, wi)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup)
  (
    gfx_set( r, g, b, .2 );
    gfx_rect( x, y, w, h );
    
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    
    pad = .3*h;
    wi = .5 * (h-pad);
    x1 = x+w-wi-pad;
    x2 = x+w-pad;
    x3 = x+w-.5*wi-pad;
    
    y1 = y+pad;
    y2 = y+pad;
    y3 = y+h-pad;
    
    gfx_line(x1, y1, x2, y2);
    gfx_line(x2, y2, x3, y3);
    gfx_line(x3, y3, x1, y1);
  
    xtxt = x+3;
    gfx_x = xtxt;
    gfx_y = y+4;
    gfx_printf(comboStrings(stridx, curitem));
  );
  
function combobox_draw_top()
  local(i, xtxt, x1, x2, x3, y1, y2, y3, pad, wi, delta)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup)
  (    
    xtxt = x+3;
    delta = goup ? (nitems+1)*h : 0;
    gfx_x = xtxt;
    gfx_y = y + 4 - delta;
    
    open ?
    (
      gfx_set( r*.1, g*.1, b*.1, 1 );
      gfx_rect( x, y-delta+h, w, h * nitems );
      i = 0;
      gfx_set( r, g, b, a, 0.95 );
      loop( nitems,
        gfx_x = xtxt;
        gfx_y += h;
        gfx_printf(comboStrings(stridx, i));
        i += 1;
      );
      gfx_set( 1, 1, 1, .1 );
      gfx_rect( x, y+h*hover+h - delta, w, h );
    )
  );
  
function combobox_processMouse(xx, yy, mc)
  local(left, right, change, delta)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, hasfocus, goup)  
  (
    delta = goup ? (nitems+1)*h : 0;
    change = 0;
    left = mc & 1;
    open ? 
    (
      hover = min( nitems-1, max( 0, floor((yy - (y-delta))/h) - 1 ) );
      
      !lastleft && left ? (
        open = 0;
        ( xx > x && xx < ( x+w ) && yy > (y+h-delta) && yy < ( y+(nitems+1)*h-delta ) ) ? ( curitem = hover; change = 1 );
      )
    ) : (
      ( lastleft == 0 && left && xx > x && xx < ( x+w ) && yy > y && yy < ( y + h ) ) ? (
        open = 1; hasfocus = 1;
      )
    );
    
    ( !left && !open ) ? hasfocus = 0;
    
    lastleft = left;
    
    change
  );
  
function sliderWidget(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in, two_values, minval_in, maxval_in, default_in, unit_in, isInteger_in )
  local()
  global()
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastright, lastclick, yslidercenter, cap, twoval, unit, isInteger)
  (
      x             = x_in+2;
      y             = y_in;
      w             = w_in-4;
      h             = h_in;
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      label         = label_in;
      lastleft      = 0;
      lastright     = 0;
      value         = 0;
      value2        = 0;
      yslidercenter = y + 0.3 * h;
      cap           = 0;
      twoval        = two_values;
      minval        = minval_in;
      maxval        = maxval_in;
      default       = ( default_in - minval ) / ( maxval - minval );
      lastclick     = 0;
      unit          = unit_in;
      isInteger     = isInteger_in;
  );
  
function sliderWidget_setValue(value_in)
  local()
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
  (
    value = ( value_in - minval ) / ( maxval - minval )
  );
  
function sliderWidget_getValue()
  local(v)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval, isInteger)
  (
    v = value * ( maxval - minval ) + minval;
    v = isInteger ? floor(v+0.499999) : v;
    v
  );  
  
function sliderWidget_draw()
  local(jnk, siz, q, str)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval, unit)
  (
    gfx_setfont(1, "Sans Serif", 12);
    gfx_set( r, g, b, .1 );
    gfx_rect( x-4, yslidercenter-.25*h, w+8, h*.5 );

    gfx_set( r, g, b, 0.8 );
    gfx_line(x, yslidercenter, x+w, yslidercenter);
    gfx_set( r*.3, g*.3, b*.3, 0.8 );
    gfx_line(x + 1, yslidercenter + 1, x+w + 1, yslidercenter + 1);

    gfx_set( r, g, b, 1.0 );    
    gfx_rect( x-2 + value*w, yslidercenter - .2*h, 4, h*.4 );
    gfx_set( r*.2, g*.2, b*.2, 0.4 );
    gfx_rect( x-1 + value*w, yslidercenter - .2*h + 1, 2, h*.4-2 );

    gfx_set( r, g, b, 0.4 );
    value2 > 0 ? gfx_rect( x + value*w, yslidercenter - .1*h, value2*w+1, h*.3 ) : gfx_rect( x + (value+value2)*w, yslidercenter - .1*h, abs(value2)*w, h*.3 );
    
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    gfx_x = x;
    gfx_y = y + 9;
    gfx_printf( label );
    
    sprintf( str, "%2.3g%s", this.sliderWidget_getValue(), unit );
    gfx_measurestr(str, siz, jnk);
    gfx_x = x + w - siz;
    gfx_y = y + 9;
    gfx_printf( str );
  );
  
function sliderWidget_setValue2(value_in)
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 = value_in;
   );
   
// Set value in a non-normalized manner
function sliderWidget_setValue2_nn(value_in)
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 = ( value_in > 0 ) ? value_in * (1.0 - value) : value_in * value;
   );   
  
function sliderWidget_getValue2()
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2
   ); 
   
function sliderWidget_getValue2_nn()
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 > 0 ? value2 / (1.0 - value) : value2 / value
   );    
  
function sliderWidget_processMouse(xx, yy, dx, dy, mc)
  local(left, right, change, newcap, onslider)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastright, lastclick, yslidercenter, cap, twoval)
  (
    left  = mc & 1;
    right = mc & 2;
    change = 0;
    newcap = 0;
    
    onslider = ( ( xx > x ) && ( xx < (x+w) ) && ( yy > (yslidercenter-.2*h) ) && ( yy < (yslidercenter+.2*h) ) );
    left ? (
      ( ( lastleft == 0 ) && ( time_precise() - lastclick ) < .2 ) ?
      (
        value       = default;
        change      = 1;
      ) : ( ( cap == 1 ) || ( onslider && lastleft == 0 ) ) ? ( 
        value       = (xx-x)/w;
        change      = 1;
        newcap      = 1;
        lastclick   = time_precise();
      );
    ) : ( 
      twoval ? (
        right ? (
          ( ( cap == 2 ) || (onslider && lastright == 0) ) ? ( 
            value2 = (xx-x)/w - value;
            change = 1;
            newcap = 2;
          );
        );
      );
    );
    
    lastleft  = left;
    lastright = right;
    cap       = newcap;
    value     = value > 1.0 ? 1 : value;
    value     = value < 0.0 ? 0 : value;
    twoval ? (
      value2 = (value2+value) > 1.0 ? 1.0-value : value2;
      value2 = (value2+value) < 0.0 ? -value : value2;    
    );
    
    change
  );

function gen_window(xp, yp, wp, hp, N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline)
  global(buttonOff.selectionButton)
  local(hy)
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    
    hy = 15;
    buttonOff.selectionButton(x+5, y+4, 55, 10, "OFF",  .3, .4, .8, .3);
    buttonArctan.selectionButton(x+5, y+4+hy, 55, 10, "Atan",  .3, .4, .8, .3);
    buttonFast.selectionButton(x+5, y+4+2*hy, 55, 10, "Fast",  .3, .4, .8, .3);
    buttonSpline.selectionButton(x+5, y+4+3*hy, 55, 10, "Spline", .3, .4, .8, .3);
    
    spline = spline.gen_spline(N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2);
  );
  
function gen_dynamics(xp, yp, wp, hp)
  instance(x, y, w, h, yref, sc, cap_mode, inLight, outLight, dynLight, lastleft)
  global(inLight.toggleLight)
  local()
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    cap_mode = 0; 
    lastleft = 0;
        
    inLight.toggleLight(x+w-15, y+5, 10, 10, "In", 1, 1, .3, .3, .3, 1);
    outLight.toggleLight(x+w-15, y+25, 10, 10, "Out", 1, .6, .3, 1, .9, 1);
    dynLight.toggleLight(x+w-15, y+45, 10, 10, "Dynamics", 1, .8, .8, .2, .3, 1);    
    
    sc = h;
  );

function processMouse(mx, my, dx, dy, mc)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline)
  global(slider56, buttonOff.selectionButton_processMouse, buttonOff.selectionButton_setActive)
  local()  
  (
    buttonOff.selectionButton_setActive(0);
    buttonArctan.selectionButton_setActive(0);
    buttonFast.selectionButton_setActive(0);
    buttonSpline.selectionButton_setActive(0);
    
    buttonOff.selectionButton_processMouse(mx, my, mc)    ? ( slider56 = 3; slider_automate(slider56); );
    buttonArctan.selectionButton_processMouse(mx, my, mc) ? ( slider56 = 1; slider_automate(slider56); );
    buttonFast.selectionButton_processMouse(mx, my, mc)   ? ( slider56 = 2; slider_automate(slider56); );
    buttonSpline.selectionButton_processMouse(mx, my, mc) ? ( slider56 = 0; slider_automate(slider56); );

    (slider56 == 0) ? ( buttonSpline.selectionButton_setActive(1);
      ) : ( slider56 == 1 ) ? ( buttonArctan.selectionButton_setActive(1);
      ) : ( slider56 == 2 ) ? ( buttonFast.selectionButton_setActive(1);
      ) : ( slider56 == 3 ) ? ( buttonOff.selectionButton_setActive(1);
    );
    
    spline.processMouse((mx-x)/w, (my-y)/h, dx/w, dy/h, mc);
  );

function sort_spline()
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.sort_spline();
  );

function update_spline()
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.update_spline();
  );


function rotatedPrint(x, y, str, rot)
local(sw,sh)
global(gfx_x, gfx_y, gfx_dest, gfx_mode)
(
  gfx_measurestr(str, sw, sh);
  gfx_dest = 1; 
  gfx_setimgdim(1, sw, sw);
  gfx_set( 0, 0, 0, 1 );
  gfx_rect(0, 0, sw, sw);
  gfx_x = 1;
  gfx_y = 1;
  gfx_set( .7, .7, .7, .7 );
  gfx_printf(str);
  gfx_dest = -1;
  gfx_mode = 1;
  gfx_x = x;
  gfx_y = y;
  gfx_blit(1, 1.0, rot);
  gfx_mode = 0;
);

function ylabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, gfx_dest, rotatedPrint)
  local(sw, sh)
  (
    gfx_measurestr(str, sw, sh);
    rotatedPrint(x-16, y+0.5*(h-sw), str, -.5*$pi); 
  );
  
function xlabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(sw, sh)
  (
    gfx_set( .7, .7, .7, 1.0 );
    gfx_measurestr(str, sw, sh);
    gfx_x = x + 0.5*(w-sw);
    gfx_y = y + h + 12;
    gfx_printf(str);
  );  

function draw_text(str, rx, ry)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local()
  (
    gfx_set( .7, .7, .7, 1.0 );
    gfx_x = x + w*rx;
    gfx_y = y + h*ry;
    gfx_printf(str);
  );

function draw_grid(N)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(dx, dy)
  (
    gfx_set( .3, .3, .6, .2 );
    dx = w/(N-1);
    dy = h/(N-1);    
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    gfx_x = x;
    gfx_y = y+h;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );
  
function draw_grid(N, dy)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(dx, dy)
  (
    gfx_set( .3, .3, .6, .2 );
    dx = w/(N-1);  
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    
    gfx_x = x;
    gfx_y = y+h;
    loop(min(100, floor(h/dy)),
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );  

function draw_back()
  instance(x, y, w, h, yref, sc)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local()
  (
    gfx_set( .2, .2, .3, .1 );
    gfx_rect(x, y, w, h);
  );

function draw_window(movAvgL, movAvgR, movAvgOL, movAvgOR)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, buttonOff.selectionButton_draw)
  (
    this.draw_back();
    this.draw_grid(10);
    spline.plot_spline(x, y, w, h);
    
    gfx_set( 0.6 + max(-.2,(movAvgL - 1)), .1, .1, 1.0);
    gfx_rect(x,y+h+2,w*min(1,movAvgL),2);
    gfx_rect(x,y+h+4,w*min(1,movAvgR),2);
    gfx_set( 0.2, .2, 0.9 + max(movAvgOL - 1, -.5), 1.0);
    movAvgOL = min(movAvgOL, 1);
    movAvgOR = min(movAvgOR, 1);
    gfx_rect(x-2,y+h-h*movAvgOL,2,h*movAvgOL);
    gfx_rect(x-4,y+h-h*movAvgOR,2,h*movAvgOR);
    
    buttonOff.selectionButton_draw();
    buttonArctan.selectionButton_draw();
    buttonFast.selectionButton_draw();
    buttonSpline.selectionButton_draw();
  );
  
function draw_buffer(scopeptr, scopebuffer, scopebuffermax, mul)
  instance(x, y, w, h, yref, sc, cap_mode)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(xx, dx, lptr, yy, lastx, lasty, scale, isc)
  (
    xx = x;
    dx = w/(scopebuffermax-scopebuffer);
    lptr = scopeptr;
    scale = (mul > 0) ? mul*h : sc;

    gfx_x = xx;
    gfx_y = yref;
    isc = h/scale;
    loop(scopebuffermax-scopeptr,
      yy = yref - scale*min(isc,lptr[]);
      gfx_lineto(xx, yy);
      lptr += 1;
      xx += dx;
    );
    
    lptr = scopebuffer;
    loop(scopeptr - scopebuffer,
      yy = yref - scale*min(isc,lptr[]);
      gfx_lineto(xx, yy);
      lptr += 1;
      xx += dx;
    );
  );  

function draw_dynamics(thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, inLight.toggleLight_draw)
  local()
  (
    yref = y+h;
    this.draw_grid(10, 10*sc/h);
    gfx_set( 0.9, 0.3, 0.3, 0.4 );
    gfx_x = x+2;
    gfx_y = yref-sc*thresh-10;
    gfx_printf( "Thresh" );
    gfx_line( x, yref - sc*thresh, x + w, yref -sc*thresh );
    ( highlight == 1 ) ? gfx_rect( x, yref - sc*thresh-1, w, 2 );
    
    inLight.toggleLight_draw();
    outLight.toggleLight_draw();
    dynLight.toggleLight_draw();
  );
  
function processMouseDynamics(xx, yy, dx, dy, mc, thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight, lastleft)
  local(left, right)
  global(forceUpdate, gfx_x, gfx_y,mouse_wheel, slider59, inLight.toggleLight_processMouse, outLight.toggleLight_processMouse, dynLight.toggleLight_processMouse)
  (
    left  = mc & 1;
    right = mc & 2;
    
    inLight.toggleLight_processMouse(xx, yy, mc);
    outLight.toggleLight_processMouse(xx, yy, mc);
    dynLight.toggleLight_processMouse(xx, yy, mc);    
    
    highlight = 0;
    ( mouse_wheel ~= 0 && xx > 0 && yy > 0 && xx < (x+w) && yy < (y+h) ) ?
    (
      sc += 10*mouse_wheel;
      mouse_wheel = 0;
      ( sc < 0 ) ? sc = 0.01;
    );
    
    ( left ) ?
    (
      ( cap_mode == 0 ) ? 
      (
        ( xx > x && yy > y && xx < (x+w) && yy < (y+h) && lastleft == 0 ) ?
        (
          ( yy > (yref - sc*thresh - 4) ) && ( yy < (yref - sc*thresh + 4) ) ?
          (
            cap_mode = 2;
          ) : (
            cap_mode = 1;
          );
        );
      ) : ( cap_mode == 1 ) ? (
        sc += 15 * dy;
       ( sc < 100 ) ? sc = 100;
       ( sc > 5000 ) ? sc = 5000;
      ) : (
        thresh += dy/h/(sc/h);
        ( thresh < 0 ) ? thresh = 0.01;
        slider59 = thresh;
        slider_automate(slider59);
        forceUpdate = 1;
      );
    ) : (
      cap_mode = 0;
      ( xx > 0 && yy > 0 && xx < (x+w) && yy < (y+h) ) ?
      (
        ( yy > (yref - sc*thresh-10) ) && ( yy < (yref - sc*thresh+10) ) ?
        (
          highlight = 1;
        );
      );
    );
    
    lastleft = left;
    thresh
  );  

function initRMS(N, loc_in)
  local()
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    sc      = 1.0/N;
    ptr     = loc_in;
    loc     = loc_in;
    loc_end = loc_in + N;
    
    loop(N,
     ptr[]  = 0;
     ptr   += 1; 
    );
    
    ptr = loc_in;
    movavg  = 0;
  );

function updateRMS(sr, sl)
  local( M )
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    M       = sc * max(sr*sr, sl*sl);
    
    movAvg -= ptr[];
    ptr[]   = M;
    movAvg += M;
    
    ptr    += 1;
    ptr > loc_end ? ptr = loc;
        
    movAvg
  );

function getBuffer()
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[];
  );

function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );
  
function updateIntegrationTime()
  (
    ( (lastIntegrationTime != slider64) || (slider35 != lookAhead) ) ? 
    (
      lastIntegrationTime = slider64;      
      lookAhead           = slider35;
    
      ndelay = ceil(srate*lastIntegrationTime/1000);
      RMS1.initRMS(ndelay, 100000);
      RMS2.initRMS(ndelay, 200000);

      ndelay = ceil(ndelay * 0.5);
      preBufferL.initBuffer(300000, 300000 + ndelay);
      preBufferR.initBuffer(400000, 400000 + ndelay);
      
      lookAhead ? (
        // delays the first two channels (spl0/spl1).
        pdc_bot_ch=0; 
        pdc_top_ch=2;
        pdc_delay = ndelay;
      ) : ( 
        pdc_delay = 0;
      );
    );
  );
  
updateIntegrationTime();

delay_buf1      = 500000;
delay_buf2      = 600000;

// Global storage for variables
negative_xloc   = 100;
negative_yloc   = 200;
positive_xloc   = 300;
positive_yloc   = 400;
negative_xloc2  = 500;
negative_yloc2  = 600;
positive_xloc2  = 700;
positive_yloc2  = 800;
temp_xloc       = 900;
temp_yloc       = 1000;
pos_c1s         = 1100;
pos_c2s         = 1200;
pos_c3s         = 1300;
neg_c1s         = 1400;
neg_c2s         = 1500;
neg_c3s         = 1600;
pos_c1s2        = 1700;
pos_c2s2        = 1800;
pos_c3s2        = 1900;
neg_c1s2        = 2000;
neg_c2s2        = 2100;
neg_c3s2        = 2200;
temp_indices    = 2300;
pos_indices     = 2400;
neg_indices     = 2500;
vowel_A         = 2600;
vowel_E         = 2650;
vowel_I         = 2700;
vowel_O         = 2750;
vowel_U         = 2800;
Nbuf            = 20000;
inVol.initBuffer(20000, 20000+Nbuf-1);
outVol.initBuffer(20000+Nbuf, 20000+2*Nbuf-1);
dynBuf.initBuffer(20000+Nbuf*2, 20000+3*Nbuf-1);

filter_delay1.initBuffer(delay_buf1, delay_buf1 + filterFreq * 1000);
filter_delay2.initBuffer(delay_buf2, delay_buf2 + filterReso * 2000);

dynval = 0;

// Initialize object instances
wndX = 250;
wndY = 250;
wndPad = 30;
window1.gen_window(wndPad, wndPad, wndX, wndY, 10, 1, negative_xloc, negative_yloc, negative_xloc2, negative_yloc2, pos_indices, temp_xloc, temp_yloc, temp_indices, neg_c1s, neg_c2s, neg_c3s, neg_c1s2, neg_c2s2, neg_c3s2);
window2.gen_window(2*wndPad+wndX, wndPad, wndX, wndY, 10, 2, positive_xloc, positive_yloc, positive_xloc2, positive_yloc2, neg_indices, temp_xloc, temp_yloc, temp_indices, pos_c1s, pos_c2s, pos_c3s, pos_c1s2, pos_c2s2, pos_c3s2);
window3.gen_dynamics(3*wndPad+2*wndX, wndPad, wndX, wndY );

wR = wG = wA = 0.7; wB = 0.9;
masterPanelX = 4*wndPad+3*wndX;
masterPanelY = 30 + 5;
sliderWidth = 150;
sliderHeight= 20;
sliderPad   = 5;
masterPanel.groupWidget(masterPanelX, masterPanelY, sliderWidth, sliderHeight*3+5*sliderPad, "MASTER", wR, wG, wB, wA );
inGain.sliderWidget(masterPanelX+sliderPad, masterPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, "Pre-Gain / Drive", wR, wG, wB, wA, 1, -40, 40, 0, " dB", 0);
outGain.sliderWidget(masterPanelX+sliderPad, masterPanelY+2*sliderPad+sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Post-Gain", wR, wG, wB, wA, 0, -40, 40, 0, " dB", 0);
overSampling.sliderWidget(masterPanelX+sliderPad, masterPanelY+3*sliderPad+2*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Oversampling", wR, wG, wB, wA, 0, 0, 8, 0, "x", 1);

filterPanelX = masterPanelX;
filterPanelY = 140;
filterPanel.groupWidget(filterPanelX, filterPanelY, sliderWidth, sliderHeight*4+6*sliderPad, "FILTER", wR, wG, wB, wA );
filterSelect.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nFilters, 0, 0 );
modeSelect.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad*2+sliderHeight, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nModes, 1, 0 );
cutoffSlider.sliderWidget(filterPanelX+sliderPad, filterPanelY+4*sliderPad+2*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Cutoff", wR, wG, wB, wA, 1, 0, 1, 0, "", 0);
resonanceSlider.sliderWidget(filterPanelX+sliderPad, filterPanelY+5*sliderPad+3*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Resonance", wR, wG, wB, wA, 1, 0, 1, 0, "", 0);

dynamicsPanelX = masterPanelX;
dynamicsPanelY = 270;
buttonHeight = 12;
dynamicsPanel.groupWidget(dynamicsPanelX, dynamicsPanelY, sliderWidth, buttonHeight+sliderHeight*4+7*sliderPad, "DYNAMICS", wR, wG, wB, wA );

dynamicFilterButton.selectionButton(dynamicsPanelX+sliderPad, dynamicsPanelY+sliderPad+1, 40, buttonHeight, "Filter",  .3, .4, .8, .3);
dynamicWaveShapingButton.selectionButton(dynamicsPanelX+sliderPad+45, dynamicsPanelY+sliderPad+1, 40, buttonHeight, "Shaper",  .3, .4, .8, .3);
lookaheadButton.selectionButton(dynamicsPanelX+sliderPad+90, dynamicsPanelY+sliderPad+1, 50, buttonHeight, "LookAhead",  .3, .4, .8, .3);
threshSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+3*sliderPad+buttonHeight, sliderWidth-2*sliderPad, sliderHeight, "Threshold", wR, wG, wB, wA, 1, 0, 1, 0, " V", 0);
attackSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, sliderWidth-2*sliderPad, sliderHeight, "Attack", wR, wG, wB, wA, 1, 0, 50, 0, "", 0);
decaySlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, sliderWidth-2*sliderPad, sliderHeight, "Decay", wR, wG, wB, wA, 1, 0, 50, 0, "", 0);
rmsSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, sliderWidth-2*sliderPad, sliderHeight, "RMS time", wR, wG, wB, wA, 1, 0.02, 40, 0, "", 0);

lfoPanelX = masterPanelX;
lfoPanelY = 415;
buttonHeight = 12;
lfoPanel.groupWidget(lfoPanelX, lfoPanelY, sliderWidth, buttonHeight+sliderHeight*2+2*sliderPad, "LFO", wR, wG, wB, wA );

lfoSelect.combobox(lfoPanelX+sliderPad, lfoPanelY+sliderPad, .7*sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nLFO, 2, 1 );
lfoResetButton.selectionButton(lfoPanelX+sliderPad+.7*sliderWidth, lfoPanelY+sliderPad, 35, sliderHeight, "MIDI",  .3, .4, .8, .3);
lfoFrequency.sliderWidget(lfoPanelX+sliderPad, lfoPanelY+3*sliderPad+sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Rate", wR, wG, wB, wA, 1, 0, 1, 0, "", 0);

filter_vowel.bootvowel();

n_pos = 8;
n_neg = 8;

function updateSliders()
(
  calcGain();
  modulator.setModRate( (1+2*slider37)^4 - 1 );

  overSampling.sliderWidget_setValue(slider54);
  inGain.sliderWidget_setValue(slider52);
  inGain.sliderWidget_setValue2_nn(slider51);
  outGain.sliderWidget_setValue(slider53);
  cutoffSlider.sliderWidget_setValue(slider48);
  resonanceSlider.sliderWidget_setValue(slider49); 
  cutoffSlider.sliderWidget_setValue2_nn(slider62);
  resonanceSlider.sliderWidget_setValue2_nn(slider63);
  filterSelect.combobox_setcuritem(slider47);
  modeSelect.combobox_setcuritem(slider46);
  lfoSelect.combobox_setcuritem(slider36);

  threshSlider.sliderWidget_setValue(slider59);
  attackSlider.sliderWidget_setValue(slider60);
  decaySlider.sliderWidget_setValue(slider61);
  rmsSlider.sliderWidget_setValue(slider64);
  lookAheadButton.active = slider35==1 ? 1 : 0;

  lfoFrequency.sliderWidget_setValue(slider37);
  lfoResetButton.active = slider38==1 ? 1 : 0;

  dynamics = slider58;
  dynamicsEnabled = dynamics > 0;
  ( dynamicsEnabled ) ?
  (
    dyn_thresh    = slider59;
    dyn_atk       = 1 / ( slider60 * srate / 100 + 0.0001 );
    dyn_decay     = 1 / ( log(2) * slider61 * srate / 100 + 0.0001 );
    dyn_mod_filt  = cutoffSlider.sliderWidget_getValue2();
    dyn_mod_reso  = resonanceSlider.sliderWidget_getValue2();
    dyn_mod_gain  = inGain.sliderWidget_getValue2();
  );
  
  ( ( dynamics == 1 ) || ( dynamics == 3 ) ) ? ( filterDynamics = 1; ) : ( filterDynamics = 0; );
  ( ( dynamics == 2 ) || ( dynamics == 3 ) ) ? ( distortionDynamics = 1; ) : ( distortionDynamics = 0; );
  dynamicFilterButton.active = filterDynamics;
  dynamicWaveShapingButton.active = distortionDynamics;  

  setter = window2.spline.xloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider3; setter += 1;
  setter[] = slider5; setter += 1;
  setter[] = slider7; setter += 1;
  setter[] = slider9; setter += 1;
  setter[] = slider11; setter += 1;
  setter[] = slider13; setter += 1;
  setter[] = slider15; setter += 1;
  setter[] = slider17; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window2.spline.yloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider4; setter += 1;
  setter[] = slider6; setter += 1;
  setter[] = slider8; setter += 1;
  setter[] = slider10; setter += 1;
  setter[] = slider12; setter += 1;
  setter[] = slider14; setter += 1;
  setter[] = slider16; setter += 1;
  setter[] = slider18; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window1.spline.xloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider19; setter += 1;
  setter[] = slider21; setter += 1;
  setter[] = slider23; setter += 1;
  setter[] = slider25; setter += 1;
  setter[] = slider27; setter += 1;
  setter[] = slider29; setter += 1;
  setter[] = slider31; setter += 1;
  setter[] = slider33; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window1.spline.yloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider20; setter += 1;
  setter[] = slider22; setter += 1;
  setter[] = slider24; setter += 1;
  setter[] = slider26; setter += 1;
  setter[] = slider28; setter += 1;
  setter[] = slider30; setter += 1;
  setter[] = slider32; setter += 1;
  setter[] = slider34; setter += 1;  
  setter[] = 1; setter += 1;
  
  window1.setN(slider1);
  window2.setN(slider2);
  window1.spline.xloc_write[slider1-1] = 1;
  window2.spline.xloc_write[slider2-1] = 1;
  
  window1.sort_spline();
  window2.sort_spline();
  window1.update_spline();
  window2.update_spline();
  
  filterL.updateFilter(slider54);
  filterR.updateFilter(slider54);
  
  updateIntegrationTime();
);

function distort(s)
  global(window1.evalDistAudio, window2.evalDistAudio, rc_filter.evalRC2)
  local(os)
  global(slider56, dynval, distortionDynamics)
  ( 
    ( slider56 == 0 ) ? (
      os = s; 
      s = max(min(s,1),-1);
      s = ( s > 0 ) ? s = window1.evalDistAudio(s) : ( s = -window2.evalDistAudio(-s); );
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 1 ) ? ( 
      os = s;
      s = tanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 2 ) ? (
      os = s;
      s = fasttanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    );

    s
  );
  
function distortderiv(s)
  global(window1.evalDiff, window2.evalDiff, rc_filter.evalRC2)
  local(th)
  global(slider56, dynval)
  (
    ( slider56 == 0 ) ? (
      s = ( s > 0 ) ? s = window1.evalDiff(s) : ( s = -window2.evalDiff(-s); );
    ) : ( slider56 == 1 ) ? (
      th = tanh(s);
      s = 1.0 - th*th;
    ) : ( slider56 == 2 ) ? (
      th = fasttanh(s);
      s = 1.0 - th*th;
    );
    (1.0-dynval) + dynval * s
  );  

//---------------------------
// Filter usage section
//--------------------------- 

function evalRC(input)
  instance(len, v0, v1, a1, c)
  local(output, tmp)
  global(srate)
  (
    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    tmp = v1;

    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    output = (tmp+v1)*0.5;
  );

function eval303(input)
  local(y0, s0, s)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4
            b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  global(distort)
  (
    s = (z0*wc3 + z1*a20 + z2*c2 + z3*c3);
    y4 = (g*input + s)/(1 + g*k);
    
    y0 = distort(input - k*y4);
    y1 = b * ( y0*b0 + z0*a0 + z1*a1 + z2*a2 + z3*a3 );
    y2 = b * (y0*b10 + z0*a10 + z1*a11 + z2*a12 + z3*a13);
    y3 = b * (y0*b20 + z0*a20 + z1*a21 + z2*a22 + z3*a23);
    y4 = g*y0 + s;
    
    z0 += 4*wc*(y0 - y1 + y2);
    z1 += 2*wc*(y1 - 2*y2 + y3);
    z2 += 2*wc*(y2 - 2*y3 + y4);
    z3 += 2*wc*(y3 - 2*y4);
  );

function evalmoog(input)
  local(x)
  global()
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    // Process input
    x = input - r*y4;
    
    // Four cascaded onepole filters (bilinear transform)
    y1= x*p +  oldx*p - k*y1;
    y2=y1*p + oldy1*p - k*y2;
    y3=y2*p + oldy2*p - k*y3;
    y4=y3*p + oldy3*p - k*y4;
    
    // Clipper band limited sigmoid
    y4-=(y4*y4*y4)/6.;
    //y4 -= distort(y4);
    oldx = x; oldy1 = y1; oldy2 = y2; oldy3 = y3;
    
    y4;
  );

  //filter_karlsen
function evalkarlsen(b_v)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  ( 
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    b_v     = distort(b_v);
    b_v     = min(max(b_v, 0),1);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = b_aflt4;
  );
 
  //filter_karlsen
function evalkarlsen_sat(b_v)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    // for nice low sat, or sharper type low deemphasis saturation, one can use a onepole shelf before the filter.
    b_lfcut = .001;
    b_lf    = b_lf + ((-b_lf + b_v) * b_lfcut); // b_lfcut 0..1
    b_lfhp  = b_v - b_lf;
    b_v     = b_lf + (b_lf1hp * ((b_lfgain*0.5)+1)); 
  
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    b_v     = distort(b_v);
    b_v     = min(max(b_v, 0),1);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = 4*b_aflt4;
  );
  
function evaldualfilt(sample)
  local(out)
  global(distort)
  instance(fb, f, d0, d1)
  (
    d0  = d0 + f * (sample - d0 + fb * .5*(distort(d0 - d1) + (d0-d1) + 0.15 * out ) );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(d1)*0.9 + d1*0.1;
  );
  
function evaldualfiltHP(sample)
  local(out, hp, bp)
  global(distort)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    d0  = d0 + f * ( hp + fb * .5*(distort(d0 - d1) + (d0-d1) + 0.15 * out ) );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(hp)*0.9 + hp*0.51;
  );
  
function evaldualfiltBP(sample)
  local(out, hp, bp)
  global(distor)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    d0  = d0 + f * ( hp + fb * (.6*distort(d0 - d1) + .4*(d0-d1) + 0.15 * out ) );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(bp)*.7 + bp*0.3 + 0.05*hp + 0.05*d1;
  );
  
function evalfancymoog(y0)
  local(S0, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3                    
        )
  global(distort, distortderivt, tanh)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, S1)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      WS0 = distort(S0);
      gJ0 = g*distortderiv(S0);

      WS1 = distort(S1);
      gJ1 = g*distortderiv(S1);
      
      WS2 = distort(S2);
      gJ2 = g*distortderiv(S2);
      
      WS3 = distort(S3);
      gJ3 = g*distortderiv(S3);
      
      WS4 = distort(S4);
      gJ4 = g*distortderiv(S4);      
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );

      // Jacobian subexpressions
      t2 = gJ2*gJ3;
      t3 = gJ2*gJ4;
      t4 = gJ3*gJ4;
      t5 = gJ2*gJ3*gJ4;
      t6 = gJ1*gJ2;
      t7 = gJ1*gJ3;
      t8 = gJ1*gJ4;
      t9 = gJ1*gJ2*gJ3;
      t10 = gJ1*gJ2*gJ4;
      t11 = gJ1*gJ3*gJ4;
      t12 = gJ1*gJ2*gJ3*gJ4;
      t13 = gJ0*gJ1*gJ2*gJ3*k;
      t14 = gJ1+gJ2+gJ3+gJ4+t2+t3+t4+t5+t6+t7+t8+t9+t10+t11+t12+t13+1.0;
      t15 = 1.0/t14;
      t16 = gJ2+1.0;
      t17 = gJ3+1.0;
      t18 = gJ1+1.0;
      
      // Jacobian
      A0_0_0 = t15*(gJ2+gJ3+gJ4+t2+t3+t4+t5+1.0);
      A0_0_1 = -gJ0*gJ2*gJ3*k*t15;
      A0_0_2 = -gJ0*gJ3*k*t15*t16;
      A0_0_3 = -gJ0*k*t15*t16*t17;
      A0_1_0 = t15*(gJ1+t7+t8+t11);
      A0_1_1 = t15*(gJ1+gJ3+gJ4+t4+t7+t8+t11+1.0);
      A0_1_2 = -gJ0*gJ1*gJ3*k*t15;
      A0_1_3 = -gJ0*gJ1*k*t15*t17;
      A0_2_0 = t15*(t6+t10);
      A0_2_1 = t15*(gJ2+t3+t6+t10);
      A0_2_2 = t15*(gJ1+gJ2+gJ4+t3+t6+t8+t10+1.0);
      A0_2_3 = -gJ0*gJ1*gJ2*k*t15;
      A0_3_0 = gJ1*gJ2*gJ3*t15;
      A0_3_1 = gJ2*gJ3*t15*t18;
      A0_3_2 = gJ3*t15*t16*t18;
      A0_3_3 = t15*t16*t17*t18;
      
      // Newton Raphson update
      y1 = y1 - ( A0_0_0 * F1 + A0_1_0 * F2 + A0_2_0 * F3 + A0_3_0 * F4 );
      y2 = y2 - ( A0_0_1 * F1 + A0_1_1 * F2 + A0_2_1 * F3 + A0_3_1 * F4 );
      y3 = y3 - ( A0_0_2 * F1 + A0_1_2 * F2 + A0_2_2 * F3 + A0_3_2 * F4 );
      y4 = y4 - ( A0_0_3 * F1 + A0_1_3 * F2 + A0_2_3 * F3 + A0_3_3 * F4 );
      //y1 = y1 - ( A0_0_0 * F1 + A0_0_1 * F2 + A0_0_2 * F3 + A0_0_3 * F4 );
      //y2 = y2 - ( A0_1_0 * F1 + A0_1_1 * F2 + A0_1_2 * F3 + A0_1_3 * F4 );
      //y3 = y3 - ( A0_2_0 * F1 + A0_2_1 * F2 + A0_2_2 * F3 + A0_2_3 * F4 );
      //y4 = y4 - ( A0_3_0 * F1 + A0_3_1 * F2 + A0_3_2 * F3 + A0_3_3 * F4 );
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalfancymoog_noJac(y0)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4)
  global(distort, distortderiv)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      WS0 = distort(S0);
      WS1 = distort(S1);
      WS2 = distort(S2);
      WS3 = distort(S3);
      WS4 = distort(S4);
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );
     
      // Newton Raphson update (assuming derivatives 0)
      y1 = y1 - F1;
      y2 = y2 - F1 - F2;
      y3 = y3 - F3;
      y4 = y4 - F4;
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalvowel(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;
    
    d2yC = d1yC;
    d1yC = outC;
    
    out  = amp1 * outA + amp2 * outB + amp3 * outC;
  );
  
function evalsai0(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    sample = distort(sample);
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;

    d2yC = d1yC;
    d1yC = outC - .01 * ( outA - outB );
    
    out  = outA-.6*distort(outC-outB);
    out = 0.4*out;
  );  
  
function evalmodulator(sample)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp, d2x2, d1x2
   )
  local(out, dS, outA, outB, modo)
  global()
  (
    // Modulator LP
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB; 
    d2yB = d1yB;
    d1yB = outB;
    d2x = d1x;
    d1x = sample;
    
    modo = sample * outB;
    outA = Ab0 * modo + Ab1 * d1x2 + Ab2 * d2x2 - Aa1 * d1yA - Aa2 * d2yA;    
    d2yA = d1yA;
    d1yA = outA;    
    d2x2 = d1x2;
    d1x2 = modo;
    
    out  = distort(outB * distort(sample+amp*outA)*2);
  );    
  
function evalrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local(out)
  global()
  (
    out = b0 * sample + b1 * d1x + b2 * d2x - a1 * d1y - a2 * d2y;
    
    d2x = d1x;
    d1x = sample;
    
    d2y = d1y;
    d1y = out;
    out;
  );

function evalphaserOTA(sample, jnk)
  global(distort)
  local(w)
  instance(C1, C2, dw, dx, sq)
  (
    sample = sample - sq * jnk;
    w = dw + C1 * distort( C2 * ( sample + dx + dw ) );
    dx = sample;
    dw = w;
    
    w + sample
  );
    
function evalphaserFET(sample)
  global(distort)
  local(w, u, I_ds, out)
  instance(C1, C2, dw, dx, IDSSdivVpSq, thresh)
  (
    u = sample - dw;
    
    I_ds = ( u < thresh ) ? (
      IDSSdivVpSq * 2 * thresh * u - u*u;
    ):(
      IDSSdivVpSq * thresh * thresh * u;
    );
    
    w = dw + C1 * ( C2 * u + I_ds );
    
    out = sample - w - dw;
    dw = w;
    
    out
  );

// One-pole zero-delay LP filter
function zdf(G, x)
  global()
  local()
  instance(tpt, y)
  (
    y = G*x + tpt.s;
    tpt.TPT_step(G, x-y);
  );

function eval_MS20lin(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    x = distort(x);
  
    y  = a0 * x + a1 * s1 + a2 * s2;
    ky = k*y;
    onepole1.zdf(g, x - ky);
    onepole2.zdf(g, onepole1.y + ky);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20linBP(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    x = distort(x);
  
    y  = -a0 * x + a1 * (s1 + x) + a2 * s2;
    ky = k*y;
    onepole1.zdf(g, -x - ky);
    onepole2.zdf(g, onepole1.y + ky + x);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20linHP(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    x = distort(x);
  
    y  = a1 * (s1 - x) + x + s2;
    ky = k*y;
    onepole1.zdf(g, - ky);
    onepole2.zdf(g, onepole1.y + ky - x);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );    
  
function eval_MS20(x)
  global(slider54)
  local(ky, y, fy, fyprime, distky, ddistky)
  instance(s1, s2, G, Gsq, Gsqk, Gk, k, onepole1, onepole2)
  (
    //fyprime = 1.0 - d/dy(Gsq*x*k*distort(y)) - d/dy(G*k*distort(y));
    //x = distort(x);

    loop(3,
      ky = k*y;
      distky = distort(ky);
      ddistky = distortderiv(ky);
      fy = y - Gsq*x + Gsq*distky - G * S1 - G*distky - S2;
      fyprime = 1.0 + Gsq*ddistky - G*ddistky;
      y = y - fy/fyprime;
    );
    
    //y = (Gsq*x + G*S1 + S2)/(1+Gsqk-Gk);
    
    ky = k*y;
    onepole1.zdf(g, x - distky);
    onepole2.zdf(g, onepole1.y + distky);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20_nonlin(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2;
      dgky2   = k - k * min( abs(gky2), 1 );
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2) 
  );
  
function eval_MS20_nonlinBP(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
     
    atanterm1 = atan(d1 +  x + gkd2);
    atanterm2 = atan(d1 - d2 + x + gkd2);
    hk    = h * k;
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2;
      dgky2   = k - k * min( abs(gky2), 1 );
      
      gky2    = max(-1,min(1,gky2));
      
      sig1    = y1 + x + gky2;
      sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig1));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig2));
           
      sfunsq  = sig1*sig1;
      sub3    = (2*(sfunsq + 1));
      sub3i   = 1/sub3;
      
      sub4sq  = sig2*sig2;
      sub5    = 1 / (2*(sub4sq + 1));
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1 - (hk*dgky2 - h)*sub5;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2)
  );  
  
function eval_MS20_nonlinHP(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2px, gky2px, dgky2px, sub1sq, sub1i sub4sq, sub4i, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2px  = k*(d2 + x);    // g(k*(d2 + x))
    gkd2px  = max(-1,min(1,gkd2px));
    hk      = h * k;
    
    atanterm1 = atan(d1 + gkd2px);
    atanterm2 = atan(d1 - d2 - x + gkd2px);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      
      gky2px  = k*(x + y2);   // g(k*(x + y2))

      // Clipper (g(y))
      gky2px  = max(-1,min(1,gky2px));
      
      // Derivative
      dgky2px = k - k * min( abs(gky2px), 1 );
      
      sig1    = y1 + gky2px;
      sig2    = x + y2 - sig1;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig1));
      f2      = y2 - d2 - hh*(atanterm2 - atan(sig2));
      
      sub1sq  = sig1*sig1;
      sub1i   = 1/(2*(sub1sq + 1));
      sub4sq  = sig2*sig2;
      sub4i   = 1/(2*(sub4sq + 1));
      
      a       = h*sub1i + 1;
      b       = hk*dgky2px*sub1i;
      c       = -h*sub4i;
      d       = 1 - (hk*dgky2px - h)*sub4i;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2+x)
  );    
  
function bufferFun(sample, delay1, delay2)
  global(distort)
  local(h)
  instance()
  (
    h = 5;
  );

  //global(window1.evalDist, window2.evalDist, filter_303.eval303)
function process(sample)
  (
    ( slider47 == 0 ) ? (
      sample = distort(sample);
    ) : ( slider47 == 1 ) ? (
      sample = this.rc_filter.evalRC(sample);
      sample = distort(sample);
    ) : ( slider47 == 2 ) ? (
      sample = this.filter_303.eval303(sample);
    ) : ( slider47 == 3 ) ? (
      sample = distort(sample);
      sample = this.filter_vowel.evalvowel(sample);
    ) : ( slider47 == 4 ) ? (
      sample = this.filter_karlsen.evalkarlsen(sample);
    ) : ( slider47 == 5 ) ? (
      sample = this.filter_karlsen_sat.evalkarlsen_sat(sample);
    ) : ( slider47 == 6 ) ? (
      sample = this.filter_dualfilt.evaldualfilt(sample);
    ) : ( slider47 == 7 ) ? (
      sample = this.filter_dualfiltHP.evaldualfiltHP(sample);
    ) : ( slider47 == 8 ) ? (
      sample = this.filter_dualfiltBP.evaldualfiltBP(sample);
    ) : ( slider47 == 9 ) ? (
      sample = gaincompensation * this.filter_fancymoog.evalfancymoog(40*sample)/40;
    ) : ( slider47 == 10 ) ? (
      sample = gaincompensation * this.filter_fancymoog.evalfancymoog_noJac(40*sample)/40;
    ) : ( slider47 == 11 ) ? (
      sample = this.filter_notch.evalrbj(sample);
      sample = distort(sample);
    ) : ( slider47 == 12 ) ? (
      sample = this.filter_sai0.evalsai0(sample);
    ) : ( slider47 == 13 ) ? (
      sample = this.filter_modulator.evalmodulator(sample);
    ) : ( slider47 == 14 ) ? (
      os = sample;
      sample = this.filter_phaser.evalphaserOTA(sample, jnk);
      sample = this.filter_phaser2.evalphaserOTA(sample, 0);
      sample = this.filter_phaser3.evalphaserOTA(sample, 0);
      sample = this.filter_phaser4.evalphaserOTA(sample, 0);
      jnk = sample;
      sample = distort((os + sample)*.5);
    ) : ( slider47 == 15 ) ? (
      os = sample;
      sample = this.filter_phaser.evalphaserFET(sample);
      sample = this.filter_phaser2.evalphaserFET(sample);
      sample = this.filter_phaser3.evalphaserFET(sample);
      sample = this.filter_phaser4.evalphaserFET(sample);
      sample = distort((os + sample)*.5);
    ) : ( slider47 == 16 ) ? (
      os1 = filter_delay1.getBuffer();
      os2 = filter_delay2.getBuffer();
      ys1 = sample - .2 * distort(os1-os2);
      filter_delay1.updateBuffer(sample);
      filter_delay2.updateBuffer(ys1-sample);
      sample = ys1 + os2;
    ) : ( slider47 == 17 ) ? (
      os1 = filter_delay1.getBuffer();
      os2 = filter_delay2.getBuffer();
      os3 = 0.001 * abs(sample) + 0.999 * abs(os3);
      filter_delay1.updateBuffer(sample);
      filter_delay2.updateBuffer(sample);
      sample = tanh(5*os3*sample + distort(sample-os1));
    ) : ( slider47 == 18 ) ? (
      sample = this.filter_ms20lin.eval_MS20lin(sample);
    ) : ( slider47 == 19 ) ? (
      sample = this.filter_ms20lin.eval_MS20linBP(sample);
    ) : ( slider47 == 20 ) ? (
      sample = this.filter_ms20lin.eval_MS20linHP(sample);            
    ) : ( slider47 == 21 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlin(sample);
    ) : ( slider47 == 22 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinBP(sample);
    ) : ( slider47 == 23 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinHP(sample);      
    );
    
    sample;
  );

gfx_ext_retina  = 1.0;
ext_nodenorm    = 1; 
gfx_clear       = -1;
updateSliders();

@slider
updateSliders();
updateActiveFilters();

@block
  ( forceUpdate==1 ) ? (
    forceUpdate = 0;
    updateSliders();
    updateActiveFilters();
  );
  
  while (midirecv(offset,msg1,msg2,msg3)) (
     msg1==$x90 && msg3!=0 ? modulator.reset=1; // note-on!
     midisend(offset,msg1,msg2,msg3); // passthrough MIDI events
  );
  
@sample
  sl      = spl0 * pregain;
  sr      = spl1 * pregain;
  alpha   = 0.9999;
  
  modulator.updateModulator();
  
  // Dynamics
  inV = inVol.updateBuffer( RMS1.updateRMS(sl, sr) );
  ( dynamicsEnabled ) ?
  (
    ( inV > dyn_thresh ) ? (
      dynval = dynval + dyn_atk;
      dynval = min(1, dynval);
    ) : (
      dynval = dynval - dyn_decay * dynval;
    );
    dynBuf.updateBuffer(dynval);
  ) : ( dynval = 1 );
  
  filterDynamics ? updateActiveFilters();
  
  ( lookAhead ) ?
  (
    oldl = preBufferL.getBuffer();
    oldr = preBufferR.getBuffer();
    preBufferL.updateBuffer( sl );
    preBufferR.updateBuffer( sr );
    sl = oldl;
    sr = oldr; 
  );
  
  movavgLN = max(alpha*movavgLN, -sl);
  movavgLP = max(alpha*movavgLP,  sl);
  movavgRN = max(alpha*movavgRN, -sr);
  movavgRP = max(alpha*movavgRP,  sr);
  
  ( slider54 == 0 ) ? (
    // Without oversampling
    sl = L.process(sl);
    sr = R.process(sr);
//  ) : ( slider54 == 1 ) ? (
//    // With oversampling
//    os.os_up2(sl); 
//    os.y1 = process(os.y1);
//    os.y0 = process(os.y0);    
//    sl = os.os_down2();
//    os.os_up2(sr);  
//    os.y1 = process(os.y1);
//    os.y0 = process(os.y0);
//    sr = os.os_down2();
  ) : ( 
    q = 0;
    // N>1 oversampling
    sli = sl;
    sri = sr;
    loop( slider54,
      ssl = filterL.inputFilter(sli);
      ssr = filterR.inputFilter(sri);
      
      ( slider46 == 0 ) ?
      (
        ssl = L.process(ssl);
        ssr = R.process(ssr);
      ) : ( slider46 == 1 ) ?
      (
        ssl = L.process(ssl);
        ssr = L.process(ssr);
      ) : ( slider46 == 2 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side);
        side = L.process(side);
        mid  = R.process(mid);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 3 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side);
        mid  = R.process(mid);
        mid  = R.process(mid);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 4 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side);
        mid  = mid;
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 5 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        mid  = R.process(mid);
        side = side;
        ssl  = mid + side;
        ssr  = mid - side;
      );
      
      (q += 1)==1 ? (
        sl = filterL.outputFilter(ssl);
        sr = filterR.outputFilter(ssr);
      ) : (
        filterL.outputFilter(ssl);
        filterR.outputFilter(ssr);
      )
    )
  );
  
  // DC correction
  (
    otm1=0.999*otm1 + sl - itm1;
    itm1=sl;
    sl=otm1;
    otm2=0.999*otm2 + sr - itm2;
    itm2=sr;
    sr=otm2;
  );
  
  movavgOLN = max(alpha*movavgOLN, -sl);
  movavgOLP = max(alpha*movavgOLP,  sl);
  movavgORN = max(alpha*movavgORN, -sr);
  movavgORP = max(alpha*movavgORP,  sr);
  
  spl0 = sl * postgain;
  spl1 = sr * postgain;

  // Scope
  outVol.updateBuffer( RMS2.updateRMS(spl0, spl1) );

@gfx 600 600

gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

  //function draw_button(xp, yp, str) 
  //  instance(w,h,x,y) 
  //  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,bgcolor) 
  
  gfx_clear=-1;
  
  // Clear screen first
  gfx_r=gfx_g=gfx_b=0; gfx_a=.6;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w,gfx_h);

  window3.draw_back();
  window3.draw_dynamics(dyn_thresh);
  window3.inLight.active ? (
    gfx_set( 1, .3, .3, .3 );
    window3.draw_buffer(inVol.scopeptr, inVol.scopebuffer, inVol.scopebuffermax, 0);
  );
  window3.outLight.active ? (
    gfx_set( .6, .3, 1, .9 );
    window3.draw_buffer(outVol.scopeptr, outVol.scopebuffer, outVol.scopebuffermax, 0);  
  );
  window3.dynLight.active ? (
    dynamicsEnabled ? (
      gfx_set( .8, .8, .2, .3 );  
      window3.draw_buffer(dynBuf.scopeptr, dynBuf.scopebuffer, dynBuf.scopebuffermax, 1); 
    );
  );
  
  gfx_setfont(0);
  window3.draw_text("Dynamics", .025, .025);
  window3.ylabel("RMS / Level");
  window3.xlabel("Time");
  window1.draw_window(movAvgLN, movAvgRN, movavgOLN, movavgORN);
  window2.draw_window(movAvgLP, movAvgRP, movavgOLP, movavgORP);
//  window1.draw_text("Negative", .025, .025);
  window1.ylabel("Out Voltage (-)");
  window1.xlabel("In Voltage (-)");
//  window2.draw_text("Positive", .025, .025);
  window2.ylabel("Out Voltage (+)");
  window2.xlabel("In Voltage (+)");

  masterPanel.groupWidget_draw();
  filterPanel.groupWidget_draw();
  dynamicsPanel.groupWidget_draw();
  lfoPanel.groupWidget_draw();

  inGain.sliderWidget_draw();
  outGain.sliderWidget_draw();
  overSampling.sliderWidget_draw();
  
  lfoFrequency.sliderWidget_draw();
  
  dynamicFilterButton.selectionButton_draw();
  dynamicWaveShapingButton.selectionButton_draw();
  lookaheadButton.selectionButton_draw();
  lfoResetButton.selectionButton_draw();
  
  threshSlider.sliderWidget_draw();
  attackSlider.sliderWidget_draw();
  decaySlider.sliderWidget_draw();
  rmsSlider.sliderWidget_draw();
  
  cutoffSlider.sliderWidget_draw();
  resonanceSlider.sliderWidget_draw();
  
  // Combobox should be the last to draw
  lfoSelect.combobox_draw();  
  modeSelect.combobox_draw();
  filterSelect.combobox_draw();
  
  lfoSelect.combobox_draw_top();  
  modeSelect.combobox_draw_top();
  filterSelect.combobox_draw_top();
  
  (filterSelect.hasfocus == 0) ? (
    ( modeSelect.hasFocus == 0 ) ? (
      ( lfoSelect.hasFocus == 0 ) ? (
        inGain.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)           ? ( slider_automate( slider52=inGain.sliderWidget_getValue(); ); slider_automate( slider51=inGain.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );
        outGain.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)          ? ( slider_automate( slider53=outGain.sliderWidget_getValue(); ); forceUpdate = 1; );
        overSampling.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider54=overSampling.sliderWidget_getValue(); ); forceUpdate = 1; );
      
        cutoffSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider48=cutoffSlider.sliderWidget_getValue(); ); slider_automate( slider62=cutoffSlider.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );
        resonanceSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)  ? ( slider_automate( slider49=resonanceSlider.sliderWidget_getValue(); ); slider_automate( slider63=resonanceSlider.sliderWidget_getValue2_nn() ); forceUpdate = 1; );
    
        threshSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider59=threshSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
        attackSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider60=attackSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
        decaySlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)      ? ( slider_automate( slider61=decaySlider.sliderWidget_getValue(); ); forceUpdate = 1; );
        rmsSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)        ? ( slider_automate( slider64=rmsSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
        
        lookAheadButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider35=lookAheadButton.active; ); forceUpdate = 1; );
        lfoResetButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap)  ? ( slider_automate( slider38=lfoResetButton.active; ); forceUpdate = 1; );        
        
        lfoFrequency.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider37=lfoFrequency.sliderWidget_getValue(); ); forceUpdate = 1; );
        
        // Something changed w.r.t. dynamics
        dynamicFilterButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) || dynamicWaveShapingButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? (
          slider58 = dynamicFilterButton.active + 2 * dynamicWaveShapingButton.active;
          slider_automate(slider58);
          forceUpdate = 1;
        );
        
        window1.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
        window2.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
        dyn_thresh = window3.processMouseDynamics(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap, dyn_thresh);
      );
    );      
  );

  ( filterSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 ) ?
    modeSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider46=modeSelect.curitem; ); forceUpdate = 1; );

  ( modeSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 ) ?
    filterSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider47=filterSelect.curitem; ); forceUpdate = 1; );

  ( modeSelect.hasFocus == 0 && filterSelect.hasFocus == 0 ) ?
    lfoSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider36=lfoSelect.curitem; ); forceUpdate = 1; );


  lx = mouse_x;
  ly = mouse_y;
  
  filterDescription(slider47);
  
//  spline1.sort_spline();
//  spline2.sort_spline();

//    gfx_set( .7, .7, .7, .7 );
//    gfx_x = 0;
//    gfx_y = 0;
//    q = positive_xloc;
//    q += 2;
//    gfx_printf("xloc: %f", q[]);
