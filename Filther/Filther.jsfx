desc:Filther
tags: Filther
version: 1.38
author: Joep Vanlier
changelog: Potatoes, improved kr0g filters, added pregain automation, fixed minor issues, added 5 more filters, widened combobox, added a bunch of FM filters and sine wave distortion, added optional input/output clipping, improved usability (bigger sliders, mouse wheel for precise motion, black background for threshold slider), presets, attempt 2, attempt 3, fix for LFO (disabled when turned off), added RMS mode for dynamics, removed secondary slider range for sliders which do not support it, added wasp filter, added retina scaling, added keyboard handling, added attack and decay multiplier options, fixed threshold going out of bounds,fix thresh jitter,major bugfix extrapolation,fix issue with RMS acquiring DC and not losing it, attempted to automate retina support, initialize spline immediately to avoid flicker, fixed update bug, enhanced stability saike's waveshaped filters (feedback clipper), added logo, fixed mouse wheel behaviour, fixed incorrect spline loading behavior, fix for RMS detection, fontsize fix for mac (hopefully), added drawing dynamics of the shaper when activated to make this more clear, added a few comb filters, added scaling for non windows machines, bugfix modulation, bugfix refreshing of dynamic mode labels, bugfix filter selection, fix rms clipping behavior, added FIR option for up/downsampling, fix pdc_delay, increase scale when double clicking logo, added usage hints, improved some hint descriptions, hotfix lfo, perf improvements wasp, fixed issue with filters modes leaking output to eachother when switching, more rigorous buffer clearing, added cutoff/reso interpolation, display modulation range (to avoid confusion), added option to change modulation amnt, added filter frequency in Hz where sensible, made default tooltip wait time a bit longer and added a toggle to turn them off (T key), extra optimization wasp, made gui sizing / hide persistent. Added linux mode for font (L key). Minor bugfix vowel filter display. Add minimum oversampling. Made sliders draggable. Added tempo synced modulation option. Fix for RMS mode (x4's should be ignored).
provides: Filther.jsfx.rpl
Copyright (C) 2018 Joep Vanlier
License: MIT

Filter attribution:
LP Diode Ladder (MIT Licensed)
Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
Karlsen Fast Ladder III
Copyright (c) Ove Hy Karlsen

slider1:2<2,9,1>-Nodes negative
slider2:2<2,9,1>-Nodes positive

slider3:0.15<0,1,.01>-Pos1x
slider4:0.15<0,1,.01>-Pos1y
slider5:0.25<0,1,.01>-Pos2x
slider6:0.25<0,1,.01>-Pos2y
slider7:0.35<0,1,.01>-Pos3x
slider8:0.35<0,1,.01>-Pos3y
slider9:0.5<0,1,.01> -Pos4x
slider10:0.5<0,1,.01>-Pos4y
slider11:0.6<0,1,.01>-Pos5x
slider12:0.6<0,1,.01>-Pos5y
slider13:0.7<0,1,.01>-Pos6x
slider14:0.7<0,1,.01>-Pos6y
slider15:0.8<0,1,.01>-Pos7x
slider16:0.8<0,1,.01>-Pos7y
slider17:0.9<0,1,.01>-Pos8x
slider18:0.9<0,1,.01>-Pos8y

slider19:0.15<0,1,.01>-Neg1x
slider20:0.15<0,1,.01>-Neg1y
slider21:0.25<0,1,.01>-Neg2x
slider22:0.25<0,1,.01>-Neg2y
slider23:0.35<0,1,.01>-Neg3x
slider24:0.35<0,1,.01>-Neg3y
slider25:0.5<0,1,.01>-Neg4x
slider26:0.5<0,1,.01>-Neg4y
slider27:0.6<0,1,.01>-Neg5x
slider28:0.6<0,1,.01>-Neg5y
slider29:0.7<0,1,.01>-Neg6x
slider30:0.7<0,1,.01>-Neg6y
slider31:0.8<0,1,.01>-Neg7x
slider32:0.8<0,1,.01>-Neg7y
slider33:0.9<0,1,.01>-Neg8x
slider34:0.9<0,1,.01>-Neg8y
slider35:1<0,1,1{Off, On}>-Lookahead
slider36:0<0,16,1>-LFO type
slider37:0<0,1,0.001>-LFO freq
slider38:0<0,3,1>-Reset LFO
slider39:1<0,4,.00001>-Modulation range
slider40:0<0,1,1>-FIR resampling

slider45:0<0,1,1>-Dynamics RMS mode
slider46:<0,6,1>-Filter Operation Mode
slider47:<0,30,1{OFF, LP RC-C,LP Diode Ladder (303/Non-Linear Dominique Wurtz),Vowel,LP Karlsen Fast Ladder III,LP Karlsen Fast Ladder III (sat),Saike`s Waveshaped Resonance (LP),Saike`s Waveshaped Resonance (HP),Saike`s Waveshaped Resonance (BP),Expensive Moog,Less Expensive Moog (DANGEROUS),Notch filter,Narsty,Modulator,Phaser (OTA),Phaser (FET),Delay Feedbok,Mangler,,MS-20 linear LP, MS-20 linear BP, MS-20 linear HP, MS-20 nonlinear LP, MS-20 nonlinear BP, MS-20 nonlinear HP}>-Filter Type
slider48:<0,1,.001>-Cutoff
slider49:<0,1,.001>-Reso
slider50:1<0,1,1>-Interpolation

slider51:0<-1,1,.01>-Pre-Gain/Drive Mod %
slider52:0<-40,40,.01>-PreGain
slider53:0<-40,40,.01>-PostGain
slider54:1<1,8,1>-Oversampling
slider55:0<0,3,1{Off,In,Out,Both}>-Clipping
slider56:0<0,4,4{Spline,Tanh,Fast Tanh,None,Sine}>-Waveshaping Mode

slider57:0<0,63,1{Attack x1 Decay x1 RMS x1,Attack x4 Decay x1 RMS x1,Attack x4 Decay x1 RMS x1,Attack x16 Decay x1 RMS x1,Attack x1 Decay x4 RMS x1,Attack x4 Decay x4 RMS x1,Attack x4 Decay x4 RMS x1,Attack x16 Decay x4 RMS x1,Attack x1 Decay x4 RMS x1,Attack x4 Decay x4 RMS x1,Attack x4 Decay x4 RMS x1,Attack x16 Decay x4 RMS x1,Attack x1 Decay x16 RMS x1,Attack x4 Decay x16 RMS x1,Attack x4 Decay x16 RMS x1,Attack x16 Decay x16 RMS x1,Attack x1 Decay x1 RMS x4,Attack x4 Decay x1 RMS x4,Attack x4 Decay x1 RMS x4,Attack x16 Decay x1 RMS x4,Attack x1 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attackx16 Decay x4 RMS x4,Attack x1 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x16 Decay x4 RMS x4,Attack x1 Decay x16 RMS x4,Attack x4 Decay x16 RMS x4,Attack x4 Decay x16 RMS x4,Attack x16 Decay x16 RMS x4,Attack x1 Decay x1 RMS x4,Attack x4 Decay x1 RMS x4,Attack x4 Decay x1 RMS x4,Attack x16 Decay x1 RMS x4,Attack x1 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x16 Decay x4 RMS x4,Attack x1 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x4 Decay x4 RMS x4,Attack x16 Decay x4 RMS x4,Attack x1 Decay x16 RMS x4,Attack x4 Decay x16 RMS x4,Attack x4 Decay x16 RMS x4,Attack x16 Decay x16 RMS x4,Attack x1 Decay x1 RMS x16,Attack x4 Decay x1 RMS x16,Attack x4 Decay x1 RMS x16,Attack x16 Decay x1 RMS x16,Attack x1 Decay x4 RMS x16,Attack x4 Decay x4 RMS x16,Attack x4 Decay x4 RMS x16,Attack x16 Decay x4 RMS x16,Attack x1 Decay x4 RMS x16,Attack x4 Decay x4 RMS x16,Attack x4 Decay x4 RMS x16,Attack x16 Decay x4 RMS x16,Attack x1 Decay x16 RMS x16,Attack x4 Decay x16 RMS x16,Attack x4 Decay x16 RMS x16,Attack x16 Decay x16 RMS x16}>-Multipliers
slider58:1<0,2,1{OFF,Filter,Waveshaper,Both}>-Dynamics
slider59:1<0,1,.001>-Thresh
slider60:1<0,50,.1>-Attack
slider61:1<0.1,50,.1>-Decay
slider62:.5<-1,1,.01>-Filt Cutoff Mod %
slider63:0<-1,1,.01>-Filt Reso Mod %
slider64:.34<0.02,40,0.001>-RMS Integration time

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output
options:no_meter

@serialize
file_var(0,extraScale);
file_var(0,hideToolTips);
file_var(0,linuxMode);

@init
MAXOVERSAMPLING = 8;
MAXBUFFERSIZE = MAXOVERSAMPLING*10000;

gfx_ext_retina  = 1.0;
plugname = "FILTHER 1.38";
//fontface = "Sans Serif";
fontface = "Arial";
newUI = 1;
refreshDynMode = -1;
nFilters = 51;
nModes = 7;
nLFO = 14;
lastOversample = 0;
lastpdcDelay = -1000;
lastIntegrationTime = -1000;
nTapSinc = slider54 < 5 ? 16 : slider54*4;
modulator.t = 0;

function comboStrings(stridx, curitem)
  local(str)
  global()
  instance()
  (
    str = "";
    (stridx == 0) ?
    (
      ( curitem == 0 ) ? ( str = "OFF"
      ) : ( curitem == 1 ) ? ( str = "LP RC-C"
      ) : ( curitem == 2 ) ? ( str = "Diode Ladder"
      ) : ( curitem == 3 ) ? ( str = "Vowel"
      ) : ( curitem == 4 ) ? ( str = "Karlsen Ladder III (303)"
      ) : ( curitem == 5 ) ? ( str = "Karlsen Ladder IIIs (303)"
      ) : ( curitem == 6 ) ? ( str = "Sai'ke Waveshaped LP"
      ) : ( curitem == 7 ) ? ( str = "Sai'ke Waveshaped HP"
      ) : ( curitem == 8 ) ? ( str = "Sai'ke Waveshaped BP"
      ) : ( curitem == 9 ) ? ( str = "Expensive Moog (ZDF)"
      ) : ( curitem == 10 ) ? ( str = "Cheap Moog (unstable)"
      ) : ( curitem == 11 ) ? ( str = "Notch"
      ) : ( curitem == 12 ) ? ( str = "Narsty"
      ) : ( curitem == 13 ) ? ( str = "Modulator"
      ) : ( curitem == 14 ) ? ( str = "Phaser (OTA)"
      ) : ( curitem == 15 ) ? ( str = "Phaser (FET)"
      ) : ( curitem == 16 ) ? ( str = "Delay Feedbok"
      ) : ( curitem == 17 ) ? ( str = "Phase Mangler"      
      ) : ( curitem == 18 ) ? ( str = "Kr0g MS-20 linear LP (ZDF)"
      ) : ( curitem == 19 ) ? ( str = "Kr0g MS-20 linear BP (ZDF)"
      ) : ( curitem == 20 ) ? ( str = "Kr0g MS-20 linear HP (ZDF)"
      ) : ( curitem == 21 ) ? ( str = "Kr0g MS-20 nonlin LP (ZDF)" 
      ) : ( curitem == 22 ) ? ( str = "Kr0g MS-20 nonlin BP (ZDF)"
      ) : ( curitem == 23 ) ? ( str = "Kr0g MS-20 nonlin HP (ZDF)"
      ) : ( curitem == 24 ) ? ( str = "Experimental"
      ) : ( curitem == 25 ) ? ( str = "Rezzy (ZDF)"
      ) : ( curitem == 26 ) ? ( str = "4p LP SSM 2020 NL (ZDF)"
      ) : ( curitem == 27 ) ? ( str = "4p LP SSM 2020 NL (Approx)"      
      ) : ( curitem == 28 ) ? ( str = "4p LP CEM 3389 NL (ZDF)"      
      ) : ( curitem == 29 ) ? ( str = "4p LP SSM 2020 L (ZDF)"        
      ) : ( curitem == 30 ) ? ( str = "4p LP CEM 3389 L (ZDF)"
      ) : ( curitem == 31 ) ? ( str = "Sine"  
      ) : ( curitem == 32 ) ? ( str = "FM Feedback"  
      ) : ( curitem == 33 ) ? ( str = "Filter FM-ish 2" 
      ) : ( curitem == 34 ) ? ( str = "Broken connection"
      ) : ( curitem == 35 ) ? ( str = "Broken feedback (ZDF)"
      ) : ( curitem == 36 ) ? ( str = "Waspey Linear (ZDF)"
      ) : ( curitem == 37 ) ? ( str = "Waspey Non-Linear LP(ZDF)"
      ) : ( curitem == 38 ) ? ( str = "Waspey Non-Linear BP (ZDF)"      
      ) : ( curitem == 39 ) ? ( str = "Linear SVF LP (ZDF)"
      ) : ( curitem == 40 ) ? ( str = "Linear SVF BP (ZDF)"
      ) : ( curitem == 41 ) ? ( str = "Linear SVF HP (ZDF)"
      ) : ( curitem == 42 ) ? ( str = "Linear SVF Notch (ZDF)"   
      ) : ( curitem == 43 ) ? ( str = "Linear SVF Peak (ZDF)"    
      ) : ( curitem == 44 ) ? ( str = "Everything is a saw (ZDF)"     
      ) : ( curitem == 45 ) ? ( str = "SVF with waveshaped resonance (ZDF)"
      ) : ( curitem == 46 ) ? ( str = "Voodoo"
      ) : ( curitem == 47 ) ? ( str = "Junk (ZDF)"  
      ) : ( curitem == 48 ) ? ( str = "Comb"    
      ) : ( curitem == 49 ) ? ( str = "Combed resonance (LP)"
      ) : ( curitem == 50 ) ? ( str = "Combed resonance (BP)"
      );
    ) : (stridx == 1) ? 
    (
      ( curitem == 0 ) ? ( str = "Stereo"
      ) : ( curitem == 1 ) ? ( str = "Mono double"
      ) : ( curitem == 2 ) ? ( str = "M1/S2"
      ) : ( curitem == 3 ) ? ( str = "M2/S1"
      ) : ( curitem == 4 ) ? ( str = "Only side"
      ) : ( curitem == 5 ) ? ( str = "Only mid"
      ) : ( curitem == 6 ) ? ( str = "Stereoize"
      );
    ) : (stridx == 2) ?
    (
      ( curitem == 0 ) ? ( str = "OFF"
      ) : ( curitem == 1 ) ? ( str = "Cosine"
      ) : ( curitem == 2 ) ? ( str = "Sine"
      ) : ( curitem == 3 ) ? ( str = "Cos^2"
      ) : ( curitem == 4 ) ? ( str = "Sin^2"
      ) : ( curitem == 5 ) ? ( str = "Ramp up"
      ) : ( curitem == 6 ) ? ( str = "Ramp down"
      ) : ( curitem == 7 ) ? ( str = "Exponential"
      ) : ( curitem == 8 ) ? ( str = "Exp + Atk"
      ) : ( curitem == 9 ) ? ( str = "1-Exponential"
      ) : ( curitem == 10 ) ? ( str = "Random"
      ) : ( curitem == 11 ) ? ( str = "Random Exps"
      ) : ( curitem == 12 ) ? ( str = "Rand Exps + Atk"
      ) : ( curitem == 13 ) ? ( str = "Single Exp"
      ) : ( curitem == 14 ) ? ( str = "Single Exp + Atk"      
      )
    );
    
    str;
  );

function modulator()
  global(srate)
  local()
  instance( invpi2, twopi, invsrate, reset, modvalue, modrate, t, modmax )
  (
    modvalue = 0;
    reset = 1;
    modmax = 1;
    invsrate = 1.0/srate;
    invpi2 = .5/$pi;
    twopi = 2*$pi;
  );


function setmodrate(val)
  global()
  local()
  instance( invsrate, reset, modvalue, modrate, t )
  (
    modrate = val;
  );
  
modulator.modulator();

function updateModulator()
  instance( invpi2, twopi, invsrate, reset, modvalue, modrate, t, lastt, lastrand )
  global( slider38, slider39, slider36, modulatorDynamics )
  local(ct, st)
  (
    slider36 > 0 ? (
      modulatorDynamics = 1;
      t = t + modrate*invsrate;
      (slider38 & 1) && reset == 1 ? ( t = 0; reset = 0 );
      modvalue = slider36 == 1 ? .5 + .5 * cos(twopi*t) 
      : ( slider36==2 )  ? .5 + .5 * sin(twopi*t)
      : ( slider36==3 )  ? ( ct = cos($pi*t); ct*ct )
      : ( slider36==4 )  ? ( st = sin($pi*t); st*st )
      : ( slider36==5 )  ? ( t-floor(t) )
      : ( slider36==6 )  ? ( 1-t+floor(t) )
      : ( slider36==7 )  ? ( exp(-4*(t-floor(t))) )
      : ( slider36==8 )  ? ( min((15*(t-floor(t))),1)*exp(-4*(t-floor(t))) )
      : ( slider36==9 )  ? ( 1-exp(-4*(t-floor(t))) )
      : ( slider36==10 ) ? ( ( t > (lastt+1) ) ? ( lastt = t; lastrand=rand() ); lastrand )
      : ( slider36==11 ) ? ( ( t > (lastt+1) ) ? ( lastt = t; lastrand=rand() ); exp(-4*lastrand*(t-floor(t))) )
      : ( slider36==12 ) ? ( ( t > (lastt+1) ) ? ( lastt = t; lastrand=rand() ); min((15*(.2+.8*lastrand)*(t-floor(t))),1)*exp(-4*lastrand*(t-floor(t))) )
      : ( slider36==13 ) ? ( exp(-t) )    
      : ( slider36==14 ) ? ( min((15*(t-floor(t))),1)*exp(-t) )
    ) : ( modvalue = 0; modulatorDynamics = 0; );
  );

function gfx_wrapprint(str, maxlen)
  global(gfx_x, gfx_y)
  local(mp, len, str, lastLineStart, lastWordStart, cpos, tmp, mx, my, xref, yref)
  (
    xref = gfx_x;
    yref = gfx_y;
    len = strlen(str);
    lastLineStart = 0;
    lastWordStart = 0;
    cpos = 0;
    tmp = 1;
    mp = 0;
    loop(len,
      // Found end of a word!
      ( str_getchar(str, cpos) == 32 ) ? (
        // Is the current line too long?
        gfx_measurestr( strcpy_substr( tmp, str, lastLineStart, cpos-lastLineStart ), mx, my );
        ( mx > maxlen ) ? (
          strcpy_substr( tmp, str, lastLineStart+mp, lastWordStart - lastLineStart );
          gfx_printf( tmp );
          // Yeah, terminate here
          lastLineStart = lastWordStart;
          gfx_x = xref;
          gfx_y += my;
          mp = 1;
        ) : (
          // Nope keep going
          lastWordStart = cpos;
        );
      );
      
      cpos += 1;
    );
    strcpy_substr(tmp, str, lastLineStart+mp, cpos - lastLineStart);
    gfx_printf(tmp);
  );

function filterDescription(filter)
global(gfx_x, gfx_y, slider47, wndX, wndY, wndPad, retina_scaling, fontface)
local(fx, fy, wx, wx2, wy)
(
  fx = 30*retina_scaling;
  fy = wndPad*2 + wndY + 3*retina_scaling;
  wx = 3*wndX + 2*wndPad;
  wx2 = wx - fx;

  gfx_set(0.1, 0.1, 0.2, .3);
  gfx_rect(fx, fy, wx, 188*retina_scaling);
  gfx_x = fx+5;
  gfx_y = fy+5;

  gfx_set(0.6, 0.6, 1.0, 1.0);

  gfx_setfont(2, fontface, 16*retina_scaling);
  ( slider47 == 0 ) ? (
    gfx_printf("Filter: OFF")
  ) : ( slider47 == 1 ) ? (
    gfx_printf("Filter: LP RC-C\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Simple state space filter. This filter does not use internal waveshaping and the output of the filter is waveshaped instead.", wx2);
  ) : ( slider47 == 2 ) ? (  
    gfx_printf("Filter: LP Diode Ladder (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter was based on a model by Dominique Wurtz which modelled the 303 diode ladder. The only modification is that rather than input clipping, the waveshaper is used.", wx2);
  ) : ( slider47 == 3 ) ? (
    gfx_printf("Filter: Vowel filter\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter uses 3 band pass filters to imitate vowel sounds.", wx2);
  ) : ( slider47 == 4 ) ? (  
    gfx_printf("Filter: LP Karlsen Fast Ladder III\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on a 303 diode ladder. The filter uses the waveshaper as non/ideal part rather than just clipping. Note that this filter doesn't completely maintain its tone when using different levels of supersampling.", wx2);
  ) : ( slider47 == 5 ) ? (  
    gfx_printf("Filter: LP Karlsen Fast Ladder III (sat)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter combines the 303 diode ladder filter with a fixed shelf filter. The filter uses the waveshaper as non/ideal part rather than just clipping. Note that this filter doesn't completely maintain its tone when using different levels of supersampling.", wx2);
  ) : ( slider47 == 6 ) ? (  
    gfx_printf("Filter: Saike`s Waveshaped Resonance (LP) (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter consists of two first order low-pass filters. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. This filter can get very mean depending on the curve you set for waveshaping. Stability can be enhanced by oversampling. Be careful!\nNote that this filter forces oversampling to be at least 2x.", wx2);
  ) : ( slider47 == 7 ) ? (  
    gfx_printf("Filter: Saike`s Waveshaped Resonance (HP) (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a waveshaped highpass filter. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. Stability can be enhanced by oversampling. Note that this filter forces oversampling to be at least 2x.", wx2);
  ) : ( slider47 == 8 ) ? (
    gfx_printf("Filter: Saike`s Waveshaped Resonance (BP) (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This is a waveshaped bandpass filter. Sort of. The difference in filter outputs is distorted through the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again. Stability can be enhanced by oversampling. Note that this filter forces oversampling to be at least 2x.", wx2);
  ) : ( slider47 == 9 ) ? (
    gfx_printf("Filter: Model of a Moog filter (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on the paper Modeling and measuring a Moog voltage-cont\rolled filter by Paschou et al. Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will bring in higher quality as the non-linearity makes it sensitive to aliasing problems. This version is more stable than the cheap version, but still be careful. Extemely high gain with high resonance can turn this baby into a glitching mess! Best used with the fast Atanh because of performance considerations.", wx2);
  ) : ( slider47 == 10 ) ? (
    gfx_printf("Filter: Approximate model of a Moog filter (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter is based on the paper Modeling and measuring a Moog voltage-controlled filter by Paschou et al. Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will bring in higher quality as the non-linearity makes it sensitive to aliasing problems. This version does not correctly compute the Jacobian. This is fine for low cutoffs and/or atanh waveshaper. Be careful though, because it can seriously blow up in your face!", wx2);
  ) : ( slider47 == 11 ) ? (
    gfx_printf("Filter: Basic notch filter\n\n"); gfx_x = fx+5;
  ) : ( slider47 == 12 ) ? (
    gfx_printf("Filter: Narsty (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Saike's make things nasty filter. Combination of 3 filters with varying interacting resonances. No guarantees that this thing won´t blow up in your face. Exclusively meant for basses. Note that this one does not maintain its character when changing the sampling rate.", wx2);
  ) : ( slider47 == 13 ) ? (
    gfx_printf("Filter: Modulator\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Passes a lowpassed version of the signal and modulates it with the signal itself. Second bandpass filtered version is added to provide the resonance peak. This filter is meant for sounds with limited high frequency content as it will sound awful with rich sounds.\n", wx2);
  ) : ( slider47 == 14 ) ? (
    gfx_printf("Filter: Phaser (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("4 pass phaser based on operational transconductance amplifiers. Note that this one frequently has problem with spline voltage curves.", wx2);
  ) : ( slider47 == 15 ) ? (
    gfx_printf("Filter: Phaser based on FET (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("4 pass phaser based on Field Effect Transistor elements.", wx2);
  ) : ( slider47 == 16 ) ? (
    gfx_printf("Filter: Phaser-like\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Non-linear phaser like filter with relatively long delays and distortion of difference signal.", wx2);
  ) : ( slider47 == 17 ) ? (
    gfx_printf("Filter: Phase mangler\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Magic??? I honestly forgot what the idea was behind this one.", wx2);
  ) : ( slider47 == 18 ) ? (
    gfx_printf("Filter: MS-20 linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);
  ) : ( slider47 == 19 ) ? (
    gfx_printf("Filter: MS-20 linear BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);
  ) : ( slider47 == 20 ) ? (
    gfx_printf("Filter: MS-20 linear HP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);        
  ) : ( slider47 == 21 ) ? (
    gfx_printf("Filter: MS-20 non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);
  ) : ( slider47 == 22 ) ? (
    gfx_printf("Filter: MS-20 non-linear BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);
  ) : ( slider47 == 23 ) ? (
    gfx_printf("Filter: MS-20 non-linear HP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback MS-20 emulation with non-linearity. This thing sounds great when overdriven, especially without waveshaper. The non-linear elements consist of arctans that saturate at each stage, and a nice diode clipper in the feedback. It can sound raw, yet clean, if that makes sense.", wx2);                
  ) : ( slider47 == 24 ) ? (
    gfx_printf("Filter: Multiphase\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Experimental thingamabob. Bits of phaser, bits of a saturating lowpass, some distortion gibberish and some ugly ass feedback. Be careful with this thing. Especially when you're combining it with a waveshaper. It has plenty of bite. P.S. It self-oscillates too. ;_;", wx2);
  ) : ( slider47 == 25 ) ? (
    gfx_printf("Filter: Rezzy\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Honestly, I forgot what this one represents really. It came around after an afternoon of screwing around with the feedback mechanism in the MS-20. It can sound quite bitey, which I like.", wx2);
  ) : ( slider47 == 26 ) ? (
    gfx_printf("Filter: 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback 4-pole SSM2020 emulation with non-linearity (tanh) in the model. The waveshaper is applied to the output and can be used to tame the output.", wx2);
  ) : ( slider47 == 27 ) ? (
    gfx_printf("Filter: Cheaper 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback 4-pole SSM2020 emulation with non-linearity (cheap tanh) in the model. The waveshaper is applied to the output and can be used to tame the output.", wx2);
  ) : ( slider47 == 28 ) ? (
    gfx_printf("Filter: 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback 4-pole CEM 3389 emulation with non-linearity (tanh) in the model. The waveshaper is applied to the output and can be used to tame the output.", wx2);
  ) : ( slider47 == 29 ) ? (
    gfx_printf("Filter: Linearized 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Linearized zero delay feedback 4-pole SSM2020 emulation. The waveshaper is applied to the output and can be used to tame the output. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);    
  ) : ( slider47 == 30 ) ? (
    gfx_printf("Filter: Linearized 4 pole non-linear LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Linearized zero delay feedback 4-pole CEM 3389 emulation. The waveshaper is applied to the output and can be used to tame the output. Note that this filter doesn't saturate or self-oscillate in the way the non-linear emulation would. The computational cost is much lower however.", wx2);        
  ) : ( slider47 == 31 ) ? (
    gfx_printf("Filter: Sine\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Take the sine of the signal. Cutoff controls frequency, resonance controls mix. Simple, but surprisingly satisfying. Use on basses, not high frequency content.", wx2); 
  ) : ( slider47 == 32 ) ? (
    gfx_printf("Filter: FM feedback\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Non-linear MS-20 but with the feedback signal FM modulated. I've had lucky sweet spots with this thing, but it's horrible. Most of the times it'll just sound horrendous.", wx2);     
  ) : ( slider47 == 33 ) ? (
    gfx_printf("Filter: FM MS-20\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This filter uses the input signal as modulation source for the cutoff of an MS-20 linear which then modifies the input signal. Huh?", wx2);    
  ) : ( slider47 == 34 ) ? (
    gfx_printf("Filter: Broken Connection\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Messy filter. Be careful with this one. It was actually sort of an accident, but it seems pretty stable and pretty unique. It is not invariant under oversampling particularly in the low frequency regions where it likes to lead a life of its own. It's based on the kr0g filter, but including a voltage inversion step in the feedback path (low to high, high to low, not just polarity switch).", wx2);    
  ) : ( slider47 == 35 ) ? (
    gfx_printf("Filter: Borked Waspey feedback (not unconditionally stable)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Circuit bended version of the non-linear WASP, makes for growly resonance, but be careful, is not unconditionally stable!.", wx2);
  ) : ( slider47 == 36 ) ? (
    gfx_printf("Filter: Wasp emulation (linearized)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Linearized approximation of the wasp filter.", wx2);
  ) : ( slider47 == 37 ) ? (
    gfx_printf("Filter: Wasp emulation LP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Approximation of the wasp filter.", wx2);
  ) : ( slider47 == 38 ) ? (
    gfx_printf("Filter: Wasp emulation BP\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Approximation of the wasp filter.", wx2);    
  ) : ( slider47 == 39 ) ? (
    gfx_printf("Filter: SVF Lowpass filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( slider47 == 40 ) ? (
    gfx_printf("Filter: SVF Bandpass filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( slider47 == 41 ) ? (
    gfx_printf("Filter: SVF Highpass filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( slider47 == 42 ) ? (
    gfx_printf("Filter: SVF Notch filter (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( slider47 == 43 ) ? (
    gfx_printf("Filter: SVF Peak (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Zero delay feedback filter based on Andy Simper's (Cytomic) SVF filter algorithms.", wx2);  
  ) : ( slider47 == 44 ) ? (
    gfx_printf("Filter: Everything is a saw (not unconditionally stable!)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Weird filter that tends to convert most things to saws. Based on biasing the wasp emulation severely. It can work pretty nicely with basses and high resonance, but be careful, it is pretty unpredictable.", wx2);  
  ) : ( slider47 == 45 ) ? (
    gfx_printf("Filter: SVF with waveshaped resonance (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("ZDF filter that lowpasses the signal twice. Once with and once without resonance. Subsequently it waveshapes the version with resonance minus the version without and adds the waveshaped resonance to the no resonance lowpass mix.", wx2);  
  ) : ( slider47 == 46 ) ? (
    gfx_printf("Filter: Voodoo\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This one is a meanie. It filters the signal with and without resonance, computes the difference, amplifies it, saturates it and then adds it to a moving average that gets added to the signal. The result is then waveshaped. Yum.", wx2);  
  ) : ( slider47 == 47 ) ? (
    gfx_printf("Filter: Junk (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("This one is fickle. It filters the signal with and without resonance, computes the difference, amplifies it, saturates it and then adds it back to the signal. The result is then waveshaped. Yum.", wx2);
  ) : ( slider47 == 48 ) ? (
    gfx_printf("Filter: Comb)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Basic comb filter. Set resonance one to have alternating notches between left and right (wide) or zero for mono phasing. Waveshaper is applied before the comb.", wx2);
  ) : ( slider47 == 49 ) ? (
    gfx_printf("Filter: Combed resonance (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Signal is lowpassed twice with and withou resonance. Resonance is lifted by differencing the signal, this resonance is amplified, saturated and mixed with a delayed copy of itself before being added to the signal. Waveshaper is applied after the filter.", wx2);
  ) : ( slider47 == 50 ) ? (
    gfx_printf("Filter: Combed BP (ZDF)\n\n"); gfx_x = fx+5;
    gfx_wrapprint("Signal is BP passed twice with and withou resonance. Resonance is lifted by differencing the signal, this resonance is mixed with a delayed copy of itself before being added to the signal. Waveshaper is applied after the filter. Not nearly as fun as the lowpassed version (previous).", wx2);
  );
);

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr        = scopebuffer_in;
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr = scopebuffer;
    //loop(scopebuffermax - scopebuffer + 1,
    loop(MAXBUFFERSIZE,
      scopeptr[] = 0;
      scopeptr += 1;
    );
    scopeptr = scopebuffer;
  );  

function initBufferNoReset(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );  

function tanh(s)
local(c)
global()
instance()
(
  c = exp(8*s);
  s = 0.25*(c - 1) / (c + 1);
);

function fasttanh(x)
local()
global()
instance()
(
  x = x / (1 + abs(2*x));
  /*( x < -3 ) ? (
      x = -1;
  ) : ( x > 3 ) ? (
      x = 1;
  ) : ( 
      x = x * ( 27 + x * x ) / ( 27 + 9 * x * x );
    )*/
 // x = (-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*x)*x)*x)/(.2464845986383725+(.0609347197060491+(.1086202599228572+.02874707922475963*x)*x)*x);
);

//----------------------------------------------
// Filter initialization section
//----------------------------------------------
function initRC(freq, q)
  instance(len, v0, v1, a1, c)
  local(r)
  global(srate, slider54)
  (
    c = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    r = pow(0.5, (q*128+24) / 16.0);
    a1 = (1.0-r*c);   
  );

function init303(freq, q)
  local()
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    // This specific filter came from
    // Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
    wc  = .25 * (pow(10, freq)-1)/9 * $pi / max(slider54,1);
    wc2 = wc*wc;
    wc3 = wc2*wc;
    wc4 = wc3*wc;
    b   = 1 / ( 1 + 8*wc + 20*wc2 + 16*wc3 + 2*wc4);
    g   = 2 * wc4 * b;
    
    k   = 5*q;
    A   = 1 + 0.5 * k;
    
    b0 = 2*wc+12*wc2+20*wc3+8*wc4;
    a0 = 1+6*wc+10*wc2+4*wc3;
    a1 = 2*wc+8*wc2+6*wc3;
    a2 = 2*wc2+4*wc3;
    a3 = 2*wc3;
    
    b10 = 2*wc2+8*wc3+6*wc4;
    a10 = wc+4*wc2+3*wc3;
    a11 = 1+6*wc+11*wc2+6*wc3;
    a12 = wc+4*wc2+4*wc3;
    a13 = wc2+2*wc3;
    
    b20 = 2*wc3+4*wc4;
    a20 = a13;
    a21 = wc+4*wc2+4*wc3;
    a22 = 1+6*wc+10*wc2+4*wc3;
    a23 = wc+4*wc2+2*wc3;
    
    c2  = a21 - a3;
    c3  = 1+6*wc+9*wc2+2*wc3;
  ); 
  
function reset303()
  local(Kbig)
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    z1 = z2 = z3 = 0;
    y1 = y2 = y3 = y4 = 0;
  );

function initmoog(freq, q)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    cutoff = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    res = .1 * q;
    
    f  = (cutoff+cutoff);
    p  = f*(1.8-0.8*f);
    k  = 2.0 * sin(cutoff * $pi * 0.5) - 1.0;
    
    t  = (1.-p)*1.386249;
    t2 = 12.+t*t;
    r  = res*(t2+6.*t)/(t2-6.*t);
  );

function resetmoog()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    oldy1=oldy2=oldy3=y1=y2=y3=y4=oldx=0;
  );

// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = 0;
  );   
  
// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen_sat(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ max(slider54,1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen_sat()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = b_lfcut = b_lf = b_lf1hp = b_lfhp = b_lfgain = 0;
  );
  
function initdualfilt(freq, res)
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    f = (pow(10, freq)-1)/9 * $pi / (max(1,slider54));
    q = res;
    
    //set feedback amount given f and q between 0 and 1
    fb = q + q/(1.0 - f);
  );
  
function resetdualfilt()
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    d0 = d1 = 0.0000001;
  );

  
function initfancymoog(freq, q)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3, VT, fs                   
        )
  global(srate, slider54, tmp)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, ftarget)
  (
    fs      = max(slider54,1) * srate;
    //ftarget = 24*(pow(10, freq)-1)/9; //24
    
    ftarget   = .5*(srate/1000)*(pow(10, freq)-1)/9;
    //ftarget = 6*freq;
    VT      = 26/1000;
    A       = 0.5 * VT;
    hA      = 0.5 * A;
    T       = 1.0/fs;
    wc      = 4*$pi*ftarget*srate;
    wcT     = wc*T;
    g       = wcT*hA;
    k       = q*4; // [0..4]
  );

function resetfancymoog()
  local()
  global()
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    y0 = y1 = y2 = y3 = y4 = d0 = d1 = d2 = d3 = d4 = 0;
  );
  
function bootvowel()
  instance( c, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, d0, d1, d2, d3, d4, d5, d6, d7, d8, d9 )
  local(ptr)
  global(vowel_A, vowel_E, vowel_I, vowel_O, vowel_U, vowel_EE)
  (
  vowel_EE = 909090;
    c[0] = vowel_A;
    c[1] = vowel_E;
    c[2] = vowel_I;
    c[3] = vowel_O;
    c[4] = vowel_U;
    c[5] = vowel_EE;
    
    // 34 39 57
    ptr = vowel_A;
    ptr[] = 660;        ptr += 1;
    ptr[] = 1700;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-15/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr = vowel_E;
    ptr[] = 530;        ptr += 1;
    ptr[] = 1850;       ptr += 1;
    ptr[] = 2500;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_I;
    ptr[] = 400;        ptr += 1;
    ptr[] = 2000;       ptr += 1;
    ptr[] = 2550;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_O;
    ptr[] = 300;        ptr += 1;
    ptr[] = 870;        ptr += 1;
    ptr[] = 2250;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_U;
    ptr[] = 640;        ptr += 1;
    ptr[] = 1200;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-11/6);  ptr += 1; // gain
    ptr[] = 2^(-13/6);   ptr += 1; // gain
    ptr[] = 9;          ptr += 1; // Q
    ptr[] = 10;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr   = vowel_EE; // These are correct
    ptr[] = 207;        ptr += 1; // freq
    ptr[] = 2300;       ptr += 1; // freq
    ptr[] = 3000;       ptr += 1; // freq
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q
);

function rfn(q,qq)
(
  q * (1+2*qq);
);

function initvowel(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(ampfac, idx, ptr, loc, rloc, fact, fr1, fr2, fr3, q1, q2, q3, w0, cw, sw, alpha, a0, a0i, Q )
  global(slider54, srate, rfn)
  (
    loc   = 5 * freq;
    idx   = floor( loc - 0.0001 );
    rloc  = loc-idx;
    rloc  = 1.0 - rloc;
    fact  = 2 * $pi / ( srate * ( max(1,slider54) ) );
    
    ampfac = 6;
    ptr   = c[idx];
    fr1   = ptr[]*rloc; ptr+=1;
    fr2   = ptr[]*rloc; ptr+=1;
    fr3   = ptr[]*rloc; ptr+=1;
    amp1  = ampfac*ptr[]*rloc; ptr+=1;
    amp2  = ampfac*ptr[]*rloc; ptr+=1;
    amp3  = ampfac*ptr[]*rloc; ptr+=1;
    q1    = ptr[]*rloc; ptr+=1;
    q2    = ptr[]*rloc; ptr+=1;
    q3    = ptr[]*rloc; ptr+=1;
  
    ptr   = c[idx+1];    
    rloc  = 1 - rloc;
    fr1   += ptr[]*rloc; ptr+=1;
    fr2   += ptr[]*rloc; ptr+=1;
    fr3   += ptr[]*rloc; ptr+=1;
    amp1  += ampfac*ptr[]*rloc; ptr+=1;
    amp2  += ampfac*ptr[]*rloc; ptr+=1;
    amp3  += ampfac*ptr[]*rloc; ptr+=1;
    q1    += ptr[]*rloc; ptr+=1;
    q2    += ptr[]*rloc; ptr+=1;
    q3    += ptr[]*rloc; ptr+=1;
  
    // Biquads RBJ BP
    Q     = rfn(q1, qin);
    w0    = fr1 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = rfn(q2, qin);
    w0    = fr2 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = rfn(q3, qin);
    w0    = fr3 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

// Biquads RBJ Notch
function initnotch(freq, q)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local( out, w0, cw, sw, alpha, a0, a0i )
  global(srate, slider54)
  (
    w0    = (pow(10, freq)-1)/9 * $pi / max(slider54,1);
    q     = q*0.9 + .1;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    b0    = 1 * a0i;
    b1    = -2 * cw * a0i;
    b2    = a0i;
    a1    = -2 * cw * a0i;
    a2    = (1 - alpha) * a0i;
  );

function initsai0(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / max(slider54,1);
    w0c   = .1*(pow(10, freq)-1)/9 * $pi * fact + .025*5*fact;
    qav   = qin*1.5 + .5;
  
    amp1  = 1;
    amp2  = 1;
    amp3  = 1;
      
    // Biquads RBJ BP
    Q     = qav*8;
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = qav*12;
    w0    = w0c*2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = qav*12;
    w0    = w0c/2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

function resetsai0()
  global()
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local( )
  (
    c = amp1 = amp2 = amp3 = Ab0 = Ab1 = Ab2 = Aa1 = Aa2 = Bb0 = Bb1 = Bb2 = Ba1 = Ba2 = Cb0 = Cb1 = Cb2 = Ca1 = Ca2 = d1x = d2x = d1yA = d2yA = d1yB = d2yB = d1yC = d2yC = 0;
  );

function initmodulator(freq, qin)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / (max(slider54,1));
    w0c   = .1*(pow(10, freq)-1)/9 * $pi * fact + .25*fact;
    Q     = qin*15 + 20;
    amp   = qin*2;
    
    // Biquads RBJ BP
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0   = Q * alpha * a0i;
    Ab1   = 0 * a0i;
    Ab2   = - alpha * Q * a0i;
    Aa1   = -2 * cw * a0i;
    Aa2   = (1 - alpha) * a0i;
  
    Q     = 5+qin*15;
    fact  = $pi / ( srate * ( max(1,slider54) ) );
    w0    = w0c*.25;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = 0.5*(1-cw)*a0i;
    Bb1    = (1-cw)*a0i;
    Bb2    = 0.5*(1-cw)*a0i;
    Ba1    = -2*cw*a0i;
    Ba2    = (1 - alpha)*a0i;
  );
  
function resetmodulator()
  global()
  local()
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  (
    c = Ab0 = Ab1 = Ab2 = Aa1 = Aa2 = Bb0 = Bb1 = Bb2 = Ba1 = Ba2 = d1x = d2x = d1yA = d2yA = d1yB = d2yB = amp = 0;
  );

function initphaserOTA(freq, reso)
  global(slider54)
  local(Rf, g)
  instance(C1, C2, dw, dx, sq)
  (
    Rf = 25/1000;
    g = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    sq = .2*reso;
    // Rf = R1*Vt/R2
    C1 = Rf * g;
    C2 = - 1 / Rf;
  );
  
function resetphaserOTA()
  global()
  local()
  instance(C1, C2, dw, dx, sq)
  (
    dw = dx = 0;
  );

// Trapezoidal integrator
function TPT_step(g, x)
  local()
  global()
  instance(s, y)
  (
    y = g * x + s;
    s = y + g * x;
    
    y;
  );

function init_MS20lin(freq, reso)
  global(slider54)
  local(fg, invTerm, smallg, Gsq, norm)
  instance(a0, a1, a2, s1, s2, G, k)
  (
//    fg      = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    smallg  = .5 * (pow(10, freq)-1)/9 * $pi / max(slider54,1);
    k       = 2*reso;
    invTerm = 1.0 / ( 1.0 + smallg );
    G       = smallg * invTerm;
    Gsq     = G*G;
    norm    = 1.0 / ( 1.0 + Gsq * k - G * k );
    
    a0      = Gsq * norm;
    a1      = G * norm;
    a2      = norm;
  );

function reset_MS20lin()
  global()
  local()
  instance(a0, a1, a2, s1, s2, G, k)
  (
    s1 = s2 = 0;
  );

function init_MS20(freq, reso)
  global(slider54)
  local(fg, invTerm)
  instance(s1, s2, G, Gsq, Gsqk, Gk, k, smallg)
  (
//    fg      = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    smallg  = .5 * (pow(10, freq)-1)/9 * $pi / max(slider54,1);
    k       = 2*reso;
    invTerm = 1.0 / ( 1.0 + smallg );
    G       = smallg * invTerm;
    Gsq     = G*G;
    Gsqk    = Gsq * k;
    Gk      = G*k;
  ); 

function init_ssm_nonlin(freq, reso)
  global(slider54, srate)
  local(h, K1, KOTA, C, dG, R, wrel)
  instance(hh, itau, K2, hhitau, f, rate, Kout)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;

    // Prewarping
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 20 * rate * tan( .5 * wrel * h );
    
    dG      = f;
    KOTA    = .00192;
    R       = 10000;
    K1      = R / 200;
    Kout    = 1;   
    K2      = .25*reso * 200000 / R;
    hh      = 0.5*h;
    
    itau    = KOTA*K1*dG;
    hhitau  = hh * itau;
  );   
  
function reset_ssm_nonlin()
  global()
  local()
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    D0 = D1 = D2 = D3 = Di = 0;
  ); 
  
function init_cem_nonlin(freq, reso)
  global(slider54, srate)
  local(h, K1, KOTA, C1, C2, dG1, dG2, R, wrel)
  instance(hh, itau, itau2, K2, hhitau, hhitau2, f, rate, Kout, res)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;

    // Prewarping
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 20 * rate * tan( .5 * wrel * h );
        
    dG1      = f;
    dG2      = f * 75;
    KOTA    = .00192;
    
    R       = 10000;
    K1      = R / 200;
    Kout    = 1;   
    res     = .5*reso;
    K2      = res * 200000 / R;
    hh      = 0.5*h;
    
    itau    = KOTA*K1*dG1;
    itau2   = KOTA*K1*dG2;
    hhitau  = hh * itau;
    hhitau2 = hh * itau2;
  );     
  
function reset_cem_nonlin()
  global()
  local()
  instance(hh, itau, K2, hhitau, hhitau2, itau2, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout, res, ifdbk)
  (
    D0 = D1 = D2 = D3 = Di = 0;
  );
  
function init_ssm_lin(freq, reso)
  global(slider54, srate)
  local(h, K1, KOTA, C, dG, R, wrel, rate, f, hh, hh2, hh3, hh4, itau, itau2, itau3, itau4)
  instance(x0, x1, x15, x2, x6, x7, x11, x13, x14, K2)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;

    // Prewarping
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 20 * rate * tan( .5 * wrel * h );
    
    dG      = f;
    KOTA    = .00192;
    R       = 10000;
    K1      = R / 200;
    K2      = .15*reso * 200000 / R;
    hh      = 0.5*h;
    itau    = KOTA*K1*dG;
    
    itau2   = itau*itau;
    itau3   = itau2*itau;
    itau4   = itau2*itau2;
    
    hh2     = hh*hh;
    hh3     = hh*hh2;
    hh4     = hh2*hh2;
    
    x0      = hh*itau;
    x1      = x0 + 1;
    x15     = x1*x1*x1;    
    x2      = 1/(K2*hh4*itau4 + x15*x1);
    x6      = hh3*itau3;  
    x7      = K2*x6;
    x11     = x0*x1*x1;    
    x13     = hh2*itau2*x1;
    x14     = K2*x13;
  );      
  
function reset_ssm_lin()
  global()
  local()
  instance(x0, x1, x15, x2, x6, x7, x11, x13, x14, x16, Di, D0, D1, D2, D3, U0, U1, U2, U3, K2)
  (
    D0 = D1 = D2 = D3 = Di = 0;
  );  
  
function init_cem_lin(freq, reso)
  global(slider54, srate)
  local(rate, f, h, hh, hh2, hh3, hh4, itau, itau2, hhitau, hhitau2, K1, KOTA, C1, C2, dG1, dG2, R, wrel)
  instance(res, x0, x1, x2, x3, x4, x5, x6, x11, x12, x13, x14, x15, x19, x27, x22, x23, x28, hh2, hh3, K2 )
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;
  
    // Prewarping
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 20 * rate * tan( .5 * wrel * h );
      
    dG1     = f;
    dG2     = f * 75;
    
    KOTA    = .00192;
    R       = 10000;
    K1      = R / 200;
    res     = .25*reso;
    K2      = res * 200000 / R;
    hh      = 0.5*h;
    
    itau    = KOTA*K1*dG1;
    itau2   = KOTA*K1*dG2;

    hh2     = hh*hh;
    hh3     = hh*hh2;
    hh4     = hh2*hh2;   

    x0      = K2*itau*itau*itau;
    x1      = hh*itau2;
    x2      = x1 + 1;
    x3      = hh*itau;
    x4      = x3 + 1;
    x5      = x4*x4*x4;
    x6      = 1/(hh4*itau2*x0 + x2*x5);
    x11     = itau2*hh3;
    x12     = itau*itau;
    x13     = K2*x12;
    x14     = x11*x13;
    x15     = x4*x4;
    x19     = K2*x3;
    x27     = x15*x2;
    x22     = hh2*x4;
    x23     = itau*itau2*x22;
    x28     = x2*x3*x4;
  );    
  
function reset_cem_lin()
  global()
  local()
  instance(K2, res, x0, x1, x2, x3, x4, x5, x6, x11, x12, x13, x14, x15, x19, x27, x22, x23, x28, hh2, hh3, D0, D1, D2, D3, U0, U1, U2, U3, Di)  
  (
    D0 = D1 = D2 = D3 = Di = 0;
  );
  
function init_MS20_nonlin(freq, reso)
  global(slider54)
  local()
  instance(y1, y2, d1, d2, h, hh, k, f)
  (
    f = .5 * (pow(10, freq)-1)/9 * $pi;
    h  = f / max(slider54,1);
    hh = 0.5 * h;
    k  = 2*reso;
  );

function reset_MS20_nonlin()
  global()
  local()
  instance(y1, y2, d1, d2, h, hh, k, f)
  (
    d1 = d2 = 0;
  );
  
function resetrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local()
  global()
  (
    c = b0 = b1 = b2 = a1 = a2 = d1x = d2x = d1y = d2y = 0;
  );  
  
function initphaserFET(freq, reso)
  global(srate, slider54)
  local(IDSS, Vt, Vp, Fs, Vg, Rp, Q1, g )
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    /*IDSS = .001;  // 1 mA
    Vt   = 0.025; // 25mV
    Vp   = -3;
    Vg   = - 2 - reso;
    Rp   = 1; // ?
     
    iVpsq = 1 / (Vp * Vp);
    Q1 = 2 * IDSS * (Vg-Vt) * iVpsq; 
    C2 = 1 / Rp;
    g  = 1  - exp( - 2 * $pi * freq/max(slider54,1) );
  
    thresh = Vg - Vp;
    IDSSdivVpSq = IDSS * iVpsq;
      
    // We seek C1.
    // Q1*C1 - C2*C1 = g; Eq. 24 from the paper
    C1 = g / (Q1-C2);*/
    
    C1=.5*freq/max(1,slider54);C2=1;
  );  

function initSine(f, r)
  global(srate, slider54)
  local()
  instance(freq, res, fraw)
  (
    freq  = 80 * $pi * ( ( pow(10, f) - 1 ) / 9 );
    res   = r;
    fraw  = f;
  );
 
function init_linearSVF(freq, res)
  global(srate, slider54)
  local(g, fn)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    fn = ( ( pow(10, freq) - 1 ) / 9 );
    g = tan(.5 * $pi * fn / max(slider54,1));
    k = 2 - 2*res;
    
    a1 = 1/(1+g*(g+k));
    a2 = g*a1;
    a3 = g*a2;
  );   
  
function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );  
  
function init_wasp_nonlin(freq, res)
  local(a, h)
  global(slider54, srate)
  instance(nl, hah, hahnl, rate, wrel, f, r, offset)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;
  
    // Prewarping
    offset  = 0.01;
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 40 * rate * tan( .5 * wrel * h );
    r       = .8-.6*res;
    nl      = .35;
    a       = .08 * f;
    hah     = .5*a*h;
    hahnl   = hah*nl;
  );
  
  
function reset_wasp_nonlin()
  global()
  local()
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  (
    Di = D1 = D2 = 0;
  );
  
function init_wasp_nonlin_saw(freq, res)
  local(a, h)
  global(slider54, srate)
  instance(nl, hah, hahnl, rate, wrel, f, r, offset)
  (
    rate    = srate * max(slider54,1);
    h       = 1.0 / rate;
  
    // Prewarping
    offset  = .4+res*.4;
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 40 * rate * tan( .5 * wrel * h );
    r       = .8-.6*res;
    nl      = .35;
    a       = .08 * f;
    hah     = .5*a*h;
    hahnl   = hah*nl;
  );  

function reset_wasp_nonlin_saw()
  global()
  local()
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  (
    Di = D1 = D2 = 0;
  );  
  
function clamp(x)
(
  x = 0.8 * x;
  y = 0.5 * (abs(x + 1) - abs(x - 1));
  x = y + .3*(x-y);
  //x = 1.5 * x - 0.5 * x * x * x;
  x = 1.25 * x;
);
  
function Dclamp(x)
(
  1
);  
  
function eval_wasp_nonlin_extrareso(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    offset  = 0.1;
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + tanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl)*(1-.8*V2);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );  
  
function eval_wasp_nonlin_realatanh(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = tanh(D1*nl+offset);
    td2nl   = tanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = tanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = tanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + tanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = tanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );
  
function eval_wasp_nonlin_expensive(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + fasttanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );  
  
function eval_wasp_nonlin(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = fasttanh(V1*nl+offset);
    tv2nl   = fasttanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)); // fasttanh ignored
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
       
      clterm  = nl*(Vi + resclamp - tv2nl); // nonlinearity ignored around whole eq
      clterm2 = clterm;           // nonlinearity ignored around whole eq
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + tv1nl); // nonlinearity ignored around tv1nl

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V2;
  );    
  
function eval_wasp_nonlin_BP(Vi)
  local(idet, Ja, Jb, Jc, tv1nl, tv2nl, ttd1nl, td1nl, td2nl, shrterm, fixterm, clterm, clterm2, V1, V2, f0, f1, resclamp)
  instance(nl, hah, hahnl, D2, D1, Di, r, offset)
  global()
  ( 
    Vi      = clamp(Vi);
    tv1nl   = tanh(V1*nl+offset);
    tv2nl   = tanh(V2*nl+offset);
    td1nl   = fasttanh(D1*nl+offset);
    td2nl   = fasttanh(D2*nl+offset);    
    ttd1nl  = tanh(td1nl);
    fixterm = fasttanh(fasttanh(nl*(Di + clamp(-r*td1nl) - td2nl)));
    
    loop(3,
      resclamp= clamp(-r*tv1nl);
      
      clterm  = fasttanh(nl*(Vi + resclamp - tv2nl));
      clterm2 = fasttanh(clterm);
      f0      = -D1 + V1 - hah*(fixterm + clterm2);
      f1      = -D2 + V2 - hah*(ttd1nl + fasttanh(tv1nl));

      shrterm = hahnl*nl*(1-clterm*clterm)*(1-clterm2*clterm2);
      Jb      = shrterm*(1-tv2nl*tv2nl);      
      Ja      = r*shrterm*(1-tv1nl*tv1nl)*Dclamp(-r*tv1nl) + 1;
      Jc      = -hahnl*(1-tv1nl*tv1nl)*(1-tv1nl*tv1nl);
      
      idet    = 1.0 / (Ja - Jb*Jc);
      V1      = V1 - (-Jb*f1 + f0)*idet;
      V2      = V2 - (Ja*f1 - Jc*f0)*idet;
      
      tv1nl   = fasttanh(V1*nl);
      tv2nl   = tanh(V2*nl);
    );
    
    // Forced to do this to keep things stable :(
    V1        = clamp(V1);
    V2        = clamp(V2);
    
    Di = Vi;
    D1 = V1;
    D2 = V2;
    
    -V1;
  );  
  
function init_wasplin(freq, res)
  global(srate, slider54)
  local(f, h, hh, itau, wrel, rate)
  instance(U0, U1, Di, D0, D1, x0, x1, x2, x3, i1, K2)
  (
    rate    = (srate * max(slider54,1));
    wrel    = 2 * $pi * 22050 * ( ( pow(10, freq) - 1 ) / 9 );
    f       = 20 * rate * tan( .5 * wrel * h );
    h       = 1.0 / rate;
    hh      = 0.5 * h;
    itau    = .08 * f;
    K2      = .8-.6*res;
    
    x0 = hh*itau;
    x1 = 2*x0;
    x2 = K2*x1;
    x3 = 4*x0*x0;
    i1 = 1.0/(x2 + x3 + 1);
  );
  
function reset_wasplin()
  global()
  local()
  instance(U0, U1, Di, D0, D1, x0, x1, x2, x3, i1)
  (
    U0 = U1 = Di = D0 = D1 = x0 = x1 = x2 = x3 = i1 = 0;
  );
  
function resetphaserFET()
  global()
  local()
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    dw = dx = 0;
  ); 
  

// Generate windowed sinc filter at memory location FIR
// Inputs are:
//    fir   - Memory location to store windowed sinc
//    nt    - Number of taps
//    bw    - Fractional bandwidth
//     g    - Gain
function sinc(fir, nt, bw, g)
  local(a, ys, yg, yw, i, pibw2, pifc2, pidnt2, hnt)
  global()
  (
    pibw2   = 2.0*$pi*bw;
    pidnt2  = 2.0*$pi/nt;
    hnt     = 0.5*nt;
    i       = 1;
        
    loop(nt-1,
      // Sinc width
      a  = (i - hnt) * pibw2;
        
      // Sinc
      ys = (a != 0) ? sin(a)/a : 1.0;
 
      // Window gain
      yg = g * (4.0 * bw);
        
      // Hamming window (could be replaced with Kaiser in the future)
      yw = 0.54 - 0.46 * cos(i * pidnt2);
         
      // Calc FIR coeffs
      fir[i-1] = yw * yg * ys;
      
      i += 1;
    );
  );

// Generate sinc filters for a specific upsampling ratio
//
// Upsampling leads to a sample followed by N-1 zeroes. Hence 
// to compute each subsample, we only need 1/Nth of the taps.
// This is why we set up a specific filter for each subsample.
// i.e. for N=4, you get something like f1*Zn + f5*Zn-1 + ...
//
// Inputs:
//    N_in            - oversampling factor
//    tapsPerFilter   - Taps per subfilter (should be 8 in this implementation)
//    targetmem       - Location to store the coefficients
//    tmp             - Working memory
function updateSincFilter(N_in, tapsPerFilter, targetmem, tmp)
  local(nHist, iFilt, nTaps)
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N, delta)
  global()
  (
    N       = N_in;
    nHist   = tapsPerFilter;
    loc     = 0;
    coeffs  = targetmem;
    nTaps   = N*nHist;
    
    // Memory being set is conservatively large.
    memset(coeffs,0,10000);
    memset(tmp,0,10000);
    
    sinc(tmp, nTaps, .5/N, .5*N);
    
    // Divide sinc over the different filters
    iFilt = 0; // Filter idx for which subsample this filter is
    delta = 0; // Sample idx
    loop(nTaps,
      coeffs[delta + iFilt*100] = tmp[];
      iFilt += 1;
      iFilt == N ? ( iFilt = 0; delta += 1 );
      tmp += 1;
    );
  );

// Generate downsample filter
// Here, the full N*nHist tap filter has to be evaluated for every sample, 
// but only every Nth sample has to be evaluated.
function updateSincDownsampleFilter(N_in, nTaps_in, histmem, coeffmem)
  global()
  instance(hist, hend, hptr, coeffs, loc, N, delta, nTaps)
  local()
  (
    N       = N_in;
    hist    = histmem;
    coeffs  = coeffmem;
    nTaps   = nTaps_in;
    hptr    = hist;
    hend    = hist + nTaps;
    
    memset(coeffs,0,10000);
    sinc(coeffs, nTaps, .5/N, .5);
  );
  
function advanceHist(sample)
  global()
  instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
  local(nHist, nTaps)
  (
    hptr += 1;
    ( hptr == hend ) ? hptr = hist;
    hptr[] = sample;
  );

function sincDownSample()
  global()
  instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
  local(nHist, hm1, hptr2, out, cfptr)
  (
    hm1   = hist-1;
    hptr2 = hptr;
    cfptr = coeffs;
    out   = 0;
    
    loop(nTaps,
      out = out + hptr2[] * cfptr[];
      
      cfptr += 1;
      hptr2 -= 1;
      ( hptr2 == hm1 ) ? hptr2 = hend-1;
    );
    
    out
  );

function resetSincDown()
  global()
  instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
  local(nHist, hm1, hptr2)
  (
    hm1   = hist-1;
    hptr2 = hptr;
    
    loop(nTaps,
      hptr2[] = 0;
      
      hptr2 -= 1;
      ( hptr2 == hm1 ) ? hptr2 = hend-1;
    );
  );

// Maintain input sample history. Hardcoded for speed.
// Note h7 is omitted because for integer upsampling it is always zero!
function advanceSinc(sample)
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
  global()
  local(filt)
  (
    h6 = h5;
    h5 = h4;
    h4 = h3;
    h3 = h2;
    h2 = h1;
    h1 = h0;
    h0 = sample;
    loc = 0;
  );

function resetSincUp()
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
  global()
  local(filt)
  (
    h0 = h1 = h2 = h3 = h4 = h5 = h6 = 0;
  );

// Note h7 is omitted because for integer upsampling it is always zero!
function getSubSample()
  instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
  global()
  local(filt, out)
  (
    filt = coeffs + loc;

    //out = filt[] * h0 + (filt+=1)[] * h1 + (filt+=1)[] * h2 + (filt+=1)[] * h3 + (filt+=1)[] * h4 + (filt+=1)[] * h5 + (filt+=1)[] * h6;
    out =  filt[] * h0 + filt[1] * h1 + filt[2] * h2 + filt[3] * h3 + filt[4] * h4 + filt[5] * h5 + filt[6] * h6;

    loc += 100;
    out
  );
 
// IIR RBJ based up/down sampling
function updateFilter(newlen)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (Q, sc, pos, cpos, spos, alpha)
  global ()
  (  
    ( newlen != len ) ?
    (
      len   = newlen;
      Q     = 0.707;
      pos   = 0.85 / len * $pi;
      cpos  = cos(pos);
      spos  = sin(pos);
      alpha = spos/(2.0*Q);
       
      sc    = 1.0 / (1+alpha);
      a1    = -2 * cpos * sc;
      a2    = (1-alpha) * sc;
      b1    = (1-cpos) * sc;
      b2    = b0 = b1 * 0.5;
    
      // Input taps
      d1 = d2 = d3 = d4 = 0;
      
      // Output taps
      o1 = o2 = o3 = o4 = 0;
    )
  );

function inputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out  = sample*b0 + d1*b1 + d2*b2 - d3*a1 - d4*a2;
    d2   = d1;
    d1   = sample;
    d4   = d3;
    d3   = out;
  );
  
function resetioFilter()
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    d1 = d2 = d3 = d4 = o1 = o2 = o3 = o4 = 0;
  );

function outputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out = sample*b0 + o1*b1 + o2*b2 - o3*a1 - o4*a2;
    o2  = o1;
    o1  = sample;
    o4  = o3;
    o3  = out;
  );
  
function getHz(f)
  global(srate, slider47, slider54, lastFilterReso, lastFilterFreq, hzin)
  local(outHz, f)
  instance()
  (
    outHz = 0;
    hzin = f;
      ( slider47 == 1 ) ? (
        outHz = pow(0.5, (128-f*128) / 16.0)*srate/$pi;
      ) : ( slider47 == 2 ) ? (
        //outHz = (pow(10, f)-1)/9 * srate / 8;
        outHz = 0;
        //L.filter_303.init303(filterFreq, filterReso);
        //R.filter_303.init303(filterFreq, filterReso);
      ) : ( slider47 == 3 ) ? (
        outHz = 0;
      ) : ( slider47 == 4 ) ? (
        //outHz = pow(0.5, (128-f*128) / 16.0) * srate / (2*$pi);
        outHz = 0;
      ) : ( slider47 == 5 ) ? (
        //outHz = pow(0.5, (128-f*128) / 16.0) * srate / (2*$pi);
        outHz = 0;
      ) : ( slider47 == 6 ) ? (
        outHz = srate * (pow(10, f)-1)/9 / 2.185; // dualFilt LP
      ) : ( slider47 == 7 ) ? (
        outHz = srate * (pow(10, f)-1)/9 / 2.25; // dualFilt HP
      ) : ( slider47 == 8 ) ? (
        outHz = srate * (pow(10, f)-1)/9 / 2.058; // dualFilt BP
      ) : ( slider47 == 9 || slider47 == 10 ) ? (
        outHz = srate * (pow(10, f)-1)/9 / 1.75; // moogs
      ) : ( slider47 == 11 ) ? (
        outHz = .5 * srate * (pow(10, f)-1)/9; // notch
      ) : ( slider47 == 12 ) ? (
        outHz = 1111*(pow(10, f)-1)/9 + 440; // narsty
      ) : ( slider47 == 13 ) ? (
        outHz = 0; // modulator   
      ) : ( slider47 == 14 ) ? (
        outHz = 0; // Phaser
      ) : ( slider47 == 15 ) ? (
        outHz=.025*f*srate; // Phaser
      ) : ( slider47 == 16 ) ? (
        outHz = 0;
      ) : ( slider47 == 17 ) ? (
        outHz = 0;
      ) : ( slider47 == 18 ) ? (
        outHz = .5 * srate * (pow(10, f)-1)/9; // ms-20 linear
      ) : ( slider47 == 19 ) ? (
        outHz = .5 * srate * (pow(10, f)-1)/9; // ms-20 linear
      ) : ( slider47 == 20 ) ? (
        outHz = .5 * srate * (pow(10, f)-1)/9; // ms-20 linear
      ) : ( slider47 == 21 ) ? (
        outHz = .227 * srate * (pow(10, f)-1)/9; // ms-20 non-linear LP
      ) : ( slider47 == 22 ) ? (
        outHz = .227 * srate * (pow(10, f)-1)/9; // ms-20 non-linear BP
      ) : ( slider47 == 23 ) ? (
        outHz = .227 * srate * (pow(10, f)-1)/9; // ms-20 non-linear HP
      ) : ( slider47 == 24 ) ? (
        outHz = 0; // Experimental (untuneable)
      ) : ( slider47 == 25 ) ? (
        outHz = .215 * srate * (pow(10, f)-1)/9; // strange thing based on ms-20
      ) : ( slider47 == 26 ) ? (
        outHz = 2 * .203 * srate * (pow(10, f)-1)/9; // ssm
      ) : ( slider47 == 27 ) ? (
        outHz = 2 * .203 * srate * (pow(10, f)-1)/9; // ssm
      ) : ( slider47 == 28 ) ? (
        outHz = 2 * .3333 * srate * (pow(10, f)-1)/9; // cem (very approximate)
      ) : ( slider47 == 29 ) ? (
        outHz = .444 * srate * (pow(10, f)-1)/9; // ssm linear
      ) : ( slider47 == 30 ) ? (
        outHz = .716 * srate * (pow(10, f)-1)/9; // cem linear
      ) : ( slider47 == 31 ) ? (
        outHz = 0; // Unclear, no resonant peak
      ) : ( slider47 == 32 ) ? (
        outHz = 0; // Unclear, no resonant peak
      ) : ( slider47 == 33 ) ? (
        outHz = 0.135 * srate * (pow(10, f)-1)/9; // very rough (poorly tuned)
      ) : ( slider47 == 34 ) ? (
        outHz = 0; // Too inaccurate
      ) : ( slider47 == 35 ) ? ( 
        outHz = 0; // Too inaccurate
      ) : ( slider47 == 36 ) ? (
        outHz = .77 * srate * ( ( pow(10, f) - 1 ) / 9 ); // Wasp linear
      ) : ( slider47 == 37 ) ? (
        outHz = 0; // Too inaccurate
      ) : ( slider47 == 38 ) ? (
        outHz = 0; // Too inaccurate
      ) : ( ( slider47 > 38 ) && ( slider47 < 44 ) ) ? (
        outHz = .5 * ( ( pow(10, f) - 1 ) / 9 ) * srate;
      ) : ( slider47 == 44 ) ? (
        outHz = 0; // Too inaccurate
      ) : ( slider47 == 45 ) ? (
        outHz = .5 * ( ( pow(10, f) - 1 ) / 9 ) * srate;
      ) : ( slider47 == 46 ) ? (
        outHz = .5 * ( ( pow(10, f) - 1 ) / 9 ) * srate;
      ) : ( slider47 == 47 ) ? (
        outHz = .5 * ( ( pow(10, f) - 1 ) / 9 ) * srate;
      ) : ( slider47 == 48 ) ? (
        outHz = 0; // comb (inaccurate)
      ) : ( slider47 == 49 ) ? (
        outHz = .5 * ( ( pow(10, f) - 1 ) / 9 ) * srate; // combed resonance
      ) : ( slider47 == 50 ) ? (
        outHz = .5 * ( ( pow(10, f) - 1 ) / 9 ) * srate; // combed resonance
      );
      
      outHz
  );  
  
function updateActiveFilters( force )
  (
    // Lerping
    sliderCutoff  = sliderCutoff + dCutoff;
    sliderReso    = sliderReso + dReso;
    
    modval = filterDynamics * dynval + modulator.modvalue * slider39;
    filterFreq = max( 0, min( 1, sliderCutoff + dyn_mod_filt * modval ) );
    filterReso = max( 0, min( 1, sliderReso + dyn_mod_reso * modval ) );
    updateFiltersNow = ( filterFreq != lastFilterFreq ) || ( filterReso != lastFilterReso ) || force;
    
    pregain  = 2^((slider52 + 40 * dyn_mod_gain * modval)/6);
    postgain = 2^(slider53/6);
    gaincompensation = 1/pregain;
    
    ( updateFiltersNow && slider47 > 0 ) ? (
      lastFilterReso = filterReso;
      lastFilterFreq = filterFreq;
    
      ( slider47 == 1 ) ? (
        L.rc_filter.initRC(filterFreq, filterReso);
        R.rc_filter.initRC(filterFreq, filterReso);
      ) : ( slider47 == 2 ) ? (
        L.filter_303.init303(filterFreq, filterReso);
        R.filter_303.init303(filterFreq, filterReso);
      ) : ( slider47 == 3 ) ? (
        L.filter_vowel.initvowel(filterFreq, filterReso);
        R.filter_vowel.initvowel(filterFreq, filterReso);
      ) : ( slider47 == 4 ) ? (
        L.filter_karlsen.initkarlsen(filterFreq, filterReso);
        R.filter_karlsen.initkarlsen(filterFreq, filterReso);
      ) : ( slider47 == 5 ) ? (
        L.filter_karlsen_sat.initkarlsen_sat(filterFreq, filterReso);
        R.filter_karlsen_sat.initkarlsen_sat(filterFreq, filterReso);
      ) : ( slider47 == 6 ) ? (
        ( slider54 < 2 ) ? ( 
          slider54 = 2;
          slider_automate(slider54);
          forceUpdate = 1;
        );
        L.filter_dualfilt.initdualfilt(filterFreq, filterReso);
        R.filter_dualfilt.initdualfilt(filterFreq, filterReso);
      ) : ( slider47 == 7 ) ? (
        ( slider54 < 2 ) ? ( 
          slider54 = 2;
          slider_automate(slider54);
          forceUpdate = 1;
        );      
        L.filter_dualfiltHP.initdualfilt(filterFreq, filterReso);
        R.filter_dualfiltHP.initdualfilt(filterFreq, filterReso);
      ) : ( slider47 == 8 ) ? (
        ( slider54 < 2 ) ? ( 
          slider54 = 2;
          slider_automate(slider54);
          forceUpdate = 1;
        );      
        L.filter_dualfiltBP.initdualfilt(filterFreq, filterReso);
        R.filter_dualfiltBP.initdualfilt(filterFreq, filterReso);
      ) : ( slider47 == 9 || slider47 == 10 ) ? (
        ( slider54 < 2 ) ? ( 
          slider54 = 2;
          slider_automate(slider54);
          forceUpdate = 1;
          );
        ( slider56 == 0 || slider56 == 4 ) ? (
          slider56 = 3;
          slider_automate(slider56);
          forceUpdate = 1;
        );
        L.filter_fancymoog.initfancymoog(filterFreq, filterReso);
        R.filter_fancymoog.initfancymoog(filterFreq, filterReso);
      ) : ( slider47 == 11 ) ? (
        L.filter_notch.initnotch(filterFreq, filterReso);
        R.filter_notch.initnotch(filterFreq, filterReso);
      ) : ( slider47 == 12 ) ? (
        L.filter_sai0.initsai0(filterFreq, filterReso);
        R.filter_sai0.initsai0(filterFreq, filterReso);
        ( slider56 == 3 ) ? (
          slider56 = 1;
          slider_automate(slider56);
          forceUpdate = 1;
        );
      ) : ( slider47 == 13 ) ? (
        L.filter_modulator.initmodulator(filterFreq, filterReso);
        R.filter_modulator.initmodulator(filterFreq, filterReso);      
      ) : ( slider47 == 14 ) ? (
        L.filter_phaser.initphaserOTA(filterFreq, filterReso);
        L.filter_phaser2.initphaserOTA(filterFreq*2, filterReso);
        L.filter_phaser3.initphaserOTA(filterFreq/2, filterReso);
        L.filter_phaser4.initphaserOTA(filterFreq/3, filterReso);
        R.filter_phaser.initphaserOTA(filterFreq, filterReso);
        R.filter_phaser2.initphaserOTA(filterFreq*2, filterReso);
        R.filter_phaser3.initphaserOTA(filterFreq/2, filterReso);
        R.filter_phaser4.initphaserOTA(filterFreq/3, filterReso);      
      ) : ( slider47 == 15 ) ? (
        L.filter_phaser.initphaserFET(filterFreq, filterReso);
        L.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
        L.filter_phaser3.initphaserFET(filterFreq/2, filterReso);
        L.filter_phaser4.initphaserFET(filterFreq/3, filterReso);
        R.filter_phaser.initphaserFET(filterFreq, filterReso);
        R.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
        R.filter_phaser3.initphaserFET(filterFreq/2, filterReso);
        R.filter_phaser4.initphaserFET(filterFreq/3, filterReso);
      ) : ( slider47 == 16 ) ? (
        L.filter_dualfilt.initdualfilt(filterFreq, filterReso);
        R.filter_dualfilt.initdualfilt(filterFreq, filterReso);
        filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq * 1000);
        filter_delay2.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*filterReso * 2000);
      ) : ( slider47 == 17 ) ? (
        L.filter_dualfilt.initdualfilt(filterFreq, filterReso);
        R.filter_dualfilt.initdualfilt(filterFreq, filterReso);
        filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq*(1000+4000*filterReso));
        filter_delay2.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*filterFreq*(1000+4000*filterReso));
      ) : ( slider47 == 18 ) ? (
        L.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
        R.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
      ) : ( slider47 == 19 ) ? (
        L.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
        R.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
      ) : ( slider47 == 20 ) ? (
        L.filter_ms20lin.init_MS20lin(filterFreq, filterReso);
        R.filter_ms20lin.init_MS20lin(filterFreq, filterReso);            
      ) : ( slider47 == 21 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      ) : ( slider47 == 22 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      ) : ( slider47 == 23 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
      ) : ( slider47 == 24 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        L.filter_phaser.initphaserFET(filterFreq, filterReso);
        L.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
        R.filter_phaser.initphaserFET(filterFreq, filterReso);
        R.filter_phaser2.initphaserFET(filterFreq*2, filterReso);
        L.filter_delay.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterReso * 50);
        R.filter_delay.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*filterReso * 51);  
      ) : ( slider47 == 25 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);      
      ) : ( slider47 == 26 ) ? (
        L.filter_ssm.init_ssm_nonlin(filterFreq, filterReso);
        R.filter_ssm.init_ssm_nonlin(filterFreq, filterReso);  
      ) : ( slider47 == 27 ) ? (
        L.filter_ssm.init_ssm_nonlin(filterFreq, filterReso);
        R.filter_ssm.init_ssm_nonlin(filterFreq, filterReso);  
      ) : ( slider47 == 28 ) ? (
        L.filter_cem.init_cem_nonlin(filterFreq, filterReso);
        R.filter_cem.init_cem_nonlin(filterFreq, filterReso);
      ) : ( slider47 == 29 ) ? (
        L.filter_ssm_lin.init_ssm_lin(filterFreq, filterReso);
        R.filter_ssm_lin.init_ssm_lin(filterFreq, filterReso);         
      ) : ( slider47 == 30 ) ? (
        L.filter_cem_lin.init_cem_lin(filterFreq, filterReso);
        R.filter_cem_lin.init_cem_lin(filterFreq, filterReso);
      ) : ( slider47 == 31 ) ? (
        L.filter_sine.initSine(filterFreq, filterReso);
        R.filter_sine.initSine(filterFreq, filterReso);
      ) : ( slider47 == 32 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);       
        L.filter_sine.initSine(filterFreq, filterReso);
        R.filter_sine.initSine(filterFreq, filterReso);      
      ) : ( slider47 == 33 ) ? (
        L.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);
        R.filter_ms20.init_MS20_nonlin(filterFreq, filterReso);    
        L.filter_sine.initSine(filterFreq, filterReso);
        R.filter_sine.initSine(filterFreq, filterReso);
      ) : ( slider47 == 34 ) ? (
        L.filter_broken.init_MS20_nonlin(.5*filterFreq, filterReso);
        R.filter_broken.init_MS20_nonlin(.5*filterFreq, filterReso);        
      ) : ( slider47 == 35 ) ? (
        //L.filter_wasp2.init_ssm_nonlin(.5*filterFreq, filterReso);
        //R.filter_wasp2.init_ssm_nonlin(.5*filterFreq, filterReso); 
        L.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
        R.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
      ) : ( slider47 == 36 ) ? (
        L.filter_wasp_lin.init_wasplin(filterFreq, filterReso);
        R.filter_wasp_lin.init_wasplin(filterFreq, filterReso);
      ) : ( slider47 == 37 ) ? (
        L.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
        R.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
      ) : ( slider47 == 38 ) ? (
        L.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
        R.filter_wasp.init_wasp_nonlin(filterFreq, filterReso);
      ) : ( ( slider47 > 38 ) && ( slider47 < 44 ) ) ? (
        L.filter_SVF.init_linearSVF( filterFreq, filterReso );
        R.filter_SVF.init_linearSVF( filterFreq, filterReso );      
      ) : ( slider47 == 44 ) ? (
        L.filter_wasp.init_wasp_nonlin_saw(filterFreq, filterReso);
        R.filter_wasp.init_wasp_nonlin_saw(filterFreq, filterReso);
      ) : ( slider47 == 45 ) ? (
        L.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        R.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        L.filter_SVF.init_linearSVF( filterFreq, filterReso );
        R.filter_SVF.init_linearSVF( filterFreq, filterReso );  
      ) : ( slider47 == 46 ) ? (
        L.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        R.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        L.filter_SVF.init_linearSVF( filterFreq, filterReso );
        R.filter_SVF.init_linearSVF( filterFreq, filterReso );  
      ) : ( slider47 == 47 ) ? (
        L.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        R.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        L.filter_SVF.init_linearSVF( filterFreq, filterReso );
        R.filter_SVF.init_linearSVF( filterFreq, filterReso );  
        L.filter_SVF2.init_linearSVF( filterFreq*.5, filterReso*.5 );
        R.filter_SVF2.init_linearSVF( filterFreq*.5, filterReso*.5 );
        L.filter_delay1.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*(400*filterReso));      
        R.filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*(400*filterReso));
      ) : ( slider47 == 48 ) ? (
        L.chan = 0;
        R.chan = 1;
        val = ( pow(10, filterFreq) - 1 ) / 9;
        L.stereoize = filterReso > 0.5 ? 1 : 0;
        R.stereoize = filterReso > 0.5 ? 1 : 0;
        L.filter_delay.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*val * 250);
        R.filter_delay.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*val * 250);  
      ) : ( slider47 == 49 ) ? (
        L.chan = 0;
        R.chan = 1;
        val = ( pow(10, filterFreq) - 1 ) / 9;
        
        L.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        R.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        L.filter_SVF.init_linearSVF( filterFreq, filterReso );
        R.filter_SVF.init_linearSVF( filterFreq, filterReso );  
         
        L.filter_delay.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*val * 250);
        R.filter_delay.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*val * 250);  
      ) : ( slider47 == 50 ) ? (
        L.chan = 0;
        R.chan = 1;
        val = ( pow(10, filterFreq) - 1 ) / 9;
        L.stereoize = filterReso;
        R.stereoize = filterReso;
        
        L.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        R.filter_SVF_nores.init_linearSVF( filterFreq, 0 );
        L.filter_SVF.init_linearSVF( filterFreq, filterReso );
        R.filter_SVF.init_linearSVF( filterFreq, filterReso );  
         
        L.filter_delay.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*val * 250);
        R.filter_delay.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*val * 250);  
      );
    );
  );
 
function resetActiveFilters()
  (
    // Reset the offset correction
    otm1 = otm2 = itm1 = itm2 = 0;
  
    // Reset up and downsampling filters
    sincFilterL.resetSincUp();
    sincFilterR.resetSincUp();
    sincDownL.resetSincDown();
    sincDownR.resetSincDown();
    filterL.resetioFilter();
    filterR.resetioFilter();
  
    maxOversampling = 8;
    ( slider47 == 1 ) ? (
      gfx_printf( " " );
    ) : ( slider47 == 2 ) ? (
      L.filter_303.reset303();
      R.filter_303.reset303();
    ) : ( slider47 == 3 ) ? (
      L.filter_moog.resetmoog();
      R.filter_moog.resetmoog();
    ) : ( slider47 == 4 ) ? (
      L.filter_karlsen.resetkarlsen();
      R.filter_karlsen.resetkarlsen();      
    ) : ( slider47 == 5 ) ? (
      L.filter_karlsen_sat.resetkarlsen_sat();
      R.filter_karlsen_sat.resetkarlsen_sat();      
    ) : ( slider47 == 6 ) ? (
      L.filter_dualfilt.resetdualfilt();
      R.filter_dualfilt.resetdualfilt();      
    ) : ( slider47 == 7 ) ? (
      L.filter_dualfiltHP.resetdualfilt();
      R.filter_dualfiltHP.resetdualfilt();      
    ) : ( slider48 == 8 ) ? (
      L.filter_dualfiltBP.resetdualfilt();
      R.filter_dualfiltBP.resetdualfilt();      
    ) : ( slider47 == 9 ) ? (
      L.filter_fancymoog.resetfancymoog();
      R.filter_fancymoog.resetfancymoog();      
    ) : ( slider47 == 10 ) ? (
      L.filter_fancymoog.resetfancymoog();
      R.filter_fancymoog.resetfancymoog();
    ) : ( slider47 == 11 ) ? (
      L.filter_notch.resetrbj();
      R.filter_notch.resetrbj();      
    ) : ( slider47 == 12 ) ? (
      L.filter_sai0.resetsai0(sample);
      R.filter_sai0.resetsai0(sample);      
    ) : ( slider47 == 13 ) ? (
      L.filter_modulator.resetmodulator();
      R.filter_modulator.resetmodulator();      
    ) : ( slider47 == 14 ) ? (
      os = 0; jnk = 0;
      L.filter_phaser.resetphaserOTA();
      R.filter_phaser.resetphaserOTA();      
    ) : ( slider47 == 15 ) ? (
      os = 0;
      L.filter_phaser.resetphaserFET();
      R.filter_phaser.resetphaserFET();
    ) : ( slider47 == 16 ) ? (
      os1 = os2 = ys1 = 0;
      L.filter_dualfilt.resetdualfilt();
      R.filter_dualfilt.resetdualfilt();
    ) : ( slider47 == 17 ) ? (
      os1 = os2 = os3 = 0;
      L.filter_dualfilt.resetdualfilt();
      R.filter_dualfilt.resetdualfilt();
    ) : ( slider47 == 18 ) ? (
      L.filter_ms20lin.reset_MS20lin();
      R.filter_ms20lin.reset_MS20lin();
    ) : ( slider47 == 19 ) ? (
      L.filter_ms20lin.reset_MS20lin();
      R.filter_ms20lin.reset_MS20lin();
    ) : ( slider47 == 20 ) ? (
      L.filter_ms20lin.reset_MS20lin();
      R.filter_ms20lin.reset_MS20lin();
    ) : ( slider47 == 21 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();
    ) : ( slider47 == 22 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();
    ) : ( slider47 == 23 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();
    ) : ( slider47 == 24 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();
      L.filter_phaser.resetphaserFET();
      L.filter_phaser2.resetphaserFET();
      R.filter_phaser.resetphaserFET();
      R.filter_phaser2.resetphaserFET();
    ) : ( slider47 == 25 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();      
    ) : ( slider47 == 26 ) ? (
      L.filter_ssm.reset_ssm_nonlin();
      R.filter_ssm.reset_ssm_nonlin();        
    ) : ( slider47 == 27 ) ? (
      L.filter_ssm.reset_ssm_nonlin();
      R.filter_ssm.reset_ssm_nonlin();        
    ) : ( slider47 == 28 ) ? (
      L.filter_cem.reset_cem_nonlin();
      R.filter_cem.reset_cem_nonlin();      
    ) : ( slider47 == 29 ) ? (
      L.filter_ssm_lin.reset_ssm_lin();
      R.filter_ssm_lin.reset_ssm_lin();         
    ) : ( slider47 == 30 ) ? (
      L.filter_cem_lin.reset_cem_lin();
      R.filter_cem_lin.reset_cem_lin();
    ) : ( slider47 == 32 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();       
      //L.filter_sine.resetSine();
      //R.filter_sine.resetSine();      
    ) : ( slider47 == 33 ) ? (
      L.filter_ms20.reset_MS20_nonlin();
      R.filter_ms20.reset_MS20_nonlin();    
      //L.filter_sine.resetSine();
      //R.filter_sine.resetSine();
    ) : ( slider47 == 34 ) ? (
      L.filter_broken.reset_MS20_nonlin();
      R.filter_broken.reset_MS20_nonlin();       
    ) : ( slider47 == 35 ) ? (
      L.filter_wasp.reset_wasp_nonlin();
      R.filter_wasp.reset_wasp_nonlin();
    ) : ( slider47 == 36 ) ? (
      L.filter_wasp_lin.reset_wasplin();
      R.filter_wasp_lin.reset_wasplin();
    ) : ( slider47 == 37 ) ? (
      L.filter_wasp.reset_wasp_nonlin();
      R.filter_wasp.reset_wasp_nonlin();
    ) : ( slider47 == 38 ) ? (
      L.filter_wasp.reset_wasp_nonlin();
      R.filter_wasp.reset_wasp_nonlin();
    ) : ( ( slider47 > 38 ) && ( slider47 < 44 ) ) ? (
      L.filter_SVF.reset_linearSVF( );
      R.filter_SVF.reset_linearSVF( );      
    ) : ( slider47 == 44 ) ? (
      L.filter_wasp.reset_wasp_nonlin_saw();
      R.filter_wasp.reset_wasp_nonlin_saw();
    ) : ( slider47 == 45 ) ? (
      L.filter_SVF_nores.reset_linearSVF();
      R.filter_SVF_nores.reset_linearSVF();
      L.filter_SVF.reset_linearSVF();
      R.filter_SVF.reset_linearSVF();  
    ) : ( slider47 == 46 ) ? (
      L.filter_SVF_nores.reset_linearSVF();
      R.filter_SVF_nores.reset_linearSVF();
      L.filter_SVF.reset_linearSVF();
      R.filter_SVF.reset_linearSVF();  
    ) : ( slider47 == 47 ) ? (
      L.filter_SVF_nores.reset_linearSVF();
      R.filter_SVF_nores.reset_linearSVF();
      L.filter_SVF.reset_linearSVF();
      R.filter_SVF.reset_linearSVF();  
      L.filter_SVF2.reset_linearSVF();
      R.filter_SVF2.reset_linearSVF();
      
      L.filter_delay1.clearBuffer();
      R.filter_delay1.clearBuffer();
    ) : ( slider47 == 48 ) ? (
      L.filter_delay.clearBuffer();
      R.filter_delay.clearBuffer();
    ) : ( slider47 == 49 ) ? (
      L.filter_SVF_nores.reset_linearSVF();
      R.filter_SVF_nores.reset_linearSVF();
      L.filter_SVF.reset_linearSVF();
      R.filter_SVF.reset_linearSVF();  
       
      L.filter_delay.clearBuffer();
      R.filter_delay.clearBuffer();
    ) : ( slider47 == 50 ) ? (
      L.filter_SVF_nores.reset_linearSVF();
      R.filter_SVF_nores.reset_linearSVF();
      L.filter_SVF.reset_linearSVF();
      R.filter_SVF.reset_linearSVF();
       
      L.filter_delay.clearBuffer();
      R.filter_delay.clearBuffer();
    );
    
  );

itm1=itm2=otm1=otm2=0;
forceUpdate=0;

movavgLN = 0;
movavgLP = 0;
movavgRN = 0;
movavgRP = 0;

updateActiveFilters(1);

function setN(S, N)
local(changed)
global(slider1, slider2)
(
  ( S == 1 ) ? (
    slider1=N; slider_automate(slider1);
  )
  : ( S == 2 ) ? (
    slider2=N; slider_automate(slider2);
  );
);

function manipulateXYSliders(S, i, x, y)
(
  // gfx_set(1,1,1,1);
  // gfx_x=0;
  // gfx_y=50;
  // gfx_printf("HEY %d, %d, %f, %f", S, i, x, y);
  (S == 2) ? (
     (i==1) ? ( slider3=x;  slider_automate(slider3);  slider4=y;  slider_automate(slider4);  )
    :(i==2) ? ( slider5=x;  slider_automate(slider5);  slider6=y;  slider_automate(slider6);  )
    :(i==3) ? ( slider7=x;  slider_automate(slider7);  slider8=y;  slider_automate(slider8);  )
    :(i==4) ? ( slider9=x;  slider_automate(slider9);  slider10=y; slider_automate(slider10); )
    :(i==5) ? ( slider11=x; slider_automate(slider11); slider12=y; slider_automate(slider12); )
    :(i==6) ? ( slider13=x; slider_automate(slider13); slider14=y; slider_automate(slider14); )
    :(i==7) ? ( slider15=x; slider_automate(slider15); slider16=y; slider_automate(slider16); )
    :(i==8) ? ( slider17=x; slider_automate(slider17); slider18=y; slider_automate(slider18); )
  )
  : ( S==1 ) ? (
     (i==1) ? ( slider19=x; slider_automate(slider19); slider20=y; slider_automate(slider20); )
    :(i==2) ? ( slider21=x; slider_automate(slider21); slider22=y; slider_automate(slider22); )
    :(i==3) ? ( slider23=x; slider_automate(slider23); slider24=y; slider_automate(slider24); )
    :(i==4) ? ( slider25=x; slider_automate(slider25); slider26=y; slider_automate(slider26); )
    :(i==5) ? ( slider27=x; slider_automate(slider27); slider28=y; slider_automate(slider28); )
    :(i==6) ? ( slider29=x; slider_automate(slider29); slider30=y; slider_automate(slider30); )
    :(i==7) ? ( slider31=x; slider_automate(slider31); slider32=y; slider_automate(slider32); )
    :(i==8) ? ( slider33=x; slider_automate(slider33); slider34=y; slider_automate(slider34); )
  );
  
  forceUpdate = 1;
);

// Really dumb sorting algorithm
// Double buffered to make sure that we don't get clicks
function sort_spline()
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(last, mini, iter, tmp)
  global(gfx_x, gfx_y)
( 
  // First copy it to temp 
  ptr_from_X  = xloc_write;
  ptr_from_Y  = yloc_write;
  ptr_to_X    = tempx;
  ptr_to_Y    = tempy;
  ptr_to_Z    = tempz;
  iter        = 0;
  loop(N_write,
    ptr_to_X[] = ptr_from_X[];
    ptr_to_X += 1; ptr_from_X += 1;
    ptr_to_Y[] = ptr_from_Y[];
    ptr_to_Y += 1; ptr_from_Y += 1;
    ptr_to_Z[] = iter;
    ptr_to_Z += 1;
    iter += 1;
  );
  
  // Sort it
  ptr_to_X = xloc_write;
  ptr_to_Y = yloc_write;
  ptr_to_Z = indices;
  last = -1;
  loop(N_write,
    ptr_from_X = tempx;
    ptr_from_Y = tempy;
    ptr_from_Z = tempz;
    mini = 1000;
    loop(N_write,
      ( ( ptr_from_X[] > last ) && ( ptr_from_X[] < mini ) ) ?
      (
        mini       = ptr_from_X[];
        ptr_to_X[] = mini;
        ptr_to_Y[] = ptr_from_Y[];
        ptr_to_Z[] = ptr_from_Z[];
      );
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;      
    );
    last = mini;
    ptr_to_X += 1;
    ptr_to_Y += 1;
    ptr_to_Z += 1;
  );
  
  tmp = xloc_read;
  xloc_read = xloc_write;
  xloc_write = tmp;
  
  tmp = yloc_read;
  yloc_read = yloc_write;
  yloc_write = tmp;  
);

function update_spline()
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(cc1, m, mNext, cm, dx, dxNext, invdx, tmp)
  global(gfx_x, gfx_y)
  (
    // Initialize coeffs
    ptr_to_X   = c1_write;
    loop(9,
      ptr_to_X[] = 0;
      ptr_to_X += 1;
    );
    ptr_to_X   = c2_write;
    loop(9,
      ptr_to_X[] = 0;
      ptr_to_X += 1;
    );
    ptr_to_X   = c3_write;
    loop(9,
      ptr_to_X[] = 0;
      ptr_to_X += 1;
    );  
  
    // Calculate differences
    ptr_from_X  = xloc_read;
    ptr_from_Y  = yloc_read;
    ptr_to_X    = tempx;
    ptr_to_Y    = tempy;  
    
    // tempx contains dxs, tempy the slopes (dy/dx)    
    loop(N_write-1,
      ptr_to_X[]  = ptr_from_X[1] - ptr_from_X[];
      ptr_to_Y[]  = ( ptr_from_Y[1] - ptr_from_Y[] ) / ptr_to_X[];
      ptr_to_X    += 1;
      ptr_to_Y    += 1;
      ptr_from_X  += 1;
      ptr_from_Y  += 1;
    );
    
    // calculate first degree coefficients
    ptr_from_X  = tempx; // dx
    ptr_from_Y  = tempy; // dy/dx (ms)
    ptr_to_X    = c1_write;
    
    ptr_to_X[]  = ptr_from_Y[];
    ptr_to_X   += 1;
    loop(N_write-2,
      m     = ptr_from_Y[];
      mNext = ptr_from_Y[1];
      ( m * mNext <= 0 ) ? ( ptr_to_X[] = 0; ):
      (
        dx = ptr_from_X[];
        dxNext = ptr_from_X[1];
        cm = dx + dxNext;
        ptr_to_X[] = 3.0*cm/((cm+dxNext)/m + (cm+dx)/mNext);
      );
      ptr_to_X   += 1;
      ptr_from_X += 1;
      ptr_from_Y += 1;
    );
    ptr_to_X[] = ptr_from_Y[];
    
    // calculate second degree coefficients
    ptr_from_X = tempx; // dx
    ptr_from_Y = tempy; // dy/dx (ms)
    ptr_from_Z = c1_write;    // c1s
    ptr_to_X   = c2_write;
    ptr_to_Y   = c3_write;
    loop(N_write-1,
      invdx = 1 / ptr_from_X[];
      cc1 = ptr_from_Z[];
      m = ptr_from_Y[];
      cm = cc1 + ptr_from_Z[1] - m - m;
      ptr_to_X[] = (m - cc1 - cm)*invdx;
      ptr_to_Y[] = cm*invdx*invdx;
      
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;
      ptr_to_X   += 1;
      ptr_to_Y   += 1;
    );
    
    tmp = c1_read;
    c1_read = c1_write;
    c1_write = tmp;
    
    tmp = c2_read;
    c2_read = c2_write;
    c2_write = tmp;
    
    tmp = c3_read;
    c3_read = c3_write;
    c3_write = tmp;
    
    N_read = N_write;
  );

function evalSplineBin(x)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    // Out of bounds means return 1
    (x > 1) ? out = yloc_read[N_read-1] : 
    (
      ( x < 0 ) ? out = 0 :
      (
        // Search for the correct interval by binary search
        low       = 0;
        high      = N_read;
        while(
          mid = floor( 0.5*(low+high) );
          xHere = xloc_read[mid];
          
          ( xHere < x ) ? low = mid + 1 :
          ( // else
            ( xHere > x ) ? high = mid - 1 :
              ( //else 
                high = yloc_read[mid];
                low = high+1; // Manual termination
              );
          );
          
          low <= high;
        );
        
        i = max( 0, high );        
        
        diff    = x - xloc_read[i];
        diffSq  = diff * diff;

        out = yloc_read[i] + c1_read[i]*diff + c2_read[i]*diffSq + c3_read[i]*diff*diffSq;
      )
    );
    
    out;
  );
  
// Linear search empirically turned out to be faster than binary search (small number of nodes, less branching I guess).
function evalSplineLin(x)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    i = -1;
    xHere = xloc_read-1;
    
    while(
      i += 1;
      xHere += 1;
      
      x >= xHere[] && ( i < N_read )
    );
        
    i = max( 0, i-1 );
        
    diff    = x - xloc_read[i];
    diffSq  = diff * diff;
    out = yloc_read[i] + c1_read[i]*diff + c2_read[i]*diffSq + c3_read[i]*diff*diffSq;
    
    out;
  );  
  
function evalSplineAudioBin(x)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio)
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_read[N_read-1] : 
    (
      ( x < 0 ) ? out = 0 :
      (
        // Search for the correct interval by binary search
        lowAudio       = 0;
        highAudio      = N_read;
        while(
          midAudio = floor( 0.5*(lowAudio+highAudio) );
          xHereAudio = xloc_read[midAudio];
          
          ( xHereAudio < x ) ? lowAudio = midAudio + 1 :
          ( // else
            ( xHereAudio > x ) ? highAudio = midAudio - 1 :
              ( //else 
                highAudio = yloc_read[midAudio];
                lowAudio = highAudio+1; // Manual termination
              );
          );
          
          lowAudio <= highAudio;
        );
        
        iAudio = max( 0, highAudio );        
          
        diffAudio    = x - xloc_read[iAudio];
        diffSqAudio  = diffAudio * diffAudio;
          
        out = yloc_read[iAudio] + c1_read[iAudio]*diffAudio + c2_read[iAudio]*diffSqAudio + c3_read[iAudio]*diffAudio*diffSqAudio;
      )
    );
    
    out;
  );    
  
function evalSplineAudioLin(x)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio)
  global(gfx_x, gfx_y)
  (
    iAudio = -1;
    xHereAudio = xloc_read-1;
    
    while(
      iAudio += 1;
      xHereAudio += 1;
      
      x >= xHereAudio[] && ( iAudio < N_read )
    );
    
    iAudio       = max(0, iAudio-1);
    diffAudio    = x - xloc_read[iAudio];
    diffSqAudio  = diffAudio * diffAudio;
          
    out = yloc_read[iAudio] + c1_read[iAudio]*diffAudio + c2_read[iAudio]*diffSqAudio + c3_read[iAudio]*diffAudio*diffSqAudio;
    
    out;
  );  

// Get first derivative of the spline (needed for some analog models)
function evalSplineAudioDiff(x)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, interpAudio, xHereAudio, diffAudio, out, midAudio)
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_read[N_read-1] : 
    (
      ( x < 0 ) ? out = 0 :
      ( 
        iAudio = max( 0, highAudio );
        diffAudio    = x - xloc_read[iAudio];
        out = c1_read[iAudio] + diffAudio*(2*c2_read[iAudio] + 3*diffAudio*c3_read[iAudio]);
      )
    );
    
    out;
  );  

// Plot the spline nodes
function plot_spline(x, y, w, h)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(xx, res, lastx, lasty, dx, yout, nx, ny, epsx, epsy, xc, yc, yout)
  global(gfx_x, gfx_y, distortPlot, slider56, dynval, distortionDynamics)
  (
    epsx = 3;
    epsy = 3;
    ptr_from_X = xloc_read;
    ptr_from_Y = yloc_read;
    ptr_from_Z = indices;
    
    gfx_set( .7, .7, .7, .7 );
    gfx_x = 0;
    gfx_y = 0;
    ( slider56 == 0 ) ? (
      loop(N_read,
        xc = x + w*ptr_from_X[] - epsx;
        yc = y + h*(1-ptr_from_Y[]) - epsy;
        gfx_rect(xc, yc, epsx, epsy);
        gfx_x = xc;
        gfx_y = yc-14;
        gfx_printf("%d", ptr_from_Z[]);
        ptr_from_X += 1;
        ptr_from_Y += 1;
        ptr_from_Z += 1;
      );
    );
    
    ( slider56 == 4 ) ? ( 
      gfx_rect( x+.75*w - 5, y + .5*h, 10, 2 );
      gfx_rect( x+.25*w - 5, y + .5*h, 10, 2 );
      gfx_rect( x+.25*w - 2, y + .5*h-4, 4, 10 );
    );
    
    xx = 0;
    res = 500;
    lastx = x;
    lasty = y+h;
    dx = 1/res;
    loop(res,
      xx = xx + dx;
      ( slider56 == 0 ) ? (
        yout = this.evalSplineLin(xx);
      ) : ( slider56 == 1 ) ? ( 
        yout = tanh(xx);
      ) : ( slider56 == 2 ) ? (
        yout = fasttanh(xx);
      ) : ( slider56 == 4 ) ? (
        yout = xx < 0.5 ? sin(2*$pi*xx) : sin(2*$pi*(-xx));
      ) : (
        yout = xx;
      );

      nx = x + w*xx - 1;
      ny = y + h*(1-yout) - 1;
      gfx_line(lastx, lasty, nx, ny, 0);
      lastx = nx;
      lasty = ny;
    );
    
    // Draw intermediate if dynamically processed
    gfx_set( .8, .8, .2, .3 );
    ( distortionDynamics ) ? (
      xx = 0;
      res = 500;
      lastx = x;
      lasty = y+h;
      dx = 1/res;
      
      loop(res,
        xx = xx + dx;
        ( slider56 == 0 ) ? (
          yout = xx * (1-dynval) + dynval * this.evalSplineLin(xx);
        ) : ( slider56 == 1 ) ? ( 
          yout = xx * (1-dynval) + dynval * tanh(xx);
        ) : ( slider56 == 2 ) ? (
          yout = xx * (1-dynval) + dynval * fasttanh(xx);
        ) : ( slider56 == 4 ) ? (
          yout = xx * (1-dynval) + dynval * (xx < 0.5 ? sin(2*$pi*xx) : sin(2*$pi*(-xx)));
        ) : (
          yout = xx;
        );
  
        nx = x + w*xx - 1;
        ny = y + h*(1-yout) - 1;
        gfx_line(lastx, lasty, nx, ny, 0);
        lastx = nx;
        lasty = ny;
      );
    )
  );
  
function evalDist(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineLin(xx);
  );  
  
function evalDistAudio(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioLin(xx);
  );
  
function evalDiff(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioDiff(xx);
  );  
  
//NODE_PROXIMITY = 5;
function findNearest(x, y)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(minDist, best, dx, dy, dist, left, i, right)
  global()
(
    // Find nearest point that may have been clicked
    i = 0;
    minDist = 100000000000000;
    best = -1;
    loop(N_read,
      dx = (x - xloc_read[i]);
      dy = ((1-y) - yloc_read[i]);
      dist = dx*dx + dy*dy;          
      ( dist < minDist ) ? 
      (
        minDist = dist;
        best = i;
       );
       i = i + 1;
     );
             
    // Found a point, then we change the capture mode
    ( minDist < .001 ) ? ( drag_node = best; ) : drag_node = -1;
);

//NODE_PROXIMITY = 5;
function killNode(i)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(i)
  global()
  (
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N_read-2))&&(i<(N_read+1))
    );
    
    manipulateXYSliders(splineIdx, indices[drag_node], xloc_read[i], yloc_read[i]);
    setN(splineIdx, N_read-1);
  );
  
function addNode(x, y)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(i)
  global()
  (
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N_read-1))&&(i<(N_read+2))
    );

    manipulateXYSliders(splineIdx, indices[N_read], xloc_read[i], yloc_read[i]);  
    manipulateXYSliders(splineIdx, indices[N_read-1], x, y);
    setN(splineIdx, N_read+1);
  );

//NODE_PROXIMITY = 5;
function processMouse(x, y, dx, dy, mc)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(left, right, i)
  global(manipulateXYSliders, gfx_x, gfx_y)
  (
    left  = mc & 1;
    right = mc & 2;
  
    ( left ) ? 
    (
      ( cap_mode == 0 ) ?
      (
        this.findNearest(x, y);
        ( drag_node > -1 ) ? ( drag_node = indices[drag_node]; cap_mode = 1; )
      ) : ( cap_mode == 1 ) ? (
        // We've already selected a node.
        x = max( min( x, .9999 ), 0.00001 );
        y = max( min( y, .9999 ), 0.00001 );
        manipulateXYSliders(splineIdx, drag_node, x, (1-y));
      );
    ) : (
      ( right ) ?
      (
        ( cap_mode == 0 ) ?
        (
          this.findNearest(x, y);
          // Are we clicking an existing one?
          ( drag_node > -1 ) ? 
          (
            // Kill it!
            ( N_read > 1 ) ? (
              this.killNode(drag_node);
              cap_mode = 2;
            )
          ):(
            // Add one?
            ( N_read < 9 ) ? (
              ( x > 0 && y > 0 && x < 1 && y < 1 ) ? (
              this.addNode(x, 1-y);
              cap_mode = 2; )
            );
          );
        );
      ) : ( cap_mode = 0; )
    )
  );

// Generate a spline object
function gen_spline(N_in, splineIdx_in, xloc_in, yloc_in, xloc_in2, yloc_in2, indices_in, tempx_in, tempy_in, tempz_in, c1_in, c2_in, c3_in, c1_in2, c2_in2, c3_in2)
  instance(N_read, N_write, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  global()
(
  N_read     = N_in;
  N_write    = N_in;
  xloc_read  = xloc_in;
  yloc_read  = yloc_in;
  xloc_write = xloc_in2;
  yloc_write = yloc_in2;  
  indices    = indices_in;
  tempx      = tempx_in;
  tempy      = tempy_in; 
  tempz      = tempz_in;
  c1_read    = c1_in;
  c2_read    = c2_in;
  c3_read    = c3_in;
  c1_write   = c1_in2;
  c2_write   = c2_in2;
  c3_write   = c3_in2;    

  splineIdx  = splineIdx_in;
  cap_mode   = 0;
);

function setN(N_new)
  local()
  global()
  instance(N_read, N_write, splineIdx, xloc, yloc, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  (
    N_write = N_new;
  );

function wsetN(N_new)
  local()
  global()
  instance(x, y, w, h, spline)
  (
    spline.setN(N_new)
  );

function groupWidget(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in)
  local()
  global()
  instance(x, y, w, h, r, g, b, a, label)
  (
    x       = x_in-2;
    y       = y_in-6;
    w       = w_in+4;
    h       = h_in+4;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
  );
  
function groupWidget_draw()
  local(siz, jnk)
  global(gfx_x, gfx_y, retina_scaling, widgetFontSize, fontface)
  instance(x, y, w, h, r, g, b, a, label)
  (
    gfx_set( r, g, b, .05 );
    gfx_rect( x, y, w, h );
    
    gfx_setfont(1, fontface, widgetFontSize*retina_scaling);    
    gfx_set( r, g, b, 1.0);
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + 8;
    gfx_y = y - .5*jnk + 1;
    gfx_printf(label);
    gfx_set( r, g, b, .4 );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+5, y);
    gfx_line(x+siz+10, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
  );

function toggleLight(x_in, y_in, w_in, h_in, label_in, align_in, r_in, g_in, b_in, a_in, active_in)
  local(jnk, jnk1)
  global()
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    x       = x_in;
    y       = y_in;
    w       = w_in;
    h       = h_in;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
    align   = align_in;
    active  = active_in;
    lastleft = 0;
  );

function toggleLight_processMouse(xx, yy, mc)
  local(left)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    left = mc & 1;
    left ? (
      ( (lastleft ~= 1 ) && ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ) ? ( 
        active = 1 - active;
      );
    );
    
    lastleft = left;
  );
  
function toggleLight_draw()
  local(jnk, siz)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    gfx_set( r, g, b, .2 + .5*active );
    gfx_rect( x, y, w, h );
  
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    ( align == 0 ) ?
    (
      gfx_x = x+15;
      gfx_y = y+2;
    ) : (
      gfx_measurestr(label, siz, jnk);
      gfx_x = x - siz-3;
      gfx_y = y+1;
    );
    gfx_printf( label );  
  );  
  
function selectionButton(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in, hint_in)
  local()
  global()
  instance(x, y, w, h, r, g, b, a, active, label, lastleft, hint, htime)
  (
      x       = x_in;
      y       = y_in;
      w       = w_in;
      h       = h_in;
      r       = r_in;
      g       = g_in;
      b       = b_in;
      a       = a_in;
      htime   = 0;
      label   = label_in;
      lastleft = 0;
      hint    = hint_in;
  );
  
function setLabel( _label )
  local()
  global()
  instance(label)
  (
    label = _label;
  );

function drawHint_draw()
  global(gfx_x, gfx_y, gfx_w, mouse_x, mouse_y, hintTime, currentHint)
  local(w, h)
  global()
  (
    ( hintTime > .99 ) ? (
      gfx_measurestr(currentHint,w,h);
      
      gfx_x = mouse_x+20;
      gfx_y = mouse_y+20;
      ( gfx_x > 0.5*gfx_w ) ? gfx_x = gfx_x - w-8;
      
      gfx_set( 0.05, 0.05, 0.1, .8 );
      gfx_rect(gfx_x-2, gfx_y-2, w+4, h+4);
      gfx_set( 0.8, 0.8, 0.8, .8 );      
      gfx_printf(currentHint);
    );
  );

function updateHintTime(hint)
  global(gfx_x, gfx_y, mouse_x, mouse_y, hintTime, currentHint, delta_time, lx, ly)
  local()
  global()
  (
    ( (lx - mouse_x) || ( ly - mouse_y ) ) > 0 ? hintTime = 0;
    
    hint != 0 ? (
      currentHint = hint;
      hintTime = hintTime + 1 * delta_time;
      hintTime = min(1, hintTime)
    ) : (
      0
    )
  );
  
function selectionButton_draw()
  local(jnk, siz)
  global(gfx_x, gfx_y, buttonFontSize, retina_scaling, fontface)
  instance(x, y, w, h, r, g, b, a, active, label, lastleft, htime)
  (
    gfx_set( min(1,r + .1*htime), min(1,g + .1*htime), min(1,b + .1*htime), .2 + .5*active );
    gfx_rect( x, y, ceil(w), ceil(h) );
  
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    retina_scaling > 1 ? gfx_setfont(1, fontface, buttonFontSize*retina_scaling);
    gfx_measurestr(label, siz, jnk);
    gfx_x = x + .5 * (w-siz);
    gfx_y = y - .5*(jnk-h) + 1;
    gfx_printf( label );
  );
  
function selectionButton_processMouse(xx, yy, mc)
  local(left, change)
  global(updateHintTime, gfx_x, gfx_y, delta_time)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft, htime, hint)
  (
    change = 0;
    left = mc & 1;
    ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ?
    (
      left ? (
        ( (lastleft ~= 1 ) ) ? ( 
          active = 1 - active;
          change = 1;
        );
      );
      
      htime = updateHintTime(hint);
    ) : htime = updateHintTime(0);
    
    lastleft = left;
    change
  );
  
function selectionButton_setActive(active_in)
  local()
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    active = active_in;
  );  

function combobox(x_in, y_in, w_in, h_in, r_in, g_in, b_in, a_in, nitems_in, stridx_in, goup_in, cols_in, hint_in )
  local()
  global(newUI)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, hasfocus, goup, cols, thisUI, htime, hint)
  (
      thisUI        = newUI+=1;
      x             = x_in;
      y             = y_in+1;
      w             = w_in;
      h             = h_in-2;
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      nitems        = nitems_in;
      cap           = 0;
      curitem       = 0;
      hover         = 8;
      open          = 0;
      stridx        = stridx_in;
      lastleft      = 0;
      hasfocus      = 0;
      goup          = goup_in;
      cols          = cols_in;
      htime         = 0;
      hint          = hint_in;
  );
  
function combobox_setcuritem( item )
  local(i, xtxt)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus)
  (
    curitem = item;
  );
  
function combobox_draw()
  local(i, xtxt, x1, x2, x3, y1, y2, y3, pad, wi)
  global(gfx_x, gfx_y, lastUI, retina_scaling)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup, cols, thisUI, htime)
  (
    //gfx_set( r, g, b, .2 );
    gfx_set( min(1,r + .15*htime), min(1,g + .15*htime), min(1,b + .25*htime), .1 );
    gfx_rect( x, y, w, h );
    
    lastUI == thisUI ? gfx_set( .9, g, b, a ) : gfx_set( r, g, b, a );
    
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    
    pad = .3*h;
    wi = .5 * (h-pad);
    x1 = x+w-wi-pad;
    x2 = x+w-pad;
    x3 = x+w-.5*wi-pad;
    
    y1 = y+pad;
    y2 = y+pad;
    y3 = y+h-pad;
    
    gfx_line(x1, y1, x2, y2);
    gfx_line(x2, y2, x3, y3);
    gfx_line(x3, y3, x1, y1);
  
    xtxt = x+3*retina_scaling;
    gfx_x = xtxt;
    gfx_y = y+4*retina_scaling;
    gfx_printf(comboStrings(stridx, curitem));
  );
  
function combobox_draw_top()
  local(i, j, xtxt, x1, x2, x3, y1, y2, y3, pad, wi, delta)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup, cols)
  (    
    xtxt = x+3;
    delta = goup ? (nitems+1)*h : 0;
    gfx_x = xtxt;
    gfx_y = y + 4 - delta;
    
    open ?
    (
      gfx_set( r*.3, g*.3, b*.3, 1 );
      gfx_rect( x - (cols-1)*w-1, y-delta+h-1, cols*w+2, h * nitems/cols+2 );
          
      gfx_set( r*.1, g*.1, b*.1, 1 );
      gfx_rect( x - (cols-1)*w, y-delta+h, cols*w, h * nitems/cols );
      i = 0; j = 0;
      gfx_set( r, g, b, a, 0.95 );
      loop( cols, 
        loop( nitems/cols,
          gfx_x = xtxt - (cols-1-j)*w;
          gfx_y += h;
          hover == i ? gfx_rect( gfx_x-3, gfx_y - 3, w, h );
          gfx_printf(comboStrings(stridx, i));
          i += 1;
        );
        gfx_y = y + 4 - delta;
        j += 1;
      );
      gfx_set( 1, 1, 1, .1 );
    )
  );

function combobox_processMouse(xx, yy, mc)
  local(over, left, right, change, delta, xmin, xmax, ymin, ymax, xl)
  global(gfx_x, gfx_y, lastUI, lastChar)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, hasfocus, goup, cols, thisUI, htime, hint)  
  (
    delta = goup ? (nitems+1)*h : 0;
    change = 0;
    left = mc & 1;
    
    xmin = x - (cols-1)*w;
    ymin = y + h - delta;
    xmax = x + w;
    ymax = ( y+((nitems)/cols+1)*h-delta );
    
    ( lastUI == thisUI ) ?
    (
      ( lastChar == 1685026670 ) ? ( 
        curitem = curitem + 1;
        curitem > nitems - 2 ? curitem = 0;
        change = 1;
      ) : (
        ( lastChar == 30064 ) ? (
          curitem = curitem - 1;
          curitem < 0 ? curitem = nitems-2;
          change = 1;
        );
      );
    );
    
    over = xx > x && xx < ( x+w ) && yy > y && yy < ( y + h );
    
    over ? (
      htime = updateHintTime(hint);
    ) : htime = updateHintTime(0);
    
    open ? 
    (
      xl = min( max( 0, floor((xx - xmin)/w)), cols-1 );
      hover = min( nitems-1, max( 0, xl * floor(nitems/cols) + floor((max(ymin,min(ymax-h,yy)) - (y-delta))/h) - 1 ) );
      
      !lastleft && left ? (
        open = 0;
        ( xx > xmin && xx < xmax && yy > (y+h-delta) && yy < ( ymax ) ) ? ( curitem = hover; change = 1 );
      )
    ) : (
      ( lastleft == 0 && left && over ) ? (
        open = 1; hasfocus = 1; lastUI = thisUI;
      )
    );
    
    ( !left && !open ) ? hasfocus = 0;
    
    lastleft = left;
    
    change
  );
  
function sliderWidget(x_in, y_in, w_in, h_in, label_in, r_in, g_in, b_in, a_in, two_values, minval_in, maxval_in, default_in, unit_in, isInteger_in, hint_in )
  local()
  global(newUI)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastright, lastclick, yslidercenter, cap, twoval, unit, isInteger, thisUI, htime, hint, onmarker)
  (
      thisUI        = newUI+=1;
      x             = x_in+2;
      y             = y_in;
      w             = w_in-4;
      h             = h_in;
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      label         = label_in;
      lastleft      = 0;
      lastright     = 0;
      value         = 0;
      value2        = 0;
      yslidercenter = y + 0.3 * h;
      cap           = 0;
      twoval        = two_values;
      minval        = minval_in;
      maxval        = maxval_in;
      default       = ( default_in - minval ) / ( maxval - minval );
      lastclick     = 0;
      unit          = unit_in;
      isInteger     = isInteger_in;
      htime         = 0;
      hint          = hint_in;
      onmarker      = 0;
  );
  
function sliderWidget_setValue(value_in)
  local()
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
  (
    value = ( value_in - minval ) / ( maxval - minval )
  );
  
function sliderWidget_getValue()
  local(v)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval, isInteger)
  (
    v = value * ( maxval - minval ) + minval;
    v = isInteger ? floor(v+0.499999) : v;
    v
  );  
  
function sliderWidget_draw()
  local(jnk, siz, q, str, modmax, modmin)
  global(gfx_x, gfx_y, lastUI, retina_scaling,widgetFontSize, filterDynamics, dynval, modulator.modvalue, mlevel, fontface, slider39, modulatorDynamics )
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval, unit, thisUI, htime, overridevalue, overrideunit, onmarker)
  (
    gfx_setfont(1, fontface, widgetFontSize*retina_scaling);
    //gfx_set( r, g, b, .1 );
    gfx_set( min(1,r + .25*htime), min(1,g + .25*htime), min(1,b + .25*htime), .1 );
    gfx_rect( x-3*retina_scaling, yslidercenter-.25*h, w+6*retina_scaling, h*.5 );

    modulatorDynamics ? (
      gfx_set( r, g, b, .4 );
      modmax = x + (1+slider39) * value2 * w + value*w;
      modmin = x + value*w;
      modmin = max( x, min( x+w, modmin ) );
      modmax = max( x, min( x+w, modmax ) );
      
      gfx_rect( modmin, yslidercenter - 2, modmax - modmin, 1 );
      gfx_rect( modmin, yslidercenter + 2, modmax - modmin, 1 );
      
      //gfx_rect( modmin-1, yslidercenter - .2*h, 2, h*.4 );
      //gfx_rect( modmax-1, yslidercenter - .2*h, 2, h*.4 );
      //gfx_rect( x + value*w, yslidercenter - .1*h, modmax - modmin, h*.3 );
    );

    lastUI == thisUI ? gfx_set( .9, g, b, a ) : gfx_set( r, g, b, 0.8 );
    gfx_line(x, yslidercenter, x+w, yslidercenter);
    gfx_set( r*.3, g*.3, b*.3, 0.8 );
    gfx_line(x + retina_scaling, yslidercenter + 1, x+w + retina_scaling, yslidercenter + 1);

    gfx_set( r, g, b, 1.0 );    
    gfx_rect( x-2*retina_scaling + value*w, yslidercenter - .2*h, 4*retina_scaling, h*.4 );
    gfx_set( r*.2, g*.2, b*.2, 0.4 );
    gfx_rect( x-retina_scaling + value*w, yslidercenter - .2*h + 1, 2*retina_scaling, h*.4-2 );
    
    onmarker == 1 ? 
    (
      gfx_set( 1, 1, 1, 0.4 );
      gfx_rect( x-2*retina_scaling + value*w-1, yslidercenter - .2*h-1, 4*retina_scaling+2, h*.4+2 );
    );
    
    gfx_set( r, g, b, 0.4 );
    value2 > 0 ? gfx_rect( x + value*w, yslidercenter - .1*h, value2*w+1, h*.3 ) : gfx_rect( x + (value+value2)*w, yslidercenter - .1*h, abs(value2)*w, h*.3 );

    gfx_set( .9, .9, .7, .7 );
    mlevel = modulator.modvalue*slider39 + (filterDynamics > 0 ? dynval : 0);
    mlevel = x + (value+value2*mlevel)*w;
    mlevel = max( x, min( x+w, mlevel ) );
    gfx_rect( mlevel-1, yslidercenter - .2*h, 2, h*.4 );
    
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    gfx_x = x;
    gfx_y = y + 11*retina_scaling;
    gfx_printf( label );
    
    ( overridevalue == 0 ) ? (
      sprintf( str, "%2.3g%s", this.sliderWidget_getValue(), unit );
    ) : (
      ( overridevalue == -1000 ) ? (
        sprintf( str, "%2.3g (%s)", this.sliderWidget_getValue(), overrideunit );
      ) : (
        ( overridevalue > 1000 ) ? (
          sprintf( str, "%2.3g (%2.3g k%s)", this.sliderWidget_getValue(), overridevalue/1000, overrideunit );
        ) : (
          sprintf( str, "%2.3g (%2.3g %s)", this.sliderWidget_getValue(), overridevalue, overrideunit );      
        )
      );
    );
    gfx_measurestr(str, siz, jnk);
    gfx_x = x + w - siz;
    gfx_y = y + 11*retina_scaling;
    gfx_printf( str );
  );
  
function sliderWidget_setValue2(value_in)
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 = value_in;
   );
   
// Set value in a non-normalized manner
function sliderWidget_setValue2_nn(value_in)
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 = ( value_in > 0 ) ? value_in * (1.0 - value) : value_in * value;
   );   
  
function sliderWidget_getValue2()
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2
   ); 
   
function sliderWidget_getValue2_nn()
   local()
   global(gfx_x, gfx_y)
   instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastclick, yslidercenter, cap, twoval)
   (
    value2 > 0 ? value2 / (1.0 - value) : value2 / value
   );    
  
function sliderWidget_processMouse(xx, yy, dx, dy, mc)
  local(left, right, change, newcap, onslider, shft)
  global(gfx_x, gfx_y, mouse_wheel, mouse_cap, lastUI, lastChar, retina_scaling)
  instance(x, y, w, h, r, g, b, a, default, minval, maxval, value, value2, label, lastleft, lastright, lastclick, yslidercenter, cap, twoval, thisUI, htime, hint, onmarker)
  (
    left  = mc & 1;
    right = mc & 2;
    shft  = mc & 8;
    
    change = 0;
    newcap = 0;
    onslider = ( ( xx > x ) && ( xx < (x+w) ) && ( yy > (yslidercenter-.2*h) ) && ( yy < (yslidercenter+.2*h) ) );
    onmarker = abs( value * w + x - xx ) < 5*retina_scaling && ( yy > (yslidercenter-.2*h) ) && ( yy < (yslidercenter+.2*h) );
    
    onslider ? (
      htime = updateHintTime(hint);
    ) : htime = updateHintTime(0);
    
    ( lastUI == thisUI ) ?
    (
      ( lastChar == 1919379572 ) ? value = value + .001;
      ( lastChar == 1818584692 ) ? value = value - .001;      
    );
    
    left ? (
      ( ( lastleft == 0 ) && ( time_precise() - lastclick ) < .2 ) ?
      (
        value       = default;
        change      = 1;
      ) : ( ( cap == 1 ) || ( ( onslider || onmarker ) && lastleft == 0 ) ) ? ( 
        (mouse_cap & 8 == 0) ? (
          value       = (xx-x)/w;
        ) : (
          value       = value - .125*dx/w;
        );
        change      = 1;
        newcap      = 1;
        lastclick   = time_precise();
        lastUI      = thisUI;
      );
    ) : ( 
      twoval && right ? 
      (
        ( ( cap == 2 ) || ((onmarker || onslider) && lastright == 0) ) ? ( 
          value2 = (xx-x)/w - value;
          change = 1;
          newcap = 2;
        );
      ) : ( (mouse_wheel ~= 0) && onslider ) ? (
        ( shft && twoval ) ? (
          value2 = value2 + .00001 * mouse_wheel; change = 1;
        ) : (
          value = value + .00001 * mouse_wheel;  change = 1;
        );
        mouse_wheel = 0;
      );
    );
    
    lastleft  = left;
    lastright = right;
    cap       = newcap;
    value     = value > 1.0 ? 1 : value;
    value     = value < 0.0 ? 0 : value;
    twoval ? (
      value2 = (value2+value) > 1.0 ? 1.0-value : value2;
      value2 = (value2+value) < 0.0 ? -value : value2;    
    );
    
    change
  );

function init_window(xp, yp, wp, hp, N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline, buttonSine)
  global(buttonOff.selectionButton, retina_scaling)
  local(hy, bw, bh)
  (
    spline = spline.gen_spline(N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2);
  );

function gen_window(xp, yp, wp, hp, N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline, buttonSine)
  global(buttonOff.selectionButton, retina_scaling)
  local(hy, bw, bh)
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    
    hy = 15*retina_scaling;
    bw = 55*retina_scaling;
    bh = 10*retina_scaling;
    buttonOff.selectionButton(x+5, y+4, bw, bh, "OFF",  .3, .4, .8, .3, "No waveshaping");
    buttonArctan.selectionButton(x+5, y+4+hy, bw, bh, "Atan",  .3, .4, .8, .3, "Atan waveshaper");
    buttonFast.selectionButton(x+5, y+4+2*hy, bw, bh, "Fast",  .3, .4, .8, .3, "Atan approximation");
    buttonSpline.selectionButton(x+5, y+4+3*hy, bw, bh, "Spline", .3, .4, .8, .3, "Spline waveshaping");
    buttonSine.selectionButton(x+5, y+4+4*hy, bw, bh, "Sine", .3, .4, .8, .3, "Sine waveshaping (FM-like)");
  );
  
function gen_dynamics(xp, yp, wp, hp)
  instance(x, y, w, h, yref, sc, cap_mode, inLight, outLight, dynLight, lastleft)
  global(inLight.toggleLight, retina_scaling)
  local(bw, bh, ych, xoff, yoff)
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    cap_mode = 0; 
    lastleft = 0;
    
    bw = 10*retina_scaling;
    bh = 10*retina_scaling;
    ych = 2*bh;
    xoff = x+w-15*retina_scaling;
    yoff = y+5*retina_scaling;
    inLight.toggleLight(xoff, yoff, bw, bh, "In", 1, 1, .3, .3, .3, 1);
    outLight.toggleLight(xoff, yoff+ych, bw, bh, "Out", 1, .6, .3, 1, .9, 1);
    dynLight.toggleLight(xoff, yoff+2*ych, bw, bh, "Dynamics", 1, .8, .8, .2, .3, 1);    
    
    sc = h;
  );

function processMouse(mx, my, dx, dy, mc)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline, buttonSine)
  global(slider56, buttonOff.selectionButton_processMouse, buttonOff.selectionButton_setActive)
  local()  
  (
    buttonOff.selectionButton_setActive(0);
    buttonArctan.selectionButton_setActive(0);
    buttonFast.selectionButton_setActive(0);
    buttonSpline.selectionButton_setActive(0);
    buttonSine.selectionButton_setActive(0);

    buttonSine.selectionButton_processMouse(mx, my, mc)   ? ( slider56 = 4; slider_automate(slider56); );  
    buttonOff.selectionButton_processMouse(mx, my, mc)    ? ( slider56 = 3; slider_automate(slider56); );
    buttonArctan.selectionButton_processMouse(mx, my, mc) ? ( slider56 = 1; slider_automate(slider56); );
    buttonFast.selectionButton_processMouse(mx, my, mc)   ? ( slider56 = 2; slider_automate(slider56); );
    buttonSpline.selectionButton_processMouse(mx, my, mc) ? ( slider56 = 0; slider_automate(slider56); );

    (slider56 == 0) ? ( buttonSpline.selectionButton_setActive(1);
      ) : ( slider56 == 1 ) ? ( buttonArctan.selectionButton_setActive(1);
      ) : ( slider56 == 2 ) ? ( buttonFast.selectionButton_setActive(1);
      ) : ( slider56 == 3 ) ? ( buttonOff.selectionButton_setActive(1);
      ) : ( slider56 == 4 ) ? ( buttonSine.selectionButton_setActive(1);
    );
    
    spline.processMouse((mx-x)/w, (my-y)/h, dx/w, dy/h, mc);
  );

function sort_spline()
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.sort_spline();
  );

function update_spline()
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.update_spline();
  );


function rotatedPrint(x, y, str, rot)
local(sw,sh)
global(gfx_x, gfx_y, gfx_dest, gfx_mode)
(
  gfx_measurestr(str, sw, sh);
  gfx_dest = 1; 
  gfx_setimgdim(1, sw, sw);
  gfx_set( 0, 0, 0, 1 );
  gfx_rect(0, 0, sw, sw);
  gfx_x = 1;
  gfx_y = 1;
  gfx_set( .7, .7, .7, .7 );
  gfx_printf(str);
  gfx_dest = -1;
  gfx_mode = 1;
  gfx_x = x;
  gfx_y = y;
  gfx_blit(1, 1.0, rot);
  gfx_mode = 0;
);

function ylabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, gfx_dest, rotatedPrint, retina_scaling)
  local(sw, sh)
  (
    gfx_measurestr(str, sw, sh);
    rotatedPrint(x-16*retina_scaling, y+0.5*(h-sw), str, -.5*$pi); 
  );
  
function xlabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(sw, sh)
  (
    gfx_set( .7, .7, .7, 1.0 );
    gfx_measurestr(str, sw, sh);
    gfx_x = x + 0.5*(w-sw);
    gfx_y = y + h + 12;
    gfx_printf(str);
  );

function draw_text(str, rx, ry)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local()
  (
    gfx_set( .7, .7, .7, 1.0 );
    gfx_x = x + w*rx;
    gfx_y = y + h*ry;
    gfx_printf(str);
  );

function draw_grid(N)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(dx, dy)
  (
    gfx_set( .3, .3, .6, .2 );
    dx = w/(N-1);
    dy = h/(N-1);    
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    gfx_x = x;
    gfx_y = y+h;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );
  
function draw_grid(N, dy)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(dx, dy)
  (
    gfx_set( .3, .3, .6, .2 );
    dx = w/(N-1);  
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    
    gfx_x = x;
    gfx_y = y+h;
    loop(min(100, floor(h/dy)),
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );  

function draw_back()
  instance(x, y, w, h, yref, sc)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local()
  (
    gfx_set( .2, .2, .3, .1 );
    gfx_rect(x, y, w, h);
  );

function draw_window(movAvgL, movAvgR, movAvgOL, movAvgOR)
  instance(x, y, w, h, spline, buttonOff, buttonArctan, buttonFast, buttonSpline, buttonSine)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, buttonOff.selectionButton_draw)
  (
    this.draw_back();
    this.draw_grid(10);
    spline.plot_spline(x, y, w, h);
    
    gfx_set( 0.6 + max(-.2,(movAvgL - 1)), .1, .1, 1.0);
    gfx_rect(x,y+h+2,w*min(1,movAvgL),2);
    gfx_rect(x,y+h+4,w*min(1,movAvgR),2);
    gfx_set( 0.2, .2, 0.9 + max(movAvgOL - 1, -.5), 1.0);
    movAvgOL = min(movAvgOL, 1);
    movAvgOR = min(movAvgOR, 1);
    gfx_rect(x-2,y+h-h*movAvgOL,2,h*movAvgOL);
    gfx_rect(x-4,y+h-h*movAvgOR,2,h*movAvgOR);
    
    buttonOff.selectionButton_draw();
    buttonArctan.selectionButton_draw();
    buttonFast.selectionButton_draw();
    buttonSpline.selectionButton_draw();
    buttonSine.selectionButton_draw();
  );
  
function draw_buffer(scopeptr, scopebuffer, scopebuffermax, mul)
  instance(x, y, w, h, yref, sc, cap_mode)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(xx, dx, lptr, yy, lastx, lasty, scale, isc)
  (
    xx = x;
    dx = w/(scopebuffermax-scopebuffer);
    lptr = scopeptr;
    scale = (mul > 0) ? mul*h : sc;

    gfx_x = xx;
    gfx_y = yref;
    isc = h/scale;
    loop(scopebuffermax-scopeptr,
      yy = yref - scale*min(isc,lptr[]);
      gfx_lineto(xx, yy);
      lptr += 1;
      xx += dx;
    );
    
    lptr = scopebuffer;
    loop(scopeptr - scopebuffer,
      yy = yref - scale*min(isc,lptr[]);
      gfx_lineto(xx, yy);
      lptr += 1;
      xx += dx;
    );
  );  

function draw_dynamics(thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, inLight.toggleLight_draw)
  local(texloc, lineloc)
  (
    yref = y+h;
    this.draw_grid(10, 10*sc/h);
    gfx_set( 0.0, 0.0, 0.0, 1.0 );
    gfx_x = x;
    texloc = yref-sc*thresh-9;
    ( texloc > y ) ? (
      gfx_y = texloc;
      gfx_printf( "Thresh" );
    );
    lineloc = yref - sc*thresh+1;
    ( lineloc > y ) ? gfx_line( x, lineloc, x + w, yref -sc * thresh + 1 );
    
    gfx_set( 0.9, 0.3, 0.3, 1.0 );
    gfx_x = x+2;
    ( texloc > y ) ? (
      gfx_y = texloc-1;
      gfx_printf( "Thresh" );
    );
    
    ( lineloc > y ) ? (
      gfx_line( x, yref - sc*thresh, x + w, yref -sc*thresh );
      ( highlight == 1 ) ? gfx_rect( x, yref - sc*thresh-1, w, 2 );
    );
    
    inLight.toggleLight_draw();
    outLight.toggleLight_draw();
    dynLight.toggleLight_draw();
  );
  
function processMouseDynamics(xx, yy, dx, dy, mc, thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight, lastleft)
  local(left, right)
  global(forceUpdate, gfx_x, gfx_y, mouse_wheel, slider59, inLight.toggleLight_processMouse, outLight.toggleLight_processMouse, dynLight.toggleLight_processMouse)
  (
    left  = mc & 1;
    right = mc & 2;
    
    inLight.toggleLight_processMouse(xx, yy, mc);
    outLight.toggleLight_processMouse(xx, yy, mc);
    dynLight.toggleLight_processMouse(xx, yy, mc);    
    
    highlight = 0;
    ( (mouse_wheel ~= 0) && xx > x && yy > y && xx < (x+w) && yy < (y+h) ) ?
    (
      sc += .5*mouse_wheel;
      mouse_wheel = 0;
      ( sc < 0 ) ? sc = 0.01;
    );
    
    ( left ) ?
    (
      ( cap_mode == 0 ) ? 
      (
        ( xx > x && yy > y && xx < (x+w) && yy < (y+h) && lastleft == 0 ) ?
        (
          ( yy > (yref - sc*thresh - 8) ) && ( yy < (yref - sc*thresh + 8) ) ?
          (
            cap_mode = 2;
          ) : (
            cap_mode = 1;
          );
        );
      ) : ( cap_mode == 1 ) ? (
        sc += 15 * dy;
       ( sc < 100 ) ? sc = 100;
       ( sc > 5000 ) ? sc = 5000;
      ) : (
        thresh += dy/h/(sc/h);
        ( thresh < 0 ) ? thresh = 0;
        ( thresh > h/sc ) ? thresh = h/sc;
        ( thresh > 1 ) ? thresh = 1;        
        slider59 = thresh;
        slider_automate(slider59);
        forceUpdate = 1;
      );
    ) : (
      cap_mode = 0;
      ( xx > 0 && yy > 0 && xx < (x+w) && yy < (y+h) ) ?
      (
        ( yy > (yref - sc*thresh-10) ) && ( yy < (yref - sc*thresh+10) ) ?
        (
          highlight = 1;
        );
      );
    );
    
    lastleft = left;
    thresh
  );  

function initRMS(N, loc_in)
  local()
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    sc      = 1.0/N;
    ptr     = loc_in;
    loc     = loc_in;
    loc_end = loc_in + N;
    
    loop(N+1,
     ptr[]  = 0;
     ptr   += 1; 
    );
    
    ptr = loc_in;
    movavg  = 0;
  );

function updateRMS(sr, sl)
  local( M )
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    M       = max(sr*sr, sl*sl);
    M       = sc * min(M, 2.4);
    
    movAvg -= ptr[];
    movAvg  = 0.999999999*movAvg; // Very simple DC corr (dissipate energy)
    ptr[]   = M;
    movAvg += M;
    
    ptr    += 1;
    ptr > loc_end ? ptr = loc;
        
    movAvg
  );

function getBuffer()
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[];
  );

function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );
  
function updateIntegrationTime()
  (
    integrationTime = ( 1 + 3*rms_x4_1.active ) * ( 1 + 3*rms_x4_2.active ) * slider64;
    ( (lastIntegrationTime != integrationTime) || (slider35 != lookAhead) ) ? 
    (
      lastIntegrationTime = integrationTime;      
      lookAhead           = slider35;
    
      ndelay = ceil(srate*lastIntegrationTime/1000);
      RMS1.initRMS(ndelay, 100000);
      RMS2.initRMS(ndelay, 200000);

      ndelay = ndelay * 0.5;
      preBufferL.initBuffer(300000, 300000 + ndelay);
      preBufferR.initBuffer(400000, 400000 + ndelay);
      
      lookAhead ? (
        // delays the first two channels (spl0/spl1).
        lookAheadDelay = ndelay;
      ) : ( 
        lookAheadDelay = 0;
      );
    );
  );
  
//updateIntegrationTime();

//////////////////////////////////////////////////////////
// Memory layout
//////////////////////////////////////////////////////////
delay_buf1      = 500000;
delay_buf2      = 600000;
delay_buf3      = 700000;
delay_buf4      = 800000;

sinc_tmp        = 900000;
sinc_flt        = 910000; // Upsample filters are spaced at 100 difference. There are N filters, with 8 taps per filter.
sinc_flt2       = 920000;
sinc_flt3       = 930000; // Downsamplers
sinc_flt4       = 940000;
sinc_hist1      = 950000; // Downsampler history
sinc_hist2      = 960000;

// Global storage for variables
negative_xloc   = 100;
negative_yloc   = 200;
positive_xloc   = 300;
positive_yloc   = 400;
negative_xloc2  = 500;
negative_yloc2  = 600;
positive_xloc2  = 700;
positive_yloc2  = 800;
temp_xloc       = 900;
temp_yloc       = 1000;
pos_c1s         = 1100;
pos_c2s         = 1200;
pos_c3s         = 1300;
neg_c1s         = 1400;
neg_c2s         = 1500;
neg_c3s         = 1600;
pos_c1s2        = 1700;
pos_c2s2        = 1800;
pos_c3s2        = 1900;
neg_c1s2        = 2000;
neg_c2s2        = 2100;
neg_c3s2        = 2200;
temp_indices    = 2300;
pos_indices     = 2400;
neg_indices     = 2500;
vowel_A         = 2600;
vowel_E         = 2650;
vowel_I         = 2700;
vowel_O         = 2750;
vowel_U         = 2800;
Nbuf            = 20000;

inVol.initBuffer(20000, 20000+Nbuf-1);
outVol.initBuffer(20000+Nbuf, 20000+2*Nbuf-1);
dynBuf.initBuffer(20000+Nbuf*2, 20000+3*Nbuf-1);

filter_delay1.initBuffer(delay_buf1, delay_buf1 + filterFreq * 1000);
filter_delay2.initBuffer(delay_buf2, delay_buf2 + filterReso * 2000);
L.filter_delay.initBuffer(delay_buf1, delay_buf1 + filterFreq * 1000);
R.filter_delay.initBuffer(delay_buf2, delay_buf2 + filterReso * 2000);

stereo_delay_bufferL.initBuffer(delay_buf1, delay_buf1 + 1000);
stereo_delay_bufferR.initBuffer(delay_buf1, delay_buf1 + 1000);

dynval = 0;
filter_vowel.bootvowel();
n_pos = 8;
n_neg = 8;
initialized = 1;

function updateSliders( hard )
(
  (slider38&2) == 0 ? (
    modulator.setModRate( (1+2*slider37)^4 - 1 );
  ) : (
    cTime = slider37;
    ( cTime < 0.0196078 ) ?
    (
      tempoLabel = "256";
      cRate = 256;
    ) : ( cTime < 0.0392157 ) ?
    (
      tempoLabel = "224";
      cRate = 224;
    ) : ( cTime < 0.0588235 ) ?
    (
      tempoLabel = "192";
      cRate = 192;
    ) : ( cTime < 0.0784314 ) ?
    (
      tempoLabel = "160";
      cRate = 160;
    ) : ( cTime < 0.0980392 ) ?
    (
      tempoLabel = "144";
      cRate = 144;
    ) : ( cTime < 0.117647 ) ?
    (
      tempoLabel = "128";
      cRate = 128;
    ) : ( cTime < 0.137255 ) ?
    (
      tempoLabel = "112";
      cRate = 112;
    ) : ( cTime < 0.156863 ) ?
    (
      tempoLabel = "96";
      cRate = 96;
    ) : ( cTime < 0.176471 ) ?
    (
      tempoLabel = "80";
      cRate = 80;
    ) : ( cTime < 0.196078 ) ?
    (
      tempoLabel = "64";
      cRate = 64;
    ) : ( cTime < 0.215686 ) ?
    (
      tempoLabel = "56";
      cRate = 56;
    ) : ( cTime < 0.235294 ) ?
    (
      tempoLabel = "48";
      cRate = 48;
    ) : ( cTime < 0.254902 ) ?
    (
      tempoLabel = "40";
      cRate = 40;
    ) : ( cTime < 0.27451 ) ?
    (
      tempoLabel = "32";
      cRate = 32;
    ) : ( cTime < 0.294118 ) ?
    (
      tempoLabel = "28";
      cRate = 28;
    ) : ( cTime < 0.313725 ) ?
    (
      tempoLabel = "24";
      cRate = 24;
    ) : ( cTime < 0.333333 ) ?
    (
      tempoLabel = "16";
      cRate = 16;
    ) : ( cTime < 0.352941 ) ?
    (
      tempoLabel = "8";
      cRate = 8;
    ) : ( cTime < 0.372549 ) ?
    (
      tempoLabel = "7";
      cRate = 7;
    ) : ( cTime < 0.392157 ) ?
    (
      tempoLabel = "6";
      cRate = 6;
    ) : ( cTime < 0.411765 ) ?
    (
      tempoLabel = "16/3";
      cRate = 5.33333;
    ) : ( cTime < 0.431373 ) ?
    (
      tempoLabel = "5";
      cRate = 5;
    ) : ( cTime < 0.45098 ) ?
    (
      tempoLabel = "4";
      cRate = 4;
    ) : ( cTime < 0.470588 ) ?
    (
      tempoLabel = "3";
      cRate = 3;
    ) : ( cTime < 0.490196 ) ?
    (
      tempoLabel = "8/3";
      cRate = 2.66667;
    ) : ( cTime < 0.509804 ) ?
    (
      tempoLabel = "4/3";
      cRate = 1.33333;
    ) : ( cTime < 0.529412 ) ?
    (
      tempoLabel = "7/6";
      cRate = 1.16667;
    ) : ( cTime < 0.54902 ) ?
    (
      tempoLabel = "1";
      cRate = 1;
    ) : ( cTime < 0.568627 ) ?
    (
      tempoLabel = "15/16";
      cRate = 0.9375;
    ) : ( cTime < 0.588235 ) ?
    (
      tempoLabel = "7/8";
      cRate = 0.875;
    ) : ( cTime < 0.607843 ) ?
    (
      tempoLabel = "5/6";
      cRate = 0.833333;
    ) : ( cTime < 0.627451 ) ?
    (
      tempoLabel = "13/16";
      cRate = 0.8125;
    ) : ( cTime < 0.647059 ) ?
    (
      tempoLabel = "3/4";
      cRate = 0.75;
    ) : ( cTime < 0.666667 ) ?
    (
      tempoLabel = "11/16";
      cRate = 0.6875;
    ) : ( cTime < 0.686275 ) ?
    (
      tempoLabel = "2/3";
      cRate = 0.666667;
    ) : ( cTime < 0.705882 ) ?
    (
      tempoLabel = "5/8";
      cRate = 0.625;
    ) : ( cTime < 0.72549 ) ?
    (
      tempoLabel = "9/16";
      cRate = 0.5625;
    ) : ( cTime < 0.745098 ) ?
    (
      tempoLabel = "1/2";
      cRate = 0.5;
    ) : ( cTime < 0.764706 ) ?
    (
      tempoLabel = "7/16";
      cRate = 0.4375;
    ) : ( cTime < 0.784314 ) ?
    (
      tempoLabel = "3/8";
      cRate = 0.375;
    ) : ( cTime < 0.803922 ) ?
    (
      tempoLabel = "1/3";
      cRate = 0.333333;
    ) : ( cTime < 0.823529 ) ?
    (
      tempoLabel = "5/16";
      cRate = 0.3125;
    ) : ( cTime < 0.843137 ) ?
    (
      tempoLabel = "1/4";
      cRate = 0.25;
    ) : ( cTime < 0.862745 ) ?
    (
      tempoLabel = "3/16";
      cRate = 0.1875;
    ) : ( cTime < 0.882353 ) ?
    (
      tempoLabel = "1/6";
      cRate = 0.166667;
    ) : ( cTime < 0.901961 ) ?
    (
      tempoLabel = "1/8";
      cRate = 0.125;
    ) : ( cTime < 0.921569 ) ?
    (
      tempoLabel = "1/12";
      cRate = 0.0833333;
    ) : ( cTime < 0.941176 ) ?
    (
      tempoLabel = "1/16";
      cRate = 0.0625;
    ) : ( cTime < 0.960784 ) ?
    (
      tempoLabel = "1/24";
      cRate = 0.0416667;
    ) : ( cTime < 0.980392 ) ?
    (
      tempoLabel = "1/32";
      cRate = 0.03125;
    ) : ( cTime < 1 ) ?
    (
      tempoLabel = "1/64";
      cRate = 0.015625;
    );
    modulator.setModRate( .25 * (cTempo/60) / cRate );
  );
  
  overSampling.sliderWidget_setValue(slider54);
  inGain.sliderWidget_setValue(slider52);
  inGain.sliderWidget_setValue2_nn(slider51);
  outGain.sliderWidget_setValue(slider53);
  cutoffSlider.sliderWidget_setValue(slider48);
  resonanceSlider.sliderWidget_setValue(slider49); 
  cutoffSlider.sliderWidget_setValue2_nn(slider62);
  resonanceSlider.sliderWidget_setValue2_nn(slider63);
  filterSelect.combobox_setcuritem(slider47);
  modeSelect.combobox_setcuritem(slider46);
  lfoSelect.combobox_setcuritem(slider36);

  threshSlider.sliderWidget_setValue(slider59);
  attackSlider.sliderWidget_setValue(slider60);
  decaySlider.sliderWidget_setValue(slider61);
  rmsSlider.sliderWidget_setValue(slider64);
  lookAheadButton.active          = slider35==1 ? 1 : 0;
  inClip.active                   = slider55 & 1 ? 1 : 0;
  outClip.active                  = slider55 & 2 ? 1 : 0;
  dynButton.active                = slider45==1 ? 1 : 0;

  atk_x4_1.active                 = slider57 & 1 ? 1 : 0;
  atk_x4_2.active                 = slider57 & 2 ? 1 : 0;
  decay_x4_1.active               = slider57 & 4 ? 1 : 0;
  decay_x4_2.active               = slider57 & 8 ? 1 : 0;
  rms_x4_1.active                 = slider57 & 16 ? 1 : 0;
  rms_x4_2.active                 = slider57 & 32 ? 1 : 0;
  firButton.active                = slider40==1 ? 1 : 0;
  
  lfoFrequency.sliderWidget_setValue(slider37);
  modulationFactor.sliderWidget_setValue(slider39);
  lfoResetButton.active = (slider38&1) ? 1 : 0;
  tempoLFOButton.active = (slider38&2) ? 1 : 0;
  
  dynamics = slider58;
  dynamicsEnabled = dynamics > 0;
  ( dynamicsEnabled ) ?
  (
    atkmul        = ( 1 + 3*atk_x4_1.active ) * ( 1 + 3*atk_x4_2.active );
    
    dyn_thresh    = slider59;
    ( slider45 == 0 ) ? (
      decaymul      = ( 1 + 3*decay_x4_1.active ) * ( 1 + 3*decay_x4_2.active );
      dyn_atk     = 1 / ( atkmul * slider60 * srate / 100 + 0.0001 );
      dyn_decay   = 1 / ( log(2) * max(.05, decaymul * slider61) * srate / 100 + 0.0001 );      
    ) : (
      dyn_atk     = (2^(2*(atkmul * slider60-25)/25));
      dyn_decay   = slider61/50;
    );
  );
  
  dyn_mod_filt  = cutoffSlider.sliderWidget_getValue2();
  dyn_mod_reso  = resonanceSlider.sliderWidget_getValue2();
  dyn_mod_gain  = inGain.sliderWidget_getValue2();  
  
  ( ( dynamics == 1 ) || ( dynamics == 3 ) ) ? ( filterDynamics = 1; ) : ( filterDynamics = 0; );
  ( ( dynamics == 2 ) || ( dynamics == 3 ) ) ? ( distortionDynamics = 1; ) : ( distortionDynamics = 0; );
  dynamicFilterButton.active = filterDynamics;
  dynamicWaveShapingButton.active = distortionDynamics;  

  setter = window2.spline.xloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider3; setter += 1;
  setter[] = slider5; setter += 1;
  setter[] = slider7; setter += 1;
  setter[] = slider9; setter += 1;
  setter[] = slider11; setter += 1;
  setter[] = slider13; setter += 1;
  setter[] = slider15; setter += 1;
  setter[] = slider17; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window2.spline.yloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider4; setter += 1;
  setter[] = slider6; setter += 1;
  setter[] = slider8; setter += 1;
  setter[] = slider10; setter += 1;
  setter[] = slider12; setter += 1;
  setter[] = slider14; setter += 1;
  setter[] = slider16; setter += 1;
  setter[] = slider18; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window1.spline.xloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider19; setter += 1;
  setter[] = slider21; setter += 1;
  setter[] = slider23; setter += 1;
  setter[] = slider25; setter += 1;
  setter[] = slider27; setter += 1;
  setter[] = slider29; setter += 1;
  setter[] = slider31; setter += 1;
  setter[] = slider33; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window1.spline.yloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider20; setter += 1;
  setter[] = slider22; setter += 1;
  setter[] = slider24; setter += 1;
  setter[] = slider26; setter += 1;
  setter[] = slider28; setter += 1;
  setter[] = slider30; setter += 1;
  setter[] = slider32; setter += 1;
  setter[] = slider34; setter += 1;  
  setter[] = 1; setter += 1;
  
  ( slider56 == 0 || hard == 1 ) ? (
    window1.wsetN(slider1);
    window2.wsetN(slider2);
    window1.spline.xloc_write[slider1-1] = 1;
    window2.spline.xloc_write[slider2-1] = 1;
 
    window1.sort_spline();
    window2.sort_spline();
    window1.update_spline();
    window2.update_spline();
  );

  // Only update the oversampling filters when needed.
  ( slider54 != lastOversample ) ? 
  (
    lastOversample = slider54;   

    filterL.updateFilter(slider54);
    filterR.updateFilter(slider54);
    // Memory for the sincs is located at sinc_tmp, sinc_flt, sinc_flt2, sinc_flt3 and sinc_flt4
    sincFilterL.updateSincFilter(slider54, 8, sinc_flt,  sinc_tmp);
    sincFilterR.updateSincFilter(slider54, 8, sinc_flt2, sinc_tmp);
    nTapSinc = slider54 < 5 ? 16 : slider54*4;
    sincDownL.updateSincDownsampleFilter(slider54, nTapSinc, sinc_hist1, sinc_flt3);
    sincDownR.updateSincDownsampleFilter(slider54, nTapSinc, sinc_hist2, sinc_flt4);  
 );
  
  // Calculate group delay incurred by sincs
  iN = 1.0 / slider54;
  cDelay  = ( slider40 == 0 ) ? 0 : iN * (.5 * 7 * slider54 - 1);
  cDelay += ( slider40 == 0 ) ? 0 : iN * (.5 * nTapSinc - 1);
  updateIntegrationTime(); // updates lookAheadDelay
  cDelay += lookAheadDelay;
 
  pdcDelay = cDelay;
);

function initGUI()
(
  // Initialize object instances
  window1.init_window(wndPad, wndPad, wndX, wndY, 10, 1, negative_xloc, negative_yloc, negative_xloc2, negative_yloc2, pos_indices, temp_xloc, temp_yloc, temp_indices, neg_c1s, neg_c2s, neg_c3s, neg_c1s2, neg_c2s2, neg_c3s2);
  window2.init_window(2*wndPad+wndX, wndPad, wndX, wndY, 10, 2, positive_xloc, positive_yloc, positive_xloc2, positive_yloc2, neg_indices, temp_xloc, temp_yloc, temp_indices, pos_c1s, pos_c2s, pos_c3s, pos_c1s2, pos_c2s2, pos_c3s2);
  
  updateSliders(1);
  updateActiveFilters(1);
);

function setupGUI()
(
  UI_Loaded = 1;
  retina_scaling = gfx_ext_retina * (1+extraScale);
  widgetFontSize = 12 + linuxMode;
  buttonFontSize = 11;
  
  gfx_setfont(1, fontface, widgetFontSize);
  gfx_measurestr("LookAhead", str_width, str_height);
  font_factor    = 47 / str_width; // 47 is the button text area
  widgetFontSize = widgetFontSize * font_factor * ( 1 + linuxMode * .2 );
  buttonFontSize = buttonFontSize * font_factor;

  // Initialize object instances
  wndX    = 250 * retina_scaling;
  wndY    = 250 * retina_scaling;
  wndPad  = 30 * retina_scaling;
  window1.gen_window(wndPad, wndPad, wndX, wndY, 10, 1, negative_xloc, negative_yloc, negative_xloc2, negative_yloc2, pos_indices, temp_xloc, temp_yloc, temp_indices, neg_c1s, neg_c2s, neg_c3s, neg_c1s2, neg_c2s2, neg_c3s2);
  window2.gen_window(2*wndPad+wndX, wndPad, wndX, wndY, 10, 2, positive_xloc, positive_yloc, positive_xloc2, positive_yloc2, neg_indices, temp_xloc, temp_yloc, temp_indices, pos_c1s, pos_c2s, pos_c3s, pos_c1s2, pos_c2s2, pos_c3s2);
  window3.gen_dynamics(3*wndPad+2*wndX, wndPad, wndX, wndY );
  
  wR = wG = wA = 0.7; wB = 0.9;
  masterPanelX = 4*wndPad+3*wndX;
  masterPanelY = (30 + 5) * retina_scaling;
  sliderWidth = 234 * retina_scaling;
  sliderHeight= 20 * retina_scaling;
  sliderPad   = 5 * retina_scaling;
  masterPanel.groupWidget(masterPanelX, masterPanelY, sliderWidth, sliderHeight*3+5*sliderPad, "MASTER", wR, wG, wB, wA );
  inGain.sliderWidget(masterPanelX+sliderPad, masterPanelY+sliderPad, .82*sliderWidth-2*sliderPad, sliderHeight, "Pre-Gain / Drive", wR, wG, wB, wA, 1, -40, 40, 0, " dB", 0, "Input gain\n(Post upsampling, pre-effect)");
  inClip.selectionButton(masterPanelX+sliderPad + .8*sliderWidth, masterPanelY+sliderPad, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Clip",  .3, .4, .8, .3, "Toggle input clipping");
  outGain.sliderWidget(masterPanelX+sliderPad, masterPanelY+2*sliderPad+sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Post-Gain", wR, wG, wB, wA, 0, -40, 40, 0, " dB", 0, "Output gain");
  outClip.selectionButton(masterPanelX+sliderPad + .8*sliderWidth, masterPanelY+2*sliderPad+sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Clip",  .3, .4, .8, .3, "Toggle output clipping");
  overSampling.sliderWidget(masterPanelX+sliderPad, masterPanelY+3*sliderPad+2*sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Oversampling", wR, wG, wB, wA, 0, 1, 8, 1, "x", 1, "Oversampling factor\nOversampling reduces aliasing that occurs when distorting heavily\nand is required for the stability of a few filters.\nUse FIR version if phase is important (stabby sounds).\n");
  firButton.selectionButton(masterPanelX+sliderPad + .8*sliderWidth, masterPanelY+3*sliderPad+2*sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "FIR",  .3, .4, .8, .3, "Enable FIR up/downsampling\n(preserves phase but expensive)");
  
  filterPanelX = masterPanelX;
  filterPanelY = 140 * retina_scaling;
  filterPanel.groupWidget(filterPanelX, filterPanelY, sliderWidth, sliderHeight*4+6*sliderPad, "FILTER", wR, wG, wB, wA );
  filterSelect.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nFilters, 0, 0, 3, "Filter selection.\nNon-linear (NL) filters are more expensive and benefit more from oversampling.\nTheir character comes out when driven (increase the pre-gain without enabling clipping).\nZero Delay Feedback (ZDF) filters behave better with rapid modulation.\nAll filters are IIR filters, meaning they do not preserve linear phase.\n\nWARNING: Not all filters are stable under rapid modulation!\nRemember to read the filter description to avoid being hit by instability.\nInstability manifests itself as there suddenly being a spike and then no sound." );
  modeSelect.combobox(filterPanelX+sliderPad, filterPanelY+sliderPad*2+sliderHeight, sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nModes, 1, 0, 1, "Filter mode selection.\nStereo - Default mode. Process left and right independently.\nMono double - Interleave samples and process.\nM1/S2 - Process mid regularly, feed side samples to filter twice.\nM2/S1 - Feed mid to filter twice, process side regularly.\nOnly side - Only filter the side channel.\nOnly mid - Only filter the mid channel.\nStereoize - Filter both, but pre-amplify side channel." );
  cutoffSlider.sliderWidget(filterPanelX+sliderPad, filterPanelY+4*sliderPad+2*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Cutoff", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Filter cutoff.\nLMB sets filter cutoff.\nRMB sets range for modulation.\n\nFor more info on modulation, hover over the Filter button in the dynamics panel.\nNote that when LFO and dynamics are both active, the modulation range is twice what is diplayed.");
  resonanceSlider.sliderWidget(filterPanelX+sliderPad, filterPanelY+5*sliderPad+3*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Resonance", wR, wG, wB, wA, 1, 0, 1, 0, "", 0, "Filter resonance.\nLMB sets filter cutoff.\nRMB sets range for modulation.\n\nFor more info on modulation, hover over the Shaper button in the dynamics panel.\nNote that when LFO and dynamics are both active, the modulation range is twice what is diplayed.");
  
  dynamicsPanelX = masterPanelX;
  dynamicsPanelY = 270 * retina_scaling;
  buttonHeight = 12 * retina_scaling;
  buttonWidth = 51 * retina_scaling;
  buttonPad = 6 * retina_scaling;
  dynamicsPanel.groupWidget(dynamicsPanelX, dynamicsPanelY, sliderWidth, buttonHeight+sliderHeight*4+7*sliderPad, "DYNAMICS", wR, wG, wB, wA );
  
  dynamicFilterButton.selectionButton(dynamicsPanelX+sliderPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "Filter",  .3, .4, .8, .3, "Enable dynamic filter manipulation.\n\nWhen activated, the filter responds to changes in the dynamic\nvariable (shown with the yellow curve). This value changes based\non the settings set in the dynamics panel. It is either modulated\nby an attack/decay mechanism based on thresholding the input RMS\nvalue, or directly set to some function of the RMS value (RMS mode).");
  dynamicWaveShapingButton.selectionButton(dynamicsPanelX+sliderPad+buttonWidth+buttonPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "Shaper",  .3, .4, .8, .3, "Enable dynamic waveshaper activation.\n\nWhen activated, the waveshaper responds to changes in the dynamic\nvariable (shown with the yellow curve). Based on the dynamic variable,\nthe waveshaper interpolates between no waveshaping and the curve set\nby the user. This can be used to simulate compressors for instance.\n\nThe dynamic variable changes based on the settings set in the dynamics\npanel. It is either modulated by an attack/decay mechanism based on\nthresholding the input RMS value or directly set to some function of\nthe RMS value (RMS mode).\n");
  lookaheadButton.selectionButton(dynamicsPanelX+sliderPad+2*buttonWidth+2*buttonPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "LookAhead",  .3, .4, .8, .3, "Prevent lag in RMS estimate");
  dynButton.selectionButton(dynamicsPanelX+sliderPad+3*buttonWidth+3*buttonPad, dynamicsPanelY+sliderPad+1, buttonWidth, buttonHeight, "RMS Mode",  .3, .4, .8, .3, "Use threshold or modulate directly by RMS.\n\nThe dynamic variable (shown with the yellow curve) changes based\non one of two mechanisms. Either it changes based on an attack/decay\nmechanism based on thresholding the input RMS value (RMS mode off),\nor it is directly set (without transient) to a function of the RMS \nvalue (RMS mode on).");
  threshSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+3*sliderPad+buttonHeight, sliderWidth-2*sliderPad, sliderHeight, "Threshold", wR, wG, wB, wA, 0, 0, 1, 0, " V", 0, "Threshold value.\nWhen input RMS exceeds this value, the dynamic variable begins to accumulate.\n");
  mulWidth = .06 * sliderWidth;
  mulPad = 4 * retina_scaling;
  attackSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, sliderWidth-2*sliderPad - 2*mulWidth-2*mulPad, sliderHeight, "Attack", wR, wG, wB, wA, 0, 0, 50, 0, "", 0, "Attack\nHow long does the dynamic variable take to change\nto its maximal value once over the threshold.");
  atk_x4_1.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-mulWidth, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  .3, .4, .8, .3, "Multiply value by 4");
  atk_x4_2.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, dynamicsPanelY+4*sliderPad+sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  .3, .4, .8, .3, "Multiply value by 4");
  decaySlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, sliderWidth-2*sliderPad - 2*mulWidth-2*mulPad, sliderHeight, "Decay", wR, wG, wB, wA, 0, 0, 50, 0, "", 0, "Decay\nHow long does the dynamic variable take to\ndecay when below the threshold.");
  decay_x4_1.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-mulWidth, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  .3, .4, .8, .3, "Multiply value by 4");
  decay_x4_2.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, dynamicsPanelY+5*sliderPad+2*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  .3, .4, .8, .3, "Multiply value by 4");
  rmsSlider.sliderWidget(dynamicsPanelX+sliderPad, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, sliderWidth-2*sliderPad - 2*mulWidth-2*mulPad, sliderHeight, "RMS time", wR, wG, wB, wA, 0, 0.02, 40, 0, "", 0, "RMS time\nSets over how much time is the RMS computed");
  rms_x4_1.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-mulWidth, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  .3, .4, .8, .3, "Multiply value by 4");
  rms_x4_2.selectionButton(dynamicsPanelX-sliderPad+sliderWidth-2*mulWidth-mulPad, dynamicsPanelY+6*sliderPad+3*sliderHeight+buttonHeight, mulWidth, sliderHeight-4, "x4",  .3, .4, .8, .3, "Multiply value by 4");
  
  lfoPanelX = masterPanelX;
  lfoPanelY = 415 * retina_scaling;
  buttonHeight = 12 * retina_scaling;
  lfoPanel.groupWidget(lfoPanelX, lfoPanelY, sliderWidth, buttonHeight+sliderHeight*3+3*sliderPad, "LFO", wR, wG, wB, wA );
  lfoSelect.combobox(lfoPanelX+sliderPad, lfoPanelY+sliderPad, .82*sliderWidth-2*sliderPad, sliderHeight, wR, wG, wB, wA, nLFO, 2, 1, 1, "Select LFO type" );
  lfoResetButton.selectionButton(lfoPanelX+sliderPad+.8*sliderWidth, lfoPanelY+sliderPad, .2*sliderWidth-2*sliderPad, sliderHeight, "MIDI",  .3, .4, .8, .3, "Reset LFO phase on incoming MIDI note.");
  modulationFactor.sliderWidget(lfoPanelX+sliderPad, lfoPanelY+4*sliderPad+2*sliderHeight, sliderWidth-2*sliderPad, sliderHeight, "Modulation Range", wR, wG, wB, wA, 0, 0, 4, 1, "", 0, "Modulation range");
  lfoFrequency.sliderWidget(lfoPanelX+sliderPad, lfoPanelY+3*sliderPad+sliderHeight, .82*sliderWidth-2*sliderPad, sliderHeight, "Rate", wR, wG, wB, wA, 0, 0, 1, 0, "", 0, "LFO rate");
  tempoLFOButton.selectionButton(lfoPanelX+sliderPad + .8*sliderWidth, lfoPanelY+3*sliderPad+sliderHeight, .2*sliderWidth-2*sliderPad, sliderHeight-4, "Tempo",  .3, .4, .8, .3, "Synchronize to tempo");

  updateSliders(1);
  updateActiveFilters(1);
);

// Initialize the splines
initGUI();

function distort(s)
  global(window1.evalDistAudio, window2.evalDistAudio, rc_filter.evalRC2)
  local(os)
  global(slider55, slider56, dynval, distortionDynamics)
  ( 
    ( slider56 == 0 ) ? (
      os = s; 
      s = ( s > 0 ) ? s = window1.evalDistAudio(s) : ( s = -window2.evalDistAudio(-s); );
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 1 ) ? ( 
      os = s;
      s = tanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 2 ) ? (
      os = s;
      s = fasttanh(s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    ) : ( slider56 == 4 ) ? (
      os = s;
      s = sin(2*$pi*s);
      distortionDynamics ? s = (1.0-dynval) * os + dynval * s;
    );

    s
  );
  
function distortderiv(s)
  global(window1.evalDiff, window2.evalDiff, rc_filter.evalRC2)
  local(th)
  global(slider56, dynval)
  (
    ( slider56 == 0 ) ? (
      s = ( s > 0 ) ? s = window1.evalDiff(s) : ( s = -window2.evalDiff(-s); );
    ) : ( slider56 == 1 ) ? (
      th = tanh(s);
      s = 1.0 - th*th;
    ) : ( slider56 == 2 ) ? (
      th = fasttanh(s);
      s = 1.0 - th*th;
    );
    (1.0-dynval) + dynval * s
  );  

//---------------------------
// Filter usage section
//--------------------------- 
function evalRC(input)
  instance(len, v0, v1, a1, c)
  local(output, tmp)
  global(srate)
  (
    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    tmp = v1;

    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    output = (tmp+v1)*0.5;
  );

function eval303(input)
  local(y0, s0, s)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4
            b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  global(distort)
  (
    s = (z0*wc3 + z1*a20 + z2*c2 + z3*c3);
    y4 = (g*input + s)/(1 + g*k);
    
    y0 = max(-1,min(1,distort(input - k*y4)));
    y1 = b * ( y0*b0 + z0*a0 + z1*a1 + z2*a2 + z3*a3 );
    y2 = b * (y0*b10 + z0*a10 + z1*a11 + z2*a12 + z3*a13);
    y3 = b * (y0*b20 + z0*a20 + z1*a21 + z2*a22 + z3*a23);
    y4 = g*y0 + s;
    
    z0 += 4*wc*(y0 - y1 + y2);
    z1 += 2*wc*(y1 - 2*y2 + y3);
    z2 += 2*wc*(y2 - 2*y3 + y4);
    z3 += 2*wc*(y3 - 2*y4);
  );

function evalmoog(input)
  local(x)
  global()
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    // Process input
    x = input - r*y4;
    
    // Four cascaded onepole filters (bilinear transform)
    y1= x*p +  oldx*p - k*y1;
    y2=y1*p + oldy1*p - k*y2;
    y3=y2*p + oldy2*p - k*y3;
    y4=y3*p + oldy3*p - k*y4;
    
    // Clipper band limited sigmoid
    y4-=(y4*y4*y4)/6.;
    //y4 -= distort(y4);
    oldx = x; oldy1 = y1; oldy2 = y2; oldy3 = y3;
    
    y4;
  );

  //filter_karlsen
function evalkarlsen(b_v)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  ( 
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    b_v     = distort(b_v);
    b_v     = min(max(b_v, 0),1);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = b_aflt4;
  );
 
  //filter_karlsen
function evalkarlsen_sat(b_v)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    // for nice low sat, or sharper type low deemphasis saturation, one can use a onepole shelf before the filter.
    b_lfcut = .001;
    b_lf    = b_lf + ((-b_lf + b_v) * b_lfcut); // b_lfcut 0..1
    b_lfhp  = b_v - b_lf;
    b_v     = b_lf + (b_lf1hp * ((b_lfgain*0.5)+1)); 
  
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    b_v     = distort(b_v);
    b_v     = min(max(b_v, 0),1);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = 4*b_aflt4;
  );
  
function evaldualfilt(sample)
  local(out, fbs)
  global(distort)
  instance(fb, f, d0, d1)
  (
    fbs = fb * .5*(distort(d0 - d1) + (d0-d1) + 0.15 * out );
    fbs = max(-2, min(2, fbs));
    d0  = d0 + f * (sample - d0 + fbs );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(d1)*0.9 + d1*0.1;
  );
  
function evaldualfiltHP(sample)
  local(out, hp, bp, fbs)
  global(distort)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    fbs = fb * .5*(distort(d0 - d1) + (d0-d1) + 0.15 * out );
    fbs = max(-2, min(2, fbs));
    d0  = d0 + f * ( hp + fbs );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(hp)*0.9 + hp*0.51;
  );
  
function evaldualfiltBP(sample)
  local(out, hp, bp, fbs)
  global(distor)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    fbs = fb * (.6*distort(d0 - d1) + .4*(d0-d1) + 0.15 * out );
    fbs = max(-2, min(2, fbs));
    d0  = d0 + f * ( hp + fbs );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(bp)*.7 + bp*0.3 + 0.05*hp + 0.05*d1;
  );
  
function evalfancymoog(y0)
  local(S0, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3                    
        )
  global(distort, distortderivt, tanh)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, S1)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      WS0 = distort(S0);
      gJ0 = g*distortderiv(S0);

      WS1 = distort(S1);
      gJ1 = g*distortderiv(S1);
      
      WS2 = distort(S2);
      gJ2 = g*distortderiv(S2);
      
      WS3 = distort(S3);
      gJ3 = g*distortderiv(S3);
      
      WS4 = distort(S4);
      gJ4 = g*distortderiv(S4);      
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );

      // Jacobian subexpressions
      t2 = gJ2*gJ3;
      t3 = gJ2*gJ4;
      t4 = gJ3*gJ4;
      t5 = gJ2*gJ3*gJ4;
      t6 = gJ1*gJ2;
      t7 = gJ1*gJ3;
      t8 = gJ1*gJ4;
      t9 = gJ1*gJ2*gJ3;
      t10 = gJ1*gJ2*gJ4;
      t11 = gJ1*gJ3*gJ4;
      t12 = gJ1*gJ2*gJ3*gJ4;
      t13 = gJ0*gJ1*gJ2*gJ3*k;
      t14 = gJ1+gJ2+gJ3+gJ4+t2+t3+t4+t5+t6+t7+t8+t9+t10+t11+t12+t13+1.0; 
      t15 = 1.0/t14;
      t16 = gJ2+1.0;
      t17 = gJ3+1.0;
      t18 = gJ1+1.0;
      
      // Jacobian
      A0_0_0 = t15*(gJ2+gJ3+gJ4+t2+t3+t4+t5+1.0);
      A0_0_1 = -gJ0*gJ2*gJ3*k*t15;
      A0_0_2 = -gJ0*gJ3*k*t15*t16;
      A0_0_3 = -gJ0*k*t15*t16*t17;
      A0_1_0 = t15*(gJ1+t7+t8+t11);
      A0_1_1 = t15*(gJ1+gJ3+gJ4+t4+t7+t8+t11+1.0);
      A0_1_2 = -gJ0*gJ1*gJ3*k*t15;
      A0_1_3 = -gJ0*gJ1*k*t15*t17;
      A0_2_0 = t15*(t6+t10);
      A0_2_1 = t15*(gJ2+t3+t6+t10);
      A0_2_2 = t15*(gJ1+gJ2+gJ4+t3+t6+t8+t10+1.0);
      A0_2_3 = -gJ0*gJ1*gJ2*k*t15;
      A0_3_0 = gJ1*gJ2*gJ3*t15;
      A0_3_1 = gJ2*gJ3*t15*t18;
      A0_3_2 = gJ3*t15*t16*t18;
      A0_3_3 = t15*t16*t17*t18;
      
      // Newton Raphson update
      y1 = y1 - ( A0_0_0 * F1 + A0_1_0 * F2 + A0_2_0 * F3 + A0_3_0 * F4 );
      y2 = y2 - ( A0_0_1 * F1 + A0_1_1 * F2 + A0_2_1 * F3 + A0_3_1 * F4 );
      y3 = y3 - ( A0_0_2 * F1 + A0_1_2 * F2 + A0_2_2 * F3 + A0_3_2 * F4 );
      y4 = y4 - ( A0_0_3 * F1 + A0_1_3 * F2 + A0_2_3 * F3 + A0_3_3 * F4 );
      //y1 = y1 - ( A0_0_0 * F1 + A0_0_1 * F2 + A0_0_2 * F3 + A0_0_3 * F4 );
      //y2 = y2 - ( A0_1_0 * F1 + A0_1_1 * F2 + A0_1_2 * F3 + A0_1_3 * F4 );
      //y3 = y3 - ( A0_2_0 * F1 + A0_2_1 * F2 + A0_2_2 * F3 + A0_2_3 * F4 );
      //y4 = y4 - ( A0_3_0 * F1 + A0_3_1 * F2 + A0_3_2 * F3 + A0_3_3 * F4 );
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalfancymoog_noJac(y0)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4)
  global(distort, distortderiv)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      WS0 = distort(S0);
      WS1 = distort(S1);
      WS2 = distort(S2);
      WS3 = distort(S3);
      WS4 = distort(S4);
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );
     
      // Newton Raphson update (assuming derivatives 0)
      y1 = y1 - F1;
      y2 = y2 - F1 - F2;
      y3 = y3 - F3;
      y4 = y4 - F4;
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalvowel(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;
    
    d2yC = d1yC;
    d1yC = outC;
    
    out  = amp1 * outA + amp2 * outB + amp3 * outC;
  );
  
function evalsai0(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    sample = distort(sample);
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;

    d2yC = d1yC;
    d1yC = outC - .01 * ( outA - outB );
    
    out  = outA-.6*distort(outC-outB);
    out = 0.4*out;
  );  
  
function evalmodulator(sample)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp, d2x2, d1x2
   )
  local(out, dS, outA, outB, modo)
  global()
  (
    // Modulator LP
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB; 
    d2yB = d1yB;
    d1yB = outB;
    d2x = d1x;
    d1x = sample;
    
    modo = sample * outB;
    outA = Ab0 * modo + Ab1 * d1x2 + Ab2 * d2x2 - Aa1 * d1yA - Aa2 * d2yA;    
    d2yA = d1yA;
    d1yA = outA;    
    d2x2 = d1x2;
    d1x2 = modo;
    
    out  = distort(outB * distort(sample+amp*outA)*2);
  );    
  
function evalrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local(out)
  global()
  (
    out = b0 * sample + b1 * d1x + b2 * d2x - a1 * d1y - a2 * d2y;
    
    d2x = d1x;
    d1x = sample;
    
    d2y = d1y;
    d1y = out;
    out;
  );

function evalphaserOTA(sample, jnk)
  global(distort)
  local(w)
  instance(C1, C2, dw, dx, sq)
  (
    sample = sample - sq * jnk;
    w = dw + C1 * distort( C2 * ( sample + dx + dw ) );
    dx = sample;
    dw = w;
    
    w + sample
  );
    
function evalphaserFET(sample)
  global(distort)
  local(w, u, I_ds, out)
  instance(C1, C2, dw, IDSSdivVpSq, thresh)
  (
    u = sample - dw;
    
    I_ds = ( u < thresh ) ? (
      IDSSdivVpSq * 2 * thresh * u - u*u;
    ):(
      IDSSdivVpSq * thresh * thresh * u;
    );
    
    w = dw + C1 * ( C2 * u + I_ds );
    
    out = sample - w - dw;
    dw = w;
    
    out
  );

// One-pole zero-delay LP filter
function zdf(G, x)
  global()
  local()
  instance(tpt, y)
  (
    y = G*x + tpt.s;
    tpt.TPT_step(G, x-y);
  );

function eval_MS20lin(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    x = distort(x);
  
    y  = a0 * x + a1 * s1 + a2 * s2;
    ky = k*y;
    onepole1.zdf(g, x - ky);
    onepole2.zdf(g, onepole1.y + ky);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20linBP(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    x = distort(x);
  
    y  = -a0 * x + a1 * (s1 + x) + a2 * s2;
    ky = k*y;
    onepole1.zdf(g, -x - ky);
    onepole2.zdf(g, onepole1.y + ky + x);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20linHP(x)
  global()
  local(y, ky)
  instance(a0, a1, a2, s1, s2, g, k, onepole1, onepole2)
  (
    x = distort(x);
  
    y  = a1 * (s1 - x) + x + s2;
    ky = k*y;
    onepole1.zdf(g, - ky);
    onepole2.zdf(g, onepole1.y + ky - x);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );    
  
function eval_MS20(x)
  global(slider54)
  local(ky, y, fy, fyprime, distky, ddistky)
  instance(s1, s2, G, Gsq, Gsqk, Gk, k, onepole1, onepole2)
  (
    //fyprime = 1.0 - d/dy(Gsq*x*k*distort(y)) - d/dy(G*k*distort(y));
    //x = distort(x);

    loop(3,
      ky = k*y;
      distky = distort(ky);
      ddistky = distortderiv(ky);
      fy = y - Gsq*x + Gsq*distky - G * S1 - G*distky - S2;
      fyprime = 1.0 + Gsq*ddistky - G*ddistky;
      y = y - fy/fyprime;
    );
    
    //y = (Gsq*x + G*S1 + S2)/(1+Gsqk-Gk);
    
    ky = k*y;
    onepole1.zdf(g, x - distky);
    onepole2.zdf(g, onepole1.y + distky);
    
    s1 = onepole1.tpt.s;
    s2 = onepole2.tpt.s;
  
    y
  );
  
function eval_MS20_nonlin(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2;
      dgky2   = k - k * min( abs(gky2), 1 );
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2) 
  );  
  
function eval_MS20_nonlin_FM(x)
  global(slider54)
  local(mag, hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs, f)
  (
    mag   = f*5;
      
    gkd2  = k * sin(mag*d2); // g(k*d2)
    gkd2  = mag * k * cos(mag*d2);
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*sin(mag*y2); //k*y2;
      dgky2   = mag * k* cos(mag*y2);
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2) 
  );    
  
function eval_MS20_nonlin_mod(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
    hk    = h*k;
    
    atanterm1 = atan(d1 -  x + gkd2);
    atanterm2 = atan(d1 - d2 + gkd2);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2-2*k*(y2*y2-y2*y2*y2)-.1*k*y1;
      dgky2   = k - k * min( abs(gky2), 1 );
      gky2    = max(-1,min(1,gky2));
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x +  gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2) 
  );
  
function eval_MS20_nonlinBP(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = k*d2; // g(k*d2)
    gkd2  = max(-1,min(1,gkd2));
     
    atanterm1 = atan(d1 +  x + gkd2);
    atanterm2 = atan(d1 - d2 + x + gkd2);
    hk    = h * k;
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = k*y2;
      dgky2   = k - k * min( abs(gky2), 1 );
      
      gky2    = max(-1,min(1,gky2));
      
      sig1    = y1 + x + gky2;
      sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig1));
      f2      = y2 - d2 - hh*(atanterm2 + atan(sig2));
           
      sfunsq  = sig1*sig1;
      sub3    = (2*(sfunsq + 1));
      sub3i   = 1/sub3;
      
      sub4sq  = sig2*sig2;
      sub5    = 1 / (2*(sub4sq + 1));
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1 - (hk*dgky2 - h)*sub5;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2)
  );  
  
function eval_MS20_nonlinHP(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2px, gky2px, dgky2px, sub1sq, sub1i sub4sq, sub4i, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2px  = k*(d2 + x);    // g(k*(d2 + x))
    gkd2px  = max(-1,min(1,gkd2px));
    hk      = h * k;
    
    atanterm1 = atan(d1 + gkd2px);
    atanterm2 = atan(d1 - d2 - x + gkd2px);
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      
      gky2px  = k*(x + y2);   // g(k*(x + y2))

      // Clipper (g(y))
      gky2px  = max(-1,min(1,gky2px));
      
      // Derivative
      dgky2px = k - k * min( abs(gky2px), 1 );
      
      sig1    = y1 + gky2px;
      sig2    = x + y2 - sig1;
      f1      = y1 - d1 + hh*(atanterm1 + atan(sig1));
      f2      = y2 - d2 - hh*(atanterm2 - atan(sig2));
      
      sub1sq  = sig1*sig1;
      sub1i   = 1/(2*(sub1sq + 1));
      sub4sq  = sig2*sig2;
      sub4i   = 1/(2*(sub4sq + 1));
      
      a       = h*sub1i + 1;
      b       = hk*dgky2px*sub1i;
      c       = -h*sub4i;
      d       = 1 - (hk*dgky2px - h)*sub4i;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2+x)
  );    

function eval_ssm_nonlin_cheap(Ui)
  global(slider54, srate)
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distk2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm, term
        )
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    term        = D0 + D1; term = term + term*term*term;
    distd0d1    = term / ( 1 + abs(term) );
    
    term        = D1 + D2; term = term + term*term*term;
    distd1d2    = term / ( 1 + abs(term) );
    
    term        = D2 + D3; term = term + term*term*term;
    distd2d3    = term / ( 1 + abs(term) );
    
    term        = K2 * D3; term = term + term*term*term;
    distk2d3    = term / ( 1 + abs(term) );
    
    term        = (D0 + Di - distk2d3); term = term + term*term*term;
    distd0difb  = term / ( 1 + abs(term) );
    
    loop(3,
      term = U0 + U1; term = term + term*term*term;
      distu0u1    = term / ( 1 + abs(term) );
      term = U1 + U2; term = term + term*term*term;
      distu1u2    = term / ( 1 + abs(term) );
      term = U2 + U3; term = term + term*term*term;
      distu2u3    = term / ( 1 + abs(term) );
      term = K2 * U3; term = term + term*term*term;
      fbterm      = term / ( 1 + abs(term) );
      term        = U0 + Ui - fbterm; term = term + term*term*term;
      distu0uifb  = term / ( 1 + abs(term) );
    
      ddistu0uifb = 1 - distu0uifb*distu0uifb;
      ddistu0u1   = 1 - distu0u1*distu0u1;
      ddistu1u2   = 1 - distu1u2*distu1u2;
      ddistu2u3   = 1 - distu2u3*distu2u3;
      dfbterm     = 1 - fbterm*fbterm;
    
      f0 = -D0 + U0 + hhitau * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );


function eval_ssm_nonlin(Ui)
  global(slider54, srate)
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm)
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    distd0d1    = tanh(D0 + D1);
    distd1d2    = tanh(D1 + D2);
    distd2d3    = tanh(D2 + D3);
    distd0difb  = tanh(D0 + Di - tanh(K2*D3));
    
    loop(3,
      distu0u1    = tanh(U0 + U1);
      distu1u2    = tanh(U1 + U2);
      distu2u3    = tanh(U2 + U3);
      fbterm      = tanh(K2 * U3);
      distu0uifb  = tanh(U0 + Ui - fbterm);
    
      ddistu0uifb = 1 - distu0uifb*distu0uifb;
      ddistu0u1   = 1 - distu0u1*distu0u1;
      ddistu1u2   = 1 - distu1u2*distu1u2;
      ddistu2u3   = 1 - distu2u3*distu2u3;
      dfbterm     = 1 - fbterm*fbterm;
    
      f0 = -D0 + U0 + hhitau * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );

function ftanh2(x)
  global()
  local(sgn, ax)
  (
    sgn = sign(x);
    ax = abs(x);
//    sgn*(-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*ax)*ax)*ax)/(.2464845986383725+(.060934719706049+(.1086202599228572+.02874707922475963*ax)*ax)*ax)
    sgn*(-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*ax)*ax)*ax)/(.2464845986383725+(.0609347197060491+(.1086202599228572+.02874707922475963*ax)*ax)*ax)
  );

function cmosFun(x)
  global()
  local(absterm, signterm, taa, tab, tasc)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;
  
    absterm = abs(x); signterm = sign(x);
    
    tasc * (1-tanh( tab + taa*absterm )) * signterm;
  );

function cmosDeriv(fun)
  global()
  local(absterm, signterm, taa, tab, tasc, taadsc, taatasc)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;
    taadsc  = taa/tasc;
    taatasc = taa*tasc;
    
    (taadsc*fun*fun - taatasc)
  );
  
function cmosFun2(x)
  global()
  local(absterm, signterm, taa, tab, tasc, t)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;

    absterm = abs(x); signterm = sign(x);
    
    t = tasc * x - tasc * (1-tanh( tab + taa*absterm ))*signterm;
  );

function cmosDeriv2(fun)
  global()
  local(absterm, signterm, taa, tab, tasc, taadsc, taatasc)
  (
    taa     = 11.25;
    tab     = -8;
    tasc    = 0.6;
    taadsc  = taa/tasc;
    taatasc = taa*tasc;
    
    tasc - (taadsc*fun*fun - taatasc)
  );  
  
function eval_broken_nonlin_LP(x)
  global(slider54, srate)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    // taa = 7.5*1.5 = 11.25
    // tab = -8
    // tasc = 4.8/7.5 = 0.6
    // Empirical cmos func tasc  * ( 1.0 - tanh(taa*x+tab) )
  
    gkd2  = cmosFun(k*d2); // g(k*d2)
    hk    = h*k;
    
    atanterm1 = cmosFun(d1 -  x + gkd2);
    atanterm2 = cmosFun(d1 - d2 + gkd2);
    
    // BP
    //atanterm1 = cmosFun(d1 +  x + gkd2);
    //atanterm2 = cmosFun(d1 - d2 + x + gkd2);
    
    loop(3,
      gky2    = cmosFun(k*y2);
      dgky2   = cmosDeriv(gky2);
    
      sig1    = y1 - y2 + gky2;
      sig2    = y1 - x  + gky2;
      
      // BP
      //sig1    = y1 + x + gky2;
      //sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + cmosFun(sig2));
      f2      = y2 - d2 - hh*(atanterm2 + cmosFun(sig1));
      
      sfunsq  = sig2 * sig2;
      sub3    = 2*(sfunsq + 1);
      sub3i   = 1 / sub3;
      sub4sq  = sig1*sig1;
      sub5    = 1/(2*(sub4sq + 1));      
      
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1.0 - (hk*dgky2 - h)*sub5;
  
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
  );
  
function eval_broken_nonlin_BP(x)
  global(slider54)
  local(hk, sig1, sig2, a, b, c, d, norm, f1, f2, gkd2, gky2, dgky2, sfunsq, sub3, sub3i, sub4sq, sub5, atanterm1, atanterm2)
  instance(y1, y2, d1, d2, h, hh, k, obs)
  (
    gkd2  = cmosFun(k*d2); // g(k*d2)
    gkd2  = min(3,max(-3,gkd2)); 
     
    atanterm1 = cmosFun(d1 +  x + gkd2);
    atanterm2 = cmosFun(d1 - d2 + x + gkd2);
    hk    = h * k;
    
    loop(3,
      //gky2    = distort(k*y2);
      //dgky2   = distortderiv(k*y2);
      gky2    = min(3,max(-3,cmosFun(k*y2)));
      dgky2   = cmosDeriv(gky2);
      
      sig1    = y1 + x + gky2;
      sig2    = x + y1 - y2 + gky2;
      f1      = y1 - d1 + hh*(atanterm1 + cmosFun(sig1));
      f2      = y2 - d2 - hh*(atanterm2 + cmosFun(sig2));
           
      sfunsq  = sig1*sig1;
      sub3    = (2*(sfunsq + 1));
      sub3i   = 1/sub3;
      
      sub4sq  = sig2*sig2;
      sub5    = 1 / (2*(sub4sq + 1));
      a       = h*sub3i + 1;
      b       = hk*dgky2*sub3i;
      c       = -h*sub5;
      d       = 1 - (hk*dgky2 - h)*sub5;
        
      norm    = 1.0 / ( a*d - b*c );
      
      y1      = y1 - ( d*f1 - b*f2 ) * norm;
      y2      = y2 - ( a*f2 - c*f1 ) * norm;
    );
    
    d1 = y1;
    d2 = y2;
    
    distort(y2)
  );    
  
function eval_wasp_nonlin2(Ui)
  global(slider54, srate)
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm, fb1,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm)
  instance(hh, itau, K2, hhitau, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout)
  (
    // taa = 7.5*1.5 = 11.25
    // tab = -8
    // tasc = 4.8/7.5 = 0.6
    // Empirical cmos func tasc  * ( 1.0 - tanh(taa*x+tab) )
  
    distd0d1    = cmosFun2(D0 + D1);
    distd1d2    = cmosFun2(D1 + D2);
    distd2d3    = cmosFun2(D2 + D3);   
    fb1         = cmosFun2(K2 * D3);
    distd0difb  = cmosFun2(D0 + Di - fb1);
     
    // We desire: a*sc*(tanh(a*|x| + b)**2 - 1)*sign(x)*dabs(x)/dx
    // a dist term squared will be tasc^2 * tanh(tab + taa*abs(x))^2
    // This is one tasc too many, but one taa too little. sign(x)*dabs(x)/dx cancel out (sort of).
    
    loop(3,
      distu0u1    = cmosFun2(U0+U1);
      distu1u2    = cmosFun2(U1+U2);
      distu2u3    = cmosFun2(U2+U3);
      fbterm      = cmosFun2(K2 * U3);
      distu0uifb  = cmosFun2(U0+Ui-fbterm);
        
      ddistu0uifb = cmosDeriv2(distu0uifb);
      ddistu0u1   = cmosDeriv2(distu0u1);
      ddistu1u2   = cmosDeriv2(distu1u2);
      ddistu2u3   = cmosDeriv2(distu2u3);
      dfbterm     = cmosDeriv2(fbterm);
    
      f0 = -D0 + U0 + hhitau * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );
  

function eval_cem_nonlin(Ui)
  global(slider54, srate)
  local(a, b, c, d, e, f, g, h, f0, f1, f2, f3, bias, idet, 
        distd0d1, distd1d2, distd2d3, distd0difb, distu0u1, distu1u2, distu2u3, distu0uifb, fbterm,
        ddistu0uifb, ddistu0u1, ddistu1u2, ddistu2u3, dfbterm)
  instance(hh, itau, K2, hhitau, hhitau2, itau2, U0, U1, U2, U3, D0, D1, D2, D3, Di, Kout, res, ifdbk)
  (
    ifdbk       = 2*res;
    distd0d1    = tanh(D0 + D1);
    distd1d2    = tanh(D1 + D2);
    distd2d3    = tanh(D2 + D3);
    fbterm      = tanh(K2 * D3 - Di * ifdbk);
    distd0difb  = tanh(D0 + Di - fbterm);
    
    loop(3,
      distu0u1    = tanh(U0 + U1);
      distu1u2    = tanh(U1 + U2);
      distu2u3    = tanh(U2 + U3);
      fbterm      = tanh(K2 * U3 - Ui * ifdbk);
      distu0uifb  = tanh(U0 + Ui - fbterm);
          
      ddistu0uifb = 1 - distu0uifb*distu0uifb;
      ddistu0u1   = 1 - distu0u1*distu0u1;
      ddistu1u2   = 1 - distu1u2*distu1u2;
      ddistu2u3   = 1 - distu2u3*distu2u3;
      dfbterm     = 1 - fbterm*fbterm;
    
      f0 = -D0 + U0 + hhitau  * (distd0difb + distu0uifb);
      f1 = -D1 + U1 + hhitau  * (distd0d1   + distu0u1);
      f2 = -D2 + U2 + hhitau  * (distd1d2   + distu1u2);
      f3 = -D3 + U3 + hhitau2 * (distd2d3   + distu2u3);
      
      a = hhitau*ddistu0uifb + 1;
      b = -K2*hhitau*dfbterm*ddistu0uifb;
      c = hhitau*ddistu0u1;
      d = c + 1;
      e = hhitau*ddistu1u2;
      f = e + 1;
      g = hhitau2*ddistu2u3;
      h = g + 1;
      
      idet = 1.0/(a*d*f*h - b*c*e*g);
      U0 = U0 - (-b*d*f*f3 + b*d*f2*g - b*e*f1*g + d*f*f0*h)*idet;
      U1 = U1 - (a*f*f1*h  + b*c*f*f3 - b*c*f2*g - c*f*f0*h)*idet;
      U2 = U2 - (a*d*f2*h  - a*e*f1*h - b*c*e*f3 + c*e*f0*h)*idet;
      U3 = U3 - (a*d*f*f3  - a*d*f2*g + a*e*f1*g - c*e*f0*g)*idet;
    );
    
    D0 = U0;
    D1 = U1;
    D2 = U2;
    D3 = U3;
    Di = Ui;
    
    Kout * U3
  );
//  instance(hh, itau, itau2, K2, hhitau, hhitau2, f, rate, Kout)  
  
function eval_ssm_lin(Ui)
  global(slider54, srate)
  local(x3, x4, x5, x8, x9, x10, x12, x16, x17, x18, x19, x20, x21, x22)
  instance(x0, x1, x15, x2, x6, x7, x11, x13, x14, x16, Di, D0, D1, D2, D3, U0, U1, U2, U3, K2)
  (
    x3      = D0*x0;
    x4      = D1*x0;
    x5      = -D1 + x3 + x4;
    x8      = D2*x0;
    x9      = D3*x0;
    x10     = -D3 + x8 + x9;
    x12     = -D2 + x4 + x8;
    x16     = -x3;
    x17     = Di*x0;
    x18     = Ui*x0;
    x19     = K2*x9;
    x20     = -x4;
    x21     = -D0 + x17 + x18 - x19 + x3;
    x22     = -x8;
    
    U0 = x2*(-K2*x10*x11 + x12*x14 + x15*(D0 + x16 - x17 - x18 + x19) - x5*x7);
    U1 = x2*(x10*x14 + x11*x21 - x12*x7 + x15*(D1 + x16 + x20));
    U2 = x2*(-x10*x7 + x11*x5 - x13*x21 + x15*(D2 + x20 + x22));
    U3 = x2*(x11*x12 - x13*x5 + x15*(D3 + x22 - x9) + x21*x6);
    
    D0      = U0;
    D1      = U1;
    D2      = U2;
    D3      = U3;
    Di      = Ui;
    
    U3
  );
  
function eval_cem_lin(Ui)
  global(slider54, srate)
  local(x7, x8, x9, x16, x17, x18, x20, x24, x25, x26, x29, iG)
  instance(K2, res, x0, x1, x2, x3, x4, x5, x6, x11, x12, x13, x14, x15, x19, x27, x22, x23, x28, hh2, hh3
    D0, D1, D2, D3, U0, U1, U2, U3, Di)
  (
    iG      = 2*res;
  
    x7      = D0*x3;
    x8      = D1*x3;
    x9      = -D1 + x7 + x8;
    x16     = D2*x1;
    x17     = D3*x1;
    x18     = -D3 + x16 + x17;
    x20     = D2*x3 - D2 + x8;
    x24     = Di*x3;
    x25     = Ui*x3;
    x26     = -D0 - D3*x19 + iG*x24 + iG*x25 + x24 + x25 + x7;
    x29     = x12*x26;

    U0      = x6*(K2*x20*x23 - x14*x9 - x15*x18*x19 - x26*x27);
    U1      = x6*(x13*x18*x22 - x14*x20 + x26*x28 - x27*x9);
    U2      = x6*(-x0*hh3*x18 - x2*hh2*x29 - x20*x27 + x28*x9);
    U3      = x6*(x1*x15*x20 + x11*x29 - x23*x9 + x5*(D3 - x16 - x17));
    
    D0      = U0;
    D1      = U1;
    D2      = U2;
    D3      = U3;
    Di      = Ui;
    
    U3
  );

function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2
  );
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );
  
function eval_linearSVF_notch(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1
  );
  
function eval_linearSVF_peak(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;
    
    v0 - k*v1 -2*v2
  );      
   
    
function eval_wasplin(Ui)
  global()
  local()
  instance(U0, U1, Di, D0, D1, x0, x1, x2, x3, i1)
  (
    U0 = (-D0*x2 - D0*x3 + D0 - 4*D1*x0 - Di*x1 - Ui*x1)*i1;
    U1 = (4*D0*x0 + D1*x2 - D1*x3 + D1 - Di*x3 - Ui*x3)*i1;
    
    D0 = U0;
    D1 = U1;
    Di = Ui;
        
    -U1;
  );
      
function bufferFun(sample, delay1, delay2)
  global(distort)
  local(h)
  instance()
  (
    h = 5;
  );

  //global(window1.evalDist, window2.evalDist, filter_303.eval303)
function process(sample)
  (
    sample+=0.00000001; // DeNorm fix
  
    // Optional clipping
    ( slider55 & 1 ) ? sample = min(1,max(-1,sample));
    
    ( slider47 == 0 ) ? (
      sample = distort(sample);
    ) : ( slider47 == 1 ) ? (
      sample = this.rc_filter.evalRC(sample);
      sample = distort(sample);
    ) : ( slider47 == 2 ) ? (
      sample = this.filter_303.eval303(sample);
    ) : ( slider47 == 3 ) ? (
      sample = distort(sample);
      sample = this.filter_vowel.evalvowel(sample);
    ) : ( slider47 == 4 ) ? (
      sample = this.filter_karlsen.evalkarlsen(sample);
    ) : ( slider47 == 5 ) ? (
      sample = this.filter_karlsen_sat.evalkarlsen_sat(sample);
    ) : ( slider47 == 6 ) ? (
      sample = this.filter_dualfilt.evaldualfilt(sample);
    ) : ( slider47 == 7 ) ? (
      sample = this.filter_dualfiltHP.evaldualfiltHP(sample);
    ) : ( slider47 == 8 ) ? (
      sample = this.filter_dualfiltBP.evaldualfiltBP(sample);
    ) : ( slider47 == 9 ) ? (
      sample = gaincompensation * this.filter_fancymoog.evalfancymoog(40*sample)/40;
    ) : ( slider47 == 10 ) ? (
      sample = gaincompensation * this.filter_fancymoog.evalfancymoog_noJac(40*sample)/40;
    ) : ( slider47 == 11 ) ? (
      sample = this.filter_notch.evalrbj(sample);
      sample = distort(sample);
    ) : ( slider47 == 12 ) ? (
      sample = this.filter_sai0.evalsai0(sample);
    ) : ( slider47 == 13 ) ? (
      sample = this.filter_modulator.evalmodulator(sample);
    ) : ( slider47 == 14 ) ? (
      os = sample;
      sample = this.filter_phaser.evalphaserOTA(sample, jnk);
      sample = this.filter_phaser2.evalphaserOTA(sample, 0);
      sample = this.filter_phaser3.evalphaserOTA(sample, 0);
      sample = this.filter_phaser4.evalphaserOTA(sample, 0);
      jnk = sample;
      sample = distort((os + sample)*.5);
    ) : ( slider47 == 15 ) ? (
      os = sample;
      sample = this.filter_phaser.evalphaserFET(sample);
      sample = this.filter_phaser2.evalphaserFET(sample);
      sample = this.filter_phaser3.evalphaserFET(sample);
      sample = this.filter_phaser4.evalphaserFET(sample);
      sample = distort((os + sample)*.5);
    ) : ( slider47 == 16 ) ? (
      os1 = filter_delay1.getBuffer();
      os2 = filter_delay2.getBuffer();
      ys1 = sample - .2 * distort(os1-os2);
      filter_delay1.updateBuffer(sample);
      filter_delay2.updateBuffer(ys1-sample);
      sample = ys1 + os2;
    ) : ( slider47 == 17 ) ? (
      os1 = filter_delay1.getBuffer();
      os2 = filter_delay2.getBuffer();
      os3 = 0.001 * abs(sample) + 0.999 * abs(os3);
      filter_delay1.updateBuffer(sample);
      filter_delay2.updateBuffer(sample);
      sample = tanh(5*os3*sample + distort(sample-os1));
    ) : ( slider47 == 18 ) ? (
      sample = this.filter_ms20lin.eval_MS20lin(sample);
    ) : ( slider47 == 19 ) ? (
      sample = this.filter_ms20lin.eval_MS20linBP(sample);
    ) : ( slider47 == 20 ) ? (
      sample = this.filter_ms20lin.eval_MS20linHP(sample);            
    ) : ( slider47 == 21 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlin(sample);
    ) : ( slider47 == 22 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinBP(sample);
    ) : ( slider47 == 23 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlinHP(sample);      
    ) : ( slider47 == 24 ) ? (
      sample += 0.8 * this.filter_phaser.evalphaserFET(this.filter_delay.getBuffer());    
      flt = this.filter_ms20.eval_MS20_nonlin(sample);
      flt = this.filter_phaser2.evalphaserFET(flt);  
      this.filter_delay.updateBuffer(distort(flt-.7*sample));
      sample = this.filter_ms20.eval_MS20_nonlin(sample+flt);
      sample = this.filter_ms20.eval_MS20_nonlin(sample+flt);
      
     // L.filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq * 1000);
     // R.filter_delay2.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*filterReso * 2000);  
    ) : ( slider47 == 25 ) ? (
      sample = this.filter_ms20.eval_MS20_nonlin_mod(sample);  
    ) : ( slider47 == 26 ) ? (
      sample = this.filter_ssm.eval_ssm_nonlin(sample);   
      sample = distort(sample);
    ) : ( slider47 == 27 ) ? (
      sample = this.filter_ssm.eval_ssm_nonlin_cheap(sample);   
      sample = distort(sample);
    ) : ( slider47 == 28 ) ? (
      sample = this.filter_cem.eval_cem_nonlin(sample);   
      sample = distort(sample);
    ) : ( slider47 == 29 ) ? (
      sample = this.filter_ssm_lin.eval_ssm_lin(sample);   
      sample = distort(sample);
    ) : ( slider47 == 30 ) ? (
      sample = this.filter_cem_lin.eval_cem_lin(sample);   
      sample = distort(sample);
    ) : ( slider47 == 31 ) ? (
      sample = ( 1 - this.filter_sine.res ) * sample + this.filter_sine.res * sin(sample * this.filter_sine.freq);
      sample = distort(sample);
    ) : ( slider47 == 32 ) ? (
      sample = ( 1 - this.filter_sine.res ) * sample + this.filter_sine.res * this.filter_ms20.eval_MS20_nonlin_FM(sample);
      sample = distort(sample);
    ) : ( slider47 == 33 ) ? (
      os = .7 + .3* sin(.5*sample * this.filter_sine.freq);
      this.filter_ms20.init_MS20_nonlin(os*this.filter_sine.fraw, this.filter_sine.res);
      sample = this.filter_ms20.eval_MS20_nonlin(sample);
    ) : ( slider47 == 34 ) ? (
//      sample = this.filter_broken.eval_broken_nonlin_BP(15*sample);   
      sample = this.filter_broken.eval_broken_nonlin_LP(sample);   
      sample = distort(sample);
    ) : ( slider47 == 35 ) ? (
      //sample = this.filter_wasp2.eval_wasp_nonlin2(sample);   
      sample = this.filter_wasp.eval_wasp_nonlin_extrareso(sample);
      sample = distort(sample);
    ) : ( slider47 == 36 ) ? (
      sample = this.filter_wasp_lin.eval_wasplin(sample);
      sample = distort(sample);
    ) : ( slider47 == 37 ) ? (
      sample = this.filter_wasp.eval_wasp_nonlin(sample);
      sample = distort(sample);  
    ) : ( slider47 == 38 ) ? (
      sample = this.filter_wasp.eval_wasp_nonlin_BP(sample);
      sample = distort(sample);   
    ) : ( slider47 == 39 ) ? (
      sample = this.filter_SVF.eval_linearSVF_LP(sample);
      sample = distort(sample);
    ) : ( slider47 == 40 ) ? (
      sample = this.filter_SVF.eval_linearSVF_BP(sample);
      sample = distort(sample);            
    ) : ( slider47 == 41 ) ? (
      sample = this.filter_SVF.eval_linearSVF_HP(sample);
      sample = distort(sample);
    ) : ( slider47 == 42 ) ? (
      sample = this.filter_SVF.eval_linearSVF_notch(sample);
      sample = distort(sample);
    ) : ( slider47 == 43 ) ? (
      sample = this.filter_SVF.eval_linearSVF_peak(sample);
      sample = distort(sample);
    ) : ( slider47 == 44 ) ? (
      sample = this.filter_wasp.eval_wasp_nonlin(sample);
      sample = distort(sample); 
    ) : ( slider47 == 45 ) ? (
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      sample = lp + .2*distort(5*(reso-lp));
    ) : ( slider47 == 46 ) ? (
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      diff = 10*(reso-lp);
      resoint = .5*tanh(resoint + tanh(diff));
      sample = distort(lp + resoint);
    ) : ( slider47 == 47 ) ? (
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      diff = tanh(10*(reso-lp));
      diff = this.filter_SVF2.eval_linearSVF_LP( sample+diff );
      diff = this.filter_SVF2.eval_linearSVF_LP( diff );                
      sample = distort((lp + diff)*.7);
    ) : ( slider47 == 48 ) ? (
      //sample = distort(sample);
      sample = distort(sample);
      os = this.filter_delay.getBuffer();
      this.filter_delay.updateBuffer(sample);
      sample = (this.chan > 0) ? (sample + os) : (sample + os - 2 * this.stereoize * os);
      
    ) : ( slider47 == 49 ) ? (  
      reso = this.filter_SVF.eval_linearSVF_LP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_LP( sample );
      diff = tanh(3*(reso-lp));
      sample = lp;
      
      os = this.filter_delay.getBuffer();
      this.filter_delay.updateBuffer(diff);
      
      sample = sample+(diff+os);
      sample = distort(sample);
    ) : ( slider47 == 50 ) ? (  
      reso = this.filter_SVF.eval_linearSVF_BP( sample );
      lp = this.filter_SVF_nores.eval_linearSVF_BP( sample );
      diff = reso-lp;
      sample = lp;
      
      os = this.filter_delay.getBuffer();
      this.filter_delay.updateBuffer(diff);
      
      sample = sample+(diff+os);
      sample = distort(sample);
    );
    
    sample;
  );

ext_nodenorm    = 1; 
gfx_clear       = -1;
updateSliders();

@slider
updateSliders();
updateActiveFilters(1);

@block
  cTempo        = tempo;
  nextCutoff    = slider48;
  nextReso      = slider49;
  (samplesblock > 0) && ( samplesblock < 44100 ) && (slider50 == 1) ? (
    dCutoff = (nextCutoff - prevCutoff) / (samplesblock);
    dReso = (nextReso - prevReso) / (samplesblock);
    sliderCutoff  = prevCutoff;
    sliderReso    = prevReso;
  ) : (
    dCutoff       = 0;
    dReso         = 0;
    sliderCutoff  = slider48;
    sliderReso    = slider49;
  );
  prevCutoff    = nextCutoff;
  prevReso      = nextReso;

  // Check if the filter or filter mode changed
  flushIt = ( slider46 != currentMode ) || ( slider47 != currentFilter );
  ( flushIt == 1 ) ? (
    currentMode   = slider46;
    currentFilter = slider47;
    resetActiveFilters();
    updateSliders();
    updateActiveFilters(1);
    resetActiveFilters();
  ) : ( forceUpdate==1 ) ? (
    forceUpdate = 0;
    updateSliders();
    updateActiveFilters(1);
  );
  
 ( pdcDelay != lastpdcDelay ) ?
  (
    lastpdcDelay = pdcDelay;
    pdc_bot_ch=0; 
    pdc_top_ch=2;
    pdc_delay = pdcDelay;
  );  
  
  while (midirecv(offset,msg1,msg2,msg3)) (
     msg1==$x90 && msg3!=0 ? modulator.reset=1; // note-on!
     midisend(offset,msg1,msg2,msg3); // passthrough MIDI events
  );
  
@sample
  sl      = spl0 * pregain;
  sr      = spl1 * pregain;
 
  modulator.updateModulator();
  
  // Dynamics
  // Optional input clipping
  // Note that this input clipping is just for the dynamics and that the real clipping
  // is done on the oversampled samples to avoid aliasing issues.
  ( slider55 & 1 ) ?
  ( 
    sbl = min(1,max(-1,sl));
    sbr = min(1,max(-1,sr));
  ) : (
    sbl = sl;
    sbr = sr;
  );
  
  inV = inVol.updateBuffer( RMS1.updateRMS(sbl, sbr) );
  ( dynamicsEnabled ) ?
  (
    // Regular threshold mode
    ( slider45 == 0 ) ?
    (
      ( inV > dyn_thresh ) ? (
        dynval = dynval + dyn_atk;
        dynval = min(1, dynval);
      ) : (
        dynval = dynval - dyn_decay * dynval;
      );
    ) : (
      // RMS based mode
      dynval = min(1, (inV/dyn_thresh)^dyn_atk);
      dynval = (1 - dyn_decay) * dynval + dyn_decay * (1-dynval);
    );
    
    dynBuf.updateBuffer(dynval);
  ) : ( dynval = 1 );
  
  // Update active filter only if cutoff changed
  updateActiveFilters(0);
  
  ( lookAhead ) ?
  (
    oldl = preBufferL.getBuffer();
    oldr = preBufferR.getBuffer();
    preBufferL.updateBuffer( sl );
    preBufferR.updateBuffer( sr );
    sl = oldl;
    sr = oldr; 
  );
  
  alpha = .9999;
  movavgLN = max(alpha*movavgLN, -sl);
  movavgLP = max(alpha*movavgLP,  sl);
  movavgRN = max(alpha*movavgRN, -sr);
  movavgRP = max(alpha*movavgRP,  sr);

  ( slider54 < 1.5 ) ? (
    // Without oversampling
    sl = L.process(sl);
    sr = R.process(sr);
//  ) : ( slider54 == 1 ) ? (
//    // With oversampling
//    os.os_up2(sl); 
//    os.y1 = process(os.y1);
//    os.y0 = process(os.y0);    
//    sl = os.os_down2();
//    os.os_up2(sr);  
//    os.y1 = process(os.y1);
//    os.y0 = process(os.y0);
//    sr = os.os_down2();
  ) : ( 
    q = 0;
    // N>1 oversampling
    sli = sl;
    sri = sr;
    ( slider40 == 1 ) ? (
      sincFilterL.advanceSinc(sli);
      sincFilterR.advanceSinc(sri);
    );
    loop( slider54,
      // Upsampling
      ( slider40 == 0 ) ? (
        ssl = filterL.inputFilter(sli);
        ssr = filterR.inputFilter(sri);
      ) : (
        ssl = sincFilterL.getSubSample();
        ssr = sincFilterR.getSubSample();
      );
      ( slider46 == 0 ) ?
      (
        ssl = L.process(ssl);
        ssr = R.process(ssr);
      ) : ( slider46 == 1 ) ?
      (
        ssl = L.process(ssl);
        ssr = L.process(ssr);
      ) : ( slider46 == 2 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side);
        side = L.process(side);
        mid  = R.process(mid);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 3 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side);
        mid  = R.process(mid);
        mid  = R.process(mid);
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 4 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        side = L.process(side);
        mid  = mid;
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 5 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        mid  = R.process(mid);
        side = side;
        ssl  = mid + side;
        ssr  = mid - side;
      ) : ( slider46 == 6 ) ?
      (
        side = .5 * ( ssl - ssr );
        mid  = .5 * ( ssl + ssr );
        mid  = R.process(mid);
        side = L.process(1.5*side);
        ssl  = mid + side;
        ssr  = mid - side;
      );
      
      // IIR downsampling?
      ( slider40 == 0 ) ? (      
        (q += 1)==1 ? (
          sl = filterL.outputFilter(ssl);
          sr = filterR.outputFilter(ssr);
        ) : (
          filterL.outputFilter(ssl);
          filterR.outputFilter(ssr);
        );
      ) : (
        sincDownL.advanceHist(ssl);
        sincDownR.advanceHist(ssr);
      );
    );
    
    // FIR downsampling?
    ( slider40 == 1 ) ?
    (
      sl = sincDownL.sincDownSample();
      sr = sincDownR.sincDownSample();
    );
  );
  
  // DC correction
  otm1=0.999*otm1 + sl - itm1;
  itm1=sl;
  sl=otm1;
  otm2=0.999*otm2 + sr - itm2;
  itm2=sr;
  sr=otm2;
   
  movavgOLN = max(alpha*movavgOLN, -sl);
  movavgOLP = max(alpha*movavgOLP,  sl);
  movavgORN = max(alpha*movavgORN, -sr);
  movavgORP = max(alpha*movavgORP,  sr);
  
  spl0 = sl * postgain;
  spl1 = sr * postgain;

  // Optional output clipping
  ( slider55 > 1 ) ? 
  ( 
    spl0 = min(1,max(-1,spl0));
    spl1 = min(1,max(-1,spl1));
  );

  // Scope
  outVol.updateBuffer( RMS2.updateRMS(spl0, spl1) );

@gfx 1130 525
  function angle_line(x, y, d1, d2, angle)
  local(ca, cb)
  (
    sx = sin(angle);
    cx = cos(angle);
    gfx_line( x + d1 * cx, y + d1 * sx, x + d2 * cx, y + d2 * sx );
  );

  function draw_logo(x, y, size)
  global(gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, retina_scaling, plugname, fontface)
  local(t1, t2, t3, a, ang1, ang2, dif, range)
  (
    gfx_set(.7,.9,1.5,.7);
    gfx_circle( x, y, size*.2 );
    t1 = .4*size;
    t2 = .6*size;
    t3 = .7*size;
    
    a = 5*time_precise();
    ang1 = a; ang2 = ang1 + .5*$pi; range = (1/12)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    
    gfx_set(.8,.9,1.5,1);
    a = 8*time_precise();
    t1 = .5*size;
    t2 = size;
    t3 = 1.3*size;
    ang1 = (1/3)*$pi + a; ang2 = ang1 + .5*$pi; range = (1/12)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_line( x + t2 * cos(ang1-range), y + t2 * sin(ang1-range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_line( x + t2 * cos(ang1+range), y + t2 * sin(ang1+range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_arc(x, y, t2, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_line( x + t2 * cos(ang1-range), y + t2 * sin(ang1-range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_line( x + t2 * cos(ang1+range), y + t2 * sin(ang1+range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_arc(x, y, t2, ang2 - range, ang2 + range );
    ang1 += (2/3)*$pi;
    ang2 += (2/3)*$pi;
    angle_line( x, y, t1, t2, ang1 );
    gfx_line( x + t2 * cos(ang1-range), y + t2 * sin(ang1-range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_line( x + t2 * cos(ang1+range), y + t2 * sin(ang1+range), x + t3 * cos(ang1), y + t3 * sin(ang1) );
    gfx_arc(x, y, t2, ang2 - range, ang2 + range );
    
    gfx_set(.8,.9,1.5,.5);
    a = -1*time_precise();
    ang2 = a + .5*$pi; range = (3/12)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );    

    t3 = 1.5*size;
    gfx_set(.8,.9,1.5,.7);
    a = -1*time_precise();
    ang2 = a + .5*$pi; range = (3/12)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    ang2 += (2/3)*$pi;
    gfx_arc(x, y, t3, ang2 - range, ang2 + range );
    
    gfx_setfont(1, fontface, 10*retina_scaling);
    gfx_measurestr( "FILTHER", t1, t2 );
    gfx_x = x + 18;
    gfx_y = y - .5*t2;
    gfx_a = .3 + .5 * sin(a);
    gfx_printf(plugname)
  );

  UI_Loaded == 0 ? SetupGUI();

  lastChar = gfx_getchar();
//gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

  //function draw_button(xp, yp, str) 
  //  instance(w,h,x,y) 
  //  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,bgcolor) 
  
  visible = gfx_getchar(65536) & 4 > 0;
  updating == 0 ? (
    gfx_clear = -1;
    updating = 1;
    
    draw_logo(17*retina_scaling, 17*retina_scaling, 9*retina_scaling);
    
    // Clear screen first
    gfx_r=gfx_g=gfx_b=0; gfx_a=.6;
    gfx_x=gfx_y=0;
    gfx_rectto(gfx_w,gfx_h);
  
    filterDescription(slider47);
  
    window3.draw_back();
    window3.inLight.active ? (
      gfx_set( 1, .3, .3, .3 );
      window3.draw_buffer(inVol.scopeptr, inVol.scopebuffer, inVol.scopebuffermax, 0);
    );
    window3.outLight.active ? (
      gfx_set( .6, .3, 1, .9 );
      window3.draw_buffer(outVol.scopeptr, outVol.scopebuffer, outVol.scopebuffermax, 0);  
    );
    window3.dynLight.active ? (
      dynamicsEnabled ? (
        gfx_set( .8, .8, .2, .3 );  
        window3.draw_buffer(dynBuf.scopeptr, dynBuf.scopebuffer, dynBuf.scopebuffermax, 1); 
      );
    );
  
    retina_scaling > 1 ? gfx_setfont(1, fontface, 10*retina_scaling) : gfx_setfont(0);
    window3.draw_dynamics(dyn_thresh);
    
    retina_scaling > 1 ? gfx_setfont(1, fontface, 10*retina_scaling) : gfx_setfont(0);
    window3.draw_text("Dynamics", .025, .025);
    window3.ylabel("RMS / Level");
    window3.xlabel("Time");
    window1.draw_window(movAvgLN, movAvgRN, movavgOLN, movavgORN);
    window2.draw_window(movAvgLP, movAvgRP, movavgOLP, movavgORP);
  //  window1.draw_text("Negative", .025, .025);
    window1.ylabel("Out Voltage (-)");
    window1.xlabel("In Voltage (-)");
  //  window2.draw_text("Positive", .025, .025);
    window2.ylabel("Out Voltage (+)");
    window2.xlabel("In Voltage (+)");
  
    masterPanel.groupWidget_draw();
    filterPanel.groupWidget_draw();
    dynamicsPanel.groupWidget_draw();
    lfoPanel.groupWidget_draw();
  
    inGain.sliderWidget_draw();
    inClip.selectionButton_draw();
    outGain.sliderWidget_draw();
    outClip.selectionButton_draw();
    firButton.selectionButton_draw();
    overSampling.sliderWidget_draw();
    tempoLFOButton.selectionButton_draw();
    
    lfoFrequency.sliderWidget_draw();
    modulationFactor.sliderWidget_draw();
    
    dynamicFilterButton.selectionButton_draw();
    dynamicWaveShapingButton.selectionButton_draw();
    lookaheadButton.selectionButton_draw();
    dynButton.selectionButton_draw();
    lfoResetButton.selectionButton_draw();
    
    atk_x4_1.selectionButton_draw();
    atk_x4_2.selectionButton_draw();
    decay_x4_1.selectionButton_draw();
    decay_x4_2.selectionButton_draw();
    rms_x4_1.selectionButton_draw();
    rms_x4_2.selectionButton_draw();
    
    threshSlider.sliderWidget_draw();
    attackSlider.sliderWidget_draw();
    decaySlider.sliderWidget_draw();
    rmsSlider.sliderWidget_draw();
    
    hz = getHz(cutoffSlider.sliderWidget_getValue());
    cutoffSlider.overridevalue = hz;
    cutoffSlider.overrideunit = "Hz";
    cutoffSlider.sliderWidget_draw();
    resonanceSlider.sliderWidget_draw();
    
    lfoFrequency.overridevalue = modulator.modrate;
    (slider38&2) == 0 ? (
      lfoFrequency.overridevalue = ((1+2*slider37)^4 - 1);
      lfoFrequency.overrideunit = "Hz";
    ) : (
      lfoFrequency.overridevalue = -1000;
      lfoFrequency.overrideunit = tempoLabel;
    );
     
    // Combobox should be the last to draw
    lfoSelect.combobox_draw();  
    modeSelect.combobox_draw();
    filterSelect.combobox_draw();
    
    lfoSelect.combobox_draw_top();  
    modeSelect.combobox_draw_top();
    filterSelect.combobox_draw_top();
    
    (filterSelect.hasfocus == 0) ? (
      ( modeSelect.hasFocus == 0 ) ? (
        ( lfoSelect.hasFocus == 0 ) ? (
          inGain.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)           ? ( slider_automate( slider52=inGain.sliderWidget_getValue(); ); slider_automate( slider51=inGain.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );
          outGain.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)          ? ( slider_automate( slider53=outGain.sliderWidget_getValue(); ); forceUpdate = 1; );
          overSampling.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider54=overSampling.sliderWidget_getValue(); ); forceUpdate = 1; );
        
          cutoffSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider48=cutoffSlider.sliderWidget_getValue(); ); slider_automate( slider62=cutoffSlider.sliderWidget_getValue2_nn(); ); forceUpdate = 1; );
          resonanceSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)  ? ( slider_automate( slider49=resonanceSlider.sliderWidget_getValue(); ); slider_automate( slider63=resonanceSlider.sliderWidget_getValue2_nn() ); forceUpdate = 1; );
      
          threshSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider59=threshSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
          attackSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider60=attackSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
          decaySlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)      ? ( slider_automate( slider61=decaySlider.sliderWidget_getValue(); ); forceUpdate = 1; );
          rmsSlider.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)        ? ( slider_automate( slider64=rmsSlider.sliderWidget_getValue(); ); forceUpdate = 1; );
          
          inClip.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          outClip.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          newClipMode = inClip.active + 2 * outClip.active;
          ( slider55 != newClipMode ) ? ( slider_automate( slider55=newClipMode; ); forceUpdate = 1; );
          
          firButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          ( slider40 != firButton.active ) ? ( slider_automate( slider40=firButton.active; ); forceUpdate = 1; );
              
          atk_x4_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          atk_x4_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          decay_x4_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          decay_x4_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          rms_x4_1.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          rms_x4_2.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);                
          newMultiplierMode = atk_x4_1.active + 2*atk_x4_2.active + 4 * decay_x4_1.active + 8 * decay_x4_2.active + 16 * rms_x4_1.active + 32 * rms_x4_2.active;
          ( slider57 != newMultiplierMode ) ? ( slider_automate( slider57=newMultiplierMode; ); forceUpdate = 1; );
          
          lookAheadButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider35=lookAheadButton.active; ); forceUpdate = 1; );
          dynButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider45 = dynButton.active; ); forceUpdate = 1; );
          lfoResetButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          tempoLFOButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
          newLFOMode = lfoResetButton.active + 2*tempoLFOButton.active;
          ( slider38 != newLFOMode ) ? ( slider_automate( slider38=newLFOMode ); forceUpdate = 1; );
          
          lfoFrequency.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap)     ? ( slider_automate( slider37=lfoFrequency.sliderWidget_getValue(); ); forceUpdate = 1; );
          modulationFactor.sliderWidget_processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap) ? ( slider_automate( slider39=modulationFactor.sliderWidget_getValue(); ); forceUpdate = 1; );
          
          // Something changed w.r.t. dynamics
          dynamicFilterButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) || dynamicWaveShapingButton.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap) ? (
            slider58 = dynamicFilterButton.active + 2 * dynamicWaveShapingButton.active;
            slider_automate(slider58);
            forceUpdate = 1;
          );
          
          window1.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
          window2.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
          dyn_thresh = window3.processMouseDynamics(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap, dyn_thresh);
        );
      );      
    );
  
    ( filterSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 ) ?
      modeSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider46=modeSelect.curitem; ); );
  
    ( modeSelect.hasFocus == 0 && lfoSelect.hasFocus == 0 ) ?
      filterSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider47=filterSelect.curitem; ); );
  
    ( modeSelect.hasFocus == 0 && filterSelect.hasFocus == 0 ) ?
      lfoSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( slider_automate( slider36=lfoSelect.curitem; ); forceUpdate = 1; );
  
    lx = mouse_x;
    ly = mouse_y;
    
    ( refreshDynMode != slider45 ) ?
    (
      ( slider45 == 0 ) ?
      (
        threshSlider.setLabel("Threshold");
        attackSlider.setLabel("Attack");
        decaySlider.setLabel("Decay");
        
        threshSlider.hint = "Threshold value.\nWhen input RMS exceeds this value,\nthe dynamic variable begins to accumulate.\n";
        attackSlider.hint = "Attack\nHow long does the dynamic variable take to change\nto its maximal value once over the threshold..";
        decaySlider.hint  = "Decay\nHow long does the dynamic variable take to\ndecay when below the threshold"; 
      ) : ( 
        threshSlider.setLabel("Maximum");
        attackSlider.setLabel("Curve / Attack");
        decaySlider.setLabel("Inversion");
        
        threshSlider.hint = "Maximum\nAt which RMS signal value should\nthe dynamic modulation be 1.\n";
        attackSlider.hint = "Curve\nSets how steep the non-linearity between\nRMS value and dynamic variable is.";
        decaySlider.hint  = "Inversion\nChange polarity. 25 results in no dynamic modulation."; 
      );
      
      refreshDynMode = slider45;
    );
    
    globalTime = time_precise();
    delta_time = globalTime - lastGlobalTime;
    
    rts = 35*retina_scaling;
    ( (mouse_cap & 1) ) ?
    (
      (lastLMB == 0) && (mouse_x < rts) && (mouse_y < rts) ? (
        tc = time_precise();
        lastLMB = 1;
      
        ( (tc-lastLogoClick) < .2 ) ? (
          extraScale = (extraScale == 0) ? .2 : 0;
          SetupGUI();
        ) : lastLogoClick = tc;
      )
    ) : ( lastLMB = 0; );
    
    lastGlobalTime = globalTime;
    
    hideToolTips == 0 ? drawHint_draw();
    
    ( lastChar == 116 ) ? hideToolTips = 1 - hideToolTips;
    ( lastChar == 108 ) ? ( linuxMode = 1 - linuxMode; setupGUI(); );
    
    updating = 0;
  );
  
  
  
