desc:Filther
tags: Filther
version: 0.01
author: Joep Vanlier
changelog: Potatoes

Copyright (C) 2018 Joep Vanlier
License: MIT

Filter attribution:
LP Diode Ladder (MIT Licensed)
Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
Karlsen Fast Ladder III
Copyright (c) ? Ove Hy Karlsen

slider1:3<0,10,1>-Nodes negative
slider2:2<0,10,1>-Nodes positive

slider3:0.15<0,1,.01>-Pos1x
slider4:0.15<0,1,.01>-Pos1y
slider5:0.25<0,1,.01>-Pos2x
slider6:0.25<0,1,.01>-Pos2y
slider7:0.35<0,1,.01>-Pos3x
slider8:0.35<0,1,.01>-Pos3y
slider9:0.5<0,1,.01> -Pos4x
slider10:0.5<0,1,.01>-Pos4y
slider11:0.6<0,1,.01>-Pos5x
slider12:0.6<0,1,.01>-Pos5y
slider13:0.7<0,1,.01>-Pos6x
slider14:0.7<0,1,.01>-Pos6y
slider15:0.8<0,1,.01>-Pos7x
slider16:0.8<0,1,.01>-Pos7y
slider17:0.9<0,1,.01>-Pos8x
slider18:0.9<0,1,.01>-Pos8y

slider19:0.15<0,1,.01>-Neg1x
slider20:0.15<0,1,.01>-Neg1y
slider21:0.25<0,1,.01>-Neg2x
slider22:0.25<0,1,.01>-Neg2y
slider23:0.35<0,1,.01>-Neg3x
slider24:0.35<0,1,.01>-Neg3y
slider25:0.5<0,1,.01>-Neg4x
slider26:0.5<0,1,.01>-Neg4y
slider27:0.6<0,1,.01>-Neg5x
slider28:0.6<0,1,.01>-Neg5y
slider29:0.7<0,1,.01>-Neg6x
slider30:0.7<0,1,.01>-Neg6y
slider31:0.8<0,1,.01>-Neg7x
slider32:0.8<0,1,.01>-Neg7y
slider33:0.9<0,1,.01>-Neg8x
slider34:0.9<0,1,.01>-Neg8y

slider47:<0,15,1{OFF, LP RC-C,LP Diode Ladder (303/Non-Linear Dominique Wurtz),Vowel,LP Karlsen Fast Ladder III,LP Karlsen Fast Ladder III (sat),Saike`s Waveshaped Resonance (LP),Saike`s Waveshaped Resonance (HP),Saike`s Waveshaped Resonance (BP),Expensive Moog,Less Expensive Moog (DANGEROUS),Notch filter,Narsty,Modulator,Phaser (OTA),Phaser (FET),Delay Feedbok,Mangler}>Filter Type
slider48:<0,1,.001>Cutoff
slider49:<0,1,.001>Reso

slider51:1<0,1,1>-DC correction
slider52:0<-40,40,.01>PreGain
slider53:0<-40,40,.01>PostGain
slider54:1<0,8,1>Oversampling
slider56:0<0,3,{Spline, Tanh, Fast Tanh, None}>Waveshaping Mode

slider58:1<0,2,1{OFF,Filter,Waveshaper,Both}>Dynamics
slider59:1<0,1,.001>Thresh
slider60:1<0,50,.1>Attack
slider61:1<0.1,50,.1>Decay
slider62:.5<-1,1,.01>Filt Mod %
slider63:.34<0.02,40,0.001>RMS Integration time
slider64:1<0,1,1{Off, On}>Lookahead

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output
options:no_meter

@init
function filterDescription(filter)
global(slider47)
local()
(
  ( slider47 == 0 ) ? (
    gfx_printf("Filter: OFF")
  ) : ( slider47 == 1 ) ? (
    gfx_printf("Filter: LP RC-C\n\n");
    gfx_printf("Simple state space filter. This filter does not use internal waveshaping and the \n");
    gfx_printf("output of the filter is waveshaped instead.\n");
  ) : ( slider47 == 2 ) ? (  
    gfx_printf("Filter: LP Diode Ladder\n\n");
    gfx_printf("This filter was based on a model by Dominique Wurtz which modelled the 303 diode ladder.\n"); 
    gfx_printf("The only modification is that rather than input clipping, the waveshaper is used.\n");
  ) : ( slider47 == 3 ) ? (  
    gfx_printf("Filter: Vowel filter\n\n");
    gfx_printf("This filter uses 3 band pass filters to imitate vowel sounds.");
  ) : ( slider47 == 4 ) ? (  
    gfx_printf("Filter: LP Karlsen Fast Ladder III\n\n");
    gfx_printf("This filter is based on a 303 diode ladder. The filter uses the waveshaper as non/ideal part \n");
    gfx_printf("rather than just clipping.\n");
  ) : ( slider47 == 5 ) ? (  
    gfx_printf("Filter: LP Karlsen Fast Ladder III (sat)\n\n");
    gfx_printf("This filter combines the 303 diode ladder filter with a fixed shelf filter. The \n");
    gfx_printf("filter uses the waveshaper as non/ideal part rather than just clipping.\n");
  ) : ( slider47 == 6 ) ? (  
    gfx_printf("Filter: Saike`s Waveshaped Resonance (LP)\n\n");
    gfx_printf("This filter consists of two first order low-pass filters. The difference in filter outputs is distorted\n"); 
    gfx_printf("through the waveshaper and fed back to give a resonant peak. The output is then subsequently \n");
    gfx_printf("distorted again. This filter can get very mean depending on the curve you set for waveshaping.\n"); 
    gfx_printf("Be careful!\n");
  ) : ( slider47 == 7 ) ? (  
    gfx_printf("Filter: Saike`s Waveshaped Resonance (HP)\n\n");
    gfx_printf("This is a waveshaped highpass filter. The difference in filter outputs is distorted through the \n");
    gfx_printf("waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again.\n");
  ) : ( slider47 == 8 ) ? (
    gfx_printf("Filter: Saike`s Waveshaped Resonance (BP)\n\n");
    gfx_printf("This is a waveshaped bandpass filter. Sort of. The difference in filter outputs is distorted through \n");
    gfx_printf("the waveshaper and fed back to give a resonant peak. The output is then subsequently distorted again.\n");
  ) : ( slider47 == 9 ) ? (
    gfx_printf("Filter: Physically accurate model of a Moog filter\n\n");
    gfx_printf("This filter is based on the paper Modeling and measuring a Moog voltage-controlled filter by \n");
    gfx_printf("Paschou et al. The only difference is that the tanh distortion is replaced by the waveshaper.\n");
    gfx_printf("Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will\n");    
    gfx_printf("bring in higher quality as the non-linearity makes it sensitive to aliasing problems.\n");
    gfx_printf("This version is more stable than the cheap version, but still be careful. Extemely high gain\n");    
    gfx_printf("with high resonance can turn this baby into a glitching mess! Best used with the fast Atanh\n");    
    gfx_printf("because of performance considerations.\n");        
  ) : ( slider47 == 10 ) ? (
    gfx_printf("Filter: Approximate physically accurate model of a Moog filter\n\n");
    gfx_printf("This filter is based on the paper Modeling and measuring a Moog voltage-controlled filter by \n");
    gfx_printf("Paschou et al. The only difference is that the tanh distortion is replaced by the waveshaper.\n");
    gfx_printf("Note that at a minimum, this filter requires 2x upsampling to remain stable. Higher values will\n");    
    gfx_printf("bring in higher quality as the non-linearity makes it sensitive to aliasing problems.\n");
    gfx_printf("This version does not correctly compute the Jacobian. This is fine for low cutoffs and/or\n");    
    gfx_printf("atanh waveshaper. Be careful though, because it can seriously blow up in your face!\n");
  ) : ( slider47 == 11 ) ? (
    gfx_printf("Filter: Basic notch filter\n\n");
  ) : ( slider47 == 12 ) ? (
    gfx_printf("Filter: Narsty\n\n");
    gfx_printf("Saike's make things nasty filter. Combination of 3 filters with varying interacting resonances.\n");
    gfx_printf("No guarantees that this thing wonÂ´t blow up in your face. Exclusively meant for basses.\n");    
  ) : ( slider47 == 13 ) ? (
    gfx_printf("Filter: Modulator\n\n");
    gfx_printf("Passes a lowpsased version of the signal and modulates it with the signal itself. Second bandpass\n");
    gfx_printf("filtered version is added to provide the resonance peak. This filter is meant for sounds with\n");
    gfx_printf("limited high frequency content as it will sound awful with rich sounds.\n");
  ) : ( slider47 == 14 ) ? (
    gfx_printf("Filter: Phaser\n\n");
    gfx_printf("4 pass phaser based on operational transconductance amplifiers.\n");  
  ) : ( slider47 == 15 ) ? (
    gfx_printf("Filter: Phaser based on FET\n\n");
    gfx_printf("4 pass phaser based on Field Effect Transistor elements.\n"); 
  ) : ( slider47 == 16 ) ? (
    gfx_printf("Filter: Phaser-like\n\n");
    gfx_printf("Non-linear phaser like filter with relatively long delays and distortion of");
    gfx_printf("difference signal.");    
  ) : ( slider47 == 17 ) ? (
    gfx_printf("Filter: Phase mangler\n\n");
    gfx_printf("Magic???");
    gfx_printf("");
  )
);

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr        = scopebuffer_in;
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );
  
function initBufferNoReset(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
  );  
  
function tanh(s)
local(c)
global()
instance()
(
  c = exp(2*s);
  s = (c - 1) / (c + 1);
);

function fasttanh(x)
local()
global()
instance()
(
  x = x / (1 + abs(x));
  /*( x < -3 ) ? (
      x = -1;
  ) : ( x > 3 ) ? (
      x = 1;
  ) : ( 
      x = x * ( 27 + x * x ) / ( 27 + 9 * x * x );
    )*/
 // x = (-.0000067436811832+(.2468149110712040+(.0583691066395175+.03357335044280075*x)*x)*x)/(.2464845986383725+(.0609347197060491+(.1086202599228572+.02874707922475963*x)*x)*x);
);

//----------------------------------------------
// Filter initialization section
//----------------------------------------------
function initRC(freq, q)
  instance(len, v0, v1, a1, c)
  local(r)
  global(srate, slider54)
  (
    c = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    r = pow(0.5, (q*128+24) / 16.0);
    a1 = (1.0-r*c);   
  );

function init303(freq, q)
  local()
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    // This specific filter came from
    // Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
    wc  = .25 * (pow(10, freq)-1)/9 * $pi / (slider54+1);
    wc2 = wc*wc;
    wc3 = wc2*wc;
    wc4 = wc3*wc;
    b   = 1 / ( 1 + 8*wc + 20*wc2 + 16*wc3 + 2*wc4);
    g   = 2 * wc4 * b;
    
    k   = 5*q;
    A   = 1 + 0.5 * k;
    
    b0 = 2*wc+12*wc2+20*wc3+8*wc4;
    a0 = 1+6*wc+10*wc2+4*wc3;
    a1 = 2*wc+8*wc2+6*wc3;
    a2 = 2*wc2+4*wc3;
    a3 = 2*wc3;
    
    b10 = 2*wc2+8*wc3+6*wc4;
    a10 = wc+4*wc2+3*wc3;
    a11 = 1+6*wc+11*wc2+6*wc3;
    a12 = wc+4*wc2+4*wc3;
    a13 = wc2+2*wc3;
    
    b20 = 2*wc3+4*wc4;
    a20 = a13;
    a21 = wc+4*wc2+4*wc3;
    a22 = 1+6*wc+10*wc2+4*wc3;
    a23 = wc+4*wc2+2*wc3;
    
    c2  = a21 - a3;
    c3  = 1+6*wc+9*wc2+2*wc3;
  ); 
  
function reset303()
  local(Kbig)
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    z1 = z2 = z3 = 0;
    y1 = y2 = y3 = y4 = 0;
  );

function initmoog(freq, q)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    cutoff = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    res = .1 * q;
    
    f  = (cutoff+cutoff);
    p  = f*(1.8-0.8*f);
    k  = 2.0 * sin(cutoff * $pi * 0.5) - 1.0;
    
    t  = (1.-p)*1.386249;
    t2 = 12.+t*t;
    r  = res*(t2+6.*t)/(t2-6.*t);
  );

function resetmoog()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    oldy1=oldy2=oldy3=y1=y2=y3=y4=oldx=0;
  );

// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = 0;
  );   
  
// Karlsen Fast Ladder III 
// Ove Hy Karlsen
function initkarlsen_sat(freq, res)
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_fenv  = pow(0.5, (128-freq*128) / 16.0)/ (slider54+1);
    b_fres  = 4 * res;
  );
  
function resetkarlsen_sat()
  local(f, t, t2, cutoff, res)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    b_aflt1 = b_aflt2 = b_aflt3 = b_aflt4 = b_lfcut = b_lf = b_lf1hp = b_lfhp = b_lfgain = 0;
  );
  
function initdualfilt(freq, res)
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    f = .25 * (pow(10, freq)-1)/9 * $pi / (slider54+1);
    q = res;
    
    //set feedback amount given f and q between 0 and 1
    fb = q + q/(1.0 - f);
  );
  
function resetdualfilt()
  local(q)
  global(slider54)
  instance(fb, f, d0, d1)
  (
    d0 = d1 = 0.0000001;
  );

  
function initfancymoog(freq, q)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3, VT, fs                   
        )
  global(srate, slider54, tmp)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4, ftarget)
  (
    fs      = (slider54+1) * srate;
    ftarget = 6 *(pow(10, freq)-1)/9;
    //ftarget = 6*freq;
    VT      = 26/1000;
    A       = 0.5 * VT;
    hA      = 0.5 * A;
    T       = 1.0/fs;
    wc      = 4*$pi*ftarget*srate;
    wcT     = wc*T;
    g       = wcT*hA;
    k       = q*4; // [0..4]
  );

function bootvowel()
  instance( c, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, d0, d1, d2, d3, d4, d5, d6, d7, d8, d9 )
  local(ptr)
  global(vowel_A, vowel_E, vowel_I, vowel_O, vowel_U, vowel_EE)
  (
  vowel_EE = 909090;
    c[0] = vowel_A;
    c[1] = vowel_E;
    c[2] = vowel_I;
    c[3] = vowel_O;
    c[4] = vowel_U;
    c[5] = vowel_EE;
    
    // 34 39 57
    ptr = vowel_A;
    ptr[] = 660;        ptr += 1;
    ptr[] = 1700;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-15/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr = vowel_E;
    ptr[] = 530;        ptr += 1;
    ptr[] = 1850;       ptr += 1;
    ptr[] = 2500;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_I;
    ptr[] = 400;        ptr += 1;
    ptr[] = 2000;       ptr += 1;
    ptr[] = 2550;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_O;
    ptr[] = 300;        ptr += 1;
    ptr[] = 870;        ptr += 1;
    ptr[] = 2250;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q

    ptr = vowel_U;
    ptr[] = 640;        ptr += 1;
    ptr[] = 1200;       ptr += 1;
    ptr[] = 2400;       ptr += 1;
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-11/6);  ptr += 1; // gain
    ptr[] = 2^(-13/6);   ptr += 1; // gain
    ptr[] = 9;          ptr += 1; // Q
    ptr[] = 10;         ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q

    ptr   = vowel_EE; // These are correct
    ptr[] = 207;        ptr += 1; // freq
    ptr[] = 2300;       ptr += 1; // freq
    ptr[] = 3000;       ptr += 1; // freq
    ptr[] = 2^(0/6);    ptr += 1; // gain
    ptr[] = 2^(-15/6);  ptr += 1; // gain
    ptr[] = 2^(-9/6);   ptr += 1; // gain
    ptr[] = 5;          ptr += 1; // Q
    ptr[] = 20;         ptr += 1; // Q
    ptr[] = 50;         ptr += 1; // Q
);

function rfn(q,qq)
(
  q * (1+2*qq);
);

function initvowel(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(idx, ptr, loc, rloc, fact, fr1, fr2, fr3, q1, q2, q3, w0, cw, sw, alpha, a0, a0i, Q )
  global(slider54, srate, rfn)
  (
    loc   = 5 * freq;
    idx   = floor( loc - 0.0001 );
    rloc  = loc-idx;
    rloc  = 1.0 - rloc;
    fact  = $pi / ( srate * ( max(1,slider54) ) );
    
    ptr   = c[idx];    
    fr1   = ptr[]*rloc; ptr+=1;
    fr2   = ptr[]*rloc; ptr+=1;
    fr3   = ptr[]*rloc; ptr+=1;
    amp1  = ptr[]*rloc; ptr+=1;
    amp2  = ptr[]*rloc; ptr+=1;
    amp3  = ptr[]*rloc; ptr+=1;
    q1    = ptr[]*rloc; ptr+=1;
    q2    = ptr[]*rloc; ptr+=1;
    q3    = ptr[]*rloc; ptr+=1;
  
    ptr   = c[idx+1];    
    rloc  = 1 - rloc;
    fr1   += ptr[]*rloc; ptr+=1;
    fr2   += ptr[]*rloc; ptr+=1;
    fr3   += ptr[]*rloc; ptr+=1;
    amp1  += ptr[]*rloc; ptr+=1;
    amp2  += ptr[]*rloc; ptr+=1;
    amp3  += ptr[]*rloc; ptr+=1;
    q1    += ptr[]*rloc; ptr+=1;
    q2    += ptr[]*rloc; ptr+=1;
    q3    += ptr[]*rloc; ptr+=1;
  
    // Biquads RBJ BP
    Q     = rfn(q1, qin);
    w0    = fr1 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = rfn(q2, qin);
    w0    = fr2 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = rfn(q3, qin);
    w0    = fr3 * fact;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

// Biquads RBJ Notch
function initnotch(freq, q)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local( out, w0, cw, sw, alpha, a0, a0i )
  global(srate, slider54)
  (
    w0    = (pow(10, freq)-1)/9 * $pi / (slider54+1);
    q     = q*0.9 + .1;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    b0    = 1 * a0i;
    b1    = -2 * cw * a0i;
    b2    = a0i;
    a1    = -2 * cw * a0i;
    a2    = (1 - alpha) * a0i;
  );

function initsai0(freq, qin)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / (slider54+1);
    w0c   = .1*(pow(10, freq)-1)/9 * $pi * fact + .025;
    qav   = qin*1.5 + .5;
  
    amp1  = 1;
    amp2  = 1;
    amp3  = 1;
      
    // Biquads RBJ BP
    Q     = qav*8;
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0    = alpha*a0i;
    Ab1    = 0;
    Ab2    = - alpha*a0i;
    Aa1    = - (2 * cw)*a0i;
    Aa2    = (1 - alpha)*a0i;
  
    Q     = qav*12;
    w0    = w0c*2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = alpha*a0i;
    Bb1    = 0;
    Bb2    = - alpha*a0i;
    Ba1    = - (2 * cw)*a0i;
    Ba2    = (1 - alpha)*a0i;
    
    Q     = qav*12;
    w0    = w0c/2;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Cb0    = alpha*a0i;
    Cb1    = 0;
    Cb2    = - alpha*a0i;
    Ca1    = - (2 * cw)*a0i;
    Ca2    = (1 - alpha)*a0i;
  );

function initmodulator(freq, qin)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2
    d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp )
  local(idx, ptr, fact, w0, w0c, cw, sw, alpha, a0, a0i, Q, qav, fact )
  global(slider54, srate, rfn)
  (
    fact  = 1 / (max(slider54,1));
    w0c   = .1*(pow(10, freq)-1)/9 * $pi * fact + .25*fact;
    Q     = qin*15 + 20;
    amp   = qin*2;
    
    // Biquads RBJ BP
    w0    = w0c;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Ab0   = Q * alpha * a0i;
    Ab1   = 0 * a0i;
    Ab2   = - alpha * Q * a0i;
    Aa1   = -2 * cw * a0i;
    Aa2   = (1 - alpha) * a0i;
  
    Q     = 5+qin*15;
    fact  = $pi / ( srate * ( max(1,slider54) ) );
    w0    = w0c*.25;
    cw    = cos(w0);
    sw    = sin(w0);
    alpha = 0.5 * sw / Q;
    a0    = 1 + alpha;
    a0i   = 1 / a0;
    Bb0    = 0.5*(1-cw)*a0i;
    Bb1    = (1-cw)*a0i;
    Bb2    = 0.5*(1-cw)*a0i;
    Ba1    = -2*cw*a0i;
    Ba2    = (1 - alpha)*a0i;
  );

function initphaserOTA(freq, reso)
  global(slider54)
  local(Rf, g)
  instance(C1, C2, dw, dx, sq)
  (
    Rf = 25/1000;
    g = 1 - exp( - $pi * ( freq / max(slider54,1) ) );
    sq = .2*reso;
    // Rf = R1*Vt/R2
    C1 = Rf * g;
    C2 = - 1 / Rf;
  );
  
function initphaserFET(freq, reso)
  global(srate, slider54)
  local(IDSS, Vt, Vp, Fs, Vg, Rp, Q1, g )
  instance(C1, C2, dw, dx, thresh, iVpsq, IDSSdivVpSq, thresh)
  (
    /*IDSS = .001;  // 1 mA
    Vt   = 0.025; // 25mV
    Vp   = -3;
    Vg   = - 2 - reso;
    Rp   = 1; // ?
     
    iVpsq = 1 / (Vp * Vp);
    Q1 = 2 * IDSS * (Vg-Vt) * iVpsq; 
    C2 = 1 / Rp;
    g  = 1  - exp( - 2 * $pi * freq/max(slider54,1) );
  
    thresh = Vg - Vp;
    IDSSdivVpSq = IDSS * iVpsq;
      
    // We seek C1.
    // Q1*C1 - C2*C1 = g; Eq. 24 from the paper
    C1 = g / (Q1-C2);*/
    
    C1=.5*freq/max(1,slider54);C2=1;
  );  

function updateActiveFilters()
  (
    filterDynamics ? (
      filterFreq = max( 0, min( 1, slider48 + dyn_mod_filt * dynval ) );
      filterReso = slider49;
    ) : (
      filterFreq = slider48;
      filterReso = slider49;
    );
  
    ( slider47 == 1 ) ? (
      rc_filter.initRC(filterFreq, filterReso);
    ) : ( slider47 == 2 ) ? (
      filter_303.init303(filterFreq, filterReso);
    ) : ( slider47 == 3 ) ? (
      filter_vowel.initvowel(filterFreq, filterReso);
    ) : ( slider47 == 4 ) ? (
      filter_karlsen.initkarlsen(filterFreq, filterReso);
    ) : ( slider47 == 5 ) ? (
      filter_karlsen_sat.initkarlsen_sat(filterFreq, filterReso);
    ) : ( slider47 == 6 ) ? (
      filter_dualfilt.initdualfilt(filterFreq, filterReso);
    ) : ( slider47 == 7 ) ? (
      filter_dualfiltHP.initdualfilt(filterFreq, filterReso);
    ) : ( slider47 == 8 ) ? (
      filter_dualfiltBP.initdualfilt(filterFreq, filterReso);        
    ) : ( slider47 == 9 || slider47 == 10 ) ? (
      ( slider54 < 2 ) ? ( 
        slider54 = 2;
        slider_automate(slider54);
        forceUpdate = 1;
        );    
      filter_fancymoog.initfancymoog(filterFreq, filterReso);
    ) : ( slider47 == 11 ) ? (
      filter_notch.initnotch(filterFreq, filterReso)
    ) : ( slider47 == 12 ) ? (
      filter_sai0.initsai0(filterFreq, filterReso);
    ) : ( slider47 == 13 ) ? (
      filter_modulator.initmodulator(filterFreq, filterReso);
    ) : ( slider47 == 14 ) ? (
      filter_phaser.initphaserOTA(filterFreq, filterReso);
      filter_phaser2.initphaserOTA(filterFreq*2, filterReso);
      filter_phaser3.initphaserOTA(filterFreq/2, filterReso);
      filter_phaser4.initphaserOTA(filterFreq/3, filterReso);       
    ) : ( slider47 == 15 ) ? (
      filter_phaser.initphaserFET(filterFreq, filterReso);      
      filter_phaser2.initphaserFET(filterFreq*2, filterReso);
      filter_phaser3.initphaserFET(filterFreq/2, filterReso);
      filter_phaser4.initphaserFET(filterFreq/3, filterReso);
    ) : ( slider47 == 16 ) ? (
      filter_dualfilt.initdualfilt(filterFreq, filterReso);
      filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq * 1000);
      filter_delay2.initBufferNoReset(delay_buf2, delay_buf2 + max(1,slider54)*filterReso * 2000);
    ) : ( slider47 == 17 ) ? (
      filter_dualfilt.initdualfilt(filterFreq, filterReso);
      filter_delay1.initBufferNoReset(delay_buf1, delay_buf1 + max(1,slider54)*filterFreq*(1000+4000*filterReso));
    );
  );
 
function resetActiveFilters()
  (
    ( slider47 == 1 ) ? (
      gfx_printf( " " );
    ) : ( slider47 == 2 ) ? (
      filter_303.reset303();
    ) : ( slider47 == 3 ) ? (
      filter_moog.resetmoog();
    ) : ( slider47 == 4 ) ? (
      filter_karlsen.resetkarlsen();
    ) : ( slider47 == 5 ) ? (
      filter_karlsen_sat.resetkarlsen_sat();
    ) : ( slider47 == 6 ) ? (
      filter_dualfilt.resetdualfilt();
    ) : ( slider47 == 7 ) ? (
      filter_dualfiltHP.resetdualfilt();
    ) : ( slider48 == 8 ) ? (
      filter_dualfiltBP.resetdualfilt();      
    ) : (
      gfx_printf( " " );
    );
  );

itm1=itm2=otm1=otm2=0;
forceUpdate=0;

movavgLN = 0;
movavgLP = 0;
movavgRN = 0;
movavgRP = 0;

updateActiveFilters();
  
function updateFilter(newlen)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (Q, sc, pos, cpos, spos, alpha)
  global ()
  (  
    ( newlen != len ) ?
    (
      len   = newlen;
      Q     = 0.707;
      pos   = 0.85 / len * $pi;
      cpos  = cos(pos);
      spos  = sin(pos);
      alpha = spos/(2.0*Q);
       
      sc    = 1.0 / (1+alpha);
      a1    = -2 * cpos * sc;
      a2    = (1-alpha) * sc;
      b1    = (1-cpos) * sc;
      b2    = b0 = b1 * 0.5;
    
      // Input taps
      d1 = d2 = d3 = d4 = 0;
      
      // Output taps
      o1 = o2 = o3 = o4 = 0;
    )
  );

function inputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out  = sample*b0 + d1*b1 + d2*b2 - d3*a1 - d4*a2;
    d2   = d1;
    d1   = sample;
    d4   = d3;
    d3   = out;
  );
  
function outputFilter(sample)
  instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
  local (out)
  global ()
  (
    out = sample*b0 + o1*b1 + o2*b2 - o3*a1 - o4*a2;
    o2  = o1;
    o1  = sample;
    o4  = o3;
    o3  = out;
  );

function setN(S, N)
local()
global(slider1, slider2)
(
  ( S == 1 ) ? (
    slider1=N; slider_automate(slider1);
  )
  : ( S == 2) ? (
    slider2=N; slider_automate(slider2);
  );
);

function manipulateXYSliders(S, i, x, y)
(
  // gfx_set(1,1,1,1);
  // gfx_x=0;
  // gfx_y=50;
  // gfx_printf("HEY %d, %d, %f, %f", S, i, x, y);
  (S == 2) ? (
     (i==1) ? ( slider3=x;  slider_automate(slider3);  slider4=y;  slider_automate(slider4);  )
    :(i==2) ? ( slider5=x;  slider_automate(slider5);  slider6=y;  slider_automate(slider6);  )
    :(i==3) ? ( slider7=x;  slider_automate(slider7);  slider8=y;  slider_automate(slider8);  )
    :(i==4) ? ( slider9=x;  slider_automate(slider9);  slider10=y; slider_automate(slider10); )
    :(i==5) ? ( slider11=x; slider_automate(slider11); slider12=y; slider_automate(slider12); )
    :(i==6) ? ( slider13=x; slider_automate(slider13); slider14=y; slider_automate(slider14); )
    :(i==7) ? ( slider15=x; slider_automate(slider15); slider16=y; slider_automate(slider16); )
    :(i==8) ? ( slider17=x; slider_automate(slider17); slider18=y; slider_automate(slider18); )
  )
  : ( S==1 ) ? (
     (i==1) ? ( slider19=x; slider_automate(slider19); slider20=y; slider_automate(slider20); )
    :(i==2) ? ( slider21=x; slider_automate(slider21); slider22=y; slider_automate(slider22); )
    :(i==3) ? ( slider23=x; slider_automate(slider23); slider24=y; slider_automate(slider24); )
    :(i==4) ? ( slider25=x; slider_automate(slider25); slider26=y; slider_automate(slider26); )
    :(i==5) ? ( slider27=x; slider_automate(slider27); slider28=y; slider_automate(slider28); )
    :(i==6) ? ( slider29=x; slider_automate(slider29); slider30=y; slider_automate(slider30); )
    :(i==7) ? ( slider31=x; slider_automate(slider31); slider32=y; slider_automate(slider32); )
    :(i==8) ? ( slider33=x; slider_automate(slider33); slider34=y; slider_automate(slider34); )
  );
  
  forceUpdate = 1;
);

// Really dumb sorting algorithm
function sort_spline()
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(last, mini, iter, tmp)
  global(gfx_x, gfx_y)
( 
  // First copy it to temp 
  ptr_from_X  = xloc_write;
  ptr_from_Y  = yloc_write;
  ptr_to_X    = tempx;
  ptr_to_Y    = tempy;
  ptr_to_Z    = tempz;
  iter        = 0;
  loop(N,
    ptr_to_X[] = ptr_from_X[];
    ptr_to_X += 1; ptr_from_X += 1;
    ptr_to_Y[] = ptr_from_Y[];
    ptr_to_Y += 1; ptr_from_Y += 1;
    ptr_to_Z[] = iter;
    ptr_to_Z += 1;
    iter += 1;
  );
  
  // Sort it
  ptr_to_X = xloc_write;
  ptr_to_Y = yloc_write;
  ptr_to_Z = indices;
  last = -1;
  loop(N,
    ptr_from_X = tempx;
    ptr_from_Y = tempy;
    ptr_from_Z = tempz;
    mini = 1000;
    loop(N,
      ( ( ptr_from_X[] > last ) && ( ptr_from_X[] < mini ) ) ?
      (
        mini       = ptr_from_X[];
        ptr_to_X[] = mini;
        ptr_to_Y[] = ptr_from_Y[];
        ptr_to_Z[] = ptr_from_Z[];
      );
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;      
    );
    last = mini;
    ptr_to_X += 1;
    ptr_to_Y += 1;
    ptr_to_Z += 1;
  );
  
  tmp = xloc_read;
  xloc_read = xloc_write;
  xloc_write = tmp;
  
  tmp = yloc_read;
  yloc_read = yloc_write;
  yloc_write = tmp;  
);

function update_spline()
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(cc1, m, mNext, cm, dx, dxNext, invdx, tmp)
  global(gfx_x, gfx_y)
  (
    // Calculate differences
    ptr_from_X  = xloc_read;
    ptr_from_Y  = yloc_read;
    ptr_to_X    = tempx;
    ptr_to_Y    = tempy;
    
    // tempx contains dxs, tempy the slopes (dy/dx)    
    loop(N-1,
      ptr_to_X[]  = ptr_from_X[1] - ptr_from_X[];
      ptr_to_Y[]  = ( ptr_from_Y[1] - ptr_from_Y[] ) / ptr_to_X[];
      ptr_to_X    += 1;
      ptr_to_Y    += 1;
      ptr_from_X  += 1;
      ptr_from_Y  += 1;
    );
    
    // calculate first degree coefficients
    ptr_from_X  = tempx; // dx
    ptr_from_Y  = tempy; // dy/dx (ms)
    ptr_to_X    = c1_write;
    
    ptr_to_X[]  = ptr_from_Y[];
    ptr_to_X   += 1;
    loop(N-2,
      m     = ptr_from_Y[];
      mNext = ptr_from_Y[1];
      ( m * mNext <= 0 ) ? ( ptr_to_X[] = 0; ):
      (
        dx = ptr_from_X[];
        dxNext = ptr_from_X[1];
        cm = dx + dxNext;
        ptr_to_X[] = 3.0*cm/((cm+dxNext)/m + (cm+dx)/mNext);
      );
      ptr_to_X   += 1;
      ptr_from_X += 1;
      ptr_from_Y += 1;
    );
    ptr_to_X[] = ptr_from_Y[];
    
    // calculate second degree coefficients
    ptr_from_X = tempx; // dx
    ptr_from_Y = tempy; // dy/dx (ms)
    ptr_from_Z = c1_write;    // c1s
    ptr_to_X   = c2_write;
    ptr_to_Y   = c3_write;
    loop(N-1,
      invdx = 1 / ptr_from_X[];
      cc1 = ptr_from_Z[];
      m = ptr_from_Y[];
      cm = cc1 + ptr_from_Z[1] - m - m;
      ptr_to_X[] = (m - cc1 - cm)*invdx;
      ptr_to_Y[] = cm*invdx*invdx;
      
      ptr_from_X += 1;
      ptr_from_Y += 1;
      ptr_from_Z += 1;
      ptr_to_X   += 1;
      ptr_to_Y   += 1;
    );
    
    tmp = c1_read;
    c1_read = c1_write;
    c1_write = tmp;
    
    tmp = c2_read;
    c2_read = c2_write;
    c2_write = tmp;
    
    tmp = c3_read;
    c3_read = c3_write;
    c3_write = tmp;    
  );

function evalSplineBin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    // Out of bounds means return 1
    (x > 1) ? out = yloc_read[N-1] : 
    (
      ( x < 0 ) ? out = 0 :
      (
        // Search for the correct interval by binary search
        low       = 0;
        high      = N;
        while(
          mid = floor( 0.5*(low+high) );
          xHere = xloc_read[mid];
          
          ( xHere < x ) ? low = mid + 1 :
          ( // else
            ( xHere > x ) ? high = mid - 1 :
              ( //else 
                high = yloc_read[mid];
                low = high+1; // Manual termination
              );
          );
          
          low <= high;
        );
        
        i = max( 0, high );        
        
        diff    = x - xloc_read[i];
        diffSq  = diff * diff;

        out = yloc_read[i] + c1_read[i]*diff + c2_read[i]*diffSq + c3_read[i]*diff*diffSq;
      )
    );
    
    out;
  );
  
function evalSplineLin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(low, high, xHere, i, diff, diffSq, mid, out)
  global()
  (
    i = -1;
    xHere = xloc_read-1;
    
    while(
      i += 1;
      xHere += 1;
      
      x >= xHere[] && ( i < N )
    );
        
    i = max( 0, i-1 );        
        
    diff    = x - xloc_read[i];
    diffSq  = diff * diff;
    out = yloc_read[i] + c1_read[i]*diff + c2_read[i]*diffSq + c3_read[i]*diff*diffSq;
    
    out;
  );  
  
function evalSplineAudioBin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio)
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_read[N-1] : 
    (
      ( x < 0 ) ? out = 0 :
      (
        // Search for the correct interval by binary search
        lowAudio       = 0;
        highAudio      = N;
        while(
          midAudio = floor( 0.5*(lowAudio+highAudio) );
          xHereAudio = xloc_read[midAudio];
          
          ( xHereAudio < x ) ? lowAudio = midAudio + 1 :
          ( // else
            ( xHereAudio > x ) ? highAudio = midAudio - 1 :
              ( //else 
                highAudio = yloc_read[midAudio];
                lowAudio = highAudio+1; // Manual termination
              );
          );
          
          lowAudio <= highAudio;
        );
        
        iAudio = max( 0, highAudio );        
          
        diffAudio    = x - xloc_read[iAudio];
        diffSqAudio  = diffAudio * diffAudio;
          
        out = yloc_read[iAudio] + c1_read[iAudio]*diffAudio + c2_read[iAudio]*diffSqAudio + c3_read[iAudio]*diffAudio*diffSqAudio;
      )
    );
    
    out;
  );    
  
function evalSplineAudioLin(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, xHereAudio, diffAudio, diffSqAudio, out, midAudio)
  global(gfx_x, gfx_y)
  (
    iAudio = -1;
    xHereAudio = xloc_read-1;
    
    while(
      iAudio += 1;
      xHereAudio += 1;
      
      x >= xHereAudio[] && ( iAudio < N )
    );
    
    iAudio       = max(0, iAudio-1);
    diffAudio    = x - xloc_read[iAudio];
    diffSqAudio  = diffAudio * diffAudio;
          
    out = yloc_read[iAudio] + c1_read[iAudio]*diffAudio + c2_read[iAudio]*diffSqAudio + c3_read[iAudio]*diffAudio*diffSqAudio;
    
    out;
  );  

function evalSplineAudioDiff(x)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(lowAudio, highAudio, interpAudio, xHereAudio, diffAudio, out, midAudio)
  global()
  (
    // Out of bounds means return 1
    ( x > 1 ) ? out = yloc_read[N-1] : 
    (
      ( x < 0 ) ? out = 0 :
      ( 
        iAudio = max( 0, highAudio );
        diffAudio    = x - xloc_read[iAudio];
        out = c1_read[iAudio] + diffAudio*(2*c2_read[iAudio] + 3*diffAudio*c3_read[iAudio]);
      )
    );
    
    out;
  );  

// Plot the spline nodes
function plot_spline(x, y, w, h)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(xx, res, lastx, lasty, dx, yout, nx, ny, epsx, epsy, xc, yc, yout)
  global(gfx_x, gfx_y, distortPlot, slider56, dynval)
  (
    epsx = 3;
    epsy = 3;
    ptr_from_X = xloc_read;
    ptr_from_Y = yloc_read;
    ptr_from_Z = indices;
    
    gfx_set( .7, .7, .7, .7 );
    gfx_x = 0;
    gfx_y = 0;
    ( slider56 == 0 ) ? (
      loop(N,
        xc = x + w*ptr_from_X[] - epsx;
        yc = y + h*(1-ptr_from_Y[]) - epsy;
        gfx_rect(xc, yc, epsx, epsy);
        gfx_x = xc;
        gfx_y = yc-14;
        gfx_printf("%d", ptr_from_Z[]);
        ptr_from_X += 1;
        ptr_from_Y += 1;
        ptr_from_Z += 1;
      );
    );
    
    xx = 0;
    res = 500;
    lastx = x;
    lasty = y+h;
    dx = 1.0/res;
    loop(res,
      xx = xx + dx;
      ( slider56 == 0 ) ? (
        yout = this.evalSplineLin(xx);
      ) : ( slider56 == 1 ) ? ( 
        yout = tanh(xx);
      ) : ( slider56 == 2 ) ? (
        yout = fasttanh(1.5*xx);
      ) : (
        yout = xx;
      );
      //        distortionDynamics ? s = (1-dynval) * os + dynval * s;
      
//      yout = distortPlot(xx);
      nx = x + w*xx - 1;
      ny = y + h*(1-yout) - 1;
      gfx_line(lastx, lasty, nx, ny, 0);
      lastx = nx;
      lasty = ny;
    );
  );
  
function evalDist(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineLin(xx);
  );  
  
function evalDistAudio(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioLin(xx);
  );
  
function evalDiff(xx)
  instance(x, y, w, h, spline)
  global()
  (
    spline.evalSplineAudioDiff(xx);
  );  
  
//NODE_PROXIMITY = 5;
function findNearest(x, y)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(minDist, best, dx, dy, dist, left, i, right)
  global()
(
    // Find nearest point that may have been clicked
    i = 0;
    minDist = 100000000000000;
    best = -1;
    loop(N,
      dx = (x - xloc_read[i]);
      dy = ((1-y) - yloc_read[i]);
      dist = dx*dx + dy*dy;          
      ( dist < minDist ) ? 
      (
        minDist = dist;
        best = i;
       );
       i = i + 1;
     );
             
    // Found a point, then we change the capture mode
    ( minDist < .001 ) ? ( drag_node = best; ) : drag_node = -1;
);

//NODE_PROXIMITY = 5;
function killNode(i)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(i)
  global()
  (
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N-2))&&(i<(N+1))
    );
    
    manipulateXYSliders(splineIdx, indices[drag_node], xloc_read[i], yloc_read[i]);
    setN(splineIdx, N-1);
  );
  
function addNode(x, y)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(i)
  global()
  (
    i = 0;
    while(
      i += 1;
      (indices[i]!=(N-1))&&(i<(N+2))
    );

    manipulateXYSliders(splineIdx, indices[N], xloc_read[i], yloc_read[i]);  
    manipulateXYSliders(splineIdx, indices[N-1], x, y);
    setN(splineIdx, N+1);
  );  

//NODE_PROXIMITY = 5;
function processMouse(x, y, dx, dy, mc)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  local(left, right, i)
  global(manipulateXYSliders, gfx_x, gfx_y)
  (
    left  = mc & 1;
    right = mc & 2;
  
    ( left ) ? 
    (
      ( cap_mode == 0 ) ?
      (
        this.findNearest(x, y);
        ( drag_node > -1 ) ? ( drag_node = indices[drag_node]; cap_mode = 1; )
      ) : ( cap_mode == 1 ) ? (
        // We've already selected a node.
        x = max( min( x, .9999 ), 0.00001 );
        y = max( min( y, .9999 ), 0.00001 );
        manipulateXYSliders(splineIdx, drag_node, x, (1-y));
      );
    ) : (
      ( right ) ?
      (
        ( cap_mode == 0 ) ?
        (
          this.findNearest(x, y);
          // Are we clicking an existing one?
          ( drag_node > -1 ) ? 
          (
            // Kill it!
            ( N > 1 ) ? (
              this.killNode(drag_node);
              cap_mode = 2;
            )
          ):(
            // Add one?
            ( N < 9 ) ? (
              ( x > 0 && y > 0 && x < 1 && y < 1 ) ? (
              this.addNode(x, 1-y);
              cap_mode = 2; )
            );
          );
        );
      ) : ( cap_mode = 0; )
    )
  );

// Generate a spline object
function gen_spline(N_in, splineIdx_in, xloc_in, yloc_in, xloc_in2, yloc_in2, indices_in, tempx_in, tempy_in, tempz_in, c1_in, c2_in, c3_in, c1_in2, c2_in2, c3_in2)
  instance(N, splineIdx, xloc_read, yloc_read, xloc_write, yloc_write, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  global()
(
  N          = N_in;
  xloc_read  = xloc_in;
  yloc_read  = yloc_in;
  xloc_write = xloc_in2;
  yloc_write = yloc_in2;  
  indices    = indices_in;
  tempx      = tempx_in;
  tempy      = tempy_in; 
  tempz      = tempz_in;
  c1_read    = c1_in;
  c2_read    = c2_in;
  c3_read    = c3_in;
  c1_write   = c1_in2;
  c2_write   = c2_in2;
  c3_write   = c3_in2;    

  splineIdx  = splineIdx_in;
  cap_mode   = 0;
);

function setN(N_new)
  local()
  global()
  instance(N, splineIdx, xloc, yloc, indices, tempx, tempy, tempz, c1_read, c2_read, c3_read, c1_write, c2_write, c3_write, ptr_from_X, ptr_from_Y, ptr_from_Z, ptr_to_X, ptr_to_Y, ptr_to_Z, cap_mode, drag_node, iAudio)
  (
    N = N_new;
  );

function setN(N_new)
  local()
  global()
  instance(x, y, w, h, spline)
  (
    spline.setN(N_new)
  );

function toggleLight(x_in, y_in, w_in, h_in, label_in, align_in, r_in, g_in, b_in, a_in, active_in)
  local(jnk, jnk1)
  global()
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    x       = x_in;
    y       = y_in;
    w       = w_in;
    h       = h_in;
    r       = r_in;
    g       = g_in;
    b       = b_in;
    a       = a_in;
    label   = label_in;
    align   = align_in;
    active  = active_in;
    lastleft = 0;
  );

function toggleLight_processMouse(xx, yy, mc)
  local(left)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    left = mc & 1;
    left ? (
      ( (lastleft ~= 1 ) && ( xx > x ) && ( xx < (x+w) ) && ( yy > y ) && ( yy < (y+h) ) ) ? ( 
        active = 1 - active;
      );
    );
    
    lastleft = left;
  );
  
function toggleLight_draw()
  local(jnk, siz)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, active, label, align, lastleft)
  (
    gfx_set( r, g, b, .2 + .5*active );
    gfx_rect( x, y, w, h );
  
    gfx_set( r, g, b, a );
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    gfx_set( 0.8, 0.8, 0.8, 0.8 );
    ( align == 0 ) ?
    (
      gfx_x = x+15;
      gfx_y = y+2;
    ) : (
      gfx_measurestr(label, siz, jnk);
      gfx_x = x - siz-3;
      gfx_y = y+1;
    );
    gfx_printf( label );  
  );

function gen_window(xp, yp, wp, hp, N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2)
  instance(x, y, w, h, spline)
  global()
  local()
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    
    spline = spline.gen_spline(N, splineIdx, splineCoordsX, splineCoordsY, splineCoordsX2, splineCoordsY2, indices, tempCoordStorageX, tempCoordStorageY, tempCoordStorageZ, c1_storage, c2_storage, c3_storage, c1_storage2, c2_storage2, c3_storage2);
  );
  
function gen_dynamics(xp, yp, wp, hp)
  instance(x, y, w, h, yref, sc, cap_mode, inLight, outLight, dynLight)
  global(inLight.toggleLight)
  local()
  (
    x = xp;
    y = yp;
    w = wp;
    h = hp;
    cap_mode = 0; 
        
    inLight.toggleLight(x+w-15, y+5, 10, 10, "In", 1, 1, .3, .3, .3, 1);
    outLight.toggleLight(x+w-15, y+25, 10, 10, "Out", 1, .6, .3, 1, .9, 1);
    dynLight.toggleLight(x+w-15, y+45, 10, 10, "Dynamics", 1, .8, .8, .2, .3, 1);
    
    sc = h;
  );

function processMouse(mx, my, dx, dy, mc)
  instance(x, y, w, h, spline)
  global()
  local()  
  (
    spline.processMouse((mx-x)/w, (my-y)/h, dx/w, dy/h, mc);
  );

function sort_spline()
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.sort_spline();
  );

function update_spline()
  instance(x, y, w, h, spline)
  global()
  local()
  (
    spline.update_spline();
  );


function rotatedPrint(x, y, str, rot)
local(sw,sh)
global(gfx_x, gfx_y, gfx_dest, gfx_mode)
(
  gfx_measurestr(str, sw, sh);
  gfx_dest = 1; 
  gfx_setimgdim(1, sw, sw);
  gfx_set( 0, 0, 0, 1 );
  gfx_rect(0, 0, sw, sw);
  gfx_x = 1;
  gfx_y = 1;
  gfx_set( .7, .7, .7, .7 );
  gfx_printf(str);
  gfx_dest = -1;
  gfx_mode = 1;
  gfx_x = x;
  gfx_y = y;
  gfx_blit(1, 1.0, rot);
  gfx_mode = 0;
);

function ylabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, gfx_dest, rotatedPrint)
  local(sw, sh)
  (
    gfx_measurestr(str, sw, sh);
    rotatedPrint(x-16, y+0.5*(h-sw), str, -.5*$pi); 
  );
  
function xlabel(str)
  instance(x, y, w, h)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(sw, sh)
  (
    gfx_set( .7, .7, .7, 1.0 );
    gfx_measurestr(str, sw, sh);
    gfx_x = x + 0.5*(w-sw);
    gfx_y = y + h + 12;
    gfx_printf(str);
  );  

function draw_text(str, rx, ry)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local()
  (
    gfx_set( .7, .7, .7, 1.0 );
    gfx_x = x + w*rx;
    gfx_y = y + h*ry;
    gfx_printf(str);
  );

function draw_grid(N)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(dx, dy)
  (
    gfx_set( .3, .3, .6, .2 );
    dx = w/(N-1);
    dy = h/(N-1);    
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    gfx_x = x;
    gfx_y = y+h;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );
  
function draw_grid(N, dy)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(dx, dy)
  (
    gfx_set( .3, .3, .6, .2 );
    dx = w/(N-1);  
    gfx_x = x;
    gfx_y = y;
    loop(N,
      gfx_line(gfx_x, gfx_y, gfx_x, gfx_y+h);
      gfx_x += dx;
    );
    
    gfx_x = x;
    gfx_y = y+h;
    loop(min(100, floor(h/dy)),
      gfx_line(gfx_x, gfx_y, gfx_x+w, gfx_y);
      gfx_y -= dy;
    );
  );  

function draw_back()
  instance(x, y, w, h, yref, sc)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local()
  (
    gfx_set( .2, .2, .3, .1 );
    gfx_rect(x, y, w, h);
  );

function draw_window(movAvgL, movAvgR, movAvgOL, movAvgOR)
  instance(x, y, w, h, spline)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  (
    this.draw_back();
    this.draw_grid(10);
    spline.plot_spline(x, y, w, h);
    
    gfx_set( 0.6 + max(-.2,(movAvgL - 1)), .1, .1, 1.0);
    gfx_rect(x,y+h+2,w*min(1,movAvgL),2);
    gfx_rect(x,y+h+4,w*min(1,movAvgR),2);
    gfx_set( 0.2, .2, 0.9 + max(movAvgOL - 1, -.5), 1.0);
    movAvgOL = min(movAvgOL, 1);
    movAvgOR = min(movAvgOR, 1);
    gfx_rect(x-2,y+h-h*movAvgOL,2,h*movAvgOL);
    gfx_rect(x-4,y+h-h*movAvgOR,2,h*movAvgOR);
  );
  
function draw_buffer(scopeptr, scopebuffer, scopebuffermax, mul)
  instance(x, y, w, h, yref, sc, cap_mode)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y)
  local(xx, dx, lptr, yy, lastx, lasty, scale, isc)
  (
    xx = x;
    dx = w/(scopebuffermax-scopebuffer);
    lptr = scopeptr;
    scale = (mul > 0) ? mul*h : sc;

    gfx_x = xx;
    gfx_y = yref;
    isc = h/scale;
    loop(scopebuffermax-scopeptr,
      yy = yref - scale*min(isc,lptr[]);
      gfx_lineto(xx, yy);
      lptr += 1;
      xx += dx;
    );
    
    lptr = scopebuffer;
    loop(scopeptr - scopebuffer,
      yy = yref - scale*min(isc,lptr[]);
      gfx_lineto(xx, yy);
      lptr += 1;
      xx += dx;
    );
  );  

function draw_dynamics(thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight)
  globals(gfx_r, gfx_g, gfx_b, gfx_x, gfx_y, inLight.toggleLight_draw)
  local()
  (
    yref = y+h;
    this.draw_grid(10, 10*sc/h);
    gfx_set( 0.9, 0.3, 0.3, 0.4 );
    gfx_x = x+2;
    gfx_y = yref-sc*thresh-10;
    gfx_printf( "Thresh" );
    gfx_line( x, yref - sc*thresh, x + w, yref -sc*thresh );
    ( highlight == 1 ) ? gfx_rect( x, yref - sc*thresh-1, w, 2 );
    
    inLight.toggleLight_draw();
    outLight.toggleLight_draw();
    dynLight.toggleLight_draw();
  );
  
function processMouseDynamics(xx, yy, dx, dy, mc, thresh)
  instance(x, y, w, h, yref, sc, cap_mode, highlight, inLight, outLight, dynLight)
  local(left, right)
  global(gfx_x, gfx_y,mouse_wheel, slider59, inLight.toggleLight_processMouse, outLight.toggleLight_processMouse, dynLight.toggleLight_processMouse)
  (
    left  = mc & 1;
    right = mc & 2;
    
    inLight.toggleLight_processMouse(xx, yy, mc);
    outLight.toggleLight_processMouse(xx, yy, mc);
    dynLight.toggleLight_processMouse(xx, yy, mc);    
    
    highlight = 0;
    ( mouse_wheel ~= 0 && xx > 0 && yy > 0 && xx < (x+w) && yy < (y+h) ) ?
    (
      sc += 10*mouse_wheel;
      mouse_wheel = 0;
      ( sc < 0 ) ? sc = 0.01;
    );
    
    ( left ) ?
    (
      ( cap_mode == 0 ) ? 
      (
        ( xx > x && yy > y && xx < (x+w) && yy < (y+h) ) ?
        (
          ( yy > (yref - sc*thresh - 4) ) && ( yy < (yref - sc*thresh + 4) ) ?
          (
            cap_mode = 2;
          ) : (
            cap_mode = 1;
          );
        );
      ) : ( cap_mode == 1 ) ? (
        sc += 15 * dy;
       ( sc < 100 ) ? sc = 100;
       ( sc > 5000 ) ? sc = 5000;
      ) : (
        thresh += dy/h/(sc/h);
        ( thresh < 0 ) ? thresh = 0.01;
        slider59 = thresh;
        slider_automate(slider59);
      );
    ) : (
      cap_mode = 0;
      ( xx > 0 && yy > 0 && xx < (x+w) && yy < (y+h) ) ?
      (
        ( yy > (yref - sc*thresh-10) ) && ( yy < (yref - sc*thresh+10) ) ?
        (
          highlight = 1;
        );
      );
    );
    
    thresh
  );  

function initRMS(N, loc_in)
  local()
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    sc      = 1.0/N;
    ptr     = loc_in;
    loc     = loc_in;
    loc_end = loc_in + N;
    
    loop(N,
     ptr[]  = 0;
     ptr   += 1; 
    );
    
    ptr = loc_in;
    movavg  = 0;
  );

function updateRMS(sr, sl)
  local( M )
  global()
  instance(loc, loc_end, ptr, movavg, sc)
  (
    M       = sc * max(sr*sr, sl*sl);
    
    movAvg -= ptr[];
    ptr[]   = M;
    movAvg += M;
    
    ptr    += 1;
    ptr > loc_end ? ptr = loc;
        
    movAvg
  );

function getBuffer()
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[];
  );

function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );
  
function updateIntegrationTime()
  (
    ( (lastIntegrationTime != slider63) || (slider64 != lookAhead) ) ? 
    (
      lastIntegrationTime = slider63;      
      lookAhead           = slider64;
    
      ndelay = ceil(srate*lastIntegrationTime/1000);
      RMS1.initRMS(ndelay, 100000);
      RMS2.initRMS(ndelay, 200000);

      ndelay = ceil(ndelay * 0.5);
      preBufferL.initBuffer(300000, 300000 + ndelay);
      preBufferR.initBuffer(400000, 400000 + ndelay);
      
      lookAhead ? (
        // delays the first two channels (spl0/spl1).
        pdc_bot_ch=0; 
        pdc_top_ch=2;
        pdc_delay = ndelay;
      ) : ( 
        pdc_delay = 0;
      );
    );
  );
  
updateIntegrationTime();

delay_buf1      = 500000;
delay_buf2      = 600000;

// Global storage for variables
negative_xloc   = 100;
negative_yloc   = 200;
positive_xloc   = 300;
positive_yloc   = 400;
negative_xloc2  = 500;
negative_yloc2  = 600;
positive_xloc2  = 700;
positive_yloc2  = 800;
temp_xloc       = 900;
temp_yloc       = 1000;
pos_c1s         = 1100;
pos_c2s         = 1200;
pos_c3s         = 1300;
neg_c1s         = 1400;
neg_c2s         = 1500;
neg_c3s         = 1600;
pos_c1s2        = 1700;
pos_c2s2        = 1800;
pos_c3s2        = 1900;
neg_c1s2        = 2000;
neg_c2s2        = 2100;
neg_c3s2        = 2200;
temp_indices    = 2300;
pos_indices     = 2400;
neg_indices     = 2500;
vowel_A         = 2600;
vowel_E         = 2650;
vowel_I         = 2700;
vowel_O         = 2750;
vowel_U         = 2800;
Nbuf            = 20000;
inVol.initBuffer(20000, 20000+Nbuf-1);
outVol.initBuffer(20000+Nbuf, 20000+2*Nbuf-1);
dynBuf.initBuffer(20000+Nbuf*2, 20000+3*Nbuf-1);

filter_delay1.initBuffer(delay_buf1, delay_buf1 + filterFreq * 1000);
filter_delay2.initBuffer(delay_buf2, delay_buf2 + filterReso * 2000);

dynval          = 0;

// Initialize object instances
wndX = 250;
wndY = 250;
wndPad = 30;
window1.gen_window(wndPad, wndPad, wndX, wndY, 10, 1, negative_xloc, negative_yloc, negative_xloc2, negative_yloc2, pos_indices, temp_xloc, temp_yloc, temp_indices, neg_c1s, neg_c2s, neg_c3s, neg_c1s2, neg_c2s2, neg_c3s2);
window2.gen_window(2*wndPad+wndX, wndPad, wndX, wndY, 10, 2, positive_xloc, positive_yloc, positive_xloc2, positive_yloc2, neg_indices, temp_xloc, temp_yloc, temp_indices, pos_c1s, pos_c2s, pos_c3s, pos_c1s2, pos_c2s2, pos_c3s2);
window3.gen_dynamics(3*wndPad+2*wndX, wndPad, wndX, wndY );

filter_vowel.bootvowel();

n_pos = 8;
n_neg = 8;

function calcgain()
(
  pregain  = 2^(slider52/6);
  postgain = 2^(slider53/6);
);

function updateSliders()
(
  calcGain();

  dynamics = slider58;
  dynamicsEnabled = dynamics > 0;
  ( dynamicsEnabled ) ?
  (
    dyn_thresh    = slider59;
    dyn_atk       = 1 / ( slider60 * srate / 100 + 0.0001 );
    dyn_decay     = 1 / ( log(2) * slider61 * srate / 100 + 0.0001 );
    dyn_mod_filt  = slider62;
  );
  
  ( ( dynamics == 1 ) || ( dynamics == 3 ) ) ? ( filterDynamics = 1; ) : ( filterDynamics = 0; );
  ( ( dynamics == 2 ) || ( dynamics == 3 ) ) ? ( distortionDynamics = 1; ) : ( distortionDynamics = 0; );

  setter = window2.spline.xloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider3; setter += 1;
  setter[] = slider5; setter += 1;
  setter[] = slider7; setter += 1;
  setter[] = slider9; setter += 1;
  setter[] = slider11; setter += 1;
  setter[] = slider13; setter += 1;
  setter[] = slider15; setter += 1;
  setter[] = slider17; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window2.spline.yloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider4; setter += 1;
  setter[] = slider6; setter += 1;
  setter[] = slider8; setter += 1;
  setter[] = slider10; setter += 1;
  setter[] = slider12; setter += 1;
  setter[] = slider14; setter += 1;
  setter[] = slider16; setter += 1;
  setter[] = slider18; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window1.spline.xloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider19; setter += 1;
  setter[] = slider21; setter += 1;
  setter[] = slider23; setter += 1;
  setter[] = slider25; setter += 1;
  setter[] = slider27; setter += 1;
  setter[] = slider29; setter += 1;
  setter[] = slider31; setter += 1;
  setter[] = slider33; setter += 1;
  setter[] = 1; setter += 1;
  
  setter = window1.spline.yloc_write;
  setter[] = 0; setter += 1;
  setter[] = slider20; setter += 1;
  setter[] = slider22; setter += 1;
  setter[] = slider24; setter += 1;
  setter[] = slider26; setter += 1;
  setter[] = slider28; setter += 1;
  setter[] = slider30; setter += 1;
  setter[] = slider32; setter += 1;
  setter[] = slider34; setter += 1;  
  setter[] = 1; setter += 1;
  
  window1.setN(slider1);
  window2.setN(slider2);
  window1.spline.xloc_write[slider1-1] = 1;
  window2.spline.xloc_write[slider2-1] = 1;
  
  window1.sort_spline();
  window2.sort_spline();
  window1.update_spline();
  window2.update_spline();
  
  filterL.updateFilter(slider54);
  filterR.updateFilter(slider54);
  
  updateIntegrationTime();
);

function distort(s)
  global(window1.evalDistAudio, window2.evalDistAudio, rc_filter.evalRC2)
  local(os)
  global(slider56, tanh, dynval, distortionDynamics)
  ( 
    ( slider56 == 0 ) ? (
      os = s;
      s = ( s > 0 ) ? s = window1.evalDistAudio(s) : ( s = -window2.evalDistAudio(-s); );
      distortionDynamics ? s = (1-dynval) * os + dynval * s;
    ) : ( slider56 == 1 ) ? ( 
      os = s;
      s=tanh(s);
      distortionDynamics ? s = (1-dynval) * os + dynval * s;
    ) : ( slider56 == 2 ) ? (
      os = s;
      s=fasttanh(s);
      distortionDynamics ? s = (1-dynval) * os + dynval * s;
    );

    s
  );
  
function distortderiv(s)
  global(window1.evalDiff, window2.evalDiff, rc_filter.evalRC2)
  local(th)
  global(slider56, tanh)
  (
  ( slider56 == 0 ) ? (
    s = ( s > 0 ) ? s = window1.evalDiff(s) : ( s = -window2.evalDiff(-s); );
  ) : ( slider56 == 1 ) ? (
    th = tanh(s);
    s = 1.0 - th*th;
  ) : ( slider56 == 2 ) ? (
    th = 1;
  );
  s;
  );  

//---------------------------
// Filter usage section
//--------------------------- 

function evalRC(input)
  instance(len, v0, v1, a1, c)
  local(output, tmp)
  global(srate)
  (
    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    tmp = v1;

    v0 = a1*v0 - c*v1 + c*input;
    v1 = a1*v1 + c*v0;
    output = (tmp+v1)*0.5;
  );

function eval303(input)
  local(y0, s0, s)
  //instance(ah, bh, k, a, Abig, g, g0, ainv, a2, b, b2, c, z0, z1, z2, z3, z4, y1, y2, y3, y4, y5)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4
            b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  global(distort)
  (
    s = (z0*wc3 + z1*a20 + z2*c2 + z3*c3);
    y4 = (g*input + s)/(1 + g*k);
    
    y0 = distort(input - k*y4);
    y1 = b * ( y0*b0 + z0*a0 + z1*a1 + z2*a2 + z3*a3 );
    y2 = b * (y0*b10 + z0*a10 + z1*a11 + z2*a12 + z3*a13);
    y3 = b * (y0*b20 + z0*a20 + z1*a21 + z2*a22 + z3*a23);
    y4 = g*y0 + s;
    
    z0 += 4*wc*(y0 - y1 + y2);
    z1 += 2*wc*(y1 - 2*y2 + y3);
    z2 += 2*wc*(y2 - 2*y3 + y4);
    z3 += 2*wc*(y3 - 2*y4);
  );

function evalmoog(input)
  local(x)
  global()
  instance(r, p, k, oldx, oldy1, oldy2, oldy3, y1, y2, y3, y4)
  (
    // Process input
    x = input - r*y4;
    
    // Four cascaded onepole filters (bilinear transform)
    y1= x*p +  oldx*p - k*y1;
    y2=y1*p + oldy1*p - k*y2;
    y3=y2*p + oldy2*p - k*y3;
    y4=y3*p + oldy3*p - k*y4;
    
    // Clipper band limited sigmoid
    y4-=(y4*y4*y4)/6.;
    //y4 -= distort(y4);
    oldx = x; oldy1 = y1; oldy2 = y2; oldy3 = y3;
    
    y4;
  );

  //filter_karlsen
function evalkarlsen(b_v)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4)
  ( 
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    b_v     = distort(b_v);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = b_aflt4;
  );

  //filter_karlsen
function evalkarlsen_sat(b_v)
  local(f, t, t2, cutoff, res, b_rez, b_vnc)
  global(slider54)
  instance(b_fres, b_fenv, b_aflt1, b_aflt2, b_aflt3, b_aflt4, b_lfcut, b_lf, b_lf1hp, b_lfhp, b_lfgain)
  (
    // for nice low sat, or sharper type low deemphasis saturation, one can use a onepole shelf before the filter.
    b_lfcut = .001;
    b_lf    = b_lf + ((-b_lf + b_v) * b_lfcut); // b_lfcut 0..1
    b_lfhp  = b_v - b_lf;
    b_v     = b_lf + (b_lf1hp * ((b_lfgain*0.5)+1)); 
  
    b_rez   = b_aflt4 - b_v; // no attenuation with rez, makes a stabler filter.
    b_v     = b_v - (b_rez*b_fres); // b_fres = resonance amount. 0..4 typical "to selfoscillation", 0.6 covers a more saturated range.
    
    b_vnc   = b_v; // clip, and adding back some nonclipped, to get a dynamic like analog.
    b_v     = distort(b_v);
    //if (b_v > 1) {b_v = 1;} else if (b_v < -1) {b_v = -1;}
    b_v = b_vnc + ((-b_vnc + b_v) * 0.9840);
    
    b_aflt1 = b_aflt1 + ((-b_aflt1 + b_v) * b_fenv); // straightforward 4 pole filter, (4 normalized feedback paths in series)
    b_aflt2 = b_aflt2 + ((-b_aflt2 + b_aflt1) * b_fenv);
    b_aflt3 = b_aflt3 + ((-b_aflt3 + b_aflt2) * b_fenv);
    b_aflt4 = b_aflt4 + ((-b_aflt4 + b_aflt3) * b_fenv);
    b_v = b_aflt4;
  );
  
function evaldualfilt(sample)
  local(out)
  global(distort)
  instance(fb, f, d0, d1)
  (
    d0  = d0 + f * (sample - d0 + fb * .5*(distort(d0 - d1) + (d0-d1) + 0.15 * out ) );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(d1)*0.9 + d1*0.1;
  );
  
function evaldualfiltHP(sample)
  local(out, hp, bp)
  global(distort)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    d0  = d0 + f * ( hp + fb * .5*(distort(d0 - d1) + (d0-d1) + 0.15 * out ) );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(hp)*0.9 + hp*0.51;
  );
  
function evaldualfiltBP(sample)
  local(out, hp, bp)
  global(distor)
  instance(fb, f, d0, d1)
  (
    hp  = sample - d0;
    bp  = d0 - d1;
    d0  = d0 + f * ( hp + fb * (.6*distort(d0 - d1) + .4*(d0-d1) + 0.15 * out ) );
    d1  = d1 + f * ( d0 - d1 );
    out = distort(bp)*.7 + bp*0.3 + 0.05*hp + 0.05*d1;
  );
  
function evalfancymoog(y0)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4, gJ0, gJ1, gJ2, gJ3, gJ4, 
        t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18,
        A0_0_0, A0_0_1, A0_0_2, A0_0_3,
        A0_1_0, A0_1_1, A0_1_2, A0_1_3,
        A0_2_0, A0_2_1, A0_2_2, A0_2_3,
        A0_3_0, A0_3_1, A0_3_2, A0_3_3                    
        )
  global(distort, distortderivt, tanh)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (    
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      WS0 = distort(S0);
      gJ0 = g*distortderiv(S0);

      WS1 = distort(S1);
      gJ1 = g*distortderiv(S1);
      
      WS2 = distort(S2);
      gJ2 = g*distortderiv(S2);
      
      WS3 = distort(S3);
      gJ3 = g*distortderiv(S3);
      
      WS4 = distort(S4);
      gJ4 = g*distortderiv(S4);      
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );

      // Jacobian subexpressions
      t2 = gJ2*gJ3;
      t3 = gJ2*gJ4;
      t4 = gJ3*gJ4;
      t5 = gJ2*gJ3*gJ4;
      t6 = gJ1*gJ2;
      t7 = gJ1*gJ3;
      t8 = gJ1*gJ4;
      t9 = gJ1*gJ2*gJ3;
      t10 = gJ1*gJ2*gJ4;
      t11 = gJ1*gJ3*gJ4;
      t12 = gJ1*gJ2*gJ3*gJ4;
      t13 = gJ0*gJ1*gJ2*gJ3*k;
      t14 = gJ1+gJ2+gJ3+gJ4+t2+t3+t4+t5+t6+t7+t8+t9+t10+t11+t12+t13+1.0;
      t15 = 1.0/t14;
      t16 = gJ2+1.0;
      t17 = gJ3+1.0;
      t18 = gJ1+1.0;
      
      // Jacobian
      A0_0_0 = t15*(gJ2+gJ3+gJ4+t2+t3+t4+t5+1.0);
      A0_0_1 = -gJ0*gJ2*gJ3*k*t15;
      A0_0_2 = -gJ0*gJ3*k*t15*t16;
      A0_0_3 = -gJ0*k*t15*t16*t17;
      A0_1_0 = t15*(gJ1+t7+t8+t11);
      A0_1_1 = t15*(gJ1+gJ3+gJ4+t4+t7+t8+t11+1.0);
      A0_1_2 = -gJ0*gJ1*gJ3*k*t15;
      A0_1_3 = -gJ0*gJ1*k*t15*t17;
      A0_2_0 = t15*(t6+t10);
      A0_2_1 = t15*(gJ2+t3+t6+t10);
      A0_2_2 = t15*(gJ1+gJ2+gJ4+t3+t6+t8+t10+1.0);
      A0_2_3 = -gJ0*gJ1*gJ2*k*t15;
      A0_3_0 = gJ1*gJ2*gJ3*t15;
      A0_3_1 = gJ2*gJ3*t15*t18;
      A0_3_2 = gJ3*t15*t16*t18;
      A0_3_3 = t15*t16*t17*t18;
      
      // Newton Raphson update
      //y1 = y1 - ( A0_0_0 * F1 + A0_1_0 * F2 + A0_2_0 * F3 + A0_3_0 * F4 );
      //y2 = y2 - ( A0_0_1 * F1 + A0_1_1 * F2 + A0_2_1 * F3 + A0_3_1 * F4 );
      //y3 = y3 - ( A0_0_2 * F1 + A0_1_2 * F2 + A0_2_2 * F3 + A0_3_2 * F4 );
      //y4 = y4 - ( A0_0_3 * F1 + A0_1_3 * F2 + A0_2_3 * F3 + A0_3_3 * F4 );
      y1 = y1 - ( A0_0_0 * F1 + A0_0_1 * F2 + A0_0_2 * F3 + A0_0_3 * F4 );
      y2 = y2 - ( A0_1_0 * F1 + A0_1_1 * F2 + A0_1_2 * F3 + A0_1_3 * F4 );
      y3 = y3 - ( A0_2_0 * F1 + A0_2_1 * F2 + A0_2_2 * F3 + A0_2_3 * F4 );
      y4 = y4 - ( A0_3_0 * F1 + A0_3_1 * F2 + A0_3_2 * F3 + A0_3_3 * F4 );
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalfancymoog_noJac(y0)
  local(S0, S1, S2, S3, S4, F1, F2, F3, F4, WS0, WS1, WS2, WS3, WS4)
  global(distort, distortderiv)
  instance(A, k, omega, hA, g, wc, wcT, T, y0, y1, y2, y3, y4, d0, d1, d2, d3, d4)
  (
    loop(3,
      S0 = hA * (y0 + d0 + k * ( y4 + d4 ) );
      S1 = hA * (y1 + d1);
      S2 = hA * (y2 + d2);
      S3 = hA * (y3 + d3);
      S4 = hA * (y4 + d4);
      
      // Do not separate these, the index found during binary search for the original waveshaping
      // is used again in the derivate function.
      WS0 = distort(S0);
      WS1 = distort(S1);
      WS2 = distort(S2);
      WS3 = distort(S3);
      WS4 = distort(S4);
  
      F1 = y1 - d1 + wcT * ( WS1 + WS0 );
      F2 = y2 - d2 - wcT * ( WS1 - WS2 );
      F3 = y3 - d3 - wcT * ( WS2 - WS3 );
      F4 = y4 - d4 - wcT * ( WS3 - WS4 );
     
      // Newton Raphson update (assuming derivatives 0)
      y1 = y1 - F1;
      y2 = y2 - F1 - F2;
      y3 = y3 - F3;
      y4 = y4 - F4;
    );

    // Update history
    d0 = y0;
    d1 = y1;
    d2 = y2;
    d3 = y3;
    d4 = y4;
    
    y4;
  );

function evalvowel(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;
    
    d2yC = d1yC;
    d1yC = outC;
    
    out  = amp1 * outA + amp2 * outB + amp3 * outC;
  );
  
function evalsai0(sample)
  instance( c, amp1, amp2, amp3, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2, Cb0, Cb1, Cb2, Ca1, Ca2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, d1yC, d2yC,
   )
  local(out, outA, outB, outC)
  global()
  (
    sample = distort(sample);
    outA = Ab0 * sample + Ab1 * d1x + Ab2 * d2x - Aa1 * d1yA - Aa2 * d2yA;
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB;
    outC = Ab0 * sample + Cb1 * d1x + Cb2 * d2x - Ca1 * d1yC - Ca2 * d2yC;
    
    d2x = d1x;
    d1x = sample;
    
    d2yA = d1yA;
    d1yA = outA;

    d2yB = d1yB;
    d1yB = outB;

    d2yC = d1yC;
    d1yC = outC - .01 * ( outA - outB );
    
    out  = outA-.6*distort(outC-outB);
  );  
  
function evalmodulator(sample)
  instance( c, Ab0, Ab1, Ab2, Aa1, Aa2, Bb0, Bb1, Bb2, Ba1, Ba2,
  d1x, d2x, d1yA, d2yA, d1yB, d2yB, amp, d2x2, d1x2
   )
  local(out, dS, outA, outB, modo)
  global()
  (
    // Modulator LP
    outB = Bb0 * sample + Bb1 * d1x + Bb2 * d2x - Ba1 * d1yB - Ba2 * d2yB; 
    d2yB = d1yB;
    d1yB = outB;
    d2x = d1x;
    d1x = sample;
    
    modo = sample * outB;
    outA = Ab0 * modo + Ab1 * d1x2 + Ab2 * d2x2 - Aa1 * d1yA - Aa2 * d2yA;    
    d2yA = d1yA;
    d1yA = outA;    
    d2x2 = d1x2;
    d1x2 = modo;
    
    out  = distort(outB * distort(sample+amp*outA)*2);
  );    
  
function evalrbj(sample)
  instance( c, b0, b1, b2, a1, a2, d1x, d2x, d1y, d2y )
  local(out)
  global()
  (
    out = b0 * sample + b1 * d1x + b2 * d2x - a1 * d1y - a2 * d2y;
    
    d2x = d1x;
    d1x = sample;
    
    d2y = d1y;
    d1y = out;
    out;
  );

function evalphaserOTA(sample, jnk)
  global(distort)
  local(w)
  instance(C1, C2, dw, dx, sq)
  (
    sample = sample - sq * jnk;
    w = dw + C1 * distort( C2 * ( sample + dx + dw ) );
    dx = sample;
    dw = w;
    
    w + sample
  );
    
function evalphaserFET(sample)
  global(distort)
  local(w, u, I_ds, out)
  instance(C1, C2, dw, dx, IDSSdivVpSq, thresh)
  (
    u = sample - dw;
    
    I_ds = ( u < thresh ) ? (
      IDSSdivVpSq * 2 * thresh * u - u*u;
    ):(
      IDSSdivVpSq * thresh * thresh * u;
    );
    
    w = dw + C1 * ( C2 * u + I_ds );
    
    out = sample - w - dw;
    dw = w;
    
    out
  );

function bufferFun(sample, delay1, delay2)
  global(distort)
  local(h)
  instance()
  (
    h = 5;
  );

  //global(window1.evalDist, window2.evalDist, filter_303.eval303)
function process(sample)
  (
    ( slider47 == 0 ) ? (
      sample = distort(sample);
    ) : ( slider47 == 1 ) ? (
      sample = rc_filter.evalRC(sample);
      sample = distort(sample);
    ) : ( slider47 == 2 ) ? (
      sample = filter_303.eval303(sample);
    ) : ( slider47 == 3 ) ? (
      sample = distort(sample);
      sample = filter_vowel.evalvowel(sample);
    ) : ( slider47 == 4 ) ? (
      sample = filter_karlsen.evalkarlsen(sample);
    ) : ( slider47 == 5 ) ? (
      sample = filter_karlsen_sat.evalkarlsen_sat(sample);
    ) : ( slider47 == 6 ) ? (
      sample = filter_dualfilt.evaldualfilt(sample);
    ) : ( slider47 == 7 ) ? (
      sample = filter_dualfiltHP.evaldualfiltHP(sample);
    ) : ( slider47 == 8 ) ? (
      sample = filter_dualfiltBP.evaldualfiltBP(sample);
    ) : ( slider47 == 9 ) ? (
      sample = filter_fancymoog.evalfancymoog(sample);
    ) : ( slider47 == 10 ) ? (
      sample = filter_fancymoog.evalfancymoog_noJac(sample);      
    ) : ( slider47 == 11 ) ? (
      sample = filter_notch.evalrbj(sample);
      sample = distort(sample);
    ) : ( slider47 == 12 ) ? (
      sample = filter_sai0.evalsai0(sample);
    ) : ( slider47 == 13 ) ? (
      sample = filter_modulator.evalmodulator(sample);
    ) : ( slider47 == 14 ) ? (
      os = sample;
      sample = filter_phaser.evalphaserOTA(sample, jnk);
      sample = filter_phaser2.evalphaserOTA(sample, 0);
      sample = filter_phaser3.evalphaserOTA(sample, 0);
      sample = filter_phaser4.evalphaserOTA(sample, 0);
      jnk = sample;
      sample = distort(os + sample);
    ) : ( slider47 == 15 ) ? (
      os = sample;
      sample = filter_phaser.evalphaserFET(sample);
      sample = filter_phaser2.evalphaserFET(sample);
      sample = filter_phaser3.evalphaserFET(sample);
      sample = filter_phaser4.evalphaserFET(sample);
      sample = distort(os + sample);
    ) : ( slider47 == 16 ) ? (
      os1 = filter_delay1.getBuffer();
      os2 = filter_delay2.getBuffer();
      ys1 = sample - .2 * distort(os1-os2);
      filter_delay1.updateBuffer(sample);
      filter_delay2.updateBuffer(ys1-sample);
      sample = ys1 + os2;
    ) : ( slider47 == 17 ) ? (
      os1 = filter_delay1.getBuffer();
      os2 = filter_delay2.getBuffer();
      os3 = 0.001 * abs(sample) + 0.999 * abs(os3);
      filter_delay1.updateBuffer(sample);
      filter_delay2.updateBuffer(sample);      
//      filter_delay2.initBufferNoReset(delay_buf2, delay_buf2 + filterReso * 2000);
      sample = tanh(5*os3*sample + distort(sample-os1));
    );
    
    sample;
  );

gfx_ext_retina  = 1.0;
ext_nodenorm    = 1; 
gfx_clear       = -1;
updateSliders();

@slider
updateSliders();
updateActiveFilters();

@block

@sample
  sl      = spl0 * pregain;
  sr      = spl1 * pregain;
  alpha   = 0.9999;
  
  // Dynamics
  inV = inVol.updateBuffer( RMS1.updateRMS(sl, sr) );
  ( dynamicsEnabled ) ?
  (
    ( inV > dyn_thresh ) ? (
      dynval = dynval + dyn_atk;
      dynval = min(1, dynval);
    ) : (
      dynval = dynval - dyn_decay * dynval;
    );
    dynBuf.updateBuffer(dynval);
  );
  filterDynamics ? updateActiveFilters();
  
  ( lookAhead ) ?
  (
    oldl = preBufferL.getBuffer();
    oldr = preBufferR.getBuffer();
    preBufferL.updateBuffer( sl );
    preBufferR.updateBuffer( sr );
    sl = oldl;
    sr = oldr; 
  );
  
  movavgLN = max(alpha*movavgLN, -sl);
  movavgLP = max(alpha*movavgLP,  sl);
  movavgRN = max(alpha*movavgRN, -sr);
  movavgRP = max(alpha*movavgRP,  sr);
  
  ( slider54 == 0 ) ? (
    // Without oversampling
    sl = process(sl);
    sr = process(sr);
//  ) : ( slider54 == 1 ) ? (
//    // With oversampling
//    os.os_up2(sl); 
//    os.y1 = process(os.y1);
//    os.y0 = process(os.y0);    
//    sl = os.os_down2();
//    os.os_up2(sr);  
//    os.y1 = process(os.y1);
//    os.y0 = process(os.y0);
//    sr = os.os_down2();
  ) : ( 
    q = 0;
    // N>1 oversampling
    sli = sl;
    sri = sr;
    loop( slider54,
      ssl = filterL.inputFilter(sli);
      ssr = filterR.inputFilter(sri);
      ssl = process(ssl);
      ssr = process(ssr);
      (q += 1)==1 ? (
        sl = filterL.outputFilter(ssl);
        sr = filterR.outputFilter(ssr);
      ) : (
        filterL.outputFilter(ssl);
        filterR.outputFilter(ssr);
      )
    )
  );
  
  // DC correction?
  ( slider51 == 1 ) ?
  (
    otm1=0.999*otm1 + sl - itm1;
    itm1=sl;
    sl=otm1;
    otm2=0.999*otm2 + sr - itm2;
    itm2=sr;
    sr=otm2;
  );
  
  movavgOLN = max(alpha*movavgOLN, -sl);
  movavgOLP = max(alpha*movavgOLP,  sl);
  movavgORN = max(alpha*movavgORN, -sr);
  movavgORP = max(alpha*movavgORP,  sr);
  
  spl0 = sl * postgain;
  spl1 = sr * postgain;

  // Scope
  outVol.updateBuffer( RMS2.updateRMS(spl0, spl1) );

@gfx 600 600

gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

  //function draw_button(xp, yp, str) 
  //  instance(w,h,x,y) 
  //  globals(gfx_r,gfx_g,gfx_b,gfx_x,gfx_y,bgcolor) 
  
  gfx_clear=-1;
  
  // Clear screen first
  gfx_r=gfx_g=gfx_b=0; gfx_a=.6;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w,gfx_h);

  window3.draw_back();
  window3.draw_dynamics(dyn_thresh);
  window3.inLight.active ? (
    gfx_set( 1, .3, .3, .3 );
    window3.draw_buffer(inVol.scopeptr, inVol.scopebuffer, inVol.scopebuffermax, 0);
  );
  window3.outLight.active ? (
    gfx_set( .6, .3, 1, .9 );
    window3.draw_buffer(outVol.scopeptr, outVol.scopebuffer, outVol.scopebuffermax, 0);  
  );
  window3.dynLight.active ? (
    dynamicsEnabled ? (
      gfx_set( .8, .8, .2, .3 );  
      window3.draw_buffer(dynBuf.scopeptr, dynBuf.scopebuffer, dynBuf.scopebuffermax, 1); 
    );
  );
  
  window3.draw_text("Dynamics", .025, .025);
  window3.ylabel("RMS / Level");
  window3.xlabel("Time");
  window1.draw_window(movAvgLN, movAvgRN, movavgOLN, movavgORN);
  window2.draw_window(movAvgLP, movAvgRP, movavgOLP, movavgORP);
  window1.draw_text("Negative", .025, .025);
  window1.ylabel("Out Voltage (-)");
  window1.xlabel("In Voltage (+)");
  window2.draw_text("Positive", .025, .025);
  window2.ylabel("Out Voltage (-)");
  window2.xlabel("In Voltage (+)");
  
  window1.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
  window2.processMouse(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap);
  dyn_thresh = window3.processMouseDynamics(mouse_x, mouse_y, lx-mouse_x, ly-mouse_y, mouse_cap, dyn_thresh);
  lx = mouse_x;
  ly = mouse_y;
  
  ( forceUpdate==1 ) ? (
    forceUpdate = 0;
    updateSliders();
  );
  
  gfx_x = 30;
  gfx_y = 400;
  filterDescription(slider47);
  
//  spline1.sort_spline();
//  spline2.sort_spline();

//    gfx_set( .7, .7, .7, .7 );
//    gfx_x = 0;
//    gfx_y = 0;
//    q = positive_xloc;
//    q += 2;
//    gfx_printf("xloc: %f", q[]);
