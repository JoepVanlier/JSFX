@init
//   max_partial = 1024;
function alloc_model_memory_block(freemem, max_partials)
instance()
global()
local(ptr, ds, ix)
(
  // Memory Layout is as follows: 
  //   Frequency Ratio (x2) | Abs Frequency Shift (x2) | Decay (x2) | Amplitude (x2)
  freemem[max_partials * 8 + 1] == 0 ? (
    /* Uninitialized, initialize it now */
    memset(freemem, max_partials * 2, 0);
    memset(freemem + max_partials * 2, max_partials * 2, 0);
    
    // Decays
    ds = 1 / (max_partials * 2);
    ptr = freemem + max_partials * 4;
    ix = 0; loop(max_partials, ptr[ix] = -2 - 80 * ds * ix; ix += 1; );
    ptr = freemem + max_partials * 5;
    ix = 0; loop(max_partials, ptr[ix] = -1 - ds * ix; ix += 1; );
    
    // Amplitudes
    ptr = freemem + max_partials * 6;
    ix = 0; loop(max_partials, ptr[ix] = - 20 * ds * ix - 100; ix += 1; );
    ptr = freemem + max_partials * 7;
    ix = 0; loop(max_partials, ptr[ix] = - ds * ix; ix += 1; );
    
    freemem[max_partials * 8 + 1] = 1;
  );
  freemem + max_partials * 8 + 64  
);

function draw_array(me, xc, yc, wc, hc, bin_width, min_value, max_value, memory_block)
local(
  bins, idx, value, xp, range, inv_range, y_bottom,
  increments, lx, ly, dx, dy
)
global(
  gfx_a, mouse_x, mouse_y, mouse_cap, captured, settings_changed,
)
instance(
  bin_count, m_idx, last_x, last_y
)
(
  idx = 0;
  xp = xc;
  bin_count = floor(wc / bin_width);
  range = (max_value - min_value) / hc;
  inv_range = 1.0 / range;
  y_bottom = yc + hc;
  loop(bin_count,
    colormodel(idx / bin_count);
    gfx_a = 0.1;
    gfx_rect(xp, yc, bin_width - 2, hc, 1);
    gfx_a = 0.5;
    gfx_rect(xp, yc, bin_width - 2, hc, 0);
    
    value = min(hc, max(0, (memory_block[idx] - min_value) * inv_range));
    gfx_rect(xp, y_bottom - value, bin_width - 2, value, 1);
    
    idx += 1;
    xp += bin_width;
  );
  
  // Are we in here?
  ((captured == 0) || (captured == me)) ? (
    ((mouse_x > xc) && (mouse_y > yc) && (mouse_x < (xc + wc)) && (mouse_y < (yc + hc))) || (captured == me) ? (
      (mouse_cap == 1) ? (
        captured = me;
        
        // Smaller increments than mouse movement to increase precision and
        // not miss bins when the user moves fast.
        lx = last_x;
        ly = last_y;
        dx = mouse_x - lx;
        increments = ceil(abs(dx) / (bin_width / 2));
        dx /= increments;
        dy = (mouse_y - ly) / increments;
        loop(increments + 1,
          m_idx = (lx - xc) / bin_width;        
          memory_block[m_idx] = min(max_value, max(min_value, (yc + hc - ly) * range + min_value));
          lx += dx;
          ly += dy;
        );
        settings_changed = 1;
      );
    );
  );
  ((mouse_cap == 0) && (captured == me)) ? captured = 0;
  
  last_x = mouse_x;
  last_y = mouse_y;
);

function draw_custom_partial_ui(xc, yc, wc, hc, memory_block, max_partials)
local(vert_step, vert_size, bin_width)
global()
instance(a1, a2, a3, a4)
(
  bin_width = 12;
  gfx_set(0, 0, 0, 0.8);
  gfx_rect(xc, yc, wc, hc);
  
  vert_size = floor((hc - 8) / 4);
  vert_step = vert_size + 2;
  a1.draw_array(100, xc, yc, wc, vert_size, bin_width, -1, 1, memory_block); /* Freq */
  a2.draw_array(101, xc, yc + vert_step, wc, vert_size, bin_width, -50, 50, memory_block + max_partials * 2); /* Freq */
  a3.draw_array(102, xc, yc + 2 * vert_step, wc, vert_size, bin_width, -3, 0, memory_block + max_partials * 4); /* Decay */
  a4.draw_array(103, xc, yc + 3 * vert_step, wc, vert_size, bin_width, -72, 0, memory_block + max_partials * 6); /* Amplitude */
);

