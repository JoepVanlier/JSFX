@init
function _impulse_svf(freq, res)
global(srate)
local(div, omega, ct, st)
instance(f0, ic1eq, ic2eq, g, k, a1, a2, a3)
(
  f0 = exp((1.0 - freq) * log(20/22050)) * (44100 / srate);
  
  omega = 0.5 * $pi * f0;
  k = 2.0 - 2.0 * res;
  
  ct = cos(omega);
  st = sin(omega);
  div = 1.0 / (1.0 + k * st * ct);
  a1 = ct * ct * div;
  a2 = st * ct * div;
  a3 = st * st * div;
);

function _impulse_svf_lp(v0)
global()
local(v1, v2, v3)
instance(ic1eq, ic2eq, a1, a2, a3)
(
  v3 = v0 - ic2eq;
  v1 = a1 * ic1eq + a2 * v3;
  v2 = ic2eq + a2 * ic1eq + a3*v3;
  ic1eq = 2*v1 - ic1eq;
  ic2eq = 2*v2 - ic2eq;    
  
  v2
);

function prepare_impulse_globals()
local(w, ip)
global(srate,
       impulse_init_1, impulse_init_2, impulse_window_coeff, impulse_halflength, impulse_length)
instance()
(
  // Cheap Hann window N is given by the relation (note that N must be odd)
  //   w = 2.0 * pi / (N - 1)
  //   impulse_window_coeff = 2.0 * cos(w)
  // Where the initial conditions of the system are given by:
  //   ip = - 0.5 * pi
  //   y1 = sin( ip - w )
  //   y2 = sin( ip - 2.0*w );
  // Upon initialization in the oscillator.
  // Since we want a bright impulse, we switch sign halfway through the window.
  
  // The dynamical system that we need to run inside the oscillator is:
  //    y0 = impulse_window_coeff * y1 - y2
  //    y2 = y1
  //    y1 = y0
  //    w = 0.5 * (y0 + 1) * sign(i - impulse_halflength)
  
  impulse_length = floor(0.01 * srate);
  ((impulse_length % 2) == 0) ? impulse_length += 1; // Force it to be odd
  impulse_halflength = floor(impulse_length / 2);
  
  w = 2.0 * $pi / (impulse_length - 1);
  ip = - 0.5 * $pi;
  impulse_window_coeff = 2.0 * cos(w);
  impulse_init_1 = sin(ip - w);
  impulse_init_2 = sin(ip - 2.0 * w); 
);

function update_impulse_note(state, inverse_brightness)
instance(
  impulse_type, clipped_inverse,
  t, y1, y2, len, scale,
)
local()
global(
  play_mode
  impulse_init_1, impulse_init_2, impulse_window_coeff, impulse_halflength, impulse_length,
)
(
  clipped_inverse = max(min(1, inverse_brightness), 0);
  
  /* State 1 is press, -1 is release */
  (state > 0) ? (
    t = 0;
    impulse_type = floor(play_mode) - 1;
    ((impulse_type == 1) || (impulse_type == 2)) ? (
      // Simple pulse
      y1 = impulse_init_1;
      y2 = impulse_init_2;
      len = impulse_length;
      scale = pow(10, 1 - 3 * clipped_inverse);
      impulse_type == 2 ? this._impulse_svf(1.0 - clipped_inverse, 0);
    ) : ( impulse_type == 3 ) ? (
      len = impulse_length * 1000;
    );
  );
);


function eval_impulse()
local(y0, loc)
global(impulse_window_coeff, impulse_halflength)
instance(
  impulse_type,
  t, y1, y2,
  b0, b1, b2, white, pink,
  len, scale,
)
(
  t += 1;
  (t < len) ? (
    (impulse_type == 1) ? (
      y0 = impulse_window_coeff * y1 - y2;
      y2 = y1;
      y1 = y0;
      loc = t - impulse_halflength;
      5000 * (y0 + 1) * (scale * loc / (1 + scale * abs(loc))) // sign(t - impulse_halflength)
    ) : (impulse_type == 2) ? (
      y0 = impulse_window_coeff * y1 - y2;
      y2 = y1;
      y1 = y0;
      
      // Cheapo pink noise
      // Stolen from: https://www.firstpr.com.au/dsp/pink-noise/#Filtering
      white = rand() - 0.5;
      b0 = 0.99765 * b0 + white * 0.0990460;
      b1 = 0.96300 * b1 + white * 0.2965164;
      b2 = 0.57000 * b2 + white * 1.0526913;
      pink = b0 + b1 + b2 + white * 0.1848;
      
      this._impulse_svf_lp(5000 * (y0 + 1) * pink);
    ) : (impulse_type == 3) ? (
      // Breathy (placeholder)
      
      // Cheapo pink noise
      // Stolen from: https://www.firstpr.com.au/dsp/pink-noise/#Filtering
      white = rand() - 0.5;
      b0 = 0.99765 * b0 + white * 0.0990460;
      b1 = 0.96300 * b1 + white * 0.2965164;
      b2 = 0.57000 * b2 + white * 1.0526913;
      pink = b0 + b1 + b2 + white * 0.1848;
      2000 * pink 
    );
  ) : (
    0
  )
);

function impulse_alive(fft_size)
local()
global()
instance(t, len)
(
  t < (len + fft_size)
);

