@init
function identify_note(midi_pitch)
local(octave, note, note_label)
global(CUSTOM_SLIDER)
(
  (midi_pitch > 0) ? (
    octave = floor((midi_pitch - 12) / 12);
    note = (midi_pitch - 21) % 12;
    note_label = note < 1 ? "A-" : note < 2 ? "A#" : note < 3 ? "B-" : note < 4 ? "C-" : note < 5 ? "C#" : note < 6 ? "D-" : note < 7 ? "D#" : note < 8 ? "E-" : note < 9 ? "F-" : note < 10 ? "F#" : note < 11 ? "G-" : "G#";
    sprintf(CUSTOM_SLIDER, "%s%d", note_label, octave)
  ) : "";
);


function init_midi(freemem)
instance(note_mem, active_note_mem, active_note_vel, max_notes, notes_on, pitchbend, modwheel)
global()
(
  max_notes = 512;
  freemem = (note_mem = freemem) + 32768;
  freemem = (active_note_mem = freemem) + 4096;
  freemem = (active_note_vel = freemem) + 4096;  
  memset(active_note_mem, 0, 128);
  memset(note_mem, 0, 32768);
  notes_on = 0;
  pitchbend = 0;
  modwheel = 0;
  freemem
);


function midi_block()
global()
instance(note_next, active_note_mem, note_mem, notes_remain, curSample, note_ptr)
local(offset, msg1, msg2, msg3, note_on, note_off, mwCC, pb, lastpb)
(
  notes_remain = 0;
  note_ptr = note_mem;
  lastpb = -1337;
  while (midirecv(offset,msg1,msg2,msg3) && (note_ptr < (active_note_mem - 4))) (
    note_on = msg1>$x8F&&msg1<$xA0 && msg3!=0;
    note_off = (msg1>$x7F&&msg1<$x90) || (msg1>$x89&&msg1<$xA0 && msg3==0);
    mwCC = (msg1>$xAF&&msg1<$xC0);
    pb = msg1 & 0xF0 === 0xE0;
    notes_remain = 1;
    note_on ? (
      note_ptr[] = offset;
      note_ptr += 1;
      note_ptr[] = msg3;
      note_ptr += 1;
      note_ptr[] = msg2;
      note_ptr += 1;
    ) : ( note_off ) ? (
      note_ptr[] = offset;
      note_ptr += 1;
      note_ptr[] = -1;
      note_ptr += 1;
      note_ptr[] = msg2;
      note_ptr += 1;
    ) : ( pb ) ? (
      pb = (((msg3 << 8) | msg2) - 0x4000)/16384;
      (pb != lastpb) ? (
        note_ptr[] = offset;
        note_ptr += 1;
        note_ptr[] = -3;
        note_ptr += 1;
        note_ptr[] = pb;
        note_ptr += 1;
      );
      lastpb = pb;
    ) : ( mwCC ) ? (
      note_ptr[] = offset;
      note_ptr += 1;
      note_ptr[] = -2;
      note_ptr += 1;
      note_ptr[] = msg2;
      note_ptr += 1;
      note_ptr[] = msg3;
      note_ptr += 1;
    );
  );
  note_ptr[]       = -1337;     // Signal end of note buffer
  note_ptr         = note_mem;
  curSample       = -1;        // Current sample in block
  note_next       = note_ptr[];
);

// Put in loop with
// midi.notes_remain
function midi_sample(respond_to_notes)
instance(note_next, curSample, note_ptr, notes_remain, notes_on, note, velocity,
         active_note_mem, active_note_vel, cur_cc, cc_target, max_notes, modwheel, pitchbend)
local(i, found, current_item, change)
global()
(
  change = 0;
  // Take notes from the stack until we hit the end marker -1
  while(note_next == curSample) (
    note_ptr += 1;
    current_item = note_ptr[];

    (current_item > 0) ? ( // note-on
      respond_to_notes ? (
        velocity = note_ptr[]/127;
        note_ptr += 1;
        note = note_ptr[];
        found = 0; i=0;
        loop(notes_on,
          (active_note_mem[i] == note) ? found = 1;
          i += 1;
        );
        !found ? (
          notes_on = notes_on + 1;
          // Add note to list of active notes
          active_note_mem[notes_on - 1] = note;
          active_note_vel[notes_on - 1] = velocity;
        );
        change = 1;
      ) : (
        note_ptr += 1;
      );
    ) : (current_item == -1) ? ( // note-off
      respond_to_notes ? (
        notes_on = notes_on - 1;
        notes_on = max(0, notes_on);
        note_ptr += 1;
        note = note_ptr[];
        
        i = -1;
        while(
          i += 1;
          (active_note_mem[i] != note) && (i < 30)
        );
  
        // Memcpy is undefined for overlapping buffers.
        loop(max_notes,
          active_note_mem[i] = active_note_mem[i+1];
          active_note_vel[i] = active_note_vel[i+1];
          i += 1;
        );
        notes_on > 0 ? (
          note != active_note_mem[notes_on-1] ? (
            note = active_note_mem[notes_on-1];
          );
        );
        change = 1;
      ) : (
        note_ptr += 1;
      );
    ) : (current_item == -2) ? ( // CC
      note_ptr += 1;
      // msg3
      cur_cc = note_ptr[];
      
      note_ptr += 1;
      // msg2
      cur_cc == 1 ? (
        cc_target = note_ptr[]/128;
        
        (modwheel != cc_target) ? change = 1;
        modwheel = cc_target;
      );
    ) : (current_item == -3) ? (
      note_ptr += 1;
      (pitchbend != note_ptr[]) ? change = 1;
      pitchbend = note_ptr[];
    );
    note_ptr += 1;
    
    // Avoid constantly dereferencing by picking up the next one
    note_next = note_ptr[];
    notes_remain = note_next != -1337;
  );
  
  change
);



//midisend(offset,msg1,msg2,msg3); // passthrough MIDI events
