@init
function fft_mem(freemem, _max_fft_size)
instance(
  max_fft_size,
  buffer_size,
  in_fft_mem, out_fft_mem, window_mem, input_mem, output_mem
)
global()
local()
(
  max_fft_size = _max_fft_size;
  buffer_size = 65536;
  
  /* Make sure we start on a boundary */
  freemem = ceil(freemem / 65536) * 65536;
  freemem = (in_fft_mem = freemem) + 2 * max_fft_size;
  freemem = (out_fft_mem = freemem) + 2 * max_fft_size;
  freemem = (window_mem = freemem) + 2 * max_fft_size;
  freemem = (input_mem = freemem) + buffer_size;
  freemem = (output_mem = freemem) + buffer_size;
  
  freemem
);


function init_stft(_fft_size)
instance(
  max_fft_size
  fft_size,
  buffer_size,
  
  overlap_factor,
  fft_interval,
  in_fft_mem, out_fft_mem, window_mem,
  input_mem, output_mem,
  input_idx, fft_idx, output_idx,
  fft_scaling_factor,
)
local(gain, i, r, a0, a1, a2, a3, a4)
global()
(
  (fft_size != _fft_size) ? (    
    fft_size = min(_fft_size, max_fft_size);
    memset(in_fft_mem, 0, 2 * max_fft_size);
    memset(out_fft_mem, 0, 2 * max_fft_size);
    memset(window_mem, 0, 2 * max_fft_size);
    memset(input_mem, 0, buffer_size);
    memset(output_mem, 0, buffer_size);
  
    // Hann
    a0 = 0.5;
    a1 = 0.5;
    a2 = a3 = a4 = 0;
    overlap_factor = fft_size / ceil(fft_size/4);
    gain = 5 / 0.375;//0.5 * 0.55;
    
    // Blackmann-Harris
    
    a0 = 0.35875;
    a1 = 0.48829;
    a2 = 0.14128;
    a3 = 0.01168;
    a4 = 0;
    overlap_factor = fft_size / ceil(fft_size/3); // Actually attained overlap with a target of 3
  //  gain = 0.25 / 0.35875;
    gain = 5 / 0.25796335495;
    
    fft_idx = output_idx = input_idx = 0;
    fft_interval = fft_size / overlap_factor;
    fft_scaling_factor = gain / overlap_factor / overlap_factor / fft_size / fft_size;
      
    i = 0;
    loop(2 * fft_size,
      r = (i + 0.5) / (2 * fft_size);
      window_mem[i] = sqrt(fft_scaling_factor) * (a0 - a1 * cos(2 * $pi * r) + a2 * cos(4 * $pi * r) - a3 * cos(6 * $pi * r) + a4 * cos(8 * $pi * r));
      i += 1;
    );
    1
  ) : 0;
);

function string_mem(freemem, _in_fft_mem, _out_fft_mem)
instance(
  max_partial,
  bin_mem, coeff_mem, mix_mem, state_mem,
  in_fft_mem, out_fft_mem,
)
local()
global()
(
  // Allocate memory for this string, note that in and out fft_mem have to be preallocated.
  max_partial = 1024;
  freemem = (bin_mem = freemem) + 2 * max_partial;
  freemem = (coeff_mem = freemem) + 2 * max_partial;
  freemem = (mix_mem = freemem) + 2 * max_partial;
  freemem = (state_mem = freemem) + 2 * max_partial;
  
  in_fft_mem = _in_fft_mem;
  out_fft_mem = _out_fft_mem;
  
  freemem
);

function string_init(_fft_size, _fft_interval)
local()
instance(
  max_partial, ticker,
  bin_mem, coeff_mem, mix_mem, state_mem,
  fft_idx, fft_size, fft_interval
)
global()
(
  memset(bin_mem, 0, 2 * max_partial);
  memset(coeff_mem, 0, 2 * max_partial);
  memset(mix_mem, 0, 2 * max_partial);
  memset(state_mem, 0, 2 * max_partial);
  
  ticker = 0;
  fft_idx = 0;
  fft_size = _fft_size;
  fft_interval = _fft_interval;
);

function set_pars_stft_basic(f_0)
global(soundboard_factor, srate, model, legacy_gain)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, max_bin, norm_factor)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials,
  base_damp, f_damp, inharm, rel_position, max_partial,
)
(
  norm_factor = calc_base_gain(f_0);
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
    
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
    
  k = 1;
  k_inc = 1 + model;
  idx = 0;
  num_partials = 0;
  max_bin = (2 * fft_size - 2);
  loop(partials,
    f_k = f_0 * k * sqrt(1 + inharm * (k-1) * (k-1));
    omega_k = 2.0 * $pi * f_k;
    advance = omega_k * irate;
    bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
    
      bin_mem[num_partials] = bin;
      damp = exp(- (base_damp + f_damp * omega_k) * irate);
        
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
          
      mix_mem[num_partials] = norm_factor * sin(k * $pi * rel_position) * 100 * (k * soundboard_factor) / f_k;
      num_partials += 1; idx += 2;
    );
    k += k_inc;
  );
);


function set_pars_stft_messy(f_0)
global(soundboard_factor, srate, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin, norm_factor)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials,
  base_damp, f_damp, inharm, rel_position, max_partial,
)
(
  norm_factor = calc_base_gain(f_0);
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  offset = 3;
  max_bin = (2 * fft_size - 2);
  loop(partials,
    loop(2,
      offset = 3 - offset;
      f_k = f_0 * k * sqrt(1 + inharm * (k-1) * (k-1)) + offset * (1 + .05 * k * k) * (0.1 + rel_position);
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * irate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        (bin != bin_mem[num_partials]) ? (
          state_mem[idx] *= -1;
          state_mem[idx + 1] *= -1;
        );
      
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + f_damp * omega_k * (1 + f_k / 1000)) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = 0.5 * norm_factor * ((2 * floor(k / 2) != floor(k)) + 0.08) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
    );
    k += 1;
  );
);

function set_pars_stft_beam(f_0, clamped)
global(soundboard_factor, srate, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, norm_factor)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials,
  base_damp, f_damp, inharm, rel_position, max_partial,
)
(
  norm_factor = calc_base_gain(f_0);
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  max_bin = (2 * fft_size - 2);
  loop(partials,
    clamped ? (
      (k == 1) ? (
        f_k = f_0 * 0.59686420;
      ) : ( k == 2 ) ? (
        f_k = f_0 * 1.49417560;
      ) : ( k == 3 ) ? (
        f_k = f_0 * 2.50024690;
      ) : ( k == 4 ) ? (
        f_k = f_0 * 3.49998930;
      ) : ( 
        f_k = f_0 * (k - 0.5);
      );
    ) : (
      (k == 1) ? (
        f_k = f_0 * 1.5056187;
      ) : ( k == 2 ) ? (
        f_k = f_0 * 2.4997527;
      ) : ( k == 3 ) ? (
        f_k = f_0 * 3.5000107;
      ) : ( 
        f_k = f_0 * (k + 0.5);
      );
    );
    f_k *= (1 + inharm * k);
    omega_k = 2.0 * $pi * f_k;
    advance = omega_k * irate;
    bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
    
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
    
      bin_mem[num_partials] = bin;
      damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
      
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
      
      mix_mem[num_partials] = norm_factor * sin(k * $pi * rel_position) * 100 * (k * soundboard_factor) / f_k;
      num_partials += 1; idx += 2;
    );
    k += 1;
  );
);


function set_pars_stft_marimba(f_0)
global(soundboard_factor, srate, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp, norm_factor)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials,
  base_damp, f_damp, inharm, rel_position, max_partial
)
(
  norm_factor = calc_base_gain(f_0);
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  max_bin = (2 * fft_size - 2);
  loop(partials,
    camp = 1;
    (k < 9) ? (
      (k == 1) ? (
        f_k = f_0;
      ) : ( k == 2 ) ? (
        f_k = f_0 * 1.911076; // Torsional
        camp = 0.04 + 0.2 * rel_position;
      ) : ( k == 3 ) ? (
        f_k = f_0 * 4;
      ) : ( k == 4 ) ? (
        f_k = f_0 * 10.25;
      ) : ( k == 5 ) ? (
        f_k = f_0 * 14.2511700468; // Torsional
        camp = 0.04 + 0.3 * rel_position;
      ) : ( k == 6 ) ? (
        f_k = f_0 * 17.745709828; // Torsional
        camp = 0.04 + 0.3 * rel_position;
      ) : ( k == 7 ) ? (
        f_k = f_0 * 19;
      ) : ( k == 8 ) ? (
        f_k = f_0 * 24.352574; // Torsional
        camp = 0.04 + 0.2 * rel_position;
      );
    ) : ( 
      f_k = f_0 * k * 2;
      camp = 0.09;
    );
    f_k *= sqrt((1 + inharm * k * k));
    omega_k = 2.0 * $pi * f_k;
    advance = omega_k * irate;
    bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
    
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
    
      bin_mem[num_partials] = bin;
      damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
      
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
      
      mix_mem[num_partials] = norm_factor * camp * 100 * (k * soundboard_factor) / f_k;
      num_partials += 1; idx += 2;
    );
    k += 1;
  );
);

function set_pars_stft_raw(f_0)
global(soundboard_factor, Adivfs, srate, model,
       rel_position, base_damp, f_damp, inharm)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem,
  fft_size, fft_interval, num_partials,
  new_freq, new_damp, new_amp, max_partial,
  /*base_damp, f_damp, inharm, rel_position,*/
)
(
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  offset = 3;
  max_bin = (2 * fft_size - 2);
  
  // TODO: investigate a better way than globals for this
  // This makes me weep ;_____;
  rel_position = this.rel_position;
  base_damp = this.base_damp;
  f_damp = this.f_damp;
  inharm = this.inharm;
  
  loop(partials,
    this.partial_func(f_0, k);
    omega_k = 2.0 * $pi * new_freq;
    advance = omega_k * irate;
    bin = 2 * floor((new_freq / srate) * (2 * fft_size) + 0.5);
      
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
    
      bin_mem[num_partials] = bin;
      damp = exp(-new_damp * irate);
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
      mix_mem[num_partials] = Adivfs * new_amp;
      num_partials += 1; idx += 2;
    );
    
    k += 1;
  );
);

function set_pars_stft_from_memory(f_0)
global(
  soundboard_factor, Adivfs, srate, model,
  custom_partial_mem, MAX_CUSTOM_PARTIALS,
  freq_damp, inharmonic, // Sliders
)
local(
  idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin, relative_freq

  // Memory locations
  m_freq_relative, m_freq_abs, m_decay, m_amplitude,
  m_freq_relative2, m_freq_abs2, m_decay2, m_amplitude2,

  x, xsq, ptr,
  inharm_01, damp_01, // Mapped to [0 - 1]
  new_freq, new_damp, new_amp,
)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem,
  fft_size, fft_interval, num_partials, max_partial,
  rel_position,
)
(
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  offset = 3;
  max_bin = (2 * fft_size - 2);
  
  /* Unpack my data */
  ptr = custom_partial_mem;
  ptr = (m_freq_relative = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_freq_relative2 = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_freq_abs = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_freq_abs2 = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_decay = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_decay2 = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_amplitude = ptr) + MAX_CUSTOM_PARTIALS;
  ptr = (m_amplitude2 = ptr) + MAX_CUSTOM_PARTIALS;
  
  // Sorry devs who see this. Mistakes of the past ;_;
  inharm_01 = 0.25 * inharmonic + 1; // inharmonic - Value between -4 and 0 (linearly mapped) => [0, 1]
  damp_01 = 0.2 * freq_damp + 1.2; // freq_damp - Value between -6 and -1 (linearly mapped) => [0, 1]
  
  loop(partials,
    // Sensitivity feels better when mapping nonlinearly
    x = m_freq_relative[k - 1] * (1.0 - inharm_01) + m_freq_relative2[k - 1] * inharm_01;
    xsq = x * x; relative_freq = sign(x) * (3 * xsq - 2 * xsq * abs(x));
    
    new_freq = f_0 * (k + relative_freq) + m_freq_abs[k - 1] * (1.0 - inharm_01) + m_freq_abs2[k - 1] * inharm_01;
    new_damp = - ((m_decay[k - 1] * (1.0 - damp_01) + m_decay2[k - 1] * damp_01) - 1);
    new_amp = m_amplitude[k - 1] * (1.0 - rel_position) + m_amplitude2[k - 1] * rel_position;
    new_amp = new_amp > -71.999 ? pow(10, new_amp / 20) : 0;
    
    omega_k = 2.0 * $pi * new_freq;
    advance = omega_k * irate;
    bin = 2 * floor((new_freq / srate) * (2 * fft_size) + 0.5);
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
    
      bin_mem[num_partials] = bin;
      damp = exp(-new_damp * irate);
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
      mix_mem[num_partials] = Adivfs * new_amp;
      num_partials += 1; idx += 2;
    );
    
    k += 1;
  );
  k
);

function _stft_rot_phase(bin_diff, idx)
local(re, im)
global(phase_jump, rerot, imrot, bdiff)
instance(fft_interval, fft_size, state_mem)
(
  //phase_jump = 2.0 * $pi * 0.5 * bin_diff * fft_interval / fft_size;
  bdiff = max(abs(bin_diff), 0.8*bdiff);
  phase_jump = 0.5 * $pi * bin_diff;
  
  rerot = cos(phase_jump);
  imrot = sin(phase_jump);
  
  re = state_mem[idx];
  im = state_mem[idx + 1];
  
  state_mem[idx] = re * rerot - im * imrot;
  state_mem[idx + 1] = re * imrot + im * rerot;
  
  //state_mem[idx] *= -1;
  //state_mem[idx + 1] *= -1;
);

function set_pars_stft_from_memory_b(f_0)
global(
  soundboard_factor, Adivfs, srate, model,
  custom_partial_mem, MAX_CUSTOM_PARTIALS,
  freq_damp, inharmonic, // Sliders
)
local(
  idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin, relative_freq

  // Memory locations
  m_freq_relative, m_freq_abs, m_decay, m_amplitude,

  x, xsq, ptr,
  inharm_01, damp_01, // Mapped to [0 - 1]
  new_freq, new_damp, new_amp,
)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, inharm,
  fft_size, fft_interval, num_partials, max_partial,
  rel_position, base_damp, f_damp,
)
(
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  offset = 3;
  max_bin = (2 * fft_size - 2);
  
  /* Unpack my data */
  ptr = custom_partial_mem;
  ptr = (m_freq_relative = ptr) + 2 * MAX_CUSTOM_PARTIALS;
  ptr = (m_freq_abs = ptr) + 2 * MAX_CUSTOM_PARTIALS;
  ptr = (m_decay = ptr) + 2 * MAX_CUSTOM_PARTIALS;
  ptr = (m_amplitude = ptr) + 2 * MAX_CUSTOM_PARTIALS;
  
  loop(partials,
    // Sensitivity feels better when mapping nonlinearly
    x = m_freq_relative[k - 1];
    xsq = x * x;
    relative_freq = sign(x) * (3 * xsq - 2 * xsq * abs(x));
    
    new_freq = f_0 * sqrt((1 + inharm * k * k)) * (k + relative_freq) + m_freq_abs[k - 1];
    new_damp = - (m_decay[k - 1] - 1);
    new_amp = m_amplitude[k - 1];
    new_amp = new_amp > -71.999 ? pow(10, new_amp / 20) : 0;
    
    omega_k = 2.0 * $pi * new_freq;
    advance = omega_k * irate;
    bin = 2 * floor((new_freq / srate) * (2 * fft_size) + 0.5);
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
    
      bin_mem[num_partials] = bin;
      damp = exp(- (new_damp + base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
      
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
      mix_mem[num_partials] = Adivfs * new_amp * sin(k * $pi * rel_position);
      num_partials += 1; idx += 2;
    );
    
    k += 1;
  );
  
  k
);

function colormodel(x)
global(model, gfx_a)
local(frac)
(
  // Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice (male),Voice (female)
  model == 0 ? (
    // Metal
    x = sqrt(x); gfx_set(0.2 + 0.67 * x, 0.2 + 0.3 * x, 0.2 + 0.8 * (1 - x), 0.8);
  ) : ( model == 1 ) ? (
    // Tube
    x = sqrt(x); gfx_set(0.3 + 0.67 * x, 0.5 - 0.3 * x, 0.2 + 0.8 * (1 - x), 0.8);
  ) : ( model == 2 ) ? (
    // Beating
    x = sqrt(x); gfx_set(1.0 * x, 0.84 * x + 0.44, 1.0 - x, 0.8);
  ) : ( model == 9 ) ? (
    // Female vocal
    x = sqrt(x);
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.4745098039215686 + frac * 0.22745098039215683, 0.27058823529411763 + frac * 0.0, 0.8 + frac * -0.07058823529411773); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.7019607843137254 + frac * 0.23921568627450984, 0.27058823529411763 + frac * 0.14901960784313728, 0.7294117647058823 + frac * -0.14117647058823524); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.9411764705882353 + frac * 0.05882352941176472, 0.4196078431372549 + frac * 0.23529411764705882, 0.5882352941176471 + frac * -0.01176470588235301); )
    : ( frac = (4 * x - 3); gfx_set(1.0 + frac * 0.0, 0.6549019607843137 + frac * 0.10588235294117643, 0.5764705882352941 + frac * 0.05490196078431375); )
  ) : ( model == 4 ) ? (
    // Beam closed
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.34901960784313724 + frac * 0.20000000000000007, 0.403921568627451 + frac * -0.09019607843137256, 1.0 + frac * 0.0); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.5490196078431373 + frac * 0.4509803921568627, 0.3137254901960784 + frac * -0.07450980392156861, 1.0 + frac * -0.21568627450980393); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(1.0 + frac * 0.0, 0.23921568627450981 + frac * 0.10980392156862742, 0.7843137254901961 + frac * -0.6196078431372549); )
    : ( frac = (4 * x - 3); gfx_set(1.0 + frac * 0.0, 0.34901960784313724 + frac * 0.34509803921568627, 0.16470588235294117 + frac * -0.03529411764705881); )
  ) : ( model == 5 ) ? (
    // Membrane
    x = sqrt(x); gfx_set(10.2 + 0.97 * x, 0.5 + 0.97 * x, 0.2 + 0.97 * x, 0.8);
  ) : ( model == 6 ) ? (
    // Marimba
    x = sqrt(x);
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.596078431372549 + frac * 0.039215686274509776, 0.38823529411764707 + frac * 0.0549019607843137, 0.23137254901960785 + frac * 0.0549019607843137); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.6352941176470588 + frac * 0.08235294117647063, 0.44313725490196076 + frac * 0.12549019607843137, 0.28627450980392155 + frac * 0.1294117647058824); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.7176470588235294 + frac * 0.08235294117647063, 0.5686274509803921 + frac * 0.1215686274509804, 0.41568627450980394 + frac * 0.1411764705882353); )
    : ( frac = (4 * x - 3); gfx_set(0.8 + frac * 0.039215686274509776, 0.6901960784313725 + frac * 0.05882352941176472, 0.5568627450980392 + frac * 0.06666666666666665); )
  ) : ( model == 3 ) ? (
    // Beam open
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(1.0 + frac * 0.0, 0.2 + frac * 0.17254901960784313, 0.2 + frac * 0.023529411764705882); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(1.0 + frac * -0.0039215686274509665, 0.37254901960784315 + frac * 0.25098039215686274, 0.2235294117647059 + frac * 0.1372549019607843); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.996078431372549 + frac * -0.0039215686274509665, 0.6235294117647059 + frac * 0.19215686274509802, 0.3607843137254902 + frac * 0.23529411764705882); )
    : ( frac = (4 * x - 3); gfx_set(0.9921568627450981 + frac * 0.007843137254901933, 0.8156862745098039 + frac * 0.07843137254901966, 0.596078431372549 + frac * 0.12549019607843137); )
  ) : ( model == 8 ) ? (
    x *= x;
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.2784313725490196 + frac * -0.2784313725490196, 0.4823529411764706 + frac * 0.0901960784313725, 1.0 + frac * 0.0); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.0 + frac * 0.0, 0.5725490196078431 + frac * 0.14117647058823535, 1.0 + frac * -0.0117647058823529); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.0 + frac * 0.0, 0.7137254901960784 + frac * 0.09411764705882353, 0.9882352941176471 + frac * -0.1725490196078432); )
    : ( frac = (4 * x - 3); gfx_set(0.0 + frac * 0.0, 0.807843137254902 + frac * 0.03137254901960784, 0.8156862745098039 + frac * -0.07450980392156858); )
  ) : ( model == 7 ) ? (
    // Pan
    (x < 0.5) ? ( frac = (2 * x - 0); gfx_set(0.32941176470588235 + frac * -0.20392156862745098, 0.2 + frac * 0.5411764705882354, 1.0 + frac * 0.0); )
    : ( frac = (2 * x - 1); gfx_set(0.12549019607843137 + frac * 0.5215686274509804, 0.7411764705882353 + frac * 0.2549019607843137, 1.0 + frac * -0.20392156862745103); )
  ) : ( model == 10 ) ? (
    x = sqrt(x);
    (x < 1.0) ? ( frac = (1 * x - 0); gfx_set(0.1568627450980392 + frac * 0.11372549019607842, 0.23529411764705882 + frac * 0.39999999999999997, 0.5254901960784314 + frac * -0.24705882352941178); )
  ) : ( model == 11 ) ? (
    x = sqrt(x); gfx_set(0.3 + 0.67 * x, 0.5 - 0.3 * x, 0.2 + 0.8 * (1 - x), 0.8);
  ) : ( model == 12 ) ? (
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.34901960784313724 + frac * 0.20000000000000007, 0.403921568627451 + frac * -0.09019607843137256, 1.0 + frac * 0.0); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.5490196078431373 + frac * 0.4509803921568627, 0.3137254901960784 + frac * -0.07450980392156861, 1.0 + frac * -0.21568627450980393); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(1.0 + frac * 0.0, 0.23921568627450981 + frac * 0.10980392156862742, 0.7843137254901961 + frac * -0.6196078431372549); )
    : ( frac = (4 * x - 3); gfx_set(1.0 + frac * 0.0, 0.34901960784313724 + frac * 0.34509803921568627, 0.16470588235294117 + frac * -0.03529411764705881); )
  );
);

function set_pars_stft_pan(f_0)
global(soundboard_factor, srate, model, bessel_roots)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp, norm_factor)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials
  base_damp, f_damp, inharm, rel_position, max_partial
)
(
  norm_factor = calc_base_gain(f_0);
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  max_bin = (2 * fft_size - 2);
  loop(partials,
    camp = 1;
    (k < 11) ? (
      (k == 1) ? (
        f_k = f_0;
        camp = 3.5 - 1.0 * rel_position;
      ) : ( k == 2 ) ? (
        f_k = f_0 * 1.19672275218;
        camp = 0.05 + 0.26 * rel_position;
      ) : ( k == 3 ) ? (
        f_k = f_0 * 0.74899885;
        camp = 0.05 + 0.18 * rel_position;
      ) : ( k == 4 ) ? (
        f_k = f_0 * 1.57885;
        camp = 0.01 + 0.03 * rel_position;
        camp *= 0;
      ) : ( k == 5 ) ? (
        f_k = f_0 * 2.000333953889411;
        camp = 0.025
      ) : ( k == 6 ) ? (
        f_k = f_0 * 2.000333953889411 + 3.34;
        camp = 0.025;
      ) : ( k == 7 ) ? (
        f_k = f_0 * 2.23426319696;
        camp = 0.005 * rel_position;
      ) : ( k == 8 ) ? (
        f_k = f_0 * 3.0029642446;
        camp = 0.05;
      ) : ( k == 9 ) ? (
        f_k = f_0 * 3.5708;
        camp = 0.003 * rel_position;
      ) : ( k == 10 ) ? (
        f_k = f_0 * 3.997778188;
        camp = 0.003 * rel_position;
      );
    ) : ( 
      f_k = f_0 * (k + 2) * 0.5;
      camp = 0.0005;
    );
    f_k *= sqrt((1 + (inharm - 0.0001) * k * k));
    camp *= 0.33;
    omega_k = 2.0 * $pi * f_k;
    advance = omega_k * irate;
    bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
    
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
      
      bin_mem[num_partials] = bin;
      damp = exp(- (base_damp + (5/k) + (f_damp / 1000) * omega_k * omega_k) * irate);
      
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
        
      mix_mem[num_partials] = norm_factor * camp * 100 * (k * soundboard_factor) / f_k;
      num_partials += 1; idx += 2;
    );
    k += 1;
  );
);


function set_pars_stft_drum(f_0)
global(soundboard_factor, srate, model, bessel_roots)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, norm_factor)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials,
  base_damp, f_damp, inharm, rel_position, max_partial
)
(
  norm_factor = calc_base_gain(f_0);
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  loop(198,
    f_k = f_0 * bessel_roots[k - 1] * (1 + inharm * k * k);
    omega_k = 2.0 * $pi * f_k;
    advance = omega_k * irate;
    bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
    
    bin < (2 * fft_size - 2) ? (
      bin_mem[num_partials] = bin;
      damp = exp(- (base_damp + (10/k) + (f_damp / 1000) * (omega_k * omega_k)) * irate);
      
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
        
      mix_mem[num_partials] = norm_factor * sin(k * $pi * rel_position) * 100 * (k * soundboard_factor) / f_k;
      num_partials += 1; idx += 2;
    );
    k += 1;
  );
);

function set_pars_stft_vowel(f_0, vowel)
global(soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp, tmp, spectrum_a, spectrum_b, spectrum_idx, spectrum_frac)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, num_partials
  base_damp, f_damp, inharm, rel_position, max_partial,
)
(
  memset(coeff_mem, 0, 2 * fft_size);
  memset(mix_mem, 0, 2 * max_partial);
  
  partials = min(floor(0.5 * srate / f_0), max_partial);
  irate = fft_interval / srate;
  
  spectrum_idx = floor(rel_position * 7);
  spectrum_frac = rel_position * 7 - spectrum_idx;
  spectrum_a = vowel + spectrum_idx * 22050;
  spectrum_b = spectrum_a + 22050;
  
  k = 1;
  idx = 0;
  num_partials = 0;
  max_bin = (2 * fft_size - 2);
  loop(partials,
    f_k = f_0 * k * sqrt((1 + (inharm - 0.0001) * k * k));
    camp = f_k < 22050 ? (
      tmp = f_k - floor(f_k);
      (spectrum_a[f_k] * (1.0 - tmp) + spectrum_a[f_k + 1] * tmp) * (1 - spectrum_frac) +
      (spectrum_b[f_k] * (1.0 - tmp) + spectrum_b[f_k + 1] * tmp) * spectrum_frac
    ) : 0;
    
    omega_k = 2.0 * $pi * f_k;
    advance = omega_k * fft_interval / srate;
    bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
    
    bin < max_bin ? (
      (bin != bin_mem[num_partials]) ? (
        state_mem[idx] *= -1;
        state_mem[idx + 1] *= -1;
      );
      
      bin_mem[num_partials] = bin;
      damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
      
      coeff_mem[idx] = cos(advance) * damp;
      coeff_mem[idx + 1] = sin(advance) * damp;
      
      mix_mem[num_partials] = Adivfs * camp;// * 100 * (k * soundboard_factor) / f_k;
      num_partials += 1; idx += 2;
    );
    k += 1;
  );
);

function set_pars_stft(f_0)
local()
global(model, vowel, female_vowel)
instance(used_partials)
(
  (model < 2) ? (
    this.set_pars_stft_basic(f_0);
  ) : (model == 2) ? (
    this.set_pars_stft_messy(f_0);
  ) : (model == 3) ? (
    this.set_pars_stft_beam(f_0, 0);
  ) : (model == 4) ? (
    this.set_pars_stft_beam(f_0, 1);
  ) : (model == 5) ? (
    this.set_pars_stft_drum(f_0);
  ) : (model == 6) ? (
    this.set_pars_stft_marimba(f_0);
  ) : (model == 7) ? (
    this.set_pars_stft_pan(f_0);
  ) : (model == 8) ? (
    this.set_pars_stft_vowel(f_0, vowel);
  ) : (model == 9) ? (
    this.set_pars_stft_vowel(f_0, female_vowel);
  ) : (model == 10) ? (
    this.set_pars_stft_raw(f_0);
  ) : (model == 11) ? (
    used_partials = this.set_pars_stft_from_memory(f_0);
  ) : (model == 12) ? (
    used_partials = this.set_pars_stft_from_memory_b(f_0);
  );
);

function process_block(in_fft_mem, out_fft_mem, active, env_level_in, env_level_out)
instance(coeff_mem, mix_mem, state_mem, bin_mem, num_partials)
global(srate, stft_mem.fft_size)
local(ix, tix, bin)
(
  // Update the resonators
  convolve_c(state_mem, coeff_mem, num_partials + 1);
  
  ix = 0; tix = 0;
  
  // This is a fudge factor added later. In reality, the amplitudes should have 
  // taken into account the fft bin width.
  env_level_in *= (stft_mem.fft_size / 64) * (stft_mem.fft_size / 64);
  
  active ? (
    loop(num_partials,
      bin = bin_mem[ix];
      state_mem[tix] += mix_mem[ix] * in_fft_mem[bin] * env_level_in;
      state_mem[tix + 1] += mix_mem[ix] * in_fft_mem[bin + 1] * env_level_in;
      
      ix += 1; tix += 2;
    );
  );

  ix = 0; tix = 0;
  loop(num_partials,
    bin = bin_mem[ix];
    out_fft_mem[bin] += state_mem[tix] * env_level_out;
    out_fft_mem[bin + 1] += state_mem[tix + 1] * env_level_out;
    ix += 1; tix += 2;
  );
);


function read_block(input_mem, input_idx, fft_loc, window_ptr, len, buffer_size)
local(fft_ptr)
instance()
global()
(
  input_idx -= len;
  fft_ptr = fft_loc;
  input_idx < 0 ? input_idx += buffer_size;
  loop(len,
    input_idx == buffer_size ? input_idx = 0;
    fft_ptr[] = input_mem[input_idx] * window_ptr[];
    window_ptr += 1;
    input_idx += 1;
    fft_ptr += 1;
  );
  
  fft_real(fft_loc, len);
  fft_permute(fft_loc, len / 2);
);


function write_block(output_mem, output_idx, fft_ptr, window_ptr, len, buffer_size)
local()
instance()
global()
(
  fft_ptr[0] += fft_ptr[1];
  //fft_ptr[0] = sqrt(fft_ptr[0] * fft_ptr[0] + fft_ptr[1] * fft_ptr[1]);
  fft_ptr[1] = 0; // Kill Nyquist
  fft_ipermute(fft_ptr, len / 2);
  ifft_real(fft_ptr, len);

  loop(len,
    (output_idx == buffer_size) ? output_idx = 0;
    output_mem[output_idx] += fft_ptr[] * window_ptr[];
    fft_ptr += 1;
    window_ptr += 1;
    output_idx += 1;
  );
);


function read_stft(f_h)
local()
global()
instance(
  fft_idx, fft_interval,
  input_mem, input_idx,
  in_fft_mem, out_fft_mem, window_mem,
  fft_size, buffer_size
)
(
  input_idx == buffer_size ? input_idx = 0;
  input_mem[input_idx] = f_h;
  
  (fft_idx == fft_interval) ? (
    read_block(input_mem, input_idx, in_fft_mem, window_mem, fft_size * 2, buffer_size);
    memset(out_fft_mem, 0, fft_size * 2);
  );
  
  input_idx += 1;
);

function write_stft()
local()
global()
instance(
  f_hn, f_b,
  fft_idx, fft_interval,
  output_mem, output_idx,
  out_fft_mem, window_mem,
  fft_size, buffer_size,
)
(
  (fft_idx == fft_interval) ? (
    write_block(output_mem, output_idx, out_fft_mem, window_mem, fft_size * 2, buffer_size);
    fft_idx = 0;
  );
  
  output_idx == buffer_size ? output_idx = 0;
  f_hn = f_b = output_mem[output_idx];
  output_mem[output_idx] = 0;
  
  fft_idx += 1;
  output_idx += 1;
);


function eval_string_stft(env_level_in, env_level_out, on)
instance(
  fft_idx,
  in_fft_mem, out_fft_mem,
  fft_interval
)
global()
local()
(
  (fft_idx == fft_interval) ? (    
    this.process_block(in_fft_mem, out_fft_mem, on, env_level_in, env_level_out);
    fft_idx = 0;
  );
  
  fft_idx += 1;
);

function draw_stft(x, y, w, h)
instance(mix_mem, bin_mem, coeff_mem, state_mem, num_partials, fft_size, ticker,
         rel_position, base_damp, f_damp, inharm)
local(s, ds, bin, dx, ix, tix, cx, cy, bin_width, yc, decay, offs, ix2, dz, amp_factor)
global(gfx_x, gfx_y, gfx_a, srate, display_log,
       relative_position, damp, freq_damp, inharmonic, legacy_gain)
(
  ticker = 5000;
  
  rel_position = relative_position;
  base_damp = 10^damp;
  f_damp = 10^freq_damp;
  inharm = 10^inharmonic;
  
  this.set_pars_stft(440 / 2 / 2);
  memset(state_mem, 0, 2 * fft_size);
  ix = 0; tix = 0;
  loop(num_partials,
    bin = bin_mem[ix];
    state_mem[bin] = max(state_mem[bin], sqrt(coeff_mem[tix] * coeff_mem[tix] + coeff_mem[tix + 1] * coeff_mem[tix + 1]));
    state_mem[bin + 1] = state_mem[bin + 1] + mix_mem[ix];
    ix += 1; tix += 2;
  );
  
  gfx_set(0.3, 0.2, 0.3, 1);
  ix = 0;
  dz = 3;
  loop(10,
    gfx_a *= 0.80;
    gfx_line(x + ix, y + h - ix, x + w + ix, y + h - ix);
    ix += 2 * dz;
  );
  
  cx = x;
  cy = y;
  bin_width = 2;
  ix = 0;
  dx = w / fft_size;
  ds = 1 / fft_size;
  s = 0;

  // For logarithmic display, we go from 20 - srate
  //   exp(log(20) + x * (log(srate) - log(20)) * fft_size / srate
  // (fft_size / srate)* (log(srate) - log(20)) * exp(log(20) + x(log(srate) - log(20))

  amp_factor = (200000 - 100000 * legacy_gain) * h;
  loop(fft_size,
    colormodel(s);
    s += ds;
    decay = state_mem[ix];
    yc = amp_factor * state_mem[ix + 1];
    gfx_rect(cx, cy + h - yc, bin_width, yc);
    
    ix2 = 0;
    gfx_a = 0.57;
    loop(50,
      gfx_a *= 0.95;
      yc *= decay;
      gfx_rect(cx + ix2, cy + h - yc - 0.5 * ix2, bin_width, yc);
      ix2 += dz;
    );
    
    //yc *= state_mem[ix];
    //gfx_rect(cx, cy + h - yc, bin_width, yc);
    display_log ? (
      cx = x + w * log((ix + 0.5) / 2) / log(fft_size);
    ) : (
      cx += dx;
    );
    ix += 2;
  );

  1
);
 
