@init
function fft_mem(freemem, _fft_size)
instance(fft_size
         overlap_factor,
         fft_interval,
         in_fft_mem, out_fft_mem, window_mem,
         input_mem, output_mem,
         input_idx, fft_idx, output_idx,
         fft_scaling_factor,
         buffer_size)
global()
local(gain, i, r, a0, a1, a2, a3, a4)
(
  fft_size = _fft_size;
  buffer_size = 65536;
  
  /* Make sure we start on a boundary */
  freemem = ceil(freemem / 65536) * 65536;
  freemem = (in_fft_mem = freemem) + 2 * fft_size;
  memset(in_fft_mem, 0, 2 * fft_size);
  freemem = (out_fft_mem = freemem) + 2 * fft_size;
  memset(out_fft_mem, 0, 2 * fft_size);
  freemem = (window_mem = freemem) + 2 * fft_size;
  memset(window_mem, 0, 2 * fft_size);
  freemem = (input_mem = freemem) + buffer_size;
  memset(input_mem, 0, buffer_size);
  freemem = (output_mem = freemem) + buffer_size;
  memset(output_mem, 0, buffer_size);
  
  // Hann
  a0 = 0.5;
  a1 = 0.5;
  a2 = a3 = a4 = 0;
  overlap_factor = fft_size / ceil(fft_size/4);
  gain = 5 / 0.375;//0.5 * 0.55;
  
  // Blackmann-Harris
  a0 = 0.35875;
  a1 = 0.48829;
  a2 = 0.14128;
  a3 = 0.01168;
  a4 = 0;
  overlap_factor = fft_size / ceil(fft_size/3); // Actually attained overlap with a target of 3
//  gain = 0.25 / 0.35875;
  gain = 5 / 0.25796335495;
  
  fft_idx = output_idx = input_idx = 0;
  fft_interval = fft_size / overlap_factor;
  fft_scaling_factor = gain / overlap_factor / overlap_factor / fft_size / fft_size;
    
  i = 0;
  loop(2 * fft_size,
    r = (i + 0.5) / (2 * fft_size);
    window_mem[i] = sqrt(fft_scaling_factor) * (a0 - a1 * cos(2 * $pi * r) + a2 * cos(4 * $pi * r) - a3 * cos(6 * $pi * r) + a4 * cos(8 * $pi * r));
    i += 1;
  );
  
  freemem
);

function string_mem(freemem, _fft_size, _fft_interval, _in_fft_mem, _out_fft_mem)
instance(
  max_partial,
  bin_mem, coeff_mem, mix_mem, state_mem,
  fft_size, fft_interval,
  in_fft_mem, out_fft_mem,
  ticker,
  fft_idx,
)
local()
global()
(
  // Allocate memory for this string, note that in and out fft_mem have to be preallocated.
  ticker = 0;
  max_partial = 1024;
  freemem = (bin_mem = freemem) + 2 * max_partial;
  memset(bin_mem, 0, 2 * max_partial);
  freemem = (coeff_mem = freemem) + 2 * max_partial;
  memset(coeff_mem, 0, 2 * max_partial);
  freemem = (mix_mem = freemem) + 2 * max_partial;
  memset(mix_mem, 0, 2 * max_partial);
  freemem = (state_mem = freemem) + 2 * max_partial;
  memset(state_mem, 0, 2 * max_partial);
  
  fft_idx = 0;
  fft_size = _fft_size;
  fft_interval = _fft_interval;
  in_fft_mem = _in_fft_mem;
  out_fft_mem = _out_fft_mem;
  
  freemem
);

function set_pars_stft_basic(f_0)
global(soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, max_bin)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials,
  base_damp, f_damp, inharm, rel_position,
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    k_inc = 1 + model;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      f_k = f_0 * k * sqrt(1 + inharm * (k-1) * (k-1));
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * irate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + f_damp * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * sin(k * $pi * rel_position) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += k_inc;
    );
    ticker = 0;
  );
);


function set_pars_stft_messy(f_0)
global(soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials,
  base_damp, f_damp, inharm, rel_position
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    offset = 3;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      loop(2,
        offset = 3 - offset;
        f_k = f_0 * k * sqrt(1 + inharm * (k-1) * (k-1)) + offset * (1 + .05 * k * k) * (0.1 + rel_position);
        omega_k = 2.0 * $pi * f_k;
        advance = omega_k * irate;
        bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
        
        bin < max_bin ? (
          bin_mem[num_partials] = bin;
          damp = exp(- (base_damp + f_damp * omega_k * (1 + f_k / 1000)) * irate);
          
          coeff_mem[idx] = cos(advance) * damp;
          coeff_mem[idx + 1] = sin(advance) * damp;
            
          mix_mem[num_partials] = 0.5 * Adivfs * ((2 * floor(k / 2) != floor(k)) + 0.08) * 100 * (k * soundboard_factor) / f_k;
          num_partials += 1; idx += 2;
        );
      );
      k += 1;
    );
    ticker = 0;
  );
);

function set_pars_stft_beam(f_0, clamped)
global(soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials,
  base_damp, f_damp, inharm, rel_position,
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      clamped ? (
        (k == 1) ? (
          f_k = f_0 * 0.59686420;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 1.49417560;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 2.50024690;
        ) : ( k == 4 ) ? (
          f_k = f_0 * 3.49998930;
        ) : ( 
          f_k = f_0 * (k - 0.5);
        );
      ) : (
        (k == 1) ? (
          f_k = f_0 * 1.5056187;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 2.4997527;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 3.5000107;
        ) : ( 
          f_k = f_0 * (k + 0.5);
        );
      );
      f_k *= (1 + inharm * k);
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * irate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * sin(k * $pi * rel_position) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);


function set_pars_stft_marimba(f_0)
global(soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials,
  base_damp, f_damp, inharm, rel_position
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      camp = 1;
      (k < 9) ? (
        (k == 1) ? (
          f_k = f_0;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 1.911076; // Torsional
          camp = 0.04 + 0.2 * rel_position;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 4;
        ) : ( k == 4 ) ? (
          f_k = f_0 * 10.25;
        ) : ( k == 5 ) ? (
          f_k = f_0 * 14.2511700468; // Torsional
          camp = 0.04 + 0.3 * rel_position;
        ) : ( k == 6 ) ? (
          f_k = f_0 * 17.745709828; // Torsional
          camp = 0.04 + 0.3 * rel_position;
        ) : ( k == 7 ) ? (
          f_k = f_0 * 19;
        ) : ( k == 8 ) ? (
          f_k = f_0 * 24.352574; // Torsional
          camp = 0.04 + 0.2 * rel_position;
        );
      ) : ( 
        f_k = f_0 * k * 2;
        camp = 0.09;
      );
      f_k *= sqrt((1 + inharm * k * k));
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * irate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * camp * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);

function set_pars_stft_raw(f_0)
global(soundboard_factor, srate, Adivfs, model,
       rel_position, base_damp, f_damp, inharm)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem,
  fft_size, fft_interval, ticker, num_partials,
  new_freq, new_damp, new_amp,
  /*base_damp, f_damp, inharm, rel_position,*/
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    offset = 3;
    max_bin = (2 * fft_size - 2);
    
    // TODO: investigate a better way than globals for this
    // This makes me weep ;_____;
    rel_position = this.rel_position;
    base_damp = this.base_damp;
    f_damp = this.f_damp;
    inharm = this.inharm;
    
    loop(partials,
      this.partial_func(f_0, k);
      omega_k = 2.0 * $pi * new_freq;
      advance = omega_k * irate;
      bin = 2 * floor((new_freq / srate) * (2 * fft_size) + 0.5);
        
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(-new_damp * irate);
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
        mix_mem[num_partials] = Adivfs * new_amp;
        num_partials += 1; idx += 2;
      );
      
      k += 1;
    );
    ticker = 0;
  );
);


function colormodel(x)
global(model, gfx_a)
local(frac)
(
  // Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice (male),Voice (female)
  model == 0 ? (
    // Metal
    x = sqrt(x); gfx_set(0.2 + 0.67 * x, 0.2 + 0.3 * x, 0.2 + 0.8 * (1 - x), 0.8);
  ) : ( model == 1 ) ? (
    // Tube
    x = sqrt(x); gfx_set(0.3 + 0.67 * x, 0.5 - 0.3 * x, 0.2 + 0.8 * (1 - x), 0.8);
  ) : ( model == 2 ) ? (
    // Beating
    x = sqrt(x); gfx_set(1.0 * x, 0.84 * x + 0.44, 1.0 - x, 0.8);
  ) : ( model == 9 ) ? (
    // Female vocal
    x = sqrt(x);
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.4745098039215686 + frac * 0.22745098039215683, 0.27058823529411763 + frac * 0.0, 0.8 + frac * -0.07058823529411773); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.7019607843137254 + frac * 0.23921568627450984, 0.27058823529411763 + frac * 0.14901960784313728, 0.7294117647058823 + frac * -0.14117647058823524); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.9411764705882353 + frac * 0.05882352941176472, 0.4196078431372549 + frac * 0.23529411764705882, 0.5882352941176471 + frac * -0.01176470588235301); )
    : ( frac = (4 * x - 3); gfx_set(1.0 + frac * 0.0, 0.6549019607843137 + frac * 0.10588235294117643, 0.5764705882352941 + frac * 0.05490196078431375); )
  ) : ( model == 4 ) ? (
    // Beam closed
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.34901960784313724 + frac * 0.20000000000000007, 0.403921568627451 + frac * -0.09019607843137256, 1.0 + frac * 0.0); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.5490196078431373 + frac * 0.4509803921568627, 0.3137254901960784 + frac * -0.07450980392156861, 1.0 + frac * -0.21568627450980393); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(1.0 + frac * 0.0, 0.23921568627450981 + frac * 0.10980392156862742, 0.7843137254901961 + frac * -0.6196078431372549); )
    : ( frac = (4 * x - 3); gfx_set(1.0 + frac * 0.0, 0.34901960784313724 + frac * 0.34509803921568627, 0.16470588235294117 + frac * -0.03529411764705881); )
  ) : ( model == 5 ) ? (
    // Membrane
    x = sqrt(x); gfx_set(10.2 + 0.97 * x, 0.5 + 0.97 * x, 0.2 + 0.97 * x, 0.8);
  ) : ( model == 6 ) ? (
    // Marimba
    x = sqrt(x);
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.596078431372549 + frac * 0.039215686274509776, 0.38823529411764707 + frac * 0.0549019607843137, 0.23137254901960785 + frac * 0.0549019607843137); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.6352941176470588 + frac * 0.08235294117647063, 0.44313725490196076 + frac * 0.12549019607843137, 0.28627450980392155 + frac * 0.1294117647058824); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.7176470588235294 + frac * 0.08235294117647063, 0.5686274509803921 + frac * 0.1215686274509804, 0.41568627450980394 + frac * 0.1411764705882353); )
    : ( frac = (4 * x - 3); gfx_set(0.8 + frac * 0.039215686274509776, 0.6901960784313725 + frac * 0.05882352941176472, 0.5568627450980392 + frac * 0.06666666666666665); )
  ) : ( model == 3 ) ? (
    // Beam open
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(1.0 + frac * 0.0, 0.2 + frac * 0.17254901960784313, 0.2 + frac * 0.023529411764705882); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(1.0 + frac * -0.0039215686274509665, 0.37254901960784315 + frac * 0.25098039215686274, 0.2235294117647059 + frac * 0.1372549019607843); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.996078431372549 + frac * -0.0039215686274509665, 0.6235294117647059 + frac * 0.19215686274509802, 0.3607843137254902 + frac * 0.23529411764705882); )
    : ( frac = (4 * x - 3); gfx_set(0.9921568627450981 + frac * 0.007843137254901933, 0.8156862745098039 + frac * 0.07843137254901966, 0.596078431372549 + frac * 0.12549019607843137); )
  ) : ( model == 8 ) ? (
    x *= x;
    (x < 0.25) ? ( frac = (4 * x - 0); gfx_set(0.2784313725490196 + frac * -0.2784313725490196, 0.4823529411764706 + frac * 0.0901960784313725, 1.0 + frac * 0.0); )
    : (x < 0.5) ? ( frac = (4 * x - 1); gfx_set(0.0 + frac * 0.0, 0.5725490196078431 + frac * 0.14117647058823535, 1.0 + frac * -0.0117647058823529); )
    : (x < 0.75) ? ( frac = (4 * x - 2); gfx_set(0.0 + frac * 0.0, 0.7137254901960784 + frac * 0.09411764705882353, 0.9882352941176471 + frac * -0.1725490196078432); )
    : ( frac = (4 * x - 3); gfx_set(0.0 + frac * 0.0, 0.807843137254902 + frac * 0.03137254901960784, 0.8156862745098039 + frac * -0.07450980392156858); )
  ) : ( model == 7 ) ? (
    // Pan
    (x < 0.5) ? ( frac = (2 * x - 0); gfx_set(0.32941176470588235 + frac * -0.20392156862745098, 0.2 + frac * 0.5411764705882354, 1.0 + frac * 0.0); )
    : ( frac = (2 * x - 1); gfx_set(0.12549019607843137 + frac * 0.5215686274509804, 0.7411764705882353 + frac * 0.2549019607843137, 1.0 + frac * -0.20392156862745103); )
  ) : ( model == 10 ) ? (
    x = sqrt(x);
    (x < 1.0) ? ( frac = (1 * x - 0); gfx_set(0.1568627450980392 + frac * 0.11372549019607842, 0.23529411764705882 + frac * 0.39999999999999997, 0.5254901960784314 + frac * -0.24705882352941178); )
  );
);

function set_pars_stft_pan(f_0)
global(soundboard_factor, srate, Adivfs, model, bessel_roots)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials
  base_damp, f_damp, inharm, rel_position,
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      camp = 1;
      (k < 11) ? (
        (k == 1) ? (
          f_k = f_0;
          camp = 3.5 - 1.0 * rel_position;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 1.19672275218;
          camp = 0.05 + 0.26 * rel_position;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 0.74899885;
          camp = 0.05 + 0.18 * rel_position;
        ) : ( k == 4 ) ? (
          f_k = f_0 * 1.57885;
          camp = 0.01 + 0.03 * rel_position;
          camp *= 0;
        ) : ( k == 5 ) ? (
          f_k = f_0 * 2.000333953889411;
          camp = 0.025
        ) : ( k == 6 ) ? (
          f_k = f_0 * 2.000333953889411 + 3.34;
          camp = 0.025;
        ) : ( k == 7 ) ? (
          f_k = f_0 * 2.23426319696;
          camp = 0.005 * rel_position;
        ) : ( k == 8 ) ? (
          f_k = f_0 * 3.0029642446;
          camp = 0.05;
        ) : ( k == 9 ) ? (
          f_k = f_0 * 3.5708;
          camp = 0.003 * rel_position;
        ) : ( k == 10 ) ? (
          f_k = f_0 * 3.997778188;
          camp = 0.003 * rel_position;
        );
      ) : ( 
        f_k = f_0 * (k + 2) * 0.5;
        camp = 0.0005;
      );
      f_k *= sqrt((1 + (inharm - 0.0001) * k * k));
      camp *= 0.33;
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * irate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (5/k) + (f_damp / 1000) * omega_k * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * camp * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);


function set_pars_stft_drum(f_0)
global(soundboard_factor, srate, Adivfs, model, bessel_roots)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials,
  base_damp, f_damp, inharm, rel_position
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    loop(198,
      f_k = f_0 * bessel_roots[k - 1] * (1 + inharm * k * k);
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * irate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < (2 * fft_size - 2) ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (10/k) + (f_damp / 1000) * (omega_k * omega_k)) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * sin(k * $pi * rel_position) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);

function set_pars_stft_vowel(f_0, vowel)
global(soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp, tmp, spectrum_a, spectrum_b, spectrum_idx, spectrum_frac)
instance(
  bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials
  base_damp, f_damp, inharm, rel_position,
)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    spectrum_idx = floor(rel_position * 7);
    spectrum_frac = rel_position * 7 - spectrum_idx;
    spectrum_a = vowel + spectrum_idx * 22050;
    spectrum_b = spectrum_a + 22050;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      f_k = f_0 * k * sqrt((1 + (inharm - 0.0001) * k * k));
      camp = f_k < 22050 ? (
        tmp = f_k - floor(f_k);
        (spectrum_a[f_k] * (1.0 - tmp) + spectrum_a[f_k + 1] * tmp) * (1 - spectrum_frac) +
        (spectrum_b[f_k] * (1.0 - tmp) + spectrum_b[f_k + 1] * tmp) * spectrum_frac
      ) : 0;
      
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * fft_interval / srate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
        
        mix_mem[num_partials] = Adivfs * camp;// * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    
    ticker = 0;
  );
);

function set_pars_stft(f_0)
local()
global(model, vowel, female_vowel)
instance()
(
  (model < 2) ? (
    this.set_pars_stft_basic(f_0);
  ) : (model == 2) ? (
    this.set_pars_stft_messy(f_0);
  ) : (model == 3) ? (
    this.set_pars_stft_beam(f_0, 0);
  ) : (model == 4) ? (
    this.set_pars_stft_beam(f_0, 1);
  ) : (model == 5) ? (
    this.set_pars_stft_drum(f_0);
  ) : (model == 6) ? (
    this.set_pars_stft_marimba(f_0);
  ) : (model == 7) ? (
    this.set_pars_stft_pan(f_0);
  ) : (model == 8) ? (
    this.set_pars_stft_vowel(f_0, vowel);
  ) : (model == 9) ? (
    this.set_pars_stft_vowel(f_0, female_vowel);
  ) : (model == 10) ? (
    this.set_pars_stft_raw(f_0);
  );
);

function process_block(in_fft_mem, out_fft_mem, active, env_level)
instance(coeff_mem, mix_mem, state_mem, bin_mem, num_partials)
global(srate)
local(ix, tix, bin)
(
  // Update the resonators
  convolve_c(state_mem, coeff_mem, num_partials + 1);
  
  ix = 0; tix = 0;  
  active ? (
    loop(num_partials,
      bin = bin_mem[ix];
      state_mem[tix] += mix_mem[ix] * in_fft_mem[bin] * env_level;
      state_mem[tix + 1] += mix_mem[ix] * in_fft_mem[bin + 1] * env_level;
      
      ix += 1; tix += 2;
    );
  );

  ix = 0; tix = 0;
  loop(num_partials,
    bin = bin_mem[ix];
    out_fft_mem[bin] += state_mem[tix] * env_level;
    out_fft_mem[bin + 1] += state_mem[tix + 1] * env_level;
    ix += 1; tix += 2;
  );
);


function read_block(input_mem, input_idx, fft_loc, window_ptr, len, buffer_size)
local(fft_ptr)
instance()
global()
(
  input_idx -= len;
  fft_ptr = fft_loc;
  input_idx < 0 ? input_idx += buffer_size;
  loop(len,
    input_idx == buffer_size ? input_idx = 0;
    fft_ptr[] = input_mem[input_idx] * window_ptr[];
    window_ptr += 1;
    input_idx += 1;
    fft_ptr += 1;
  );
  
  fft_real(fft_loc, len);
  fft_permute(fft_loc, len / 2);
);


function write_block(output_mem, output_idx, fft_ptr, window_ptr, len, buffer_size)
local()
instance()
global()
(
  fft_ptr[0] += fft_ptr[1];
  //fft_ptr[0] = sqrt(fft_ptr[0] * fft_ptr[0] + fft_ptr[1] * fft_ptr[1]);
  fft_ptr[1] = 0; // Kill Nyquist
  fft_ipermute(fft_ptr, len / 2);
  ifft_real(fft_ptr, len);

  loop(len,
    (output_idx == buffer_size) ? output_idx = 0;
    output_mem[output_idx] += fft_ptr[] * window_ptr[];
    fft_ptr += 1;
    window_ptr += 1;
    output_idx += 1;
  );
);


function read_stft(f_h)
local()
global()
instance(
  fft_idx, fft_interval,
  input_mem, input_idx,
  in_fft_mem, out_fft_mem, window_mem,
  fft_size, buffer_size
)
(
  input_idx == buffer_size ? input_idx = 0;
  input_mem[input_idx] = f_h;
  
  (fft_idx == fft_interval) ? (
    read_block(input_mem, input_idx, in_fft_mem, window_mem, fft_size * 2, buffer_size);
    memset(out_fft_mem, 0, fft_size * 2);
  );
  
  input_idx += 1;
);

function write_stft()
local()
global()
instance(
  f_hn, f_b,
  fft_idx, fft_interval,
  output_mem, output_idx,
  out_fft_mem, window_mem,
  fft_size, buffer_size,
)
(
  (fft_idx == fft_interval) ? (
    write_block(output_mem, output_idx, out_fft_mem, window_mem, fft_size * 2, buffer_size);
    fft_idx = 0;
  );
  
  output_idx == buffer_size ? output_idx = 0;
  f_hn = f_b = output_mem[output_idx];
  output_mem[output_idx] = 0;
  
  fft_idx += 1;
  output_idx += 1;
);


function eval_string_stft(env_level, on)
instance(
  fft_idx,
  in_fft_mem, out_fft_mem,
  fft_interval
)
global()
local()
(
  (fft_idx == fft_interval) ? (    
    this.process_block(in_fft_mem, out_fft_mem, on, env_level);
    fft_idx = 0;
  );
  
  fft_idx += 1;
);

function draw_stft(x, y, w, h)
instance(mix_mem, bin_mem, coeff_mem, state_mem, num_partials, fft_size, ticker,
         rel_position, base_damp, f_damp, inharm)
local(s, ds, bin, dx, ix, tix, cx, cy, bin_width, yc, decay, offs, ix2, dz)
global(gfx_x, gfx_y, gfx_a, srate, display_log,
       relative_position, damp, freq_damp, inharmonic)
(
  ticker = 5000;
  
  rel_position = relative_position;
  base_damp = 10^damp;
  f_damp = 10^freq_damp;
  inharm = 10^inharmonic;
  
  this.set_pars_stft(440 / 2 / 2);
  memset(state_mem, 0, 2 * fft_size);
  ix = 0; tix = 0;
  loop(num_partials,
    bin = bin_mem[ix];
    state_mem[bin] = max(state_mem[bin], sqrt(coeff_mem[tix] * coeff_mem[tix] + coeff_mem[tix + 1] * coeff_mem[tix + 1]));
    state_mem[bin + 1] = state_mem[bin + 1] + mix_mem[ix];
    ix += 1; tix += 2;
  );
  
  gfx_set(0.3, 0.2, 0.3, 1);
  ix = 0;
  dz = 3;
  loop(10,
    gfx_a *= 0.80;
    gfx_line(x + ix, y + h - ix, x + w + ix, y + h - ix);
    ix += 2 * dz;
  );
  
  cx = x;
  cy = y;
  bin_width = 2;
  ix = 0;
  dx = w / fft_size;
  ds = 1 / fft_size;
  s = 0;

  // For logarithmic display, we go from 20 - srate
  //   exp(log(20) + x * (log(srate) - log(20)) * fft_size / srate
  // (fft_size / srate)* (log(srate) - log(20)) * exp(log(20) + x(log(srate) - log(20))

  loop(fft_size,
    colormodel(s);
    s += ds;
    decay = state_mem[ix];
    yc = 100000 * h * state_mem[ix + 1];
    gfx_rect(cx, cy + h - yc, bin_width, yc);
    
    ix2 = 0;
    gfx_a = 0.57;
    loop(50,
      gfx_a *= 0.95;
      yc *= decay;
      gfx_rect(cx + ix2, cy + h - yc - 0.5 * ix2, bin_width, yc);
      ix2 += dz;
    );
    
    //yc *= state_mem[ix];
    //gfx_rect(cx, cy + h - yc, bin_width, yc);
    display_log ? (
      cx = x + w * log((ix + 0.5) / 2) / log(fft_size);
    ) : (
      cx += dx;
    );
    ix += 2;
  );

  1
);
 
