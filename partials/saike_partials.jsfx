desc:Partials (Saike)
tags: modal effect
version: 0.42
author: Joep Vanlier
changelog: Switch file extension again to prevent being visible in jsfx list (thanks cfillion!).
license: MIT
provides:
  partials_dependencies/*
  saike_partials.jsfx.rpl
about:
  # An effect which simulates different materials
  This effect takes both audio and MIDI input. Based on the model selected the incoming audio will excite
  a number of resonators that produce particular sounds. Up to 4 note polyphony is supported.

slider1:model=0<0,12,1{Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice male,Voice female,Custom,Custom_Mem,Custom_Mem2>-model
slider2:inverse_brightness=0<0,1,0.0001>-Inverse Brightness
slider3:relative_position=0.1<0.0001,0.999,0.001>-Relative position
slider4:damp=0.1<-2,2,0.0001>-Damping
slider5:freq_damp=-4<-6,-1,0.0001>-Frequency Dependent Damping
slider6:inharmonic=-4<-4, 0, 0.0001>-Inharmonic
slider7:stiffness=4.6<2,6,0.0001>-Stiffness
slider8:stiffness_exp=2.3<1,3.0,.0001>-Stiffness Exponent
slider9:placeholder=0<0,1,1>-Placeholder
slider10:base_note=0<-12,12,1>-Base note
slider11:force_fb=1<0,15,0.0001>-Forced feedback (TD only)
slider12:partials=32<16,64,16>-Partials
slider13:stereo=1<0,1,1{Off,On}>-Stereo-ize
slider14:position_vel=0<-1,1,0.000001>-Position velocity sensitivity
slider15:damp_vel=0<-4,4,0.000001>-Damping velocity sensitivity
slider16:freq_damp_vel=0<-5,5,0.000001>-Frequency dependent damping velocity sensitivity
slider17:inharmonic_vel=0<-4,4,0.000001>-Inharmonicity velocity sensitivity
slider18:dummy=0<0,0,1{Off,On}>-Dummy
slider19:first_note=45<0,127,1>-Midi note 1
slider20:second_note=52<0,127,1>-Midi note 2
slider21:third_note=60<0,127,1>-Midi note 3
slider22:fourth_note=64<0,127,1>-Midi note 4
slider23:fifth_note=48<0,127,1>-Midi note 5
slider24:fft_choice=1<0,4,1>-fft size
slider52:glide_speed=0<0,1,1>-Glide [10-1000ms]
slider53:legacy_gain=0<0,1,1>-Legacy mode
slider54:brightness_vel=0<0,1,0.0001>-Brightness vel
slider55:play_mode=3<0,4.99,1>-Impulse mode
slider56:attack_slider=0<0,2,0.0001>-Attack
slider57:decay_slider=1<0,3,0.0001>-Decay
slider58:release_slider=1.5<0,3,0.0001>-Release
slider59:sustain_level=0.3<0,1,0.0001>-Sustain
slider60:use_envelopes=0<0,1,1>-Use Envelopes
slider61:pitch_shift=0<-24,24,0.000001>-Large pitch bend
slider62:display_log=0<0,1,1{Linear,Logarithmic}>-Display type
slider63:stft=1<0,1,1>-STFT

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

-- You can define a custom model in this file:
import saike_modal_custom.jsfx-inc

import saike_modal.jsfx-inc
import saike_modal_kp_midi.jsfx-inc
import saike_modal_stft.jsfx-inc
import saike_modal_gfx.jsfx-inc
import saike_partial_array.jsfx-inc
import saike_vowel_data.jsfx-inc
import saike_modal_buffer.jsfx-inc
import saike_modal_impulses.jsfx-inc

@init
MAX_CUSTOM_PARTIALS = 1024;

gfx_ext_retina == 0 ? gfx_ext_retina = 1;
version = 3;

string1.used_partials = string2.used_partials = string3.used_partials = string4.used_partials = string5.used_partials = 0;

playmode_knob.init_knob(0, 4.99, 0.1, 55, 0);
brightness_knob.init_knob(1, 0, 0.1, 2, 54);
position_knob.init_knob(0, 1, 0.1, 3, 14);
damp_knob.init_knob(-2, 2, 0.1, 4, 15);
freq_damp_knob.init_knob(-6, -1, -4, 5, 16);
inharmonic_knob.init_knob(-4, 0, -4, 6, 17);
stiffness_knob.init_knob(3, 6, 4.6, 7, 0);
stiffness_exp_knob.init_knob(1.0, 3.0, 2.3, 8, 0);
force_fb.init_knob(0, 15.0, 1.0, 11, 0);
partials.init_knob(16, 64, 32, 12, 0);
glide_knob.init_knob(0, 1, 0, 52, 0);

function stft_init()
local()
global(
  string1.string_init, string2.string_init, string3.string_init, string4.string_init, string5.string_init,
  stft_mem.init_stft,
  stft_mem.fft_size, stft_mem.fft_interval,
  fft_choice,
)
instance()
(
  stft_mem.init_stft(64 * (1 << fft_choice)) ? (
    string1.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string2.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string3.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string4.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string5.string_init(stft_mem.fft_size, stft_mem.fft_interval);
  );
);

function initialize_memory()
local(logo_handle, freemem, lowcut, lowcut_freq, delay_ms, count)
instance()
global(
  rle_mem, logomem, logo_line_count,
  gfx_stft_mem.init_stft,
  stft_mem.init_stft,
  stft_mem.fft_mem, string1.string_mem, string2.string_mem, string3.string_mem, string4.string_mem, string5.string_mem,
  stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem,
  gfx_stft_mem.fft_mem, gfx_string.string_mem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem,
  gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval,
  gfx_string.string_init,
  bessel_roots,
  midi.init_midi,
  buffer.init_buffer,
  buffer.set_offset,
  hp.init_linearSVF,
  srate,
  MAX_CUSTOM_PARTIALS,
  custom_partial_mem,
  fft_choice,
)
(
  freemem = 0;
  freemem = stft_mem.fft_mem(freemem, 64 * 16);  // We allocate the maximum mem block here
  freemem = string1.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string2.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string3.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string4.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string5.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  stft_init();
  
  freemem = gfx_stft_mem.fft_mem(freemem, 512);
  freemem = gfx_string.string_mem(freemem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem);
  gfx_stft_mem.init_stft(512);
  gfx_string.string_init(gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval);
  
  freemem = (bessel_roots = freemem) + 2048;
  memset(bessel_roots, 0, 2048);
  bessel_roots[0] = 1.000000; bessel_roots[1] = 2.917295; bessel_roots[2] = 4.831885; bessel_roots[3] = 6.746213; bessel_roots[4] = 8.660476; bessel_roots[5] = 10.574713; bessel_roots[6] = 12.488940; bessel_roots[7] = 14.403161; bessel_roots[8] = 16.317378; bessel_roots[9] = 18.231593; bessel_roots[10] = 20.145807; bessel_roots[11] = 22.060020; bessel_roots[12] = 23.974232; bessel_roots[13] = 25.888443; bessel_roots[14] = 27.802654; bessel_roots[15] = 29.716865; bessel_roots[16] = 31.631075;
  bessel_roots[17] = 33.545286; bessel_roots[18] = 35.459496; bessel_roots[19] = 37.373706; bessel_roots[20] = 39.287916; bessel_roots[21] = 41.202125; bessel_roots[22] = 43.116335; bessel_roots[23] = 45.030545; bessel_roots[24] = 46.944754; bessel_roots[25] = 48.858964; bessel_roots[26] = 50.773173; bessel_roots[27] = 52.687383; bessel_roots[28] = 54.601592; bessel_roots[29] = 56.515802; bessel_roots[30] = 58.430011; bessel_roots[31] = 60.344220; bessel_roots[32] = 62.258430;
  bessel_roots[33] = 64.172639; bessel_roots[34] = 66.086848; bessel_roots[35] = 68.001058; bessel_roots[36] = 69.915267; bessel_roots[37] = 71.829476; bessel_roots[38] = 73.743685; bessel_roots[39] = 75.657895; bessel_roots[40] = 77.572104; bessel_roots[41] = 79.486313; bessel_roots[42] = 81.400522; bessel_roots[43] = 83.314731; bessel_roots[44] = 85.228941; bessel_roots[45] = 87.143150; bessel_roots[46] = 89.057359; bessel_roots[47] = 90.971568; bessel_roots[48] = 92.885777;
  bessel_roots[49] = 94.799986; bessel_roots[50] = 96.714196; bessel_roots[51] = 98.628405; bessel_roots[52] = 100.542614; bessel_roots[53] = 102.456823; bessel_roots[54] = 104.371032; bessel_roots[55] = 106.285241; bessel_roots[56] = 108.199450; bessel_roots[57] = 110.113660; bessel_roots[58] = 112.027869; bessel_roots[59] = 113.942078; bessel_roots[60] = 115.856287; bessel_roots[61] = 117.770496; bessel_roots[62] = 119.684705; bessel_roots[63] = 121.598914; bessel_roots[64] = 123.513123;
  bessel_roots[65] = 125.427332; bessel_roots[66] = 127.341542; bessel_roots[67] = 129.255751; bessel_roots[68] = 131.169960; bessel_roots[69] = 133.084169; bessel_roots[70] = 134.998378; bessel_roots[71] = 136.912587; bessel_roots[72] = 138.826796; bessel_roots[73] = 140.741005; bessel_roots[74] = 142.655214; bessel_roots[75] = 144.569423; bessel_roots[76] = 146.483633; bessel_roots[77] = 148.397842; bessel_roots[78] = 150.312051; bessel_roots[79] = 152.226260; bessel_roots[80] = 154.140469;
  bessel_roots[81] = 156.054678; bessel_roots[82] = 157.968887; bessel_roots[83] = 159.883096; bessel_roots[84] = 161.797305; bessel_roots[85] = 163.711514; bessel_roots[86] = 165.625723; bessel_roots[87] = 167.539933; bessel_roots[88] = 169.454142; bessel_roots[89] = 171.368351; bessel_roots[90] = 173.282560; bessel_roots[91] = 175.196769; bessel_roots[92] = 177.110978; bessel_roots[93] = 179.025187; bessel_roots[94] = 180.939396; bessel_roots[95] = 182.853605; bessel_roots[96] = 184.767814;
  bessel_roots[97] = 186.682023; bessel_roots[98] = 188.596232; bessel_roots[99] = 190.510441; bessel_roots[100] = 192.424651; bessel_roots[101] = 194.338860; bessel_roots[102] = 196.253069; bessel_roots[103] = 198.167278; bessel_roots[104] = 200.081487; bessel_roots[105] = 201.995696; bessel_roots[106] = 203.909905; bessel_roots[107] = 205.824114; bessel_roots[108] = 207.738323; bessel_roots[109] = 209.652532; bessel_roots[110] = 211.566741; bessel_roots[111] = 213.480950; bessel_roots[112] = 215.395159;
  bessel_roots[113] = 217.309368; bessel_roots[114] = 219.223578; bessel_roots[115] = 221.137787; bessel_roots[116] = 223.051996; bessel_roots[117] = 224.966205; bessel_roots[118] = 226.880414; bessel_roots[119] = 228.794623; bessel_roots[120] = 230.708832; bessel_roots[121] = 232.623041; bessel_roots[122] = 234.537250; bessel_roots[123] = 236.451459; bessel_roots[124] = 238.365668; bessel_roots[125] = 240.279877; bessel_roots[126] = 242.194086; bessel_roots[127] = 244.108295; bessel_roots[128] = 246.022504; bessel_roots[129] = 247.936713; bessel_roots[130] = 249.850923; bessel_roots[131] = 251.765132; bessel_roots[132] = 253.679341;
  bessel_roots[133] = 255.593550; bessel_roots[134] = 257.507759; bessel_roots[135] = 259.421968; bessel_roots[136] = 261.336177; bessel_roots[137] = 263.250386; bessel_roots[138] = 265.164595; bessel_roots[139] = 267.078804; bessel_roots[140] = 268.993013; bessel_roots[141] = 270.907222; bessel_roots[142] = 272.821431; bessel_roots[143] = 274.735640; bessel_roots[144] = 276.649849; bessel_roots[145] = 278.564059; bessel_roots[146] = 280.478268; bessel_roots[147] = 282.392477; bessel_roots[148] = 284.306686;
  bessel_roots[149] = 286.220895; bessel_roots[150] = 288.135104; bessel_roots[151] = 290.049313; bessel_roots[152] = 291.963522; bessel_roots[153] = 293.877731; bessel_roots[154] = 295.791940; bessel_roots[155] = 297.706149; bessel_roots[156] = 299.620358; bessel_roots[157] = 301.534567; bessel_roots[158] = 303.448776; bessel_roots[159] = 305.362985; bessel_roots[160] = 307.277194; bessel_roots[161] = 309.191403; bessel_roots[162] = 311.105613; bessel_roots[163] = 313.019822; bessel_roots[164] = 314.934031;
  bessel_roots[165] = 316.848240; bessel_roots[166] = 318.762449; bessel_roots[167] = 320.676658; bessel_roots[168] = 322.590867; bessel_roots[169] = 324.505076; bessel_roots[170] = 326.419285; bessel_roots[171] = 328.333494; bessel_roots[172] = 330.247703; bessel_roots[173] = 332.161912; bessel_roots[174] = 334.076121; bessel_roots[175] = 335.990330; bessel_roots[176] = 337.904539; bessel_roots[177] = 339.818748; bessel_roots[178] = 341.732957; bessel_roots[179] = 343.647167; bessel_roots[180] = 345.561376;
  bessel_roots[181] = 347.475585; bessel_roots[182] = 349.389794; bessel_roots[183] = 351.304003; bessel_roots[184] = 353.218212; bessel_roots[185] = 355.132421; bessel_roots[186] = 357.046630; bessel_roots[187] = 358.960839; bessel_roots[188] = 360.875048; bessel_roots[189] = 362.789257; bessel_roots[190] = 364.703466; bessel_roots[191] = 366.617675; bessel_roots[192] = 368.531884; bessel_roots[193] = 370.446093; bessel_roots[194] = 372.360302; bessel_roots[195] = 374.274511; bessel_roots[196] = 376.188720; bessel_roots[197] = 378.102930; bessel_roots[198] = 380.017139;
  
  freemem = midi.init_midi(freemem);
  
  buffer.init_buffer(freemem, freemem + 32766);
  freemem += 32768;
  
  delay_ms = 16.12;
  buffer.set_offset(delay_ms * srate / 1000);
  lowcut = 0.34;
  lowcut_freq = exp((1-LowCut) * log(20/22050));
  hp.init_linearSVF(lowcut_freq, 0);
  //displayFreq = 0.5 * srate * lowcut_freq / $pi;
  
  freemem = init_vowels(freemem);
  
  custom_partial_mem = freemem;
  freemem = alloc_model_memory_block(freemem, MAX_CUSTOM_PARTIALS);
  
  logomem = freemem;
  logo_handle = file_open("partials_dependencies/logo.dat");
  file_var(logo_handle, logo_line_count);
  file_mem(logo_handle, logomem, logo_line_count);
  rle_mem = logomem + logo_line_count + 1;
  file_var(logo_handle, count);
  file_mem(logo_handle, rle_mem, count);
  file_close(logo_handle);
);

function tanh(x)
local()
global()
instance()
(
  (2/(1+exp(-2*x)) - 1)
);


function update_freq()
local()
global(stft, k_glide, big_tick, cSample, test_mode, _test_mode_pos)
instance(freq, target_freq)
(
  freq += k_glide * (target_freq - freq);
  
  big_tick ? (
    stft ? (
      test_mode ? (
        _test_mode_pos += 0.001;
        _test_mode_pos > 0.5 ? _test_mode_pos = 0;
        this.set_pars_stft(freq * (1 + 0.5*12 * test_mode * _test_mode_pos));
      ) : (
        this.set_pars_stft(freq);
      );
    ) : (
      freq ? this.set_pars_td(freq);
    );
  );
);

function set_pars(f_0, vel, glide)
local()
global(
  stft,
  relative_position, damp, freq_damp, inharmonic,
  position_vel, damp_vel, freq_damp_vel, inharmonic_vel,
)
instance(base_damp, f_damp, inharm, rel_position, freq, target_freq)
(
  // position 0 to 1
  // damp -2 to 2
  // freq_damp -6 to -1
  // inharmonic -4 to 0
  rel_position = min(max(0, relative_position + position_vel * vel), 1);
  base_damp = 10^(min(max(-2, damp + damp_vel * vel), 2));
  f_damp = 10^(min(max(-6, freq_damp + freq_damp_vel * vel), -1));
  
  inharm = inharm * 0.8 + 0.2 * 10^(min(max(-4, inharmonic + inharmonic_vel * vel), 0));
  
  

  ((!glide) || (freq == 0)) ? (
    freq = f_0;
    target_freq = f_0;
  ) : (
    target_freq = f_0;
  );
);

function eval_string(f_h, env, on)
local(input_active)
global(stft, play_mode, stft_mem.fft_size)
instance()
(
  stft ? (
    // Impulses are added at the global level below, since the STFT
    // variant only uses one STFT for the entire input.
    input_active = (play_mode >= 1) ? this.impulse.impulse_alive(stft_mem.fft_size) : 1;

    this.eval_string_stft(env * input_active, env, on);
  ) : (
    /* Add string specific impulse if relevant */
    (play_mode >= 1) ? (
      f_h += this.impulse.eval_impulse(this.freq);
    );
    this.eval_string_td(on ? f_h * env : 0);
  );
);

function update_env_note(vel, state)
instance(last_vel, target, sustain, rate,
         k_attack, k_decay, attack_samples)
local()
global(srate, mlog0p05, attack_s, decay_s, release_s, sustain_level)
(
  target = 2 * vel;
  sustain = sustain_level * target;
  
  state ? (
    // Change!
    vel ? (
      attack_samples = attack_s * srate;
      k_attack = mlog0p05 / attack_samples;
      k_decay = mlog0p05 / (decay_s * srate);
    ) : (
      // Note is off => release!
      attack_samples = 0;
      k_decay = mlog0p05 / (release_s * srate);
    );
  );
  last_vel = vel;
);

function env_sample()
instance(state, target, sustain, 
         attack_samples,
         k_attack, k_decay)
local(current_target, rate)
global()
(
  (attack_samples > 0) ? (
    rate = k_attack;
    current_target = target;
  ) : (
    // Release and decay
    rate = k_decay;
    current_target = sustain;
  );
  attack_samples -= 1;
  
  state += rate * (current_target - state);
);

function update_notes()
instance(notes_on, active_note_mem, active_note_vel, active_note_state, note_history,
         note_on0, note_on1, note_on2, note_on3, note_on4, last_count)
global(string1.set_pars, string2.set_pars, string3.set_pars, string4.set_pars, string5.set_pars, pitch_shift, midi.pitchbend,
       use_envelopes, envelope1.update_env_note, envelope2.update_env_note, envelope3.update_env_note, envelope4.update_env_note, envelope5.update_env_note,
       string1.impulse.update_impulse_note,
       string2.impulse.update_impulse_note,
       string3.impulse.update_impulse_note,
       string4.impulse.update_impulse_note,
       string5.impulse.update_impulse_note,
       string1.used_partials,
       string2.used_partials,
       string3.used_partials,
       string4.used_partials,
       string5.used_partials,
       play_mode, midi_recv,
       inverse_brightness, brightness_vel,
       partials_used,
       glide)
local(ref_pitch, scaling
      note_vel0, note_vel1, note_vel2, note_vel3, note_vel4,
      note_state0, note_state1, note_state2, note_state3, note_state4,
      latest_note
      )
(
  scaling = 440;
  ref_pitch = 2 * midi.pitchbend + pitch_shift - 69;
  
  midi_recv = max(midi_recv, ((note_state0 > 0) + (note_state1 > 0) + (note_state2 > 0) + (note_state3 > 0) + (note_state4 > 0)) > 0);

  glide ? (
    note_on2 = note_on3 = note_on4 = 0;
    (notes_on > 0) ? (
      latest_note = note_history[notes_on - 1];
      note_on0 = active_note_mem[latest_note];
      note_vel0 = active_note_vel[latest_note];
      note_state0 = active_note_state[latest_note];
    ) : (
      note_state0 = -1;
    );
    (notes_on > 0) ? string1.set_pars(scaling * 2 ^ ((note_on0 + ref_pitch) / 12), note_vel0, last_count > 0);
  ) : (
    note_vel0 = active_note_vel[0];
    note_vel1 = active_note_vel[1];
    note_vel2 = active_note_vel[2];
    note_vel3 = active_note_vel[3];
    note_vel4 = active_note_vel[4];
    
    note_on0 = active_note_mem[0];
    note_on1 = active_note_mem[1];
    note_on2 = active_note_mem[2];
    note_on3 = active_note_mem[3];
    note_on4 = active_note_mem[4];
    
    note_state0 = active_note_state[0];
    note_state1 = active_note_state[1];
    note_state2 = active_note_state[2];
    note_state3 = active_note_state[3];
    note_state4 = active_note_state[4];
    
    // Update note parameters
    note_on0 ? string1.set_pars(scaling * 2 ^ ((note_on0 + ref_pitch) / 12), note_vel0, 0);
    note_on1 ? string2.set_pars(scaling * 2 ^ ((note_on1 + ref_pitch) / 12), note_vel1, 0);
    note_on2 ? string3.set_pars(scaling * 2 ^ ((note_on2 + ref_pitch) / 12), note_vel2, 0);
    note_on3 ? string4.set_pars(scaling * 2 ^ ((note_on3 + ref_pitch) / 12), note_vel3, 0);
    note_on4 ? string5.set_pars(scaling * 2 ^ ((note_on4 + ref_pitch) / 12), note_vel4, 0);
  );
  
  use_envelopes ? (
    envelope1.update_env_note(note_vel0, note_state0);
    envelope2.update_env_note(note_vel1, note_state1);
    envelope3.update_env_note(note_vel2, note_state2);
    envelope4.update_env_note(note_vel3, note_state3);
    envelope5.update_env_note(note_vel4, note_state4);
  );
  
  (play_mode >= 1) ? (
    string1.impulse.update_impulse_note(note_state0, inverse_brightness + brightness_vel * note_vel0);
    string2.impulse.update_impulse_note(note_state1, inverse_brightness + brightness_vel * note_vel1);
    string3.impulse.update_impulse_note(note_state2, inverse_brightness + brightness_vel * note_vel2);
    string4.impulse.update_impulse_note(note_state3, inverse_brightness + brightness_vel * note_vel3);
    string5.impulse.update_impulse_note(note_state4, inverse_brightness + brightness_vel * note_vel4);
  );
  
  active_note_state[0] = 0;
  active_note_state[1] = 0;
  active_note_state[2] = 0;
  active_note_state[3] = 0;
  active_note_state[4] = 0;
  
  partials_used = max(string1.used_partials, max(string2.used_partials, max(string3.used_partials, max(string4.used_partials, string5.used_partials))));
  last_count = notes_on;
);

function force_update()
(
  update_ticker = 0;
);

initialize_memory();
midi.reset_midi();
settings_changed = 1;

@slider
settings_changed = 1;

stft_init();

@block
sample_time = 1 / srate;
glide_decay = pow(10, glide_speed * 2 - 2.5); // 12.0 / 1000;  // Decay in seconds
k_glide = - sample_time * log(0.5) / glide_decay;

midi_input = (play_mode >= 1);
(floor(play_mode) != floor(last_play_mode)) ? (
  memset(midi.active_note_mem, 0, 5);
  midi.notes_on = 0;
  settings_changed = 1;
  last_play_mode = play_mode;
);

(srate != last_srate) ? (
  prepare_impulse_globals();
  last_srate = srate;
);

mlog0p05 = 2.995732273553991; // Corresponds to time to get to 95%
attack_s = exp(-5.809142990314027 + 2.302585092994046 * attack_slider); // 3 - 300 ms <=> 0 - 2
decay_s = exp(-5.809142990314027 + 2.302585092994046 * decay_slider); // 3 - 3000 ms <=> 0 - 3
release_s = exp(-5.809142990314027 + 2.302585092994046 * release_slider); // 3 - 3000 ms <=> 0 - 3

midi.midi_block(pass_through);

@sample
cSample += 1;
update_global_parameters();

function update_fixed_notes()
local(change, val, ix, idx)
global(settings_changed)
instance(active_note_mem, active_note_vel, notes_on)
(
  ix = 19;
  idx = 0;
  change = 0;
  loop(5,
    // If this one is used, store it in the active note memory.
    val = slider(ix);
    val ? (
      change = (active_note_mem[idx] != val) ? 1 : change;
      active_note_mem[idx] = val;
      active_note_vel[idx] = 1.0;
      idx += 1;
    );
    ix += 1;
  );
  notes_on = idx;
  val = 5 - idx;
  loop(val,
    change = (active_note_mem[idx] != 0) ? 1 : change;
    active_note_mem[idx] = 0;
    active_note_vel[idx] = 0;
    idx += 1;
  );
  change ? (
    settings_changed = 1;
  );
);

midi.curSample += 1;
!midi_input ? (
  midi.update_fixed_notes();
);

midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

big_tick = update_ticker == 0;
update_ticker += 1;
(update_ticker > 128) ? (
  update_ticker = 0;
);

big_tick ? (
  midi.update_notes();
);
midi.note_on0 ? string1.update_freq();
midi.note_on1 ? string2.update_freq();
midi.note_on2 ? string3.update_freq();
midi.note_on3 ? string4.update_freq();
midi.note_on4 ? string5.update_freq();


f_hn = 0;
f_b = 0;

stft ? (
  (play_mode >= 2) ? (
    f_h += string1.impulse.eval_impulse(string1.freq) * 4;
    f_h += string2.impulse.eval_impulse(string2.freq) * 4;
    f_h += string3.impulse.eval_impulse(string3.freq) * 4;
    f_h += string4.impulse.eval_impulse(string4.freq) * 4;
    f_h += string5.impulse.eval_impulse(string5.freq) * 4;
  );

  stft_mem.read_stft(f_h);
);

(midi_input && use_envelopes) ? (
  string1.eval_string(f_h, envelope1.env_sample(), midi.note_on0);
  string2.eval_string(f_h, envelope2.env_sample(), midi.note_on1);
  string3.eval_string(f_h, envelope3.env_sample(), midi.note_on2);
  string4.eval_string(f_h, envelope4.env_sample(), midi.note_on3);
  string5.eval_string(f_h, envelope5.env_sample(), midi.note_on4);
) : (
  string1.eval_string(f_h, 1, midi.note_on0);
  string2.eval_string(f_h, 1, midi.note_on1);
  string3.eval_string(f_h, 1, midi.note_on2);
  string4.eval_string(f_h, 1, midi.note_on3);
  string5.eval_string(f_h, 1, midi.note_on4);
);

stft ? (
  stft_mem.write_stft();
  f_b = stft_mem.f_b;
  f_hn = stft_mem.f_hn;
) : (
  (midi_input && use_envelopes) ? (
    f_b += string1.f_b * envelope1.state; f_hn += string1.f_hn;
    f_b += string2.f_b * envelope2.state; f_hn += string2.f_hn;
    f_b += string3.f_b * envelope3.state; f_hn += string3.f_hn;
    f_b += string4.f_b * envelope4.state; f_hn += string4.f_hn;
    f_b += string5.f_b * envelope5.state; f_hn += string5.f_hn;
  ) : (
    f_b += string1.f_b; f_hn += string1.f_hn;
    f_b += string2.f_b; f_hn += string2.f_hn;
    f_b += string3.f_b; f_hn += string3.f_hn;
    f_b += string4.f_b; f_hn += string4.f_hn;
    f_b += string5.f_b; f_hn += string5.f_hn;
  );
);

hammer = 0;

function soft_clip(x)
(
  (abs(x) < 1) ? 1.5 * x - 0.5 * x * x * x : sign(x)
);

amp_factor = 10^stiffness;

stft ? (
  f_h = spl0;
  f_h = -(f_h > 0 ? 100000 * f_h ^ stiffness_exp : 0);
  //f_h = soft_clip(Adivfs*f_h) * srate;
) : (
  hammer ? (
    // WIP dynamical model (broken for now)
    f_h = (1 + force_fb) * f_hn;
    f_h += spl0;
    mh = 4.9;
    ah = -(1.0 / mh) * fdy;
    vh = vh + (1.0/srate) * ah;
    yh = yh + (1.0/srate) * vh;
    dy = - f_h + yh;
    fdy = ((dy > 0) ? amp_factor * dy ^ stiffness_exp : 0);
    f_h = fdy;
  ) : (
    // No hammer but simple feedback
    f_h = force_fb * f_hn;
    f_h += spl0;
    f_h = -(f_h > 0 ? amp_factor * f_h ^ stiffness_exp : 0);
    //f_h = soft_clip(Adivfs*f_h) * srate;
  );
);

stereo ? (
  buffer.update_buffer(f_b);
  rb = buffer.read_buffer();

  /* Highpass the added comb filter signal */
  rb = hp.eval_linearSVF_HP6(rb);
  
  spl0 = f_b + 0.33 * rb;
  spl1 = f_b - 0.33 * rb;
) : (
  spl0 = spl1 = f_b;
);

!stft ? (
  // Gain normalization in case of feedback system
  spl0 /= amp_factor * 0.00001;
  spl1 /= amp_factor * 0.00001;
);

settings_changed ? (
  settings_changed = 0;
  force_update();
);

@serialize
file_var(0, version);
(version > 1) ? (
  file_var(0, env.t_max);
) : (
  env.t_max = 0.1;
  use_envelopes = 0;
);

file_var(0, MAX_CUSTOM_PARTIALS);
file_mem(0, custom_partial_mem, MAX_CUSTOM_PARTIALS * 8 + 64);

(version < 3) ? ( glide = 0; ) : ( file_var(0, glide); );
(version < 3) ? ( test_mode = 0; ) : ( file_var(0, test_mode); );
(version < 3) ? ( pass_through = 1; ) : ( file_var(0, pass_through); );
version = 3;

@gfx 1080 280
_gfx_w = gfx_w;
_gfx_h = gfx_h;

//scaling = gfx_ext_retina == 2 ? 1 : 0;
scaling = _gfx_w / 1080;

//gfx_set(0, 0, 0, 1);
//gfx_rect(0, 0, gfx_w, gfx_h);

((init_w != _gfx_w) || (init_h != _gfx_h) || (model != last_model)) ? (
  init_w = _gfx_w;
  init_h = _gfx_h;
  last_model = model;
  settings_changed = 1;
  gfx_setimgdim(1, _gfx_w, _gfx_h);
  gfx_dest = 1;
  gfx_set(0, 0, 0, 1);
  gfx_rect(0, 0, _gfx_w, _gfx_h);
  
  loop(100,
    xx = _gfx_w * rand();
    yy = _gfx_h * rand();
    colormodel(rand()*rand()*rand()); gfx_a = 0.2;
    gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
  );
  loop(5,
    gfx_x = gfx_y = 0;
    gfx_blurto(_gfx_w, _gfx_h)
  );
  
  gfx_dest = -1;
);


gfx_dest = 1;
xx = _gfx_w * rand();
yy = _gfx_h * rand();
colormodel(rand()*rand()*rand()); gfx_a = 0.2;
gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
/*
xx = 2 * gfx_w * rand();
yy = gfx_h * rand();
loop(10,
  colormodel(0); gfx_a = 0.1;
  gfx_line(xx, 1, xx - gfx_h * 2, gfx_h + 1);
  gfx_line(xx, 2, xx - gfx_h * 2, gfx_h + 2);
  gfx_a = 10;
  gfx_line(xx, 0, xx - gfx_h * 2, gfx_h);
);
*/
gfx_x = gfx_y = 0;
gfx_blurto(_gfx_w, _gfx_h);
gfx_dest = -1;

gfx_x = gfx_y = 0; gfx_a = 0.25;
gfx_blit(1, 1, 0);



/*
gfx_set(0.3, 0.3, 0.7, 1);
ix = 0;
loop(string1.fft_size,
  yc = 0.5 * gfx_h * sqrt(string1.coeff_mem[2 * ix]^2 + string1.coeff_mem[2 * ix + 1]^2);
  gfx_rect(2 * ix, gfx_h - yc, 1, yc);
  ix += 1;
);
*/

function simple_arrow(xx, yy, _r)
local(dr)
global()
(
  dr = ceil(0.06 * _r);
  xx = floor(xx);
  yy = floor(yy);
  _r = floor(_r);
  gfx_line(xx, yy - 0.4 * _r, xx, yy - 2 * dr - 1);
  gfx_line(xx + 1, yy - 0.4 * _r, xx + 1, yy - 2 * dr - 1);
  gfx_line(xx - 1, yy - 0.4 * _r, xx - 1, yy - 2 * dr - 1);
  gfx_triangle(xx - dr, yy - 2 * dr, xx + dr, yy - 2 * dr, xx, yy);
);

function gfx_draw_icon(id, enabled)
local(len, xp, xx, yy, dr, s, ds, cy, sy, ang1, ang2, x1, x2, y1, y2, i, di, rr)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _r, relative_position)
( 
  colormodel(0.9);
  id == 0 ? (
    // Position
    len = ceil(0.6 * _r);
    yy = _y + 0.1 * _r;
    gfx_line(_x - len, yy, _x + len, yy, 1);
    gfx_line(_x - len, yy + 1, _x + len, yy + 1, 1);
    
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(xx, yy, _r);
  ) : ( id == 1 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 5 * relative_position / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * s - sy);
        s -= ds * s;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 2 ) ? (
    // Freq Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > 2 * (1 - relative_position) * len) ? cy -= 2 / len;
        cy = max(0, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 3 ) ? (
    // Spring
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 4.0 * relative_position;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(8.5 * len,
        cy = (1 - 0.4 * relative_position) * s - sy;
        gfx_a = 0.5 + 0.4 * cos(cy);
        
        gfx_lineto(floor(_x + xx - sy + 5 * cos(cy) * tanh(xx / len)), floor(_y - sy + yy * sin(cy)));
        s += 0.35;
        xx += 0.25;
      );
      sy -= 1;
    );
  ) : ( id == 4 ) ? (
    // Stiffness
    len = ceil(0.6 * _r);
    yy = _y + 0.35 * _r;
    dr = _r * (0.5 + relative_position);
    
    gfx_a = 0.2 + 0.8 * enabled;
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(_x, _y + 0.05 * _r - 0.1 * _r * relative_position, _r);

    xx = _x - len + ceil(2 * len * relative_position);
    gfx_a = relative_position;
    simple_arrow(_x + 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    simple_arrow(_x - 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    
    gfx_a = 0.2 + 0.8 * enabled;
    ang1 = $pi + asin(0.45 * _r / dr);
    ang2 = $pi - asin(0.45 * _r / dr);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
  ) : ( id == 5 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 0.5 / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 0;
      gfx_x = xx;
      gfx_y = _y + yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * pow(s, 1 + 5 * relative_position) - sy);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 6 ) ? (
    gfx_a = enabled;
    x1 = floor(_x - 0.3 * _r);
    x2 = floor(_x + 0.3 * _r);
    dr = floor(0.07 * _r);
    gfx_circle(x1, y2, dr, 1);
  
    gfx_a = 0.1 + 0.9 * relative_position * enabled;
    y1 = floor(_y - 0.3 * _r);
    y2 = floor(_y + 0.3 * _r);
    
    loop(2,
      x1 = floor(_x - 0.3 * _r);
      x2 = floor(_x + 0.3 * _r);
      loop(2,
        gfx_line(x1, y1, x1, y2 - 3 * dr);
        gfx_line(x1, y1, x1, y1);
        gfx_line(x1 + 1, y1, x2 - 1, y1);
        gfx_line(x2, y1, x2, y2 - 1);
        gfx_line(x1 + 3 * dr, y2, x2, y2);    
        gfx_line(x1 + 3 * dr, y2 + 1, x1 + 4 * dr, y2 + dr + 1);
        gfx_line(x1 + 3 * dr, y2 - 1, x1 + 4 * dr, y2 - dr - 1);
        x1 += 1;
        x2 += 1;
      );
      y1 += 1;
      y2 += 1;
    );
  ) : ( id == 7 ) ? (
    s = 0;
    _r *= 0.8;
    loop(12,
      gfx_a = 0.5 + (s < (17 * relative_position) ? 0.5 : 0);
      !enabled ? gfx_a *= 0.2;
      gfx_line(
        _x - 0.2 * _r * sin(s),
        _y + 0.2 * _r * cos(s), 
        _x - (0.5 + 0.05 * s) * _r * sin(s),
        _y + (0.5 + 0.03 * s) * _r * cos(s)
      );
      gfx_line(
        _x - 0.2 * _r * sin(s),
        _y + 0.2 * _r * cos(s) + 1, 
        _x - (0.5 + 0.05 * s) * _r * sin(s),
        _y + (0.5 + 0.03 * s) * _r * cos(s) + 1
      );
      s += 0.35 * $pi;
    );
  ) : ( id == 8 ) ? (
    // Waveform
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 3.14 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      gfx_a = 0.8;
      loop(2 * len,
        _r = sin(0.1 * s) + sin(2.22 * s + 3) + 0.2 * sin(1.48 * s * s + 10) - 0.1;
        _r *= (1 - cos(s));
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 9 ) ? (
    // MIDI
    gfx_a = 0.17;
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 3.14 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(2 * len,
        _r = sin(0.1 * s) + sin(2.22 * s + 3) + 0.2 * sin(1.48 * s * s + 10) - 0.1;
        _r *= (1 - cos(s));
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
    
    gfx_a = 0.4;
    sy = 0;
    gfx_circle(_x, _y, 0.8 * len + 0.5 * sy, 1); 
    loop(3,
      gfx_circle(_x, _y, len + 0.5 * sy);
      sy += 1;
    );
    
    gfx_set(0, 0, 0, 0.7);
    gfx_circle(_x - 0.5 * len, _y, 0.85 * sy, 1);
    gfx_circle(_x + 0.5 * len, _y, 0.85 * sy, 1);
    gfx_circle(_x, _y - 0.5 * len, 0.85 * sy, 1);
    gfx_circle(_x - 0.5 / 1.41 * len, _y - 0.5 / 1.41 * len, 0.85 * sy, 1);
    gfx_circle(_x + 0.5 / 1.41 * len, _y - 0.5 / 1.41 * len, 0.85 * sy, 1);
  ) : ( id == 10 ) ? (
    // Spike
    gfx_line(_x - 0.5 * _r, _y + 0.25 * _r, _x + 0.5 * _r + 1, _y + 0.25 * _r);
    gfx_line(_x - 0.5 * _r, _y + 0.25 * _r - 1, _x + 0.5 * _r + 1, _y + 0.25 * _r - 1);
    simple_arrow(_x, _y - 0.35 * _r, -1.5 * _r);
  ) : ( id == 11 ) ? (
    // Noise burst
    ang2 = 0;
    loop(2,
      s = _x - 0.5 * _r;
      i = - 0.5;
      di = - 2 * i / _r;
      gfx_y = _y + 0.35 * _r;
      gfx_x = s;
      loop(_r,
        ang1 = _y + 0.35 * _r - 0.8 * _r * exp(-1.5 * i * i * _r);
        gfx_lineto(s, ang1 + ang2, 1);
        s += 1;
        i += di;
      );
      ang2 += 1;
    );
  ) : ( id == 12 ) ? (
    // Noise
    ang2 = 0;
    loop(2,
      s = _x - 0.5 * _r;
      i = - 0.5;
      di = - 2 * i / _r;
      gfx_y = _y + 0.35 * _r;
      gfx_x = s;
      loop(_r,
        rr = i * i;
        rr *= 3 * rr;
        ang1 = _y + 0.35 * _r - 0.8 * _r * exp(-1.5 * rr * _r);
        gfx_lineto(s, ang1 + ang2, 1);
        s += 1;
        i += di;
      );
      ang2 += 1;
    );
  ) : ( id == 20 ) ? (
    xx = _x - 0.5 * _r;
    yy = _y + 0.3 * _r;
    rr = floor(4/50 * _r);
    
    gfx_circle(xx, yy, rr, 1);
    gfx_circle(xx + 1, yy, rr, 1);
    gfx_circle(xx + 2, yy, rr, 1);
    gfx_line(xx + rr, yy, xx + rr, yy - 0.5 * _r);
    gfx_line(xx + rr + 1, yy, xx + rr + 1, yy - 0.5 * _r);
    gfx_line(xx + rr + 2, yy, xx + rr + 2, yy - 0.5 * _r);
    
    xx = _x + 0.38 * _r;
    yy = _y + 0.1 * _r - 0.5 * _r;
    gfx_circle(xx, yy, rr, 1);
    gfx_circle(xx + 1, yy, rr, 1);
    gfx_circle(xx + 2, yy, rr, 1);
    gfx_line(xx - rr, yy, xx - rr, yy + 0.5 * _r);
    gfx_line(xx - rr + 1, yy, xx - rr + 1, yy + 0.5 * _r);
    gfx_line(xx - rr + 2, yy, xx - rr + 2, yy + 0.5 * _r);
    
    yy += 0.5 * _r;
    gfx_line(_x - 0.3 * _r, yy, xx - 4 - 0.1 * _r, yy - 0.4 * _r);
    gfx_line(_x - 0.3 * _r, yy + 1, xx - 4 - 0.1 * _r, yy - 0.4 * _r + 1);
//    gfx_circle(_x, _y, 1, 0.5);
  );
);

function draw_model_icon()
local(s, ds, xx, yy, len, hh, xorig, yorig, value)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _w, _h, active, _me)
(
  colormodel(0.7); gfx_a = 1;
  (_me == 0) ? (
    len = floor(0.4 * _w);
    xx = _x + floor(0.5 * _w);
    yy = _y + 0.5 * _h;
    ds = ceil(0.05 * _w);
    s = ceil(0.2 * _w);
    
    gfx_line(xx - len, yy, xx + len, yy);
    gfx_line(xx - len, yy - ds, xx + len, yy - ds);
    gfx_line(xx - len, yy + ds, xx + len, yy + ds);
    gfx_line(xx - len, yy - 2 * ds, xx + len, yy - 2 * ds);
    gfx_line(xx - len, yy + 2 * ds, xx + len, yy + 2 * ds);
    gfx_circle(xx - ds, yy, s);
  ) : (_me == 1) ? (
    len = floor(0.25 * _h);
    ds = floor(0.08 * _w);
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    
    xx -= 3 * ds;
    loop(3,
      gfx_line(xx - ds, yy - len, xx - ds, yy + len);
      gfx_line(xx + ds, yy - len, xx + ds, yy + len);
      gfx_arc(xx, yy + len, ds, 0.5 * $pi, 1.5 * $pi);
      gfx_circle(xx, yy - len, ds);
      len -= 1;
      xx += 3 * ds;
    );
  ) : (_me == 2) ? (
    len = floor(0.3 * _w);
    ds = $pi / len;
    s = 0;
    yy = _y + 0.5 * _h;
    loop(2,
      xx = _x + floor(0.5 * _w) - len;
      gfx_x = xx;
      gfx_y = yy;
      loop(len * 2,
        gfx_lineto(xx, yy - .5 * len * sin(s));
        xx += 1;
        s += ds;
      );
      yy -= 1;
    );
  ) : (_me == 3) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 4) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_triangle(xx + 2 * len - 1, yy - 2, xx + 2 * len - ds - 1, yy - 2 * ds - 2, xx + 2 * len + ds - 1, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 5) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = 0.5 * $pi / len;
    hh = 0.12 * _h;
    loop(2 * len - 1,
      s += ds;
      colormodel(0.5); gfx_a = 0.5;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + 4 + hh * sqrt(sin(s)));
      colormodel(0.7); gfx_a = 1.0;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + hh * sqrt(sin(s)));
      xx += 1;
    );
  ) : (_me == 6) ? (
    len = floor(0.25 * _w);
    ds = floor(0.15 * _w);
    xx = _x + floor(0.47 * _w) - len;
    yy = _y + 0.5 * _h;
    gfx_line(xx, yy + len, xx + len, yy - len);
    gfx_line(xx, yy + len + 1, xx + len, yy - len + 1);
    gfx_circle(xx + len, yy - len + 1, ds / 2, 1);
    
    gfx_line(xx + ds, yy + len, xx + 2 * ds + len, yy - len + ds);
    gfx_line(xx + ds, yy + len + 1, xx + 2 * ds + len, yy - len + 1 + ds);
    gfx_circle(xx + 2 * ds + len, yy - len + 1 + ds, ds / 2, 1);
  ) : (_me == 7) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.35 * _w);
    ds = floor(0.15 * _w);
    gfx_circle(xx, yy, len, 0);
    gfx_circle(xx, yy, len + 0.5, 0);
    s = 0;
    loop(5,
      gfx_circle(xx + ds * sin(s), yy + ds * cos(s), ds, 0);
      s += 0.4 * $pi;
    );
  ) : (_me == 8 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len, 0);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len + 0.5, 0);
    xorig = xx - 0.25 * len + len / 1.41421 + 1;
    yorig = yy + 0.25 * len - len / 1.41421;
    gfx_line(xorig, yorig, xorig + 0.7 * len, yorig - 0.7 * len);
    gfx_line(xorig, yorig - 1, xorig + 0.7 * len, yorig - 0.7 * len - 1);
    xorig += 0.7 * len;
    yorig -= 0.7 * len;

    gfx_line(xorig, yorig - 1, xorig - 0.5 * len, yorig - 1);
//    gfx_line(xorig, yorig - 2, xorig - 0.5 * len, yorig - 2);
    gfx_line(xorig + 1, yorig - 1, xorig + 1, yorig + 0.5 * len);
//    gfx_line(xorig + 2, yorig - 2, xorig + 2, yorig + 0.5 * len);

  ) : (_me == 9 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.475 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx, yy - 0.5 * len, len, 0);
    gfx_circle(xx, yy - 0.5 * len, len + 0.5, 0);
    gfx_line(xx, yy + 0.5 * len + 1, xx, yy + 1.75 * len);
    gfx_line(xx - 0.5 * len, yy + 1.25 * len, xx + 0.5 * len, yy + 1.25 * len);
  ) : (_me == 11) ? (
    xx = floor(_x + 0.18 * _w) - 1;
    yy = floor(_y + 0.75 * _h);
    len = floor((1 - 0.18*2) * _w);
    ds = floor(len / 2);
    
    ds = floor(len / 3);
    loop(ds,
      value = floor(len * abs(sin(s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 3, value, 0);
      xx += 3;
      s += 1.23;
    );
    
    xx = floor(_x + 0.18 * _w) - 1;
    ds = floor(len / 2);
    loop(ds,
      value = floor(0.5 * len * abs(sin(s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 3, value, 0);
      xx += 2;
      s += 1.23;
    );
  ) : (_me == 12 ) ? (
    xx = floor(_x + 0.18 * _w) - 1;
    yy = floor(_y + 0.75 * _h);
    len = floor((1 - 0.18*2) * _w);
    ds = floor(len / 2);
    
    loop(ds,
      value = floor(len * abs(sin(.9*s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 2, value);
      xx += 2;
      s += 1.23;
    );
  );
);

((model == 11) || (model == 12)) ? (
  right = custom_partials.draw_custom_partial_ui(0.02 * _gfx_w, cy + 1.5 * radius, 0.96 * _gfx_w, 0.935 * _gfx_h - (cy + 1.5 * radius) - 5, custom_partial_mem, MAX_CUSTOM_PARTIALS, partials_used, model==11);
) : (
  gfx_string.draw_stft(0.02 * _gfx_w, 0.02 * _gfx_h, _gfx_w * 0.93, _gfx_h * 0.9);
  right = 0.95 * _gfx_w;
);

function label_toggle(x, y, str, hint)
local(ww, hh, over)
global(mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y, last_cap, hinter.sethint)
(
  gfx_x = x; gfx_y = y;
  gfx_measurestr(str, ww, hh);
  gfx_printf(str);
  
  over = (mouse_x > x) && (mouse_x < (x + ww)) && (mouse_y > y) && (mouse_y < (y + hh));
  over ? hinter.sethint(hint);
  
  ((mouse_cap == 1) && (last_cap == 0)) ? (
    over ? 1
  );
);

gfx_setfont(3, "Arial", 12 * max(1, scaling));
gfx_measurestr("[Velocity]", velw, velh);
colormodel(change_vel_mod - 0.01);
label_toggle(right - velw - 5, 0.935 * _gfx_h, " [Velocity]", "Click this to change the velocity sensitivity of the parameters.\nParameters that can be linked to MIDI note velocity will\nbe highlighted.\n\nChanging their settings will result in those parameters\nbeing sensitive to MIDI note velocity. This sensitivity is\nindicated by a differently colored arc.") ? (
  change_vel_mod = 1 - change_vel_mod;
);

label_toggle(0.02 * _gfx_w, 0.93 * _gfx_h, "[Linear] ", "Display frequencies on a linear scale") ? (display_log = 0);
colormodel(display_log);
label_toggle(gfx_x, gfx_y, "[Logarithmic]", "Display frequencies on a logarithmic scale") ? (display_log = 1);

keyboard.draw_keyboard(base_note, gfx_x + 0.01 * _gfx_w, 0.935 * _gfx_h, right - velw - gfx_x - 0.01 * _gfx_w, 0.05 * gfx_y);

midi.note_on0 ? keyboard.highlight_note(midi.active_note_mem[0]);
midi.note_on1 ? keyboard.highlight_note(midi.active_note_mem[1]);
midi.note_on2 ? keyboard.highlight_note(midi.active_note_mem[2]);
midi.note_on3 ? keyboard.highlight_note(midi.active_note_mem[3]);
midi.note_on4 ? keyboard.highlight_note(midi.active_note_mem[4]);

note_over = keyboard.note_clicked();


function handle_non_midi_click(note_over)
instance(over)
local(idx, disabled_note)
global(keyboard.over, last_cap, mouse_cap, settings_changed, midi_input)
(
  this.over ? (
    (!midi_input) ? (
      (last_cap == 0) && (mouse_cap == 1) ? (
        settings_changed = 1;
        idx = 19;
        disabled_note = 0;
        loop(5,
          (slider(idx) == note_over) ? (
            slider_automate(slider(idx) = 0);
            disabled_note = 1;
          );
          idx += 1;
        );
        idx = 19;
        (!disabled_note) ? (
          loop(5,
            (slider(idx) == 0) ? (
              (!disabled_note) ? slider_automate(slider(idx) = note_over);
              disabled_note = 1;
            );
            idx += 1;
          );
        );
      );
    );
  );
);

keyboard.handle_non_midi_click(note_over);

n_knobs = 9 + 0.65 * glide;
radius = 0.0315 * 18 / (2 * n_knobs) * _gfx_w;
button_size = 0.004 * _gfx_w;
cx = 2 * radius;
cy = 2 * radius;
knob_spacing = 0.61 * 8 / (n_knobs - 1) * radius;


label_font();
legacy_gain = legacyToggle.processMouseToggle(cx + 1.1 * radius, cy + 1 * radius, button_size, button_size, legacy_gain, "Don't normalize gain to register being played\n\nNote that enabling this leads to low notes\nbeing a lot louder than high notes.", mouse_x, mouse_y, mouse_cap);

glide = glideToggle.processMouseToggle(cx + 1.1 * radius, cy - 1.1 * radius, button_size, button_size, glide, "Monophonic mode with glide.", mouse_x, mouse_y, mouse_cap);
color_model = 1;

pass_through = passthroughToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, pass_through, "Pass through MIDI.\n\nWhen enabled, this plugin will\nforward incoming MIDI notes.", mouse_x, mouse_y, mouse_cap);

function knob_glow(cx, cy, radius, value)
local(r_ix)
global(gfx_a)
instance()
(
  gfx_a = 0.5 * value;
  r_ix = 0;
  loop(10,
    gfx_circle(floor(cx), floor(cy), radius * 1.3 + r_ix);
    r_ix += 1;
    gfx_a *= 0.7;
  );
);

midi_recv *= 0.9;
colormodel(midi_recv);
knob_glow(cx, cy, radius, midi_recv);
playmode_knob.draw_knob(cx, cy, radius, "", 
"Play mode

Determines how the plugin responds to inputs. Dial 
for the different modes, or click with right mouse 
button to select mode from a menu.

Audio input fixes notes
  Received audio and transforms it according to the
  notes set on the keyboard at the bottom.
Audio input with MIDI notes
  Receives audio and MIDI input. Transforms the input
  audio with the MIDI notes played. Note that envelopes
  can optionally be enabled on the right (below the 
  models)
Spike impulse with MIDI notes
  Plays spikes through the resonator on MIDI notes.
  This allows you to play the plugin like a MIDI
  instrument.
Noise impulse with MIDI notes
  Plays spikes through the resonator on MIDI notes.
  This allows you to play the plugin like a MIDI
  instrument.
Constant noise with MIDI notes
  Plays noise through the resonator on MIDI notes.
  As a result, this plays a continuous note until 
  released.
", 1, 1);
playmode_knob.gfx_draw_icon(8 + floor(play_mode), 1);

playmode_knob.over ? (
  ((mouse_cap & 2) == 2) && (last_cap == 0) ? (
    menu_selection = gfx_showmenu("Audio input fixed notes|Audio input with MIDI notes|Spike impulse with MIDI notes|Noise impulse with MIDI notes|Continuous notes MIDI");
    menu_selection > 0 ? (
      play_mode = menu_selection - 1;
      menu_selection = 0;
    );
  );
);

glide ? (
  cx += 2 * radius + knob_spacing;
  glide_knob.draw_knob(cx, cy, radius, "", "Glide\n\nGlide duration", 1, 1);
  glide_knob.gfx_draw_icon(20, 1);
);

cx += 2 * radius + knob_spacing;
brightness_knob.draw_knob(cx, cy, radius, "", 
"Brightness

How bright should the impulse be that is 
played through the resonator. Note that 
linking this to the velocity is generally 
a good idea to get an expressive sound.

You can do this by clicking the [velocity]
button on the lower right.
", 1, play_mode > 1.9999);
brightness_knob.gfx_draw_icon(7, play_mode > 1.9999);
cx += 2 * radius + knob_spacing;
custom_partials.amp.over && (model == 11) ? (
  knob_glow(cx, cy, radius, 1.5 * custom_partials.amp.over * abs(sin(time_precise())));
);
position_knob.draw_knob(cx, cy, radius, "", "Relative Position", 1, 1);
position_knob.gfx_draw_icon(0, 1);
cx += 2 * radius + knob_spacing;
damp_knob.draw_knob(cx, cy, radius, "", "Frequency Independent Damping", 1, 1);
damp_knob.gfx_draw_icon(1, 1);
cx += 2 * radius + knob_spacing;
custom_partials.decay.over && (model == 11) ? (
  knob_glow(cx, cy, radius, custom_partials.decay.over * 1.5 * abs(sin(time_precise())));
);
freq_damp_knob.draw_knob(cx, cy, radius, "", "Frequency Dependent Damping", 1, 1);
freq_damp_knob.gfx_draw_icon(2, 1);
cx += 2 * radius + knob_spacing;
((custom_partials.rfreq.over || custom_partials.afreq.over) && (model == 11)) ? (
  knob_glow(cx, cy, radius, 1.5 * (custom_partials.rfreq.over || custom_partials.afreq.over) * abs(sin(time_precise())));
);
inharmonic_knob.draw_knob(cx, cy, radius, "", "Inharmonicity", 1, 1);
inharmonic_knob.gfx_draw_icon(3, 1);
cx += 2 * radius + knob_spacing;
stereo = stereoToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, stereo, "Stereoize the output.", mouse_x, mouse_y, mouse_cap);
stiffness_exp_knob.draw_knob(cx, cy, radius, "", "Input Non-Linearity", 1, 1);
stiffness_exp_knob.gfx_draw_icon(5, 1);
cx += 2 * radius + knob_spacing;
stft = 1 - stftToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, 1 - stft, "Time domain mode\n\nTime domain mode allows using feedback but\nrequires significantly more CPU (especially\nwhen using a large number of partials).\n\nIn addition, it runs the risk of instability, so\nwhile it can be used to obtain creative effects\nit's not really recommended for live use.", mouse_x, mouse_y, mouse_cap);
(last_stft != stft) ? (
  settings_changed = 1;
);
last_stft = stft;

force_fb.draw_knob(cx, cy, radius, "", "Feedback Level", 1, 1 - stft);
force_fb.gfx_draw_icon(6, 1 - stft);
cx += 2 * radius + knob_spacing;

max_partial = max(string5.used_partials, max(string4.used_partials, max(string3.used_partials, max(string2.used_partials, string1.used_parials))));
partials.textbox_control(cx + 0.9 * radius, cy - 1.2 * radius, 12, 1.0 - stft, sprintf(22, 
"Number of partials to use.

More leads to more high frequencies but higher CPU use.
Low notes tend to require more partials. The currently 
highest requested count is: %d
", max_partial), 16);
partials.over ? (
  (mouse_cap & 2 == 2) ? (
    menu_selection = gfx_showmenu("16|32|48|64");
  );
  menu_selection ? (
    partials = 16 * menu_selection;
  );
);

stiffness_knob.draw_knob(cx, cy, radius, "", "Stiffness (tends to make things louder)", 1, 1 - stft);
stiffness_knob.gfx_draw_icon(4, 1 - stft);
cx += 2 * radius + knob_spacing;

choice_x = cx - radius;

choice_button1.draw_choice(0, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Metal string");
choice_button1.draw_model_icon();
choice_button2.draw_choice(1, cx - radius, cy, radius, radius, 1, "Tube");
choice_button2.draw_model_icon();
cx += radius + 4;

choice_button3.draw_choice(2, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beating");
choice_button3.draw_model_icon();
choice_button4.draw_choice(3, cx - radius, cy, radius, radius, 1, "Beam (both ends open)");
choice_button4.draw_model_icon();
cx += radius + 4;

choice_button5.draw_choice(4, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beam (one end clamped)");
choice_button5.draw_model_icon();
choice_button6.draw_choice(5, cx - radius, cy, radius, radius, 1, "Membrane");
choice_button6.draw_model_icon();
cx += radius + 4;

choice_button7.draw_choice(6, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Marimba");
choice_button7.draw_model_icon();
choice_button8.draw_choice(7, cx - radius, cy, radius, radius, 1, "Pan");
choice_button8.draw_model_icon();
cx += radius + 4;

choice_button9.draw_choice(8, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Male vowels");
choice_button9.draw_model_icon();
choice_button10.draw_choice(9, cx - radius, cy, radius, radius, 1, "Female vowels");
choice_button10.draw_model_icon();
cx += radius + 4;

choice_button11.draw_choice(11, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Custom\n\nCustom model that allows customization\nof two spectra. Interpolation between\nthese spectra is then controlled with\nthe macro controls.");
choice_button11.draw_model_icon();
choice_button12.draw_choice(12, cx - radius, cy, radius, radius, 1, "Custom\n\nCustom model that provides only a single\nspectrum.\n\nThe macro controls then retain the same\nfunction as they did for the built-in spectra.");
choice_button12.draw_model_icon();
cx += radius + 4;

bins = 100;

/*
gfx_set(1, 1, 1, 1);
ptr = vowel;
x = 0;
init_vowels(vowel);
loop(64100,
  gfx_circle(0.013 * x, 0.5 * gfx_h - 15 * log10(ptr[]), 1);
  x += 1;
  ptr += 1;
);
*/

function draw_envelope(x, y, w, h)
instance(t_max, last_x, last_y, last_cap)
local(plot_srate, attack_samples, decay_samples,
      k_attack, k_decay, k_release,
      x_cur, y_cur, x_new, y_new, state, rate, current_target, target,
      time_per_pixel, attack_pos, decay_pos, modifier, dx,
      over, highlight)
global(mlog0p05, attack_s, decay_s, release_s, sustain_level, gfx_a,
       mouse_x, mouse_y, mouse_wheel, mouse_cap, captured,
       attack_slider, decay_slider, release_slider, sustain_level,
       hinter.sethint, hinter.hint_time)
(
  gfx_set(0, 0, 0, 0.2);
  gfx_rect(x, y, w, h, 1);
  
  plot_srate = (w - 4) / t_max;
  
  attack_samples = attack_s * plot_srate;
  decay_samples = 2 * decay_s * plot_srate;
  k_attack = mlog0p05 / attack_samples;
  k_decay = mlog0p05 / (decay_s * plot_srate);
  k_release = mlog0p05 / (release_s * plot_srate);
  
  (t_max == 0) ? t_max = 0.1;
  over = (mouse_x > x) && (mouse_y > y) && (mouse_y < (y + h));
  (over) ? (
    (abs(mouse_wheel) > 0) ? (
      modifier = 0.00025 * t_max;
      (mouse_cap & 4 > 0) ? modifier *= 0.5;
      (mouse_cap & 8 > 0) ? modifier *= 0.25;
      t_max = max(0.0001, min(t_max - modifier * mouse_wheel, attack_s + 2 * decay_s + release_s));
      mouse_wheel = 0;
    );
  
    time_per_pixel = t_max / w;
    attack_pos = attack_s / time_per_pixel;
    decay_pos = 2 * decay_s / time_per_pixel;
    
    (last_cap == 0) ? (
      (mouse_x < (x + attack_pos)) ? (
        over = 2;
      ) : (mouse_x < (x + attack_pos + decay_pos)) ? (
        over = 3;
      ) : (
        over = 4;
      );
    ) : (
      (captured == 100) ? ( over = 2; )
      : (captured == 101) ? ( over = 3; )
      : (captured == 102) ? ( over = 4; )
    );
  
    (last_cap == 0) && (mouse_cap == 1) ? (
      // Fetch click ranges for the various parts of the envelope
      time_per_pixel = t_max / w;
      attack_pos = attack_s / time_per_pixel;
      decay_pos = 2 * decay_s / time_per_pixel;
    
      (over == 2) ? (
        captured = 100;
      ) : (over == 3) ? (
        captured = 101;
      ) : (over == 4) ? (
        captured = 102;
      );
    );
  );
  
  x_cur = x + 2;
  y_cur = y + h - 4;
  state = 0;
  loop(w - 4,
    x_new = x_cur + 1;
    y_new = y + 1 + (h - 4) * (1 - state);
    
    (attack_samples > 0) ? (
      rate = k_attack;
      current_target = 1;
      highlight = (over == 2);
      attack_samples -= 1;
      (attack_samples == 0) ? state = 1;
    ) : (
      // Release and decay
      (decay_samples > 0) ? (
        rate = k_decay;
        current_target = sustain_level;
        highlight = (over == 3);
        decay_samples -= 1;
        (decay_samples == 0) ? state = sustain_level;
      ) : (
        rate = k_release;
        current_target = 0;
        highlight = (over == 4);
      );
    );
    
    state += min(1, rate * (current_target - state));
  
    colormodel(0.94); gfx_a = 0.2 + 0.2 * highlight * abs(sin(2 * time_precise()));
    gfx_line(x_cur + 1, y + h - 3, x_new + 1, y_new);

    colormodel(1);
    highlight ? (
      gfx_a = 0.8 * abs(sin(time_precise()));
      gfx_line(x_cur + 1, y_cur - 1, x_new + 1, y_new - 1);
      gfx_line(x_cur + 1, y_cur + 1, x_new + 1, y_new + 1);
    );
    gfx_a = 1;
    gfx_line(x_cur + 1, y_cur, x_new + 1, y_new);
    gfx_line(x_cur, y_cur + 1, x_new, y_new + 1);
    gfx_line(x_cur, y_cur, x_new, y_new);
    
    x_cur = x_new;
    y_cur = y_new;
  );
  
  ((captured > 99) && (captured < 103)) ? (
    (mouse_cap == 0) ? (
      captured = 0;
    ) : (
      
    
      modifier = 0.01;
      (mouse_cap & 4 > 0) ? modifier *= 0.5;
      (mouse_cap & 8 > 0) ? modifier *= 0.25;
      
      dx = modifier * (mouse_x - last_x);
      (captured == 100) ? (
        // Attack
        attack_slider = min(2, max(0, attack_slider + dx));
        slider_automate(56);
        hinter.sethint(sprintf(90, "Attack:\n%.2f ms", attack_s * 1000));
        hinter.hint_time = 1000;
      ) : (captured == 101) ? (
        // Decay
        decay_slider = min(3, max(0, decay_slider + dx));
        slider_automate(57);
        sustain_level = min(1, max(0, sustain_level - modifier * (mouse_y - last_y)));
        slider_automate(59);
        hinter.sethint(sprintf(90, "Decay:\n%.2f ms\nSustain: %d \n", decay_s * 1000, 100 * sustain_level));
        hinter.hint_time = 1000;
      ) : (captured == 102) ? (
        // Release
        release_slider = min(3, max(0, release_slider + dx));
        slider_automate(58);
        hinter.sethint(sprintf(90, "Release:\n%.2f ms", release_s * 1000));
        hinter.hint_time = 1000;
      )
    );
  );
  
  colormodel(0);
  
  last_cap = mouse_cap;
  last_x = mouse_x;
  last_y = mouse_y;
  
  gfx_a = 0.7;
  gfx_rect(x, y, w, h, 0);
  gfx_rect(x + 1, y + 1, w - 2, h - 2, 0);
);

function draw_collapse_rect(x, y, w, h, label)
local(over)
global(gfx_a, mouse_x, mouse_y, mouse_cap, last_cap, hinter.sethint)
(
  over = (mouse_x < (x + w)) && (mouse_x > x) && (mouse_y < (y + h)) && (mouse_y > y);
  over ? hinter.sethint(label);
  
  gfx_a = 0.5 + 0.5 * over;
  gfx_rect(x, y, w, h);
  
  over && (mouse_cap == 1) && (last_cap == 0);
);

midi_input ? (
  use_envelopes ? (
    env.draw_envelope(floor(choice_x), floor(3 * radius + 8), floor((radius + 4) * 6 - 4), floor(2 * radius));
  );
  
  colormodel(use_envelopes);
  draw_collapse_rect(
    floor(choice_x), floor(3 * radius + 0.5 * button_size) + use_envelopes * floor(2 * radius) + use_envelopes * 1.5 * button_size, 
    floor((radius + 4) * 6 - 4), button_size,
    use_envelopes ? 
      "Disable envelope."
    : "Apply an envelope to the input and output of each string."
  ) ? (use_envelopes = 1 - use_envelopes);
  
  use_envelopes
);

gfx_x = 0;
gfx_y = 0;
function draw_logo(logomem, rle_mem, ys, x, y)
global(gfx_a)
local(xx, yy, offset, line, ptr, n_iter, current, count)
instance(s, i)
(
  line = 0;
  s += 1;
  colormodel(0);
  loop(230,
    xx = x + line * ys;
    offset = logomem[line];
    ptr = rle_mem + offset;
    n_iter = 0;
    yy = y;
    while((ptr[] != - 1) && (n_iter < 20)) (
      current = ptr[]; ptr += 1;
      (current > -1) ? (
        count = ptr[]; ptr += 1;
        current ? (
          i = abs(sin(0.1 * line - 0.1 * s));
          gfx_a = 0.1 + 0.5 * pow(i, 10);
          gfx_line(xx, yy, xx, yy + ys * count, 1);
        );
        yy += ys * count;
      );
      n_iter += 1;
    );
    line += 1;
  );
);

yy = 0.02 * _gfx_h + _gfx_h * 0.9;
//logo.draw_logo(logomem, rle_mem, 0.45, gfx_w - 110, gfx_h - 22);
logo.draw_logo(logomem, rle_mem, 0.45, 6, 6);

// Ctrl + Click the logo enters dev mode
((mouse_cap == 5) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  model = 10;
  settings_changed = 1;
);

// Ctrl + Shift + RMB the logo enters test mode
((mouse_cap == 6 + 8) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  test_mode = 1 - test_mode;
  settings_changed = 1;
);

gfx_x = 115; gfx_y = 3;
colormodel(0.4);
gfx_setfont(4, "Arial", 10 * max(1,scaling));
gfx_printf("v0.41 ALPHA (Warning: this plugin is not production ready and is still actively being developed)");

(model == 10) ? (
  colormodel(0.0);
  gfx_a = 0.3 * abs(sin(time_precise()));
  gfx_setfont(6, "Arial", 180);
  gfx_measurestr("DEV MODE", gw, gh);
  gfx_x = (_gfx_w - gw) / 2; gfx_y = (_gfx_h - gh) / 2;
  gfx_printf("DEV MODE")
);

gfx_setfont(4, "Arial", 10 * max(1,scaling));
hinter.drawhint();
newtime = time_precise();
delta_time = newtime - ctime;
ctime = newtime;

lx = mouse_x;
ly = mouse_y;
last_cap = mouse_cap;
mouse_cap == 0 ? captured = 0;

/*
gfx_x = 0;
gfx_y = 0;
gfx_set(1, 1, 1, 1);
fff = midi.note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 30;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 60;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_vel;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 90;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_state;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);
*/

