desc:Partials (Saike)
tags: modal effect
version: 0.14
author: Joep Vanlier
changelog: Hook up velocity to the impulse brightness.
license: MIT
provides:
  partials_dependencies/*
  saike_partials.jsfx.rpl
about:
  # An effect which simulates different materials
  This effect takes both audio and MIDI input. Based on the model selected the incoming audio will excite
  a number of resonators that produce particular sounds. Up to 4 note polyphony is supported.

slider1:model=0<0,1,11{Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice (male),Voice (female),Custom>-model
slider2:inverse_brightness=0<0,1,0.0001>-Inverse Brightness
slider3:relative_position=0.1<0.0001,0.999,0.001>-Relative position
slider4:damp=0.1<-2,2,0.0001>-Damping
slider5:freq_damp=-4<-6,-1,0.0001>-Frequency Dependent Damping
slider6:inharmonic=-4<-4, 0, 0.0001>-Inharmonic
slider7:stiffness=4.6<2,6,0.0001>-Stiffness
slider8:stiffness_exp=2.3<1,3.0,.0001>-Stiffness Exponent
slider9:placeholder=0<0,1,1>-Placeholder
slider10:base_note=0<-12,12,1>-Base note
slider11:force_fb=1<0,15,0.0001>-Forced feedback (TD only)
slider12:partials=32<16,64,16>-Partials
slider13:stereo=1<0,1,1{Off,On}>-Stereo-ize
slider14:position_vel=0<-1,1,0.000001>-Position velocity sensitivity
slider15:damp_vel=0<-4,4,0.000001>-Damping velocity sensitivity
slider16:freq_damp_vel=0<-5,5,0.000001>-Frequency dependent damping velocity sensitivity
slider17:inharmonic_vel=0<-4,4,0.000001>-Inharmonicity velocity sensitivity
slider18:midi_input=0<0,1,1{Off,On}>-Midi input
slider19:first_note=45<0,127,1>-Midi note 1
slider20:second_note=52<0,127,1>-Midi note 2
slider21:third_note=60<0,127,1>-Midi note 3
slider22:fourth_note=64<0,127,1>-Midi note 4
slider23:fifth_note=48<0,127,1>-Midi note 5
slider54:brightness_vel=0<0,1,0.0001>-Brightness vel
slider55:impulse_mode=0<0,3,1>Impulse mode
slider56:attack_slider=0<0,2,0.0001>-Attack
slider57:decay_slider=1<0,3,0.0001>-Decay
slider58:release_slider=1.5<0,3,0.0001>-Release
slider59:sustain_level=0.3<0,1,0.0001>-Sustain
slider60:use_envelopes=0<0,1,1>-Use Envelopes
slider61:pitch_shift=0<-24,24,0.000001>-Large pitch bend
slider62:display_log=0<0,1,1{Linear,Logarithmic}>-Display type
slider63:stft=1<0,1,1>-STFT

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

-- You can define a custom model in this file:
import saike_modal_custom.jsfx-inc

import saike_modal.jsfx-inc
import saike_modal_kp_midi.jsfx-inc
import saike_modal_stft.jsfx-inc
import saike_modal_gfx.jsfx-inc
import saike_vowel_data.jsfx-inc
import saike_modal_buffer.jsfx-inc
import saike_modal_impulses.jsfx-inc

@init
gfx_ext_retina = 1;
version = 2;

brightness_knob.init_knob(1, 0, 0.1, 2, 54);
position_knob.init_knob(0, 1, 0.1, 3, 14);
damp_knob.init_knob(-2, 2, 0.1, 4, 15);
freq_damp_knob.init_knob(-6, -1, -4, 5, 16);
inharmonic_knob.init_knob(-4, 0, -4, 6, 17);
stiffness_knob.init_knob(3, 6, 4.6, 7, 0);
stiffness_exp_knob.init_knob(1.0, 3.0, 2.3, 8, 0);
force_fb.init_knob(0, 15.0, 1.0, 11, 0);
partials.init_knob(16, 64, 32, 12, 0);

function initialize_memory()
local(logo_handle, freemem, lowcut, lowcut_freq, delay_ms, count)
instance()
global(
  rle_mem, logomem, logo_line_count,
  stft_mem.fft_mem, string1.string_mem, string2.string_mem, string3.string_mem, string4.string_mem, string5.string_mem,
  stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem,
  gfx_stft_mem.fft_mem, gfx_string.string_mem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem,
  gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval,
  bessel_roots,
  midi.init_midi,
  buffer.init_buffer,
  buffer.set_offset,
  hp.init_linearSVF,
  srate,
)
(
  freemem = 0;
  freemem = stft_mem.fft_mem(freemem, 64);
  freemem = string1.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string2.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string3.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string4.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string5.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  
  freemem = gfx_stft_mem.fft_mem(freemem, 512);
  freemem = gfx_string.string_mem(freemem, gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem);
  
  freemem = (bessel_roots = freemem) + 2048;
  memset(bessel_roots, 0, 2048);
  bessel_roots[0] = 1.000000; bessel_roots[1] = 2.917295; bessel_roots[2] = 4.831885; bessel_roots[3] = 6.746213; bessel_roots[4] = 8.660476; bessel_roots[5] = 10.574713; bessel_roots[6] = 12.488940; bessel_roots[7] = 14.403161; bessel_roots[8] = 16.317378; bessel_roots[9] = 18.231593; bessel_roots[10] = 20.145807; bessel_roots[11] = 22.060020; bessel_roots[12] = 23.974232; bessel_roots[13] = 25.888443; bessel_roots[14] = 27.802654; bessel_roots[15] = 29.716865; bessel_roots[16] = 31.631075;
  bessel_roots[17] = 33.545286; bessel_roots[18] = 35.459496; bessel_roots[19] = 37.373706; bessel_roots[20] = 39.287916; bessel_roots[21] = 41.202125; bessel_roots[22] = 43.116335; bessel_roots[23] = 45.030545; bessel_roots[24] = 46.944754; bessel_roots[25] = 48.858964; bessel_roots[26] = 50.773173; bessel_roots[27] = 52.687383; bessel_roots[28] = 54.601592; bessel_roots[29] = 56.515802; bessel_roots[30] = 58.430011; bessel_roots[31] = 60.344220; bessel_roots[32] = 62.258430;
  bessel_roots[33] = 64.172639; bessel_roots[34] = 66.086848; bessel_roots[35] = 68.001058; bessel_roots[36] = 69.915267; bessel_roots[37] = 71.829476; bessel_roots[38] = 73.743685; bessel_roots[39] = 75.657895; bessel_roots[40] = 77.572104; bessel_roots[41] = 79.486313; bessel_roots[42] = 81.400522; bessel_roots[43] = 83.314731; bessel_roots[44] = 85.228941; bessel_roots[45] = 87.143150; bessel_roots[46] = 89.057359; bessel_roots[47] = 90.971568; bessel_roots[48] = 92.885777;
  bessel_roots[49] = 94.799986; bessel_roots[50] = 96.714196; bessel_roots[51] = 98.628405; bessel_roots[52] = 100.542614; bessel_roots[53] = 102.456823; bessel_roots[54] = 104.371032; bessel_roots[55] = 106.285241; bessel_roots[56] = 108.199450; bessel_roots[57] = 110.113660; bessel_roots[58] = 112.027869; bessel_roots[59] = 113.942078; bessel_roots[60] = 115.856287; bessel_roots[61] = 117.770496; bessel_roots[62] = 119.684705; bessel_roots[63] = 121.598914; bessel_roots[64] = 123.513123;
  bessel_roots[65] = 125.427332; bessel_roots[66] = 127.341542; bessel_roots[67] = 129.255751; bessel_roots[68] = 131.169960; bessel_roots[69] = 133.084169; bessel_roots[70] = 134.998378; bessel_roots[71] = 136.912587; bessel_roots[72] = 138.826796; bessel_roots[73] = 140.741005; bessel_roots[74] = 142.655214; bessel_roots[75] = 144.569423; bessel_roots[76] = 146.483633; bessel_roots[77] = 148.397842; bessel_roots[78] = 150.312051; bessel_roots[79] = 152.226260; bessel_roots[80] = 154.140469;
  bessel_roots[81] = 156.054678; bessel_roots[82] = 157.968887; bessel_roots[83] = 159.883096; bessel_roots[84] = 161.797305; bessel_roots[85] = 163.711514; bessel_roots[86] = 165.625723; bessel_roots[87] = 167.539933; bessel_roots[88] = 169.454142; bessel_roots[89] = 171.368351; bessel_roots[90] = 173.282560; bessel_roots[91] = 175.196769; bessel_roots[92] = 177.110978; bessel_roots[93] = 179.025187; bessel_roots[94] = 180.939396; bessel_roots[95] = 182.853605; bessel_roots[96] = 184.767814;
  bessel_roots[97] = 186.682023; bessel_roots[98] = 188.596232; bessel_roots[99] = 190.510441; bessel_roots[100] = 192.424651; bessel_roots[101] = 194.338860; bessel_roots[102] = 196.253069; bessel_roots[103] = 198.167278; bessel_roots[104] = 200.081487; bessel_roots[105] = 201.995696; bessel_roots[106] = 203.909905; bessel_roots[107] = 205.824114; bessel_roots[108] = 207.738323; bessel_roots[109] = 209.652532; bessel_roots[110] = 211.566741; bessel_roots[111] = 213.480950; bessel_roots[112] = 215.395159;
  bessel_roots[113] = 217.309368; bessel_roots[114] = 219.223578; bessel_roots[115] = 221.137787; bessel_roots[116] = 223.051996; bessel_roots[117] = 224.966205; bessel_roots[118] = 226.880414; bessel_roots[119] = 228.794623; bessel_roots[120] = 230.708832; bessel_roots[121] = 232.623041; bessel_roots[122] = 234.537250; bessel_roots[123] = 236.451459; bessel_roots[124] = 238.365668; bessel_roots[125] = 240.279877; bessel_roots[126] = 242.194086; bessel_roots[127] = 244.108295; bessel_roots[128] = 246.022504; bessel_roots[129] = 247.936713; bessel_roots[130] = 249.850923; bessel_roots[131] = 251.765132; bessel_roots[132] = 253.679341;
  bessel_roots[133] = 255.593550; bessel_roots[134] = 257.507759; bessel_roots[135] = 259.421968; bessel_roots[136] = 261.336177; bessel_roots[137] = 263.250386; bessel_roots[138] = 265.164595; bessel_roots[139] = 267.078804; bessel_roots[140] = 268.993013; bessel_roots[141] = 270.907222; bessel_roots[142] = 272.821431; bessel_roots[143] = 274.735640; bessel_roots[144] = 276.649849; bessel_roots[145] = 278.564059; bessel_roots[146] = 280.478268; bessel_roots[147] = 282.392477; bessel_roots[148] = 284.306686;
  bessel_roots[149] = 286.220895; bessel_roots[150] = 288.135104; bessel_roots[151] = 290.049313; bessel_roots[152] = 291.963522; bessel_roots[153] = 293.877731; bessel_roots[154] = 295.791940; bessel_roots[155] = 297.706149; bessel_roots[156] = 299.620358; bessel_roots[157] = 301.534567; bessel_roots[158] = 303.448776; bessel_roots[159] = 305.362985; bessel_roots[160] = 307.277194; bessel_roots[161] = 309.191403; bessel_roots[162] = 311.105613; bessel_roots[163] = 313.019822; bessel_roots[164] = 314.934031;
  bessel_roots[165] = 316.848240; bessel_roots[166] = 318.762449; bessel_roots[167] = 320.676658; bessel_roots[168] = 322.590867; bessel_roots[169] = 324.505076; bessel_roots[170] = 326.419285; bessel_roots[171] = 328.333494; bessel_roots[172] = 330.247703; bessel_roots[173] = 332.161912; bessel_roots[174] = 334.076121; bessel_roots[175] = 335.990330; bessel_roots[176] = 337.904539; bessel_roots[177] = 339.818748; bessel_roots[178] = 341.732957; bessel_roots[179] = 343.647167; bessel_roots[180] = 345.561376;
  bessel_roots[181] = 347.475585; bessel_roots[182] = 349.389794; bessel_roots[183] = 351.304003; bessel_roots[184] = 353.218212; bessel_roots[185] = 355.132421; bessel_roots[186] = 357.046630; bessel_roots[187] = 358.960839; bessel_roots[188] = 360.875048; bessel_roots[189] = 362.789257; bessel_roots[190] = 364.703466; bessel_roots[191] = 366.617675; bessel_roots[192] = 368.531884; bessel_roots[193] = 370.446093; bessel_roots[194] = 372.360302; bessel_roots[195] = 374.274511; bessel_roots[196] = 376.188720; bessel_roots[197] = 378.102930; bessel_roots[198] = 380.017139;
  
  freemem = midi.init_midi(freemem);
  
  buffer.init_buffer(freemem, freemem + 32766);
  freemem += 32768;
  
  delay_ms = 16.12;
  buffer.set_offset(delay_ms * srate / 1000);
  lowcut = 0.34;
  lowcut_freq = exp((1-LowCut) * log(20/22050));
  hp.init_linearSVF(lowcut_freq, 0);
  //displayFreq = 0.5 * srate * lowcut_freq / $pi;
  
  freemem = init_vowels(freemem);
  
  logomem = freemem;
  logo_handle = file_open("partials_dependencies/logo.ske");
  file_var(logo_handle, logo_line_count);
  file_mem(logo_handle, logomem, logo_line_count);
  rle_mem = logomem + logo_line_count + 1;
  file_var(logo_handle, count);
  file_mem(logo_handle, rle_mem, count);
  file_close(logo_handle);
);

function tanh(x)
local()
global()
instance()
(
  (2/(1+exp(-2*x)) - 1)
);

function set_pars(f_0, vel)
local()
global(
  stft,
  relative_position, damp, freq_damp, inharmonic,
  position_vel, damp_vel, freq_damp_vel, inharmonic_vel,
)
instance(base_damp, f_damp, inharm, rel_position)
(
  // position 0 to 1
  // damp -2 to 2
  // freq_damp -6 to -1
  // inharmonic -4 to 0
  rel_position = min(max(0, relative_position + position_vel * vel), 1);
  base_damp = 10^(min(max(-2, damp + damp_vel * vel), 2));
  f_damp = 10^(min(max(-6, freq_damp + freq_damp_vel * vel), -1));
  inharm = 10^(min(max(-4, inharmonic + inharmonic_vel * vel), 0));

  stft ? (
    this.set_pars_stft(f_0);
  ) : (
    this.set_pars_td(f_0);
  );
);

function eval_string(f_h, env, on)
local(input_active)
global(stft, impulse_mode, stft_mem.fft_size)
instance()
(
  stft ? (
    // Impulses are added at the global level below, since the STFT
    // variant only uses one STFT for the entire input.
    input_active = impulse_mode ? this.impulse.impulse_alive(stft_mem.fft_size) : 1;

    this.eval_string_stft(env * input_active, env, on);
  ) : (
    /* Add string specific impulse if relevant */
    impulse_mode ? (
      f_h += this.impulse.eval_impulse();
    );
    this.eval_string_td(on ? f_h * env : 0);
  );
);

function update_env_note(vel, state)
instance(last_vel, target, sustain, rate,
         k_attack, k_decay, attack_samples)
local()
global(srate, mlog0p05, attack_s, decay_s, release_s, sustain_level)
(
  target = 2 * vel;
  sustain = sustain_level * target;
  
  state ? (
    // Change!
    vel ? (
      attack_samples = attack_s * srate;
      k_attack = mlog0p05 / attack_samples;
      k_decay = mlog0p05 / (decay_s * srate);
    ) : (
      // Note is off => release!
      attack_samples = 0;
      k_decay = mlog0p05 / (release_s * srate);
    );
  );
  last_vel = vel;
);

function env_sample()
instance(state, target, sustain, 
         attack_samples,
         k_attack, k_decay)
local(current_target, rate)
global()
(
  (attack_samples > 0) ? (
    rate = k_attack;
    current_target = target;
  ) : (
    // Release and decay
    rate = k_decay;
    current_target = sustain;
  );
  attack_samples -= 1;
  
  state += rate * (current_target - state);
);


function update_notes()
instance(notes_on, active_note_mem, active_note_vel, active_note_state,
         note_on0, note_on1, note_on2, note_on3, note_on4)
global(string1.set_pars, string2.set_pars, string3.set_pars, string4.set_pars, string5.set_pars, pitch_shift, midi.pitchbend,
       use_envelopes, envelope1.update_env_note, envelope2.update_env_note, envelope3.update_env_note, envelope4.update_env_note, envelope5.update_env_note,
       string1.impulse.update_impulse_note,
       string2.impulse.update_impulse_note,
       string3.impulse.update_impulse_note,
       string4.impulse.update_impulse_note,
       string5.impulse.update_impulse_note
       impulse_mode,
       inverse_brightness, brightness_vel)
local(ref_pitch, scaling
      note_vel0, note_vel1, note_vel2, note_vel3, note_vel4)
(
  scaling = 440;
  ref_pitch = 2 * midi.pitchbend + pitch_shift - 69;
  
  note_vel0 = active_note_vel[0];
  note_vel1 = active_note_vel[1];
  note_vel2 = active_note_vel[2];
  note_vel3 = active_note_vel[3];
  note_vel4 = active_note_vel[4];
  
  note_on0 = active_note_mem[0];
  note_on1 = active_note_mem[1];
  note_on2 = active_note_mem[2];
  note_on3 = active_note_mem[3];
  note_on4 = active_note_mem[4];

  // Update note parameters
  note_on0 ? string1.set_pars(scaling * 2 ^ ((active_note_mem[0] + ref_pitch) / 12), note_vel0);
  note_on1 ? string2.set_pars(scaling * 2 ^ ((active_note_mem[1] + ref_pitch) / 12), note_vel1);
  note_on2 ? string3.set_pars(scaling * 2 ^ ((active_note_mem[2] + ref_pitch) / 12), note_vel2);
  note_on3 ? string4.set_pars(scaling * 2 ^ ((active_note_mem[3] + ref_pitch) / 12), note_vel3);
  note_on4 ? string5.set_pars(scaling * 2 ^ ((active_note_mem[4] + ref_pitch) / 12), note_vel4);
  
  use_envelopes ? (
    envelope1.update_env_note(note_vel0, active_note_state[0]);
    envelope2.update_env_note(note_vel1, active_note_state[1]);
    envelope3.update_env_note(note_vel2, active_note_state[2]);
    envelope4.update_env_note(note_vel3, active_note_state[3]);
    envelope5.update_env_note(note_vel4, active_note_state[4]);
  );
  
  impulse_mode ? (
    string1.impulse.update_impulse_note(active_note_state[0], inverse_brightness + brightness_vel * note_vel0);
    string2.impulse.update_impulse_note(active_note_state[1], inverse_brightness + brightness_vel * note_vel1);
    string3.impulse.update_impulse_note(active_note_state[2], inverse_brightness + brightness_vel * note_vel2);
    string4.impulse.update_impulse_note(active_note_state[3], inverse_brightness + brightness_vel * note_vel3);
    string5.impulse.update_impulse_note(active_note_state[4], inverse_brightness + brightness_vel * note_vel4);
  );
  
  active_note_state[0] = 0;
  active_note_state[1] = 0;
  active_note_state[2] = 0;
  active_note_state[3] = 0;
  active_note_state[4] = 0;
);

function force_update()
(
  string1.ticker += 1000;
  string2.ticker += 1000;
  string3.ticker += 1000;
  string4.ticker += 1000;
  string5.ticker += 1000;
  midi.update_notes();
);

initialize_memory();
midi.reset_midi();

settings_changed = 1;

@slider
settings_changed = 1;

@block
(srate != last_srate) ? (
  prepare_impulse_globals();
  last_srate = srate;
);

mlog0p05 = 2.995732273553991; // Corresponds to time to get to 95%
attack_s = exp(-5.809142990314027 + 2.302585092994046 * attack_slider); // 3 - 300 ms <=> 0 - 2
decay_s = exp(-5.809142990314027 + 2.302585092994046 * decay_slider); // 3 - 3000 ms <=> 0 - 3
release_s = exp(-5.809142990314027 + 2.302585092994046 * release_slider); // 3 - 3000 ms <=> 0 - 3

midi.midi_block();

@sample
update_global_parameters();

function update_fixed_notes()
local(change, val, ix, idx)
global(settings_changed)
instance(active_note_mem, active_note_vel, notes_on)
(
  ix = 19;
  idx = 0;
  change = 0;
  loop(5,
    // If this one is used, store it in the active note memory.
    val = slider(ix);
    val ? (
      change = (active_note_mem[idx] != val) ? 1 : change;
      active_note_mem[idx] = val;
      active_note_vel[idx] = 1.0;
      idx += 1;
    );
    ix += 1;
  );
  notes_on = idx;
  val = 5 - idx;
  loop(val,
    change = (active_note_mem[idx] != 0) ? 1 : change;
    active_note_mem[idx] = 0;
    active_note_vel[idx] = 0;
    idx += 1;
  );
  change ? (
    settings_changed = 1;
  );
);

midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);
midi.curSample += 1;

!midi_input ? (
  midi.update_fixed_notes();
);

f_hn = 0;
f_b = 0;

stft ? (
  impulse_mode ? (
    f_h += string1.impulse.eval_impulse() * 4;
    f_h += string2.impulse.eval_impulse() * 4;
    f_h += string3.impulse.eval_impulse() * 4;
    f_h += string4.impulse.eval_impulse() * 4;
    f_h += string5.impulse.eval_impulse() * 4;
  );

  stft_mem.read_stft(f_h);
);

(midi_input && use_envelopes) ? (
  string1.eval_string(f_h, envelope1.env_sample(), midi.note_on0);
  string2.eval_string(f_h, envelope2.env_sample(), midi.note_on1);
  string3.eval_string(f_h, envelope3.env_sample(), midi.note_on2);
  string4.eval_string(f_h, envelope4.env_sample(), midi.note_on3);
  string5.eval_string(f_h, envelope5.env_sample(), midi.note_on4);
) : (
  string1.eval_string(f_h, 1, midi.note_on0);
  string2.eval_string(f_h, 1, midi.note_on1);
  string3.eval_string(f_h, 1, midi.note_on2);
  string4.eval_string(f_h, 1, midi.note_on3);
  string5.eval_string(f_h, 1, midi.note_on4);
);

stft ? (
  stft_mem.write_stft();
  f_b = stft_mem.f_b;
  f_hn = stft_mem.f_hn;
) : (
  (midi_input && use_envelopes) ? (
    f_b += string1.f_b * envelope1.state; f_hn += string1.f_hn;
    f_b += string2.f_b * envelope2.state; f_hn += string2.f_hn;
    f_b += string3.f_b * envelope3.state; f_hn += string3.f_hn;
    f_b += string4.f_b * envelope4.state; f_hn += string4.f_hn;
    f_b += string5.f_b * envelope5.state; f_hn += string5.f_hn;
  ) : (
    f_b += string1.f_b; f_hn += string1.f_hn;
    f_b += string2.f_b; f_hn += string2.f_hn;
    f_b += string3.f_b; f_hn += string3.f_hn;
    f_b += string4.f_b; f_hn += string4.f_hn;
    f_b += string5.f_b; f_hn += string5.f_hn;
  );
);

hammer = 0;

function soft_clip(x)
(
  (abs(x) < 1) ? 1.5 * x - 0.5 * x * x * x : sign(x)
);

amp_factor = 10^stiffness;

stft ? (
  f_h = spl0;
  f_h = -(f_h > 0 ? 100000 * f_h ^ stiffness_exp : 0);
  //f_h = soft_clip(Adivfs*f_h) * srate;
) : (
  hammer ? (
    // WIP dynamical model (broken for now)
    f_h = (1 + force_fb) * f_hn;
    f_h += spl0;
    mh = 4.9;
    ah = -(1.0 / mh) * fdy;
    vh = vh + (1.0/srate) * ah;
    yh = yh + (1.0/srate) * vh;
    dy = - f_h + yh;
    fdy = ((dy > 0) ? amp_factor * dy ^ stiffness_exp : 0);
    f_h = fdy;
  ) : (
    // No hammer but simple feedback
    f_h = force_fb * f_hn;
    f_h += spl0;
    f_h = -(f_h > 0 ? amp_factor * f_h ^ stiffness_exp : 0);
    //f_h = soft_clip(Adivfs*f_h) * srate;
  );
);

stereo ? (
  buffer.update_buffer(f_b);
  rb = buffer.read_buffer();

  /* Highpass the added comb filter signal */
  rb = hp.eval_linearSVF_HP6(rb);
  
  spl0 = f_b + 0.33 * rb;
  spl1 = f_b - 0.33 * rb;
) : (
  spl0 = spl1 = f_b;
);

!stft ? (
  // Gain normalization in case of feedback system
  spl0 /= amp_factor * 0.00001;
  spl1 /= amp_factor * 0.00001;
);

settings_changed ? (
  settings_changed = 0;
  force_update();
);

@serialize
file_var(0, version);
(version > 1) ? (
  file_var(0, env.t_max);
) : (
  env.t_max = 0.1;
  use_envelopes = 0;
);
version = 2;

@gfx 1080 280
//scaling = gfx_ext_retina == 2 ? 1 : 0;
scaling = gfx_w / 1080;

//gfx_set(0, 0, 0, 1);
//gfx_rect(0, 0, gfx_w, gfx_h);

((init_w != gfx_w) || (init_h != gfx_h) || (model != last_model)) ? (
  init_w = gfx_w;
  init_h = gfx_h;
  last_model = model;
  settings_changed = 1;
  gfx_setimgdim(1, gfx_w, gfx_h);
  gfx_dest = 1;
  gfx_set(0, 0, 0, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);
  
  loop(100,
    xx = gfx_w * rand();
    yy = gfx_h * rand();
    colormodel(rand()*rand()*rand()); gfx_a = 0.2;
    gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
  );
  loop(5,
    gfx_x = gfx_y = 0;
    gfx_blurto(gfx_w, gfx_h)
  );
  
  gfx_dest = -1;
);


gfx_dest = 1;
xx = gfx_w * rand();
yy = gfx_h * rand();
colormodel(rand()*rand()*rand()); gfx_a = 0.2;
gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
/*
xx = 2 * gfx_w * rand();
yy = gfx_h * rand();
loop(10,
  colormodel(0); gfx_a = 0.1;
  gfx_line(xx, 1, xx - gfx_h * 2, gfx_h + 1);
  gfx_line(xx, 2, xx - gfx_h * 2, gfx_h + 2);
  gfx_a = 10;
  gfx_line(xx, 0, xx - gfx_h * 2, gfx_h);
);
*/
gfx_x = gfx_y = 0;
gfx_blurto(gfx_w, gfx_h);
gfx_dest = -1;

gfx_x = gfx_y = 0; gfx_a = 0.25;
gfx_blit(1, 1, 0);



/*
gfx_set(0.3, 0.3, 0.7, 1);
ix = 0;
loop(string1.fft_size,
  yc = 0.5 * gfx_h * sqrt(string1.coeff_mem[2 * ix]^2 + string1.coeff_mem[2 * ix + 1]^2);
  gfx_rect(2 * ix, gfx_h - yc, 1, yc);
  ix += 1;
);
*/

function simple_arrow(xx, yy, _r)
local(dr)
global()
(
  dr = ceil(0.06 * _r);
  xx = floor(xx);
  yy = floor(yy);
  _r = floor(_r);
  gfx_line(xx, yy - 0.4 * _r, xx, yy - 2 * dr - 1);
  gfx_line(xx + 1, yy - 0.4 * _r, xx + 1, yy - 2 * dr - 1);
  gfx_line(xx - 1, yy - 0.4 * _r, xx - 1, yy - 2 * dr - 1);
  gfx_triangle(xx - dr, yy - 2 * dr, xx + dr, yy - 2 * dr, xx, yy);
);

function gfx_draw_icon(id, enabled)
local(len, xp, xx, yy, dr, s, ds, cy, sy, ang1, ang2, x1, x2, y1, y2)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _r, relative_position)
( 
  colormodel(0.9);
  id == 0 ? (
    // Position
    len = ceil(0.6 * _r);
    yy = _y + 0.1 * _r;
    gfx_line(_x - len, yy, _x + len, yy, 1);
    gfx_line(_x - len, yy + 1, _x + len, yy + 1, 1);
    
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(xx, yy, _r);
  ) : ( id == 1 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 5 * relative_position / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * s - sy);
        s -= ds * s;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 2 ) ? (
    // Freq Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > 2 * (1 - relative_position) * len) ? cy -= 2 / len;
        cy = max(0, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 3 ) ? (
    // Spring
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 4.0 * relative_position;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(8.5 * len,
        cy = (1 - 0.4 * relative_position) * s - sy;
        gfx_a = 0.5 + 0.4 * cos(cy);
        
        gfx_lineto(floor(_x + xx - sy + 5 * cos(cy) * tanh(xx / len)), floor(_y - sy + yy * sin(cy)));
        s += 0.35;
        xx += 0.25;
      );
      sy -= 1;
    );
  ) : ( id == 4 ) ? (
    // Stiffness
    len = ceil(0.6 * _r);
    yy = _y + 0.35 * _r;
    dr = _r * (0.5 + relative_position);
    
    gfx_a = 0.2 + 0.8 * enabled;
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(_x, _y + 0.05 * _r - 0.1 * _r * relative_position, _r);

    xx = _x - len + ceil(2 * len * relative_position);
    gfx_a = relative_position;
    simple_arrow(_x + 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    simple_arrow(_x - 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    
    gfx_a = 0.2 + 0.8 * enabled;
    ang1 = $pi + asin(0.45 * _r / dr);
    ang2 = $pi - asin(0.45 * _r / dr);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
  ) : ( id == 5 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 0.5 / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 0;
      gfx_x = xx;
      gfx_y = _y + yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * pow(s, 1 + 5 * relative_position) - sy);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 6 ) ? (
    gfx_a = enabled;
    x1 = floor(_x - 0.3 * _r);
    x2 = floor(_x + 0.3 * _r);
    dr = floor(0.07 * _r);
    gfx_circle(x1, y2, dr, 1);
  
    gfx_a = 0.1 + 0.9 * relative_position * enabled;
    y1 = floor(_y - 0.3 * _r);
    y2 = floor(_y + 0.3 * _r);
    
    loop(2,
      x1 = floor(_x - 0.3 * _r);
      x2 = floor(_x + 0.3 * _r);
      loop(2,
        gfx_line(x1, y1, x1, y2 - 3 * dr);
        gfx_line(x1, y1, x1, y1);
        gfx_line(x1 + 1, y1, x2 - 1, y1);
        gfx_line(x2, y1, x2, y2 - 1);
        gfx_line(x1 + 3 * dr, y2, x2, y2);    
        gfx_line(x1 + 3 * dr, y2 + 1, x1 + 4 * dr, y2 + dr + 1);
        gfx_line(x1 + 3 * dr, y2 - 1, x1 + 4 * dr, y2 - dr - 1);
        x1 += 1;
        x2 += 1;
      );
      y1 += 1;
      y2 += 1;
    );
  );
);

function draw_model_icon()
local(s, ds, xx, yy, len, hh, xorig, yorig)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _w, _h, active, _me)
(
  colormodel(0.7); gfx_a = 1;
  (_me == 0) ? (
    len = floor(0.4 * _w);
    xx = _x + floor(0.5 * _w);
    yy = _y + 0.5 * _h;
    ds = ceil(0.05 * _w);
    s = ceil(0.2 * _w);
    
    gfx_line(xx - len, yy, xx + len, yy);
    gfx_line(xx - len, yy - ds, xx + len, yy - ds);
    gfx_line(xx - len, yy + ds, xx + len, yy + ds);
    gfx_line(xx - len, yy - 2 * ds, xx + len, yy - 2 * ds);
    gfx_line(xx - len, yy + 2 * ds, xx + len, yy + 2 * ds);
    gfx_circle(xx - ds, yy, s);
  ) : (_me == 1) ? (
    len = floor(0.25 * _h);
    ds = floor(0.08 * _w);
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    
    xx -= 3 * ds;
    loop(3,
      gfx_line(xx - ds, yy - len, xx - ds, yy + len);
      gfx_line(xx + ds, yy - len, xx + ds, yy + len);
      gfx_arc(xx, yy + len, ds, 0.5 * $pi, 1.5 * $pi);
      gfx_circle(xx, yy - len, ds);
      len -= 1;
      xx += 3 * ds;
    );
  ) : (_me == 2) ? (
    len = floor(0.3 * _w);
    ds = $pi / len;
    s = 0;
    yy = _y + 0.5 * _h;
    loop(2,
      xx = _x + floor(0.5 * _w) - len;
      gfx_x = xx;
      gfx_y = yy;
      loop(len * 2,
        gfx_lineto(xx, yy - .5 * len * sin(s));
        xx += 1;
        s += ds;
      );
      yy -= 1;
    );
  ) : (_me == 3) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 4) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_triangle(xx + 2 * len - 1, yy - 2, xx + 2 * len - ds - 1, yy - 2 * ds - 2, xx + 2 * len + ds - 1, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 5) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = 0.5 * $pi / len;
    hh = 0.12 * _h;
    loop(2 * len - 1,
      s += ds;
      colormodel(0.5); gfx_a = 0.5;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + 4 + hh * sqrt(sin(s)));
      colormodel(0.7); gfx_a = 1.0;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + hh * sqrt(sin(s)));
      xx += 1;
    );
  ) : (_me == 6) ? (
    len = floor(0.25 * _w);
    ds = floor(0.15 * _w);
    xx = _x + floor(0.47 * _w) - len;
    yy = _y + 0.5 * _h;
    gfx_line(xx, yy + len, xx + len, yy - len);
    gfx_line(xx, yy + len + 1, xx + len, yy - len + 1);
    gfx_circle(xx + len, yy - len + 1, ds / 2, 1);
    
    gfx_line(xx + ds, yy + len, xx + 2 * ds + len, yy - len + ds);
    gfx_line(xx + ds, yy + len + 1, xx + 2 * ds + len, yy - len + 1 + ds);
    gfx_circle(xx + 2 * ds + len, yy - len + 1 + ds, ds / 2, 1);
  ) : (_me == 7) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.35 * _w);
    ds = floor(0.15 * _w);
    gfx_circle(xx, yy, len, 0);
    gfx_circle(xx, yy, len + 0.5, 0);
    s = 0;
    loop(5,
      gfx_circle(xx + ds * sin(s), yy + ds * cos(s), ds, 0);
      s += 0.4 * $pi;
    );
  ) : (_me == 8 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len, 0);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len + 0.5, 0);
    xorig = xx - 0.25 * len + len / 1.41421 + 1;
    yorig = yy + 0.25 * len - len / 1.41421;
    gfx_line(xorig, yorig, xorig + 0.7 * len, yorig - 0.7 * len);
    gfx_line(xorig, yorig - 1, xorig + 0.7 * len, yorig - 0.7 * len - 1);
    xorig += 0.7 * len;
    yorig -= 0.7 * len;

    gfx_line(xorig, yorig - 1, xorig - 0.5 * len, yorig - 1);
//    gfx_line(xorig, yorig - 2, xorig - 0.5 * len, yorig - 2);
    gfx_line(xorig + 1, yorig - 1, xorig + 1, yorig + 0.5 * len);
//    gfx_line(xorig + 2, yorig - 2, xorig + 2, yorig + 0.5 * len);

  ) : (_me == 9 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.475 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx, yy - 0.5 * len, len, 0);
    gfx_circle(xx, yy - 0.5 * len, len + 0.5, 0);
    gfx_line(xx, yy + 0.5 * len + 1, xx, yy + 1.75 * len);
    gfx_line(xx - 0.5 * len, yy + 1.25 * len, xx + 0.5 * len, yy + 1.25 * len);
  );
);

gfx_string.draw_stft(0.02 * gfx_w, 0.02 * gfx_h, gfx_w * 0.93, gfx_h * 0.9);

function label_toggle(x, y, str, hint)
local(ww, hh, over)
global(mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y, last_cap, hinter.sethint)
(
  gfx_x = x; gfx_y = y;
  gfx_measurestr(str, ww, hh);
  gfx_printf(str);
  
  over = (mouse_x > x) && (mouse_x < (x + ww)) && (mouse_y > y) && (mouse_y < (y + hh));
  over ? hinter.sethint(hint);
  
  ((mouse_cap == 1) && (last_cap == 0)) ? (
    over ? 1
  );
);


gfx_setfont(3, "Arial", 12 * max(1, scaling));
colormodel(1 - display_log - 0.01);
label_toggle(0.02 * gfx_w, 0.93 * gfx_h, "[Linear] ", "Display frequencies on a linear scale") ? (display_log = 0);
colormodel(display_log);
label_toggle(gfx_x, gfx_y, "[Logarithmic]", "Display frequencies on a logarithmic scale") ? (display_log = 1);

keyboard.draw_keyboard(base_note, gfx_x + 0.01 * gfx_w, 0.935 * gfx_h, gfx_w * 0.82, 0.05 * gfx_y);

midi.note_on0 ? keyboard.highlight_note(midi.active_note_mem[0]);
midi.note_on1 ? keyboard.highlight_note(midi.active_note_mem[1]);
midi.note_on2 ? keyboard.highlight_note(midi.active_note_mem[2]);
midi.note_on3 ? keyboard.highlight_note(midi.active_note_mem[3]);
midi.note_on4 ? keyboard.highlight_note(midi.active_note_mem[4]);

note_over = keyboard.note_clicked();

gfx_setfont(3, "Arial", 12 * max(1, scaling));
colormodel(midi_input - 0.01);
label_toggle(keyboard._x + keyboard._w, 0.935 * gfx_h, " [MIDI]", "Use MIDI notes as input\n\nWhen enabled, the pitches are set\nby MIDI notes being received by the\nplugin. Note that you will still need an\naudio source in addition as input.\n") ? (
  midi_input = 1.0 - midi_input;
  memset(midi.active_note_mem, 0, 5);
  midi.notes_on = 0;
  settings_changed = 1;
);

colormodel(change_vel_mod - 0.01);
label_toggle(keyboard._x + keyboard._w + 30, 0.935 * gfx_h, " [Velocity]", "Click this to change the velocity sensitivity of the parameters.\nParameters that can be linked to MIDI note velocity will\nbe highlighted.\n\nChanging their settings will result in those parameters\nbeing sensitive to MIDI note velocity. This sensitivity is\nindicated by a differently colored arc.") ? (
  change_vel_mod = 1 - change_vel_mod;
);

function handle_non_midi_click(note_over)
instance(over)
local(idx, disabled_note)
global(keyboard.over, last_cap, mouse_cap, settings_changed, midi_input)
(
  this.over ? (
    (!midi_input) ? (
      (last_cap == 0) && (mouse_cap == 1) ? (
        settings_changed = 1;
        idx = 19;
        disabled_note = 0;
        loop(5,
          (slider(idx) == note_over) ? (
            slider_automate(slider(idx) = 0);
            disabled_note = 1;
          );
          idx += 1;
        );
        idx = 19;
        (!disabled_note) ? (
          loop(5,
            (slider(idx) == 0) ? (
              (!disabled_note) ? slider_automate(slider(idx) = note_over);
              disabled_note = 1;
            );
            idx += 1;
          );
        );
      );
    );
  );
);

keyboard.handle_non_midi_click(note_over);



radius = 0.032 * gfx_w;
button_size = 0.004 * gfx_w;
cx = 2 * radius;
cy = 2 * radius;
knob_spacing = 0.65 * radius;

label_font();
brightness_knob.draw_knob(cx, cy, radius, "", "Brightness", 1, 1);
brightness_knob.gfx_draw_icon(0, 1);
cx += 2 * radius + knob_spacing;
position_knob.draw_knob(cx, cy, radius, "", "Relative Position", 1, 1);
position_knob.gfx_draw_icon(0, 1);
cx += 2 * radius + knob_spacing;
damp_knob.draw_knob(cx, cy, radius, "", "Frequency Independent Damping", 1, 1);
damp_knob.gfx_draw_icon(1, 1);
cx += 2 * radius + knob_spacing;
freq_damp_knob.draw_knob(cx, cy, radius, "", "Frequency Dependent Damping", 1, 1);
freq_damp_knob.gfx_draw_icon(2, 1);
cx += 2 * radius + knob_spacing;
inharmonic_knob.draw_knob(cx, cy, radius, "", "Inharmonicity", 1, 1);
inharmonic_knob.gfx_draw_icon(3, 1);
cx += 2 * radius + knob_spacing;
stereo = stereoToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, stereo, "Stereoize the output.", mouse_x, mouse_y, mouse_cap);
stiffness_exp_knob.draw_knob(cx, cy, radius, "", "Input Non-Linearity", 1, 1);
stiffness_exp_knob.gfx_draw_icon(5, 1);
cx += 2 * radius + knob_spacing;
stft = 1 - stftToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, 1 - stft, "Time domain mode\n\nTime domain mode allows using feedback but\nrequires significantly more CPU (especially\nwhen using a large number of partials).\n\nIn addition, it runs the risk of instability, so\nwhile it can be used to obtain creative effects\nit's not really recommended for live use.", mouse_x, mouse_y, mouse_cap);
(last_stft != stft) ? (
  settings_changed = 1;
);
last_stft = stft;

force_fb.draw_knob(cx, cy, radius, "", "Feedback Level", 1, 1 - stft);
force_fb.gfx_draw_icon(6, 1 - stft);
cx += 2 * radius + knob_spacing;
stiffness_knob.draw_knob(cx, cy, radius, "", "Stiffness (tends to make things louder)", 1, 1 - stft);
stiffness_knob.gfx_draw_icon(4, 1 - stft);
cx += 2 * radius + knob_spacing;
n_partials = sprintf(16, "%d", 16 * floor((partials / 16)));
partials.draw_knob(cx, cy, radius, n_partials, "Number of partials to include", 1, 1 - stft);
n_partials.gfx_draw_icon(7, 1 - stft);
cx += 2 * radius + knob_spacing;

choice_x = cx - radius;

choice_button1.draw_choice(0, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Metal string");
choice_button1.draw_model_icon();
choice_button2.draw_choice(1, cx - radius, cy, radius, radius, 1, "Tube");
choice_button2.draw_model_icon();
cx += radius + 4;

choice_button3.draw_choice(2, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beating");
choice_button3.draw_model_icon();
choice_button4.draw_choice(3, cx - radius, cy, radius, radius, 1, "Beam (both ends open)");
choice_button4.draw_model_icon();
cx += radius + 4;

choice_button5.draw_choice(4, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beam (one end clamped)");
choice_button5.draw_model_icon();
choice_button6.draw_choice(5, cx - radius, cy, radius, radius, 1, "Membrane");
choice_button6.draw_model_icon();
cx += radius + 4;

choice_button7.draw_choice(6, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Marimba");
choice_button7.draw_model_icon();
choice_button8.draw_choice(7, cx - radius, cy, radius, radius, 1, "Pan");
choice_button8.draw_model_icon();
cx += radius + 4;


choice_button9.draw_choice(8, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Male vowels");
choice_button9.draw_model_icon();
choice_button10.draw_choice(9, cx - radius, cy, radius, radius, 1, "Female vowels");
choice_button10.draw_model_icon();
cx += radius + 4;

bins = 100;

/*
gfx_set(1, 1, 1, 1);
ptr = vowel;
x = 0;
init_vowels(vowel);
loop(64100,
  gfx_circle(0.013 * x, 0.5 * gfx_h - 15 * log10(ptr[]), 1);
  x += 1;
  ptr += 1;
);
*/

function draw_envelope(x, y, w, h)
instance(t_max, last_x, last_y, last_cap)
local(plot_srate, attack_samples, decay_samples,
      k_attack, k_decay, k_release,
      x_cur, y_cur, x_new, y_new, state, rate, current_target, target,
      time_per_pixel, attack_pos, decay_pos, modifier, dx,
      over, highlight)
global(mlog0p05, attack_s, decay_s, release_s, sustain_level, gfx_a,
       mouse_x, mouse_y, mouse_wheel, mouse_cap, captured,
       attack_slider, decay_slider, release_slider, sustain_level,
       hinter.sethint, hinter.hint_time)
(
  gfx_set(0, 0, 0, 0.2);
  gfx_rect(x, y, w, h, 1);
  
  plot_srate = (w - 4) / t_max;
  
  attack_samples = attack_s * plot_srate;
  decay_samples = 2 * decay_s * plot_srate;
  k_attack = mlog0p05 / attack_samples;
  k_decay = mlog0p05 / (decay_s * plot_srate);
  k_release = mlog0p05 / (release_s * plot_srate);
  
  (t_max == 0) ? t_max = 0.1;
  over = (mouse_x > x) && (mouse_y > y) && (mouse_y < (y + h));
  (over) ? (
    (abs(mouse_wheel) > 0) ? (
      modifier = 0.00025 * t_max;
      (mouse_cap & 4 > 0) ? modifier *= 0.5;
      (mouse_cap & 8 > 0) ? modifier *= 0.25;
      t_max = max(0.0001, min(t_max - modifier * mouse_wheel, attack_s + 2 * decay_s + release_s));
      mouse_wheel = 0;
    );
  
    time_per_pixel = t_max / w;
    attack_pos = attack_s / time_per_pixel;
    decay_pos = 2 * decay_s / time_per_pixel;
    
    (last_cap == 0) ? (
      (mouse_x < (x + attack_pos)) ? (
        over = 2;
      ) : (mouse_x < (x + attack_pos + decay_pos)) ? (
        over = 3;
      ) : (
        over = 4;
      );
    ) : (
      (captured == 100) ? ( over = 2; )
      : (captured == 101) ? ( over = 3; )
      : (captured == 102) ? ( over = 4; )
    );
  
    (last_cap == 0) && (mouse_cap == 1) ? (
      // Fetch click ranges for the various parts of the envelope
      time_per_pixel = t_max / w;
      attack_pos = attack_s / time_per_pixel;
      decay_pos = 2 * decay_s / time_per_pixel;
    
      (over == 2) ? (
        captured = 100;
      ) : (over == 3) ? (
        captured = 101;
      ) : (over == 4) ? (
        captured = 102;
      );
    );
  );
  
  x_cur = x + 2;
  y_cur = y + h - 4;
  state = 0;
  loop(w - 4,
    x_new = x_cur + 1;
    y_new = y + 1 + (h - 4) * (1 - state);
    
    (attack_samples > 0) ? (
      rate = k_attack;
      current_target = 1;
      highlight = (over == 2);
      attack_samples -= 1;
      (attack_samples == 0) ? state = 1;
    ) : (
      // Release and decay
      (decay_samples > 0) ? (
        rate = k_decay;
        current_target = sustain_level;
        highlight = (over == 3);
        decay_samples -= 1;
        (decay_samples == 0) ? state = sustain_level;
      ) : (
        rate = k_release;
        current_target = 0;
        highlight = (over == 4);
      );
    );
    
    state += min(1, rate * (current_target - state));
  
    colormodel(0.94); gfx_a = 0.2 + 0.2 * highlight * abs(sin(2 * time_precise()));
    gfx_line(x_cur + 1, y + h - 3, x_new + 1, y_new);

    colormodel(1);
    highlight ? (
      gfx_a = 0.8 * abs(sin(time_precise()));
      gfx_line(x_cur + 1, y_cur - 1, x_new + 1, y_new - 1);
      gfx_line(x_cur + 1, y_cur + 1, x_new + 1, y_new + 1);
    );
    gfx_a = 1;
    gfx_line(x_cur + 1, y_cur, x_new + 1, y_new);
    gfx_line(x_cur, y_cur + 1, x_new, y_new + 1);
    gfx_line(x_cur, y_cur, x_new, y_new);
    
    x_cur = x_new;
    y_cur = y_new;
  );
  
  ((captured > 99) && (captured < 103)) ? (
    (mouse_cap == 0) ? (
      captured = 0;
    ) : (
      
    
      modifier = 0.01;
      (mouse_cap & 4 > 0) ? modifier *= 0.5;
      (mouse_cap & 8 > 0) ? modifier *= 0.25;
      
      dx = modifier * (mouse_x - last_x);
      (captured == 100) ? (
        // Attack
        attack_slider = min(2, max(0, attack_slider + dx));
        slider_automate(56);
        hinter.sethint(sprintf(90, "Attack:\n%.2f ms", attack_s * 1000));
        hinter.hint_time = 1000;
      ) : (captured == 101) ? (
        // Decay
        decay_slider = min(3, max(0, decay_slider + dx));
        slider_automate(57);
        sustain_level = min(1, max(0, sustain_level - modifier * (mouse_y - last_y)));
        slider_automate(59);
        hinter.sethint(sprintf(90, "Decay:\n%.2f ms\nSustain: %d \n", decay_s * 1000, 100 * sustain_level));
        hinter.hint_time = 1000;
      ) : (captured == 102) ? (
        // Release
        release_slider = min(3, max(0, release_slider + dx));
        slider_automate(58);
        hinter.sethint(sprintf(90, "Release:\n%.2f ms", release_s * 1000));
        hinter.hint_time = 1000;
      )
    );
  );
  
  colormodel(0);
  
  last_cap = mouse_cap;
  last_x = mouse_x;
  last_y = mouse_y;
  
  gfx_a = 0.7;
  gfx_rect(x, y, w, h, 0);
  gfx_rect(x + 1, y + 1, w - 2, h - 2, 0);
);

function draw_collapse_rect(x, y, w, h, label)
local(over)
global(gfx_a, mouse_x, mouse_y, mouse_cap, last_cap, hinter.sethint)
(
  over = (mouse_x < (x + w)) && (mouse_x > x) && (mouse_y < (y + h)) && (mouse_y > y);
  over ? hinter.sethint(label);
  
  gfx_a = 0.5 + 0.5 * over;
  gfx_rect(x, y, w, h);
  
  over && (mouse_cap == 1) && (last_cap == 0);
);

midi_input ? (
  use_envelopes ? (
    env.draw_envelope(floor(choice_x), floor(3 * radius + 8), floor((radius + 4) * 5 - 4), floor(2 * radius));
  );
  
  colormodel(use_envelopes);
  draw_collapse_rect(
    floor(choice_x), floor(3 * radius + 0.5 * button_size) + use_envelopes * floor(2 * radius) + use_envelopes * 1.5 * button_size, 
    floor((radius + 4) * 5 - 4), button_size,
    use_envelopes ? 
      "Disable envelope."
    : "Apply an envelope to the input and output of each string."
  ) ? (use_envelopes = 1 - use_envelopes);
  
  use_envelopes
);




//data = np.hstack((len(locations), locations, len(rle_data), rle_data))


gfx_x = 0;
gfx_y = 0;
function draw_logo(logomem, rle_mem, ys, x, y)
global(gfx_a)
local(xx, yy, offset, line, ptr, n_iter, current, count)
instance(s, i)
(
  line = 0;
  s += 1;
  colormodel(0);
  loop(230,
    xx = x + line * ys;
    offset = logomem[line];
    ptr = rle_mem + offset;
    n_iter = 0;
    yy = y;
    while((ptr[] != - 1) && (n_iter < 20)) (
      current = ptr[]; ptr += 1;
      (current > -1) ? (
        count = ptr[]; ptr += 1;
        current ? (
          i = abs(sin(0.1 * line - 0.1 * s));
          gfx_a = 0.1 + 0.5 * pow(i, 10);
          gfx_line(xx, yy, xx, yy + ys * count, 1);
        );
        yy += ys * count;
      );
      n_iter += 1;
    );
    line += 1;
  );
);

yy = 0.02 * gfx_h + gfx_h * 0.9;
//logo.draw_logo(logomem, rle_mem, 0.45, gfx_w - 110, gfx_h - 22);
logo.draw_logo(logomem, rle_mem, 0.45, 6, 6);

// Ctrl + Click the logo enters dev mode
((mouse_cap == 5) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  model = 10;
  settings_changed = 1;
);

gfx_x = 115; gfx_y = 3;
colormodel(0.4);
gfx_setfont(4, "Arial", 10 * max(1,scaling));
gfx_printf("v0.11 ALPHA (Warning: this plugin is not production ready and is still actively being developed)");

(model == 10) ? (
  colormodel(0.0);
  gfx_a = 0.3 * abs(sin(time_precise()));
  gfx_setfont(6, "Arial", 180);
  gfx_measurestr("DEV MODE", gw, gh);
  gfx_x = (gfx_w - gw) / 2; gfx_y = (gfx_h - gh) / 2;
  gfx_printf("DEV MODE")
);

hinter.drawhint();
newtime = time_precise();
delta_time = newtime - ctime;
ctime = newtime;

lx = mouse_x;
ly = mouse_y;
last_cap = mouse_cap;
mouse_cap == 0 ? captured = 0;

/*
gfx_x = 0;
gfx_y = 0;
gfx_set(1, 1, 1, 1);
fff = midi.note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 30;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 60;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_vel;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);
*/
