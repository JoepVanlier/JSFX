desc:Partials (Saike)
tags: modal effect
version: 0.58
author: Joep Vanlier
changelog: Fix envelope release bug (release mode would act like retrigger towards sustain level).
license: MIT
provides:
  partials_dependencies/*
  saike_partials.jsfx.rpl
about:
  # An effect which simulates different materials
  This effect takes both audio and MIDI input. Based on the model selected the incoming audio will excite
  a number of resonators that produce particular sounds. Up to 4 note polyphony is supported.

slider1:model=0<0,12,1{Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice male,Voice female,Custom,Custom_Mem,Custom_Mem2>-model
slider2:inverse_brightness=0<0,1,0.0001>-Inverse Brightness
slider3:relative_position=0.1<0.0001,0.999,0.001>-Relative position
slider4:damp=0.1<-2,2,0.0001>-Damping
slider5:freq_damp=-3.5<-6,-1,0.0001>-Frequency Dependent Damping
slider6:inharmonic=-3.5<-4, 0, 0.0001>-Inharmonic
slider7:stiffness=4.6<2,6,0.0001>-Stiffness
slider8:stiffness_exp=2.3<1,3.0,.0001>-Stiffness Exponent
slider9:placeholder=0<0,1,1>-Placeholder
slider10:base_note=0<-12,12,1>-Base note
slider11:force_fb=1<0,15,0.0001>-Forced feedback (TD only)
slider12:partials=32<16,64,16>-Partials
slider13:stereo=1<0,1,1{Off,On}>-Stereo-ize
slider14:position_vel=0<-1,1,0.000001>-Position velocity sensitivity
slider15:damp_vel=0<-4,4,0.000001>-Damping velocity sensitivity
slider16:freq_damp_vel=-0.75<-5,5,0.000001>-Frequency dependent damping velocity sensitivity
slider17:inharmonic_vel=0<-4,4,0.000001>-Inharmonicity velocity sensitivity
slider18:dummy=0<0,0,1{Off,On}>-Dummy
slider19:first_note=45<0,127,1>-Midi note 1
slider20:second_note=52<0,127,1>-Midi note 2
slider21:third_note=60<0,127,1>-Midi note 3
slider22:fourth_note=64<0,127,1>-Midi note 4
slider23:fifth_note=48<0,127,1>-Midi note 5
slider24:fft_choice=1<0,4,1>-fft size

slider25:spinner_frequency=2<0,20,0.01>-Spin freq
slider26:spinner_depth=0.1<0,4,0.01>-Spin depth

slider30:filter_cutoff=0.4<0,1,0.00001>-Filter Cutoff
slider31:filter_cutoff_vel=0.25<0,1,0.00001>-Filter Cutoff Velocity Sensitivity
slider32:filter_reso=0<0,1,0.0001>-Placeholder
slider33:filter_reso_vel=0<-1,1,0.0001>-Placeholder
slider34:filter_envelope=0.5<-1,1,0.0001>-Filter Envelope
slider35:filter_envelope_vel=0<-2,2,0.00001>-Filter Envelope Velocity Sensitivity
slider36:filter_attack=0<0,2,0.0001>-Filter Attack
slider37:filter_decay=1<0,3,0.0001>-Filter Decay
slider38:filter_releaser=1.5<0,3,0.0001>-Filter Release
slider39:filter_sustain=0.3<0,1,0.0001>-Filter Sustain
slider40:damp_release=0<-4, 4, 0.000001>-Damping release mod
slider41:freq_damp_release=0<-5, 5, 0.000001>-Frequency dependent damping release mod
slider42:inharmonicity_release=0<-4,4,0.00000001>-Inharmonicity release mod

slider43:force_fb_vel=1<-15,15,0.0001>-Forced feedback Velocity Sensitivity (USE AT YOUR OWN RISK)

slider44:lf_mod=0<0,4,0.01>Modulation
slider45:lf_mod_vel=0<-4,4,0.01>Modulation velocity sensitivity
slider52:glide_speed=0<0,1,1>-Glide [10-1000ms]
slider53:legacy_gain=0<0,1,1>-Legacy mode
slider54:brightness_vel=0<0,1,0.0001>-Brightness vel
slider55:play_mode=3<0,5.99,1>-Impulse mode
slider56:attack_slider=0<0,2,0.0001>-Attack
slider57:decay_slider=1<0,3,0.0001>-Decay
slider58:release_slider=1.5<0,3,0.0001>-Release
slider59:sustain_level=0.3<0,1,0.0001>-Sustain
slider60:use_envelopes=0<0,1,1>-Use Envelopes
slider61:pitch_shift=0<-24,24,0.000001>-Large pitch bend
slider62:display_log=0<0,1,1{Linear,Logarithmic}>-Display type
slider63:stft_selection=1<0,1,1>-STFT

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

-- You can define a custom model in this file:
import saike_modal_custom.jsfx-inc

import saike_partials_playback.jsfx-inc
import saike_modal.jsfx-inc
import saike_modal_kp_midi.jsfx-inc
import saike_modal_stft.jsfx-inc
import saike_modal_gfx.jsfx-inc
import saike_partial_array.jsfx-inc
import saike_vowel_data.jsfx-inc
import saike_modal_buffer.jsfx-inc

import saike_partials_sample_editor.jsfx-inc

import saike_modal_impulses.jsfx-inc

import saike_partials_fx.jsfx-inc

@init
MAX_STRING = 5;
DRAG_ENV = 100;
DRAG_ARRAY = 200;
MAX_CUSTOM_PARTIALS = 1024;
env.init_envelope(0, 56, 57, 59, 58);
env2.init_envelope(1, 36, 37, 39, 38);

gfx_ext_retina == 0 ? gfx_ext_retina = 1;
version = 8;

string1.used_partials = string2.used_partials = string3.used_partials = string4.used_partials = string5.used_partials = 0;

// _start, _stop, _default, _slider_idx, _vel_slider_idx, _release_slider_idx
playmode_knob.init_knob(0, 5.99, 0.1, 55, 0, 0);
brightness_knob.init_knob(1, 0, 0.1, 2, 54, 0);
position_knob.init_knob(0, 1, 0.1, 3, 14, 0);
damp_knob.init_knob(-2, 2, 0.1, 4, 15, 40);
freq_damp_knob.init_knob(-6, -1, -4, 5, 16, 41);
inharmonic_knob.init_knob(-4, 0, -4, 6, 17, 42);
stiffness_knob.init_knob(3, 6, 4.6, 7, 0, 0);
stiffness_exp_knob.init_knob(1.0, 3.0, 2.3, 8, 0, 0);
force_fb.init_knob(0, 15.0, 1.0, 11, 43, 0);
partials.init_knob(16, 64, 32, 12, 0, 0);
glide_knob.init_knob(0, 1, 0, 52, 0, 0);

spin_freq_knob.init_knob(0, 20, 1, 25, 0, 0);
spin_depth_knob.init_knob(0, 4, 0, 26, 0, 0);

filter_cutoff_knob.init_knob(0, 1, 0.4, 30, 31, 0);
filter_envelope_knob.init_knob(-1, 1, 0.5, 34, 35, 0);

function stft_init()
local()
global(
  string1.string_init, string2.string_init, string3.string_init, string4.string_init, string5.string_init,
  stft_mem.init_stft,
  stft_mem.fft_size, stft_mem.fft_interval,
  fft_choice,
)
instance()
(
  stft_mem.init_stft(64 * (1 << fft_choice)) ? (
    string1.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string2.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string3.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string4.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string5.string_init(stft_mem.fft_size, stft_mem.fft_interval);
  );
);

function initialize_memory()
local(logo_handle, freemem, lowcut, lowcut_freq, delay_ms, count)
instance()
global(
  rle_mem, logomem, logo_line_count,
  gfx_stft_mem.init_stft,
  stft_mem.init_stft,
  stft_mem.fft_mem, string1.string_mem, string2.string_mem, string3.string_mem, string4.string_mem, string5.string_mem,
  string1.impulse.chan_default, string2.impulse.chan_default, string3.impulse.chan_default, string4.impulse.chan_default, string5.impulse.chan_default,
  stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem,
  gfx_stft_mem.fft_mem, gfx_string.string_mem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem,
  gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval,
  gfx_string.string_init,
  bessel_roots,
  midi.init_midi,
  buffer.init_buffer,
  buffer.set_offset,
  hp.init_linearSVF,
  srate,
  MAX_CUSTOM_PARTIALS,
  custom_partial_mem,
  fft_choice,
  spinner.init_spinner,
  spinner.reset_spinner,
  samplelocs,
  sample_loc,
  scratchloc, copyloc,
  idx,
  N_SAMPLES, SAMPLE_SIZE,
  SAMPLE_FONT, TINY_FONT, BIG_FONT,
)
(
  freemem = 0;
  freemem = stft_mem.fft_mem(freemem, 64 * 16);  // We allocate the maximum mem block here
  freemem = string1.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string2.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string3.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string4.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string5.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  
  string1.impulse.chan_default(1);
  string2.impulse.chan_default(2);
  string3.impulse.chan_default(3);
  string4.impulse.chan_default(4);
  string5.impulse.chan_default(5);
  
  stft_init();
  
  freemem = gfx_stft_mem.fft_mem(freemem, 512);
  freemem = gfx_string.string_mem(freemem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem);
  gfx_stft_mem.init_stft(512);
  gfx_string.string_init(gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval);
  
  freemem = (bessel_roots = freemem) + 2048;
  memset(bessel_roots, 0, 2048);
  bessel_roots[0] = 1.000000; bessel_roots[1] = 2.917295; bessel_roots[2] = 4.831885; bessel_roots[3] = 6.746213; bessel_roots[4] = 8.660476; bessel_roots[5] = 10.574713; bessel_roots[6] = 12.488940; bessel_roots[7] = 14.403161; bessel_roots[8] = 16.317378; bessel_roots[9] = 18.231593; bessel_roots[10] = 20.145807; bessel_roots[11] = 22.060020; bessel_roots[12] = 23.974232; bessel_roots[13] = 25.888443; bessel_roots[14] = 27.802654; bessel_roots[15] = 29.716865; bessel_roots[16] = 31.631075;
  bessel_roots[17] = 33.545286; bessel_roots[18] = 35.459496; bessel_roots[19] = 37.373706; bessel_roots[20] = 39.287916; bessel_roots[21] = 41.202125; bessel_roots[22] = 43.116335; bessel_roots[23] = 45.030545; bessel_roots[24] = 46.944754; bessel_roots[25] = 48.858964; bessel_roots[26] = 50.773173; bessel_roots[27] = 52.687383; bessel_roots[28] = 54.601592; bessel_roots[29] = 56.515802; bessel_roots[30] = 58.430011; bessel_roots[31] = 60.344220; bessel_roots[32] = 62.258430;
  bessel_roots[33] = 64.172639; bessel_roots[34] = 66.086848; bessel_roots[35] = 68.001058; bessel_roots[36] = 69.915267; bessel_roots[37] = 71.829476; bessel_roots[38] = 73.743685; bessel_roots[39] = 75.657895; bessel_roots[40] = 77.572104; bessel_roots[41] = 79.486313; bessel_roots[42] = 81.400522; bessel_roots[43] = 83.314731; bessel_roots[44] = 85.228941; bessel_roots[45] = 87.143150; bessel_roots[46] = 89.057359; bessel_roots[47] = 90.971568; bessel_roots[48] = 92.885777;
  bessel_roots[49] = 94.799986; bessel_roots[50] = 96.714196; bessel_roots[51] = 98.628405; bessel_roots[52] = 100.542614; bessel_roots[53] = 102.456823; bessel_roots[54] = 104.371032; bessel_roots[55] = 106.285241; bessel_roots[56] = 108.199450; bessel_roots[57] = 110.113660; bessel_roots[58] = 112.027869; bessel_roots[59] = 113.942078; bessel_roots[60] = 115.856287; bessel_roots[61] = 117.770496; bessel_roots[62] = 119.684705; bessel_roots[63] = 121.598914; bessel_roots[64] = 123.513123;
  bessel_roots[65] = 125.427332; bessel_roots[66] = 127.341542; bessel_roots[67] = 129.255751; bessel_roots[68] = 131.169960; bessel_roots[69] = 133.084169; bessel_roots[70] = 134.998378; bessel_roots[71] = 136.912587; bessel_roots[72] = 138.826796; bessel_roots[73] = 140.741005; bessel_roots[74] = 142.655214; bessel_roots[75] = 144.569423; bessel_roots[76] = 146.483633; bessel_roots[77] = 148.397842; bessel_roots[78] = 150.312051; bessel_roots[79] = 152.226260; bessel_roots[80] = 154.140469;
  bessel_roots[81] = 156.054678; bessel_roots[82] = 157.968887; bessel_roots[83] = 159.883096; bessel_roots[84] = 161.797305; bessel_roots[85] = 163.711514; bessel_roots[86] = 165.625723; bessel_roots[87] = 167.539933; bessel_roots[88] = 169.454142; bessel_roots[89] = 171.368351; bessel_roots[90] = 173.282560; bessel_roots[91] = 175.196769; bessel_roots[92] = 177.110978; bessel_roots[93] = 179.025187; bessel_roots[94] = 180.939396; bessel_roots[95] = 182.853605; bessel_roots[96] = 184.767814;
  bessel_roots[97] = 186.682023; bessel_roots[98] = 188.596232; bessel_roots[99] = 190.510441; bessel_roots[100] = 192.424651; bessel_roots[101] = 194.338860; bessel_roots[102] = 196.253069; bessel_roots[103] = 198.167278; bessel_roots[104] = 200.081487; bessel_roots[105] = 201.995696; bessel_roots[106] = 203.909905; bessel_roots[107] = 205.824114; bessel_roots[108] = 207.738323; bessel_roots[109] = 209.652532; bessel_roots[110] = 211.566741; bessel_roots[111] = 213.480950; bessel_roots[112] = 215.395159;
  bessel_roots[113] = 217.309368; bessel_roots[114] = 219.223578; bessel_roots[115] = 221.137787; bessel_roots[116] = 223.051996; bessel_roots[117] = 224.966205; bessel_roots[118] = 226.880414; bessel_roots[119] = 228.794623; bessel_roots[120] = 230.708832; bessel_roots[121] = 232.623041; bessel_roots[122] = 234.537250; bessel_roots[123] = 236.451459; bessel_roots[124] = 238.365668; bessel_roots[125] = 240.279877; bessel_roots[126] = 242.194086; bessel_roots[127] = 244.108295; bessel_roots[128] = 246.022504; bessel_roots[129] = 247.936713; bessel_roots[130] = 249.850923; bessel_roots[131] = 251.765132; bessel_roots[132] = 253.679341;
  bessel_roots[133] = 255.593550; bessel_roots[134] = 257.507759; bessel_roots[135] = 259.421968; bessel_roots[136] = 261.336177; bessel_roots[137] = 263.250386; bessel_roots[138] = 265.164595; bessel_roots[139] = 267.078804; bessel_roots[140] = 268.993013; bessel_roots[141] = 270.907222; bessel_roots[142] = 272.821431; bessel_roots[143] = 274.735640; bessel_roots[144] = 276.649849; bessel_roots[145] = 278.564059; bessel_roots[146] = 280.478268; bessel_roots[147] = 282.392477; bessel_roots[148] = 284.306686;
  bessel_roots[149] = 286.220895; bessel_roots[150] = 288.135104; bessel_roots[151] = 290.049313; bessel_roots[152] = 291.963522; bessel_roots[153] = 293.877731; bessel_roots[154] = 295.791940; bessel_roots[155] = 297.706149; bessel_roots[156] = 299.620358; bessel_roots[157] = 301.534567; bessel_roots[158] = 303.448776; bessel_roots[159] = 305.362985; bessel_roots[160] = 307.277194; bessel_roots[161] = 309.191403; bessel_roots[162] = 311.105613; bessel_roots[163] = 313.019822; bessel_roots[164] = 314.934031;
  bessel_roots[165] = 316.848240; bessel_roots[166] = 318.762449; bessel_roots[167] = 320.676658; bessel_roots[168] = 322.590867; bessel_roots[169] = 324.505076; bessel_roots[170] = 326.419285; bessel_roots[171] = 328.333494; bessel_roots[172] = 330.247703; bessel_roots[173] = 332.161912; bessel_roots[174] = 334.076121; bessel_roots[175] = 335.990330; bessel_roots[176] = 337.904539; bessel_roots[177] = 339.818748; bessel_roots[178] = 341.732957; bessel_roots[179] = 343.647167; bessel_roots[180] = 345.561376;
  bessel_roots[181] = 347.475585; bessel_roots[182] = 349.389794; bessel_roots[183] = 351.304003; bessel_roots[184] = 353.218212; bessel_roots[185] = 355.132421; bessel_roots[186] = 357.046630; bessel_roots[187] = 358.960839; bessel_roots[188] = 360.875048; bessel_roots[189] = 362.789257; bessel_roots[190] = 364.703466; bessel_roots[191] = 366.617675; bessel_roots[192] = 368.531884; bessel_roots[193] = 370.446093; bessel_roots[194] = 372.360302; bessel_roots[195] = 374.274511; bessel_roots[196] = 376.188720; bessel_roots[197] = 378.102930; bessel_roots[198] = 380.017139;
  
  //bessel_roots[0] = 1.0; bessel_roots[1] = 1.593340505695112; bessel_roots[2] = 2.1355487866494034; bessel_roots[3] = 2.295417267427694; bessel_roots[4] = 2.6530664045492145; bessel_roots[5] = 2.9172954551172228; bessel_roots[6] = 3.155464815408362; bessel_roots[7] = 3.5001474903090264; bessel_roots[8] = 3.5984846739581138; bessel_roots[9] = 4.058931883331434; bessel_roots[10] = 4.230439127905234; bessel_roots[11] = 4.6010445344331075; bessel_roots[12] = 4.831885262930598; bessel_roots[13] = 4.903280573212368; bessel_roots[14] = 5.412118429982582; bessel_roots[15] = 5.5403985098530635; bessel_roots[16] = 5.976540221648715; bessel_roots[17] = 6.152609171589257; bessel_roots[18] = 6.208732130572546; bessel_roots[19] = 6.746213299505839; bessel_roots[20] = 6.848991602808508; bessel_roots[21] = 7.325257332462771; bessel_roots[22] = 7.468242109085181; bessel_roots[23] = 7.514500962483965; bessel_roots[24] = 8.071028338967128; bessel_roots[25] = 8.1568737689496; bessel_roots[26] = 8.66047555520746; bessel_roots[27] = 8.781093075730398; bessel_roots[28] = 8.820447105611922; bessel_roots[29] = 9.390589484063241; bessel_roots[30] = 9.464339027734203; bessel_roots[31] = 9.98784275554081; bessel_roots[32] = 10.092254814868133; bessel_roots[33] = 10.126502295693772; bessel_roots[34] = 10.706875023386747; bessel_roots[35] = 10.77153891878896; bessel_roots[36] = 11.310212368186301; bessel_roots[37] = 11.402312929615599; bessel_roots[38] = 11.432629299891353; bessel_roots[39] = 12.020976194473256; bessel_roots[40] = 12.078559478862408; bessel_roots[41] = 12.6291936518746; bessel_roots[42] = 12.711609953449942; bessel_roots[43] = 12.738806093605008; bessel_roots[44] = 13.333546087983708; bessel_roots[45] = 13.385453180985621; bessel_roots[46] = 13.945767336219362; bessel_roots[47] = 14.020359772593565; bessel_roots[48] = 14.04501881871901; bessel_roots[49] = 14.645000185525108; bessel_roots[50] = 14.692253846444546; bessel_roots[51] = 15.260566826272614; bessel_roots[52] = 15.328702904590145; bessel_roots[53] = 15.351258321221781; bessel_roots[54] = 15.955615704418207; bessel_roots[55] = 15.998984255488747; bessel_roots[56] = 16.574020171496844; bessel_roots[57] = 16.636735502683614; bessel_roots[58] = 16.657518312060414; bessel_roots[59] = 17.265584831105425; bessel_roots[60] = 17.305660312713336; bessel_roots[61] = 17.886427390005295; bessel_roots[62] = 17.94452559782329; bessel_roots[63] = 17.963794328004976; bessel_roots[64] = 18.57504506872356; bessel_roots[65] = 18.612293459048136; bessel_roots[66] = 19.198005179702488; bessel_roots[67] = 19.252122686852257; bessel_roots[68] = 19.2700831140802; bessel_roots[69] = 19.884097430065065; bessel_roots[70] = 19.91889213498009; bessel_roots[71] = 20.50891405763646; bessel_roots[72] = 20.559563645768456; bessel_roots[73] = 20.57638224071873; bessel_roots[74] = 21.19281780880533; bessel_roots[75] = 21.22546270361489; bessel_roots[76] = 21.819275510667225; bessel_roots[77] = 21.86687651357224; bessel_roots[78] = 21.88268985777816; bessel_roots[79] = 22.501264341880123; bessel_roots[80] = 22.532010052729223; bessel_roots[81] = 23.129183209056905; bessel_roots[82] = 23.174082991117032; bessel_roots[83] = 23.18900453156058; bessel_roots[84] = 23.809482322435674; bessel_roots[85] = 23.83853799891848; bessel_roots[86] = 24.43871055527686; bessel_roots[87] = 24.481200137037135; bessel_roots[88] = 24.495325133904405; bessel_roots[89] = 25.11750756522588; bessel_roots[90] = 25.14504956579362; bessel_roots[91] = 25.747915895998187; bessel_roots[92] = 25.788241546567566; bessel_roots[93] = 25.801650764922858; bessel_roots[94] = 26.425368765399043; bessel_roots[95] = 26.45154717975952; bessel_roots[96] = 27.056846201368838; bessel_roots[97] = 27.09521818837926; bessel_roots[98] = 27.107980698055208; bessel_roots[99] = 27.73308918559399; bessel_roots[100] = 27.758032810520902; bessel_roots[101] = 28.365539713752746; bessel_roots[102] = 28.4021390098783; bessel_roots[103] = 28.41431434025919; bessel_roots[104] = 29.04068788458015; bessel_roots[105] = 29.06450807370286; bessel_roots[106] = 29.674027888190647; bessel_roots[107] = 29.709011382436476; bessel_roots[108] = 29.720651202691336; bessel_roots[109] = 30.348180626606908; bessel_roots[110] = 30.370974306991094; bessel_roots[111] = 30.982336836434303; bessel_roots[112] = 31.015841433866807; bessel_roots[113] = 31.026990878787515; bessel_roots[114] = 31.65558056431991; bessel_roots[115] = 31.677432627434925; bessel_roots[116] = 32.29048841685965; bessel_roots[117] = 32.32263430011846; bessel_roots[118] = 32.3333330276527; bessel_roots[119] = 32.962898758448766; bessel_roots[120] = 32.98388397513484; bessel_roots[121] = 33.598501067720804; bessel_roots[122] = 33.629394318203495; bessel_roots[123] = 33.639677361318086; bessel_roots[124] = 34.270144578068304; bessel_roots[125] = 34.29032914694497; bessel_roots[126] = 34.906390451675975; bessel_roots[127] = 34.936125175768225; bessel_roots[128] = 34.94602363485432; bessel_roots[129] = 35.57732601229015; bessel_roots[130] = 35.59676882275539; bessel_roots[131] = 36.21416995969524; bessel_roots[132] = 36.24283002826827; bessel_roots[133] = 36.25237163862099; bessel_roots[134] = 36.88444991544925; bessel_roots[135] = 36.90320358619262; bessel_roots[136] = 37.521851108922526; bessel_roots[137] = 37.54951159164972; bessel_roots[138] = 37.558721192132666; bessel_roots[139] = 38.191522201780415; bessel_roots[140] = 38.20963394107416; bessel_roots[141] = 38.82944385967054; bessel_roots[142] = 38.856172216310185; bessel_roots[143] = 38.8650721391612; bessel_roots[144] = 39.49854800132748; bessel_roots[145] = 39.51606032459946; bessel_roots[146] = 40.13695687011323; bessel_roots[147] = 40.16281394660802; bessel_roots[148] = 40.1714243437933; bessel_roots[149] = 40.80553178580658; bessel_roots[150] = 40.82248311800838; bessel_roots[151] = 41.44439770252031; bessel_roots[152] = 41.469438569110935; bessel_roots[153] = 41.477777687232674; bessel_roots[154] = 42.11247747097152; bessel_roots[155] = 42.12890265525675; bessel_roots[156] = 42.75177299146806; bessel_roots[157] = 42.77604765199419; bessel_roots[158] = 42.78413206518778; bessel_roots[159] = 43.41938850044695; bessel_roots[160] = 43.435319230126446; bessel_roots[161] = 44.05908858196726; bessel_roots[162] = 44.08264257742662; bessel_roots[163] = 44.090487385723776; bessel_roots[164] = 44.72626791483038; bessel_roots[165] = 44.741733102090066; bessel_roots[166] = 45.36634964360787; bessel_roots[167] = 45.38922456835874; bessel_roots[168] = 45.39684356748521; bessel_roots[169] = 46.0331184089983; bessel_roots[170] = 46.04814450117729; bessel_roots[171] = 46.67356076544521; bessel_roots[172] = 46.69579471081029; bessel_roots[173] = 46.70320053821687; bessel_roots[174] = 47.33994237990128; bessel_roots[175] = 47.354553632035845; bessel_roots[176] = 47.980726035317176; bessel_roots[177] = 48.00235397251547; bessel_roots[178] = 48.009558233526036; bessel_roots[179] = 48.646741966640775; bessel_roots[180] = 48.660960677338416; bessel_roots[181] = 49.28784910649526; bessel_roots[182] = 49.30890321860208; bessel_roots[183] = 49.31591659584141; bessel_roots[184] = 49.953519084244085; bessel_roots[185] = 49.96736580065507; bessel_roots[186] = 50.5949332539693; bessel_roots[187] = 50.61544322484067; bessel_roots[188] = 50.62227557353315; bessel_roots[189] = 51.26027545226442; bessel_roots[190] = 51.27376914888668; bessel_roots[191] = 51.90198142220047; bessel_roots[192] = 51.921974688892305; bessel_roots[193] = 51.92863512016577; bessel_roots[194] = 52.56701261910822; bessel_roots[195] = 52.580170854335584; bessel_roots[196] = 53.20899626581487; bessel_roots[197] = 53.228498239898826; bessel_roots[198] = 53.87373198281662; bessel_roots[199] = 54.51598018442653;
  
  freemem = midi.init_midi(freemem);
  
  buffer.init_buffer(freemem, freemem + 32766);
  freemem += 32768;
  
  delay_ms = 16.12;
  buffer.set_offset(delay_ms * srate / 1000);
  lowcut = 0.34;
  lowcut_freq = exp((1-LowCut) * log(20/22050));
  hp.init_linearSVF(lowcut_freq, 0);
  //displayFreq = 0.5 * srate * lowcut_freq / $pi;
  
  freemem = init_vowels(freemem);
  
  custom_partial_mem = freemem;
  freemem = alloc_model_memory_block(freemem, MAX_CUSTOM_PARTIALS);
  
  freemem = spinner.init_spinner(freemem);
  spinner.reset_spinner();
  
  logomem = freemem;
  logo_handle = file_open("partials_dependencies/logo.dat");
  file_var(logo_handle, logo_line_count);
  file_mem(logo_handle, logomem, logo_line_count);
  rle_mem = logomem + logo_line_count + 1;
  file_var(logo_handle, count);
  file_mem(logo_handle, rle_mem, count);
  file_close(logo_handle);
  
  freemem += 2048;
  
  // Input pulse data
  sample_loc = freemem;
  
  init_sample_data_defaults();
  N_SAMPLES = 4;
  
  // Sample locations are recorded as [64 byte header (first is length), sampledata]
  freemem = (samplelocs = freemem) + 128;
  idx = 0;
  loop(N_SAMPLES,
    freemem = (samplelocs[idx] = freemem) + SAMPLE_SIZE;
    idx += 1;
  );
    
  freemem = (scratchloc = freemem) + SAMPLE_SIZE;
  freemem = (copyloc = freemem) + SAMPLE_SIZE;
  
  SAMPLE_FONT = 5;
  TINY_FONT = 6;
  gfx_setfont(TINY_FONT, "Arial", 12);
  BIG_FONT = 7;
  gfx_setfont(BIG_FONT, "Arial", 18);
);

function tanh(x)
local()
global()
instance()
(
  (2/(1+exp(-2*x)) - 1)
);


function update_freq()
local()
global(stft, k_glide, big_tick, cSample, test_mode, _test_mode_pos)
instance(freq, target_freq)
(
  freq += k_glide * (target_freq - freq);
  
  big_tick ? (
    stft ? (
      test_mode ? (
        _test_mode_pos += 0.001;
        _test_mode_pos > 0.5 ? _test_mode_pos = 0;
        this.set_pars_stft(freq * (1 + 0.5*12 * test_mode * _test_mode_pos));
      ) : (
        this.set_pars_stft(freq);
      );
    ) : (
      freq ? this.set_pars_td(freq);
    );
  );
);

function set_pars(f_0, vel, glide)
local()
global(
  stft,
  relative_position, damp, freq_damp, inharmonic,
  position_vel, damp_vel, freq_damp_vel, inharmonic_vel,
  lf_mod, lf_mod_vel,
)
instance(base_damp, f_damp, inharm, rel_position, freq, target_freq, last_vel, mod)
(
  // position 0 to 1
  // damp -2 to 2
  // freq_damp -6 to -1
  // inharmonic -4 to 0
  last_vel = vel;
  rel_position = min(max(0, relative_position + position_vel * vel), 1);
  base_damp = 10^(min(max(-2, damp + damp_vel * vel), 2));
  f_damp = 10^(min(max(-6, freq_damp + freq_damp_vel * vel), -1));
  mod = max(0, lf_mod + vel * lf_mod_vel);
  
  inharm = inharm * 0.8 + 0.2 * 10^(min(max(-4, inharmonic + inharmonic_vel * vel), 0));
  
  ((!glide) || (freq == 0)) ? (
    freq = f_0;
    target_freq = f_0;
  ) : (
    target_freq = f_0;
  );
);

function damp_string()
local()
global(damp, freq_damp, inharmonic, damp_vel, freq_damp_vel, damp_release, inharmonic_vel, freq_damp_release, inharmonicity_release)
instance(base_damp, f_damp, inharm, rel_position, freq, target_freq, last_vel)
( 
  base_damp = 10^(min(max(-2, damp + damp_vel * last_vel + damp_release), 2));
  f_damp = 10^(min(max(-6, freq_damp + freq_damp_vel * last_vel + freq_damp_release), -1));
  inharm = inharm * 0.8 + 0.2 * 10^(min(max(-4, inharmonic + inharmonic_vel * last_vel + inharmonicity_release), 0));
);

function eval_string(f_h, env, on)
local(input_active)
global(stft, play_mode, stft_mem.fft_size)
instance()
(
  stft ? (
    // Impulses are added at the global level below, since the STFT
    // variant only uses one STFT for the entire input.
    input_active = (play_mode >= 1) ? this.impulse.impulse_alive(stft_mem.fft_size) : 1;
    
    this.eval_string_stft(env * input_active, env, on);
  ) : (
    /* Add string specific impulse if relevant */
    (play_mode >= 1) ? (
      f_h += this.impulse.eval_impulse(this.freq);
    );
    this.eval_string_td(on ? f_h * env : 0);
  );
);

function update_env_note(vel, _state, attack_s, decay_s, sustain_level, release_s)
instance(
  last_vel, target, sustain, rate,
  k_attack, k_decay, attack_samples,
  state,
)
local()
global(srate, mlog0p05)
(
  target = vel;
  sustain = sustain_level * target;
  
  _state ? (
    // Change!
    (vel && (_state > 0)) ? (
      attack_samples = attack_s * srate;
      k_attack = mlog0p05 / attack_samples;
      k_decay = mlog0p05 / (decay_s * srate);
    ) : (
      // Note is off => release!
      attack_samples = 0;
      k_decay = mlog0p05 / (release_s * srate);
      sustain = 0;
    );
  );
  
  last_vel = vel;
);

function env_sample()
instance(state, target, sustain, 
         attack_samples,
         k_attack, k_decay)
local(current_target, rate)
global()
(
  (attack_samples > 0) ? (
    rate = k_attack;
    current_target = target;
  ) : (
    // Release and decay
    rate = k_decay;
    current_target = sustain;
  );
  attack_samples -= 1;
  
  state += rate * (current_target - state);
);

function update_notes()
instance(notes_on, active_note_mem, active_note_vel, active_note_state, note_history,
         note_on0, note_on1, note_on2, note_on3, note_on4, last_count)
global(string1.set_pars, string2.set_pars, string3.set_pars, string4.set_pars, string5.set_pars, pitch_shift,
       midi.pitchbend, midi.last_vel,
       use_envelopes,
       envelope1.update_env_note, envelope2.update_env_note, envelope3.update_env_note, envelope4.update_env_note, envelope5.update_env_note,
       use_filt_envelopes,
       filt_envelope1.update_env_note, filt_envelope2.update_env_note, filt_envelope3.update_env_note, filt_envelope4.update_env_note, filt_envelope5.update_env_note,
       string1.impulse.update_impulse_note,
       string2.impulse.update_impulse_note,
       string3.impulse.update_impulse_note,
       string4.impulse.update_impulse_note,
       string5.impulse.update_impulse_note,
       string1.used_partials,
       string2.used_partials,
       string3.used_partials,
       string4.used_partials,
       string5.used_partials,
       string1.ref_cutoff,
       string2.ref_cutoff,
       string3.ref_cutoff,
       string4.ref_cutoff,
       string5.ref_cutoff,
       play_mode, midi_recv,
       inverse_brightness, brightness_vel,
       partials_used,
       glide,
       env.attack_s, env.decay_s, env.sustain_level, env.release_s
       env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s,
       single_filter_ref_cutoff,
       enable_filter,
       filter_cutoff, filter_cutoff_vel, filter_envelope, filter_envelope_vel,
       latest_note,
       string1.damp_string,
       string2.damp_string,
       string3.damp_string,
       string4.damp_string,
       string5.damp_string,
       string1.update_freq,
       string2.update_freq,
       string3.update_freq,
       string4.update_freq,
       string5.update_freq
       )
local(ref_pitch, scaling, max_vel,
      note_vel0, note_vel1, note_vel2, note_vel3, note_vel4,
      note_state0, note_state1, note_state2, note_state3, note_state4,
      remainder,
      )
(
  scaling = 440;
  ref_pitch = 2 * midi.pitchbend + pitch_shift - 69;
  
  midi_recv = max(midi_recv, ((note_state0 > 0) + (note_state1 > 0) + (note_state2 > 0) + (note_state3 > 0) + (note_state4 > 0)) > 0);
  latest_note = note_history[notes_on - 1];
  glide ? (
    note_on2 = note_on3 = note_on4 = 0;
    (notes_on > 0) ? (
      note_on0 = active_note_mem[latest_note];
      note_vel0 = active_note_vel[latest_note];
      note_state0 = active_note_state[latest_note];
    ) : (
      note_state0 = -1;
    );
    (notes_on > 0) ? (
      string1.set_pars(scaling * 2 ^ ((note_on0 + ref_pitch) / 12), note_vel0, last_count > 0)+
      string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0;
    );
    
    // This is the cutoff when only a single global filter is used.
    // Happens when in STFT mode, or no velocity or envelopes are set in TD mode.
    // In all other cases, each string gets their own filter.
    single_filter_ref_cutoff = min(max(0.0, filter_cutoff + filter_cutoff_vel * midi.last_vel), 1.0);
  ) : (
    note_vel0 = active_note_vel[0];
    note_vel1 = active_note_vel[1];
    note_vel2 = active_note_vel[2];
    note_vel3 = active_note_vel[3];
    note_vel4 = active_note_vel[4];
    
    // This is the cutoff when only a single global filter is used.
    // Happens when in STFT mode, or no velocity or envelopes are set in TD mode.
    // In all other cases, each string gets their own filter.
    max_vel = max(max(max(max(note_vel0, note_vel1), note_vel2), note_vel3), note_vel4);
    single_filter_ref_cutoff = min(max(0.0, filter_cutoff + filter_cutoff_vel * max_vel), 1.0);
     
    note_on0 = active_note_mem[0];
    note_on1 = active_note_mem[1];
    note_on2 = active_note_mem[2];
    note_on3 = active_note_mem[3];
    note_on4 = active_note_mem[4];
    
    note_state0 = active_note_state[0];
    note_state1 = active_note_state[1];
    note_state2 = active_note_state[2];
    note_state3 = active_note_state[3];
    note_state4 = active_note_state[4];
    
    // Update note parameters
    note_on0 ? ( string1.set_pars(scaling * 2 ^ ((note_on0 + ref_pitch) / 12), note_vel0, 0); string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0; );
    note_on1 ? ( string2.set_pars(scaling * 2 ^ ((note_on1 + ref_pitch) / 12), note_vel1, 0); string2.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel1; );
    note_on2 ? ( string3.set_pars(scaling * 2 ^ ((note_on2 + ref_pitch) / 12), note_vel2, 0); string3.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel2; );
    note_on3 ? ( string4.set_pars(scaling * 2 ^ ((note_on3 + ref_pitch) / 12), note_vel3, 0); string4.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel3; );
    note_on4 ? ( string5.set_pars(scaling * 2 ^ ((note_on4 + ref_pitch) / 12), note_vel4, 0); string5.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel4; );
    
    (note_state0 == -1) ? (string1.damp_string(); string1.update_freq(); );
    (note_state1 == -1) ? (string2.damp_string(); string2.update_freq(); );
    (note_state2 == -1) ? (string3.damp_string(); string3.update_freq(); );
    (note_state3 == -1) ? (string4.damp_string(); string4.update_freq(); );
    (note_state4 == -1) ? (string5.damp_string(); string5.update_freq(); );
  );
  
  use_envelopes ? (
    envelope1.update_env_note(note_vel0, note_state0, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope2.update_env_note(note_vel1, note_state1, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope3.update_env_note(note_vel2, note_state2, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope4.update_env_note(note_vel3, note_state3, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope5.update_env_note(note_vel4, note_state4, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
  );
  
  (use_filt_envelopes && enable_filter) ? (
    // How much range remains for the envelope?
    ((filter_envelope + filter_envelope_vel) > 0) ? (
      // Envelope going up
      remainder = 1.0 - filter_cutoff;
    ) : (
      // Envelope going down
      remainder = filter_cutoff;
    );
    
    filt_envelope1.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel0))), note_state0, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope2.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel1))), note_state1, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope3.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel2))), note_state2, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope4.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel3))), note_state3, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope5.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel4))), note_state4, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
  );
  
  (play_mode >= 1) ? (
    string1.impulse.update_impulse_note(note_state0, inverse_brightness + brightness_vel * note_vel0);
    string2.impulse.update_impulse_note(note_state1, inverse_brightness + brightness_vel * note_vel1);
    string3.impulse.update_impulse_note(note_state2, inverse_brightness + brightness_vel * note_vel2);
    string4.impulse.update_impulse_note(note_state3, inverse_brightness + brightness_vel * note_vel3);
    string5.impulse.update_impulse_note(note_state4, inverse_brightness + brightness_vel * note_vel4);
  );
  
  active_note_state[0] = 0;
  active_note_state[1] = 0;
  active_note_state[2] = 0;
  active_note_state[3] = 0;
  active_note_state[4] = 0;
  
  partials_used = max(string1.used_partials, max(string2.used_partials, max(string3.used_partials, max(string4.used_partials, string5.used_partials))));
  last_count = notes_on;
);

function force_update()
(
  update_ticker = 0;
);

initialize_memory();
midi.reset_midi();
settings_changed = 1;

@slider
settings_changed = 1;

stft_init();

@block
_SVF_SAMPLING_FACTOR = 0.5 * $pi * (44100 / srate);

/* Don't switch immediately, because you might run a partial STFT */
(stft_selection != stft) ? (
  stft = stft_selection;
  settings_changed = 1;
);

spinner.block_spinner();

sample_time = 1 / srate;
glide_decay = pow(10, glide_speed * 2 - 2.5); // 12.0 / 1000;  // Decay in seconds
k_glide = - sample_time * log(0.5) / glide_decay;

midi_input = (play_mode >= 1);
(floor(play_mode) != floor(last_play_mode)) ? (
  memset(midi.active_note_mem, 0, 5);
  midi.notes_on = 0;
  settings_changed = 1;
  last_play_mode = play_mode;
);

(srate != last_srate) ? (
  prepare_impulse_globals();
  last_srate = srate;
);

mlog0p05 = 2.995732273553991; // Corresponds to time to get to 95%
env.block_envelope();
env2.block_envelope();

midi.midi_block(pass_through);

// We use the single lowpass filter in stft mode
// or when use_filt_envelopes is off and the notes
// have no velocity sensitivity on the filters.
single_filter = enable_filter && (stft || (!use_filt_envelopes && (filter_cutoff_vel == 0)));

// We use the multi filter when stft is off and 
// filt_envelopes is on
multi_filter = enable_filter && (!stft && (use_filt_envelopes || (filter_cutoff_vel != 0)));

@sample
cSample += 1;
update_global_parameters();

function update_fixed_notes()
local(change, val, ix, idx)
global(settings_changed)
instance(active_note_mem, active_note_vel, notes_on)
(
  ix = 19;
  idx = 0;
  change = 0;
  loop(5,
    // If this one is used, store it in the active note memory.
    val = slider(ix);
    val ? (
      change = (active_note_mem[idx] != val) ? 1 : change;
      active_note_mem[idx] = val;
      active_note_vel[idx] = 1.0;
      idx += 1;
    );
    ix += 1;
  );
  notes_on = idx;
  val = 5 - idx;
  loop(val,
    change = (active_note_mem[idx] != 0) ? 1 : change;
    active_note_mem[idx] = 0;
    active_note_vel[idx] = 0;
    idx += 1;
  );
  change ? (
    settings_changed = 1;
  );
);

midi.curSample += 1;
!midi_input ? (
  midi.update_fixed_notes();
);

midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

big_tick = update_ticker == 0;
update_ticker += 1;
(update_ticker > 128) ? (
  update_ticker = 0;
);

big_tick ? (
  midi.update_notes();
);
midi.note_on0 ? string1.update_freq();
midi.note_on1 ? string2.update_freq();
midi.note_on2 ? string3.update_freq();
midi.note_on3 ? string4.update_freq();
midi.note_on4 ? string5.update_freq();


f_hn = 0;
f_b = 0;

stft ? (
  (play_mode >= 2) ? (
    f_h += string1.impulse.eval_impulse(string1.freq) * 4;
    f_h += string2.impulse.eval_impulse(string2.freq) * 4;
    f_h += string3.impulse.eval_impulse(string3.freq) * 4;
    f_h += string4.impulse.eval_impulse(string4.freq) * 4;
    f_h += string5.impulse.eval_impulse(string5.freq) * 4;
  );
  stft_mem.read_stft(f_h);
);

// Process the envelopes (if any).
single_filter_cutoff = single_filter_ref_cutoff;
midi_input ? (
  use_envelopes ? (
    _e1 = envelope1.env_sample();
    _e2 = envelope2.env_sample();
    _e3 = envelope3.env_sample();
    _e4 = envelope4.env_sample();
    _e5 = envelope5.env_sample();
  ) : (
    _e1 = _e2 = _e3 = _e4 = _e5 = 1;
  );
  (use_filt_envelopes && enable_filter) ? (
    _fe1 = filt_envelope1.env_sample();
    _fe2 = filt_envelope2.env_sample();
    _fe3 = filt_envelope3.env_sample();
    _fe4 = filt_envelope4.env_sample();
    _fe5 = filt_envelope5.env_sample();

    single_filter ? (
      single_filter_cutoff += 
        (latest_note == 0) ? _fe1 : 
        (latest_note == 1) ? _fe2 : 
        (latest_note == 2) ? _fe3 : 
        (latest_note == 3) ? _fe4 : 
        (latest_note == 4) ? _fe5;
      single_filter_cutoff = max(0.0, min(1.0, single_filter_cutoff));
    );
  ) : (
    _fe1 = _fe2 = _fe3 = _fe4 = _fe5 = 0;
  );
) : (
  _e1 = _e2 = _e3 = _e4 = _e5 = 1;
  _fe1 = _fe2 = _fe3 = _fe4 = _fe5 = 1;
);

single_filter ? (
  (single_svf.last_freq != single_filter_cutoff) ? (
    single_svf.init_linearSVF(single_filter_cutoff, 0);
  );
);

// Process string internals
string1.eval_string(f_h, _e1, midi.note_on0);
string2.eval_string(f_h, _e2, midi.note_on1);
string3.eval_string(f_h, _e3, midi.note_on2);
string4.eval_string(f_h, _e4, midi.note_on3);
string5.eval_string(f_h, _e5, midi.note_on4);

// Write to output
stft ? (
  stft_mem.write_stft();
  f_b = stft_mem.f_b;
  f_hn = stft_mem.f_hn;
) : (
  (midi_input && use_envelopes) ? (
    /* Apply amplitude envelope */
    string1.f_b *= _e1;
    string2.f_b *= _e2;
    string3.f_b *= _e3;
    string4.f_b *= _e4;
    string5.f_b *= _e5;
  );
  
  /* Apply multi filter; only happens in td with envelopes on */
  multi_filter ? (
    _fe1 = min(1.0, max(0.0, string1.ref_cutoff + _fe1));
    (svf1.last_freq != _fe1) ? ( svf1.init_linearSVF(_fe1, 0); );
    _fe2 = min(1.0, max(0.0, string2.ref_cutoff + _fe2));
    (svf2.last_freq != _fe2) ? ( svf2.init_linearSVF(_fe2, 0); );
    _fe3 = min(1.0, max(0.0, string3.ref_cutoff + _fe3));
    (svf3.last_freq != _fe3) ? ( svf3.init_linearSVF(_fe3, 0); );
    _fe4 = min(1.0, max(0.0, string4.ref_cutoff + _fe4));
    (svf4.last_freq != _fe4) ? ( svf4.init_linearSVF(_fe4, 0); );
    _fe5 = min(1.0, max(0.0, string5.ref_cutoff + _fe5));
    (svf5.last_freq != _fe5) ? ( svf5.init_linearSVF(_fe5, 0); );
    
    string1.f_b = svf1.eval_linearSVF_LP(string1.f_b);
    string2.f_b = svf2.eval_linearSVF_LP(string2.f_b);
    string3.f_b = svf3.eval_linearSVF_LP(string3.f_b);
    string4.f_b = svf4.eval_linearSVF_LP(string4.f_b);
    string5.f_b = svf5.eval_linearSVF_LP(string5.f_b);
  );
  
  /* Sum to output */
  f_b += string1.f_b;
  f_b += string2.f_b;
  f_b += string3.f_b;
  f_b += string4.f_b;
  f_b += string5.f_b;
  
  f_hn += string1.f_hn;
  f_hn += string2.f_hn;
  f_hn += string3.f_hn;
  f_hn += string4.f_hn;
  f_hn += string5.f_hn;
);

// Single filter case (stft or td without envelopes)
single_filter ? (
  f_b = single_svf.eval_linearSVF_LP(f_b);
);


hammer = 0;

function soft_clip(x)
(
  (abs(x) < 1) ? 1.5 * x - 0.5 * x * x * x : sign(x)
);

amp_factor = 10^stiffness;

stft ? (
current_force_fb = force_fb + force_fb_vel * midi.last_vel;
  f_h = spl0;
  f_h = -(f_h > 0 ? 100000 * f_h ^ stiffness_exp : 0);
  //f_h = soft_clip(Adivfs*f_h) * srate;
) : (
  hammer ? (
    // WIP dynamical model (broken for now)
    mass = 4.9 * 0.001;
    mul = 100000;
    
    t_ah = f_h_last * (-1.0 / (mass * srate));
    t_vh = t_ah + t_vh;
    t_yn = t_vh / srate + t_yn;
    signal = t_yn - 370*f_hn;
    f_h = (signal > 0 ? mul * signal ^ stiffness_exp : 0);
    f_h_last = f_h;
  ) : (
    // No hammer but simple feedback
    current_force_fb = force_fb + force_fb_vel * midi.last_vel;
    f_h = tanh(current_force_fb * f_hn);
    f_h += spl0;
    f_h = -(f_h > 0 ? amp_factor * f_h ^ stiffness_exp : 0);
  );
);

stereo ? (
  buffer.update_buffer(f_b);
  rb = buffer.read_buffer();

  /* Highpass the added comb filter signal */
  rb = hp.eval_linearSVF_HP6(rb);
  
  spl0 = f_b + 0.33 * rb;
  spl1 = f_b - 0.33 * rb;
) : (
  spl0 = spl1 = f_b;
);

!stft ? (
  // Gain normalization in case of feedback system
  spl0 /= amp_factor * 0.00001;
  spl1 /= amp_factor * 0.00001;
);

settings_changed ? (
  settings_changed = 0;
  force_update();
);

spinner.eval_spinner(spl0, spl1, spinner_frequency, spinner_depth);
spl0 = spinner.outl;
spl1 = spinner.outr;

last_spl0 = spl0;
last_spl1 = spl1;

@serialize
file_var(0, version);
(version > 1) ? (
  file_var(0, env.t_max);
) : (
  env.t_max = 0.1;
  use_envelopes = 0;
);

file_var(0, MAX_CUSTOM_PARTIALS);
file_mem(0, custom_partial_mem, MAX_CUSTOM_PARTIALS * 8 + 64);

(version < 3) ? ( glide = 0; ) : ( file_var(0, glide); );
(version < 3) ? ( test_mode = 0; ) : ( file_var(0, test_mode); );
(version < 3) ? ( pass_through = 1; ) : ( file_var(0, pass_through); );
(version < 4) ? ( spinner_frequency = 0; spinner_depth = 0; );

(version >= 4) ? (
  serialize_all_samples(file_avail(0) < 0);
) : (
  idx = 0;
  loop(N_SAMPLES,
    clear_sample(idx);
    idx += 1;
  );
);

(version < 5) ? (
  // Old file format
  use_filt_envelopes = 0;
  enable_filter = 0;
  filter_cutoff = 0.4;
  filter_cutoff_vel = 0.25;
  filter_reso = 0;
  filter_reso_vel = 0;
  filter_envelope = 0.5;
  filter_envelope_vel = 0;
  filter_attack = 0;
  filter_decay = 1;
  filter_releaser = 1.5;
  filter_sustain = 0.3;
  voice_thievery = 0;
) : (
  file_var(0, use_filt_envelopes);
  file_var(0, enable_filter);
);

(version < 6) ? (
  voice_thievery = 0;
  damp_release = 0;
  freq_damp_release = 0;
  inharmonicity_release = 0;
) : (
  file_var(0, voice_thievery);
);

(version < 7) ? (
  force_fb_vel = 0;
);

(version < 8) ? (
  bp_resonator_mode = 0;
) : (
  file_var(0, bp_resonator_mode);  
);

version = 8;
last_selected_sample = -1;
reset_zoom = 1;

@gfx 1040 480
_gfx_w = gfx_w;
_gfx_h = gfx_h;

//scaling = gfx_ext_retina == 2 ? 1 : 0;
scaling = _gfx_w / 1080;

//gfx_set(0, 0, 0, 1);
//gfx_rect(0, 0, gfx_w, gfx_h);

((init_w != _gfx_w) || (init_h != _gfx_h) || (model != last_model)) ? (
  init_w = _gfx_w;
  init_h = _gfx_h;
  last_model = model;
  settings_changed = 1;
  gfx_setimgdim(1, _gfx_w, _gfx_h);
  gfx_dest = 1;
  gfx_set(0, 0, 0, 1);
  gfx_rect(0, 0, _gfx_w, _gfx_h);
  
  loop(100,
    xx = _gfx_w * rand();
    yy = _gfx_h * rand();
    colormodel(rand()*rand()*rand()); gfx_a = 0.2;
    gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
  );
  loop(5,
    gfx_x = gfx_y = 0;
    gfx_blurto(_gfx_w, _gfx_h)
  );
  
  gfx_dest = -1;
);


gfx_dest = 1;
xx = _gfx_w * rand();
yy = _gfx_h * rand();
colormodel(rand()*rand()*rand()); gfx_a = 0.2;
gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
/*
xx = 2 * gfx_w * rand();
yy = gfx_h * rand();
loop(10,
  colormodel(0); gfx_a = 0.1;
  gfx_line(xx, 1, xx - gfx_h * 2, gfx_h + 1);
  gfx_line(xx, 2, xx - gfx_h * 2, gfx_h + 2);
  gfx_a = 10;
  gfx_line(xx, 0, xx - gfx_h * 2, gfx_h);
);
*/
gfx_x = gfx_y = 0;
gfx_blurto(_gfx_w, _gfx_h);
gfx_dest = -1;

gfx_x = gfx_y = 0; gfx_a = 0.25;
gfx_blit(1, 1, 0);



/*
gfx_set(0.3, 0.3, 0.7, 1);
ix = 0;
loop(string1.fft_size,
  yc = 0.5 * gfx_h * sqrt(string1.coeff_mem[2 * ix]^2 + string1.coeff_mem[2 * ix + 1]^2);
  gfx_rect(2 * ix, gfx_h - yc, 1, yc);
  ix += 1;
);
*/

function simple_arrow(xx, yy, _r)
local(dr)
global()
(
  dr = ceil(0.06 * _r);
  xx = floor(xx);
  yy = floor(yy);
  _r = floor(_r);
  gfx_line(xx, yy - 0.4 * _r, xx, yy - 2 * dr - 1);
  gfx_line(xx + 1, yy - 0.4 * _r, xx + 1, yy - 2 * dr - 1);
  gfx_line(xx - 1, yy - 0.4 * _r, xx - 1, yy - 2 * dr - 1);
  gfx_triangle(xx - dr, yy - 2 * dr, xx + dr, yy - 2 * dr, xx, yy);
);

function gfx_draw_icon(id, enabled)
local(len, xp, xx, yy, dr, s, ds, cy, sy, ang1, ang2, x1, x2, y1, y2, i, di, rr)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _r, relative_position)
( 
  colormodel(0.9);
  id == 0 ? (
    // Position
    len = ceil(0.6 * _r);
    yy = _y + 0.1 * _r;
    gfx_line(_x - len, yy, _x + len, yy, 1);
    gfx_line(_x - len, yy + 1, _x + len, yy + 1, 1);
    
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(xx, yy, _r);
  ) : ( id == 1 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 5 * relative_position / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * s - sy);
        s -= ds * s;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 2 ) ? (
    // Freq Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > 2 * (1 - relative_position) * len) ? cy -= 2 / len;
        cy = max(0, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 3 ) ? (
    // Spring
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 4.0 * relative_position;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(8.5 * len,
        cy = (1 - 0.4 * relative_position) * s - sy;
        gfx_a = 0.5 + 0.4 * cos(cy);
        
        gfx_lineto(floor(_x + xx - sy + 5 * cos(cy) * tanh(xx / len)), floor(_y - sy + yy * sin(cy)));
        s += 0.35;
        xx += 0.25;
      );
      sy -= 1;
    );
  ) : ( id == 4 ) ? (
    // Stiffness
    len = ceil(0.6 * _r);
    yy = _y + 0.35 * _r;
    dr = _r * (0.5 + relative_position);
    
    gfx_a = 0.2 + 0.8 * enabled;
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(_x, _y + 0.05 * _r - 0.1 * _r * relative_position, _r);

    xx = _x - len + ceil(2 * len * relative_position);
    gfx_a = relative_position;
    simple_arrow(_x + 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    simple_arrow(_x - 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    
    gfx_a = 0.2 + 0.8 * enabled;
    ang1 = $pi + asin(0.45 * _r / dr);
    ang2 = $pi - asin(0.45 * _r / dr);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
  ) : ( id == 5 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 0.5 / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 0;
      gfx_x = xx;
      gfx_y = _y + yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * pow(s, 1 + 5 * relative_position) - sy);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 6 ) ? (
    gfx_a = enabled;
    x1 = floor(_x - 0.3 * _r);
    x2 = floor(_x + 0.3 * _r);
    dr = floor(0.07 * _r);
    gfx_circle(x1, y2, dr, 1);
  
    gfx_a = 0.1 + 0.9 * relative_position * enabled;
    y1 = floor(_y - 0.3 * _r);
    y2 = floor(_y + 0.3 * _r);
    
    loop(2,
      x1 = floor(_x - 0.3 * _r);
      x2 = floor(_x + 0.3 * _r);
      loop(2,
        gfx_line(x1, y1, x1, y2 - 3 * dr);
        gfx_line(x1, y1, x1, y1);
        gfx_line(x1 + 1, y1, x2 - 1, y1);
        gfx_line(x2, y1, x2, y2 - 1);
        gfx_line(x1 + 3 * dr, y2, x2, y2);    
        gfx_line(x1 + 3 * dr, y2 + 1, x1 + 4 * dr, y2 + dr + 1);
        gfx_line(x1 + 3 * dr, y2 - 1, x1 + 4 * dr, y2 - dr - 1);
        x1 += 1;
        x2 += 1;
      );
      y1 += 1;
      y2 += 1;
    );
  ) : ( id == 7 ) ? (
    s = 0;
    _r *= 0.8;
    loop(12,
      gfx_a = 0.5 + (s < (17 * relative_position) ? 0.5 : 0);
      !enabled ? gfx_a *= 0.2;
      gfx_line(
        _x - 0.2 * _r * sin(s),
        _y + 0.2 * _r * cos(s), 
        _x - (0.5 + 0.05 * s) * _r * sin(s),
        _y + (0.5 + 0.03 * s) * _r * cos(s)
      );
      gfx_line(
        _x - 0.2 * _r * sin(s),
        _y + 0.2 * _r * cos(s) + 1, 
        _x - (0.5 + 0.05 * s) * _r * sin(s),
        _y + (0.5 + 0.03 * s) * _r * cos(s) + 1
      );
      s += 0.35 * $pi;
    );
  ) : ( id == 8 ) ? (
    // Waveform
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 3.14 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      gfx_a = 0.8;
      loop(2 * len,
        _r = sin(0.1 * s) + sin(2.22 * s + 3) + 0.2 * sin(1.48 * s * s + 10) - 0.1;
        _r *= (1 - cos(s));
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 9 ) ? (
    // MIDI
    gfx_a = 0.17;
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 3.14 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(2 * len,
        _r = sin(0.1 * s) + sin(2.22 * s + 3) + 0.2 * sin(1.48 * s * s + 10) - 0.1;
        _r *= (1 - cos(s));
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
    
    gfx_a = 0.4;
    sy = 0;
    gfx_circle(_x, _y, 0.8 * len + 0.5 * sy, 1); 
    loop(3,
      gfx_circle(_x, _y, len + 0.5 * sy);
      sy += 1;
    );
    
    gfx_set(0, 0, 0, 0.7);
    gfx_circle(_x - 0.5 * len, _y, 0.85 * sy, 1);
    gfx_circle(_x + 0.5 * len, _y, 0.85 * sy, 1);
    gfx_circle(_x, _y - 0.5 * len, 0.85 * sy, 1);
    gfx_circle(_x - 0.5 / 1.41 * len, _y - 0.5 / 1.41 * len, 0.85 * sy, 1);
    gfx_circle(_x + 0.5 / 1.41 * len, _y - 0.5 / 1.41 * len, 0.85 * sy, 1);
  ) : ( id == 10 ) ? (
    // Spike
    gfx_line(_x - 0.5 * _r, _y + 0.25 * _r, _x + 0.5 * _r + 1, _y + 0.25 * _r);
    gfx_line(_x - 0.5 * _r, _y + 0.25 * _r - 1, _x + 0.5 * _r + 1, _y + 0.25 * _r - 1);
    simple_arrow(_x, _y - 0.35 * _r, -1.5 * _r);
  ) : ( id == 11 ) ? (
    // Noise burst
    ang2 = 0;
    loop(2,
      s = _x - 0.5 * _r;
      i = - 0.5;
      di = - 2 * i / _r;
      gfx_y = _y + 0.35 * _r;
      gfx_x = s;
      loop(_r,
        ang1 = _y + 0.35 * _r - 0.8 * _r * exp(-1.5 * i * i * _r);
        gfx_lineto(s, ang1 + ang2, 1);
        s += 1;
        i += di;
      );
      ang2 += 1;
    );
  ) : ( id == 12 ) ? (
    // Noise
    ang2 = 0;
    loop(2,
      s = _x - 0.5 * _r;
      i = - 0.5;
      di = - 2 * i / _r;
      gfx_y = _y + 0.35 * _r;
      gfx_x = s;
      loop(_r,
        rr = i * i;
        rr *= 3 * rr;
        ang1 = _y + 0.35 * _r - 0.8 * _r * exp(-1.5 * rr * _r);
        gfx_lineto(s, ang1 + ang2, 1);
        s += 1;
        i += di;
      );
      ang2 += 1;
    );
  ) : ( id == 13 ) ? (
    // Custom impulse
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 1 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = -0.2;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      gfx_a = 0.8;
      loop(2 * len,
        _r = sin(12.1 * s) + sin(9.22 * s + 3) + cos(12.22 * s + 1) - 0.1;
        _r *= cos(s) * cos(s);
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 20 ) ? (
    xx = _x - 0.5 * _r;
    yy = _y + 0.3 * _r;
    rr = floor(4/50 * _r);
    
    gfx_circle(xx, yy, rr, 1);
    gfx_circle(xx + 1, yy, rr, 1);
    gfx_circle(xx + 2, yy, rr, 1);
    gfx_line(xx + rr, yy, xx + rr, yy - 0.5 * _r);
    gfx_line(xx + rr + 1, yy, xx + rr + 1, yy - 0.5 * _r);
    gfx_line(xx + rr + 2, yy, xx + rr + 2, yy - 0.5 * _r);
    
    xx = _x + 0.38 * _r;
    yy = _y + 0.1 * _r - 0.5 * _r;
    gfx_circle(xx, yy, rr, 1);
    gfx_circle(xx + 1, yy, rr, 1);
    gfx_circle(xx + 2, yy, rr, 1);
    gfx_line(xx - rr, yy, xx - rr, yy + 0.5 * _r);
    gfx_line(xx - rr + 1, yy, xx - rr + 1, yy + 0.5 * _r);
    gfx_line(xx - rr + 2, yy, xx - rr + 2, yy + 0.5 * _r);
    
    yy += 0.5 * _r;
    gfx_line(_x - 0.3 * _r, yy, xx - 4 - 0.1 * _r, yy - 0.4 * _r);
    gfx_line(_x - 0.3 * _r, yy + 1, xx - 4 - 0.1 * _r, yy - 0.4 * _r + 1);
//    gfx_circle(_x, _y, 1, 0.5);
  ) : ( id == 21 ) ? (
    // Spin depth
    _x = floor(_x);
    _y = floor(_y);
    dr = (0.65 * pow(relative_position, 0.2)) * _r;
    rr = 0.1 * _r;
    
    ds = ceil(_r / 8);
    loop(ds,
      gfx_circle(_x, _y, rr, 0, 1);
      rr += 0.5;
    );
    
    rr = -1;
    loop(8,
      gfx_line(floor(_x - rr), floor(_y - rr), floor(_x + dr * 0.707 - rr), floor(_y - dr * 0.707 - rr), 1);
      rr += 0.25;
    );
    
    rr = dr;
    loop(ds,
      gfx_circle(_x, _y, rr, 0, 1);
      rr += 0.5;
    );
    
    rr = 0.1 * _r;
    loop(ds,
      gfx_circle(floor(_x + dr * 0.707), floor(_y - dr * 0.707), rr, 0, 1);
      rr += 0.5;
    );
    
    gfx_set(0, 0, 0, 1.0);
    gfx_circle(floor(_x + dr * 0.707), floor(_y - dr * 0.707), floor(0.1 * _r), 1, 1);
    gfx_set(0, 0, 0, 1.0);
    gfx_circle(floor(_x), floor(_y), floor(0.1 * _r), 1, 1);
  ) : ( id == 22 ) ? (
    // Spin Freq
    _x = floor(_x + 0.01 * _r);
    _y = floor(_y + 0.0 * _r);
    ds = ceil(_r / 8);
    
    rr = 0.6 * _r;
    s = 0;
    loop(ds * 3,
      gfx_arc(_x, _y, rr, min(- 0.76 * $pi + s, 0.46 * $pi), 0.66 * $pi);
      rr -= 0.45;
      s += 0.25;
    );
    
    ang1 = -0.76 * $pi - 1.42 * $pi * relative_position;
    gfx_line(_x, _y, _x + rr * cos(ang1), _y - rr * sin(ang1));
    gfx_line(_x + 1, _y + 1, _x + rr * cos(ang1), _y - rr * sin(ang1));
    gfx_line(_x + 1, _y - 1, _x + rr * cos(ang1), _y - rr * sin(ang1));
  ) : ( id == 23 ) ? (
    // Filter Cutoff
    gfx_a = 0.2 + 0.8 * enabled;
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    rr = 2 * relative_position * len;
    _r = 1 / len;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > rr) ? cy -= min(2, 0.15 * (s - rr)) * _r;
        cy = max(-0.1, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 24 ) ? (
    gfx_a = 0.2 + 0.8 * enabled;
    rr = 0.6 * _r;
    di = 10 / _r / (0.4);
    sy = 0;
    loop(2,
      i = 0;
      s = _x - rr;
      x2 = 2 * rr * (relative_position - 0.5);
      gfx_x = s;
      gfx_y = _y + 0.5 * rr * 2 * (relative_position - 0.5) + sy;
      loop(2 * rr,
        gfx_lineto(s, _y + sy + 0.5 * x2 - i * x2 * exp(- 0.35 * i), 1);
        s += 1;
        i += di;
      );
      sy += 1;
    );
  );
);

function draw_model_icon()
local(s, ds, xx, yy, len, hh, xorig, yorig, value)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _w, _h, active, _me)
(
  colormodel(0.7); gfx_a = 1;
  (_me == 0) ? (
    len = floor(0.4 * _w);
    xx = _x + floor(0.5 * _w);
    yy = _y + 0.5 * _h;
    ds = ceil(0.05 * _w);
    s = ceil(0.2 * _w);
    
    gfx_line(xx - len, yy, xx + len, yy);
    gfx_line(xx - len, yy - ds, xx + len, yy - ds);
    gfx_line(xx - len, yy + ds, xx + len, yy + ds);
    gfx_line(xx - len, yy - 2 * ds, xx + len, yy - 2 * ds);
    gfx_line(xx - len, yy + 2 * ds, xx + len, yy + 2 * ds);
    gfx_circle(xx - ds, yy, s);
  ) : (_me == 1) ? (
    len = floor(0.25 * _h);
    ds = floor(0.08 * _w);
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    
    xx -= 3 * ds;
    loop(3,
      gfx_line(xx - ds, yy - len, xx - ds, yy + len);
      gfx_line(xx + ds, yy - len, xx + ds, yy + len);
      gfx_arc(xx, yy + len, ds, 0.5 * $pi, 1.5 * $pi);
      gfx_circle(xx, yy - len, ds);
      len -= 1;
      xx += 3 * ds;
    );
  ) : (_me == 2) ? (
    len = floor(0.3 * _w);
    ds = $pi / len;
    s = 0;
    yy = _y + 0.5 * _h;
    loop(2,
      xx = _x + floor(0.5 * _w) - len;
      gfx_x = xx;
      gfx_y = yy;
      loop(len * 2,
        gfx_lineto(xx, yy - .5 * len * sin(s));
        xx += 1;
        s += ds;
      );
      yy -= 1;
    );
  ) : (_me == 3) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 4) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_triangle(xx + 2 * len - 1, yy - 2, xx + 2 * len - ds - 1, yy - 2 * ds - 2, xx + 2 * len + ds - 1, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 5) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = 0.5 * $pi / len;
    hh = 0.12 * _h;
    loop(2 * len - 1,
      s += ds;
      colormodel(0.5); gfx_a = 0.5;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + 4 + hh * sqrt(sin(s)));
      colormodel(0.7); gfx_a = 1.0;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + hh * sqrt(sin(s)));
      xx += 1;
    );
  ) : (_me == 6) ? (
    len = floor(0.25 * _w);
    ds = floor(0.15 * _w);
    xx = _x + floor(0.47 * _w) - len;
    yy = _y + 0.5 * _h;
    gfx_line(xx, yy + len, xx + len, yy - len);
    gfx_line(xx, yy + len + 1, xx + len, yy - len + 1);
    gfx_circle(xx + len, yy - len + 1, ds / 2, 1);
    
    gfx_line(xx + ds, yy + len, xx + 2 * ds + len, yy - len + ds);
    gfx_line(xx + ds, yy + len + 1, xx + 2 * ds + len, yy - len + 1 + ds);
    gfx_circle(xx + 2 * ds + len, yy - len + 1 + ds, ds / 2, 1);
  ) : (_me == 7) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.35 * _w);
    ds = floor(0.15 * _w);
    gfx_circle(xx, yy, len, 0);
    gfx_circle(xx, yy, len + 0.5, 0);
    s = 0;
    loop(5,
      gfx_circle(xx + ds * sin(s), yy + ds * cos(s), ds, 0);
      s += 0.4 * $pi;
    );
  ) : (_me == 8 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len, 0);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len + 0.5, 0);
    xorig = xx - 0.25 * len + len / 1.41421 + 1;
    yorig = yy + 0.25 * len - len / 1.41421;
    gfx_line(xorig, yorig, xorig + 0.7 * len, yorig - 0.7 * len);
    gfx_line(xorig, yorig - 1, xorig + 0.7 * len, yorig - 0.7 * len - 1);
    xorig += 0.7 * len;
    yorig -= 0.7 * len;

    gfx_line(xorig, yorig - 1, xorig - 0.5 * len, yorig - 1);
//    gfx_line(xorig, yorig - 2, xorig - 0.5 * len, yorig - 2);
    gfx_line(xorig + 1, yorig - 1, xorig + 1, yorig + 0.5 * len);
//    gfx_line(xorig + 2, yorig - 2, xorig + 2, yorig + 0.5 * len);

  ) : (_me == 9 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.475 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx, yy - 0.5 * len, len, 0);
    gfx_circle(xx, yy - 0.5 * len, len + 0.5, 0);
    gfx_line(xx, yy + 0.5 * len + 1, xx, yy + 1.75 * len);
    gfx_line(xx - 0.5 * len, yy + 1.25 * len, xx + 0.5 * len, yy + 1.25 * len);
  ) : (_me == 11) ? (
    xx = floor(_x + 0.18 * _w) - 1;
    yy = floor(_y + 0.75 * _h);
    len = floor((1 - 0.18*2) * _w);
    ds = floor(len / 2);
    
    ds = floor(len / 3);
    loop(ds,
      value = floor(len * abs(sin(s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 3, value, 0);
      xx += 3;
      s += 1.23;
    );
    
    xx = floor(_x + 0.18 * _w) - 1;
    ds = floor(len / 2);
    loop(ds,
      value = floor(0.5 * len * abs(sin(s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 3, value, 0);
      xx += 2;
      s += 1.23;
    );
  ) : (_me == 12 ) ? (
    xx = floor(_x + 0.18 * _w) - 1;
    yy = floor(_y + 0.75 * _h);
    len = floor((1 - 0.18*2) * _w);
    ds = floor(len / 2);
    
    loop(ds,
      value = floor(len * abs(sin(.9*s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 2, value);
      xx += 2;
      s += 1.23;
    );
  );
);

function label_toggle(x, y, str, hint)
local(ww, hh, over)
global(mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y, last_cap, hinter.sethint)
(
  gfx_x = x; gfx_y = y;
  gfx_measurestr(str, ww, hh);
  gfx_printf(str);
  
  over = (mouse_x > x) && (mouse_x < (x + ww)) && (mouse_y > y) && (mouse_y < (y + hh));
  over ? hinter.sethint(hint);
  
  ((mouse_cap == 1) && (last_cap == 0)) ? (
    over ? 1
  );
);

gfx_setfont(3, "Arial", 12 * max(1, scaling));
gfx_measurestr("[Rel]", velw2, velh2);
colormodel(change_rel_mod - 0.01);
label_toggle(right - velw - 5, 0.935 * _gfx_h, " [Rel]", "Click this to change the release sensitivity of the parameters.\nParameters that can be linked to MIDI note velocity will\nbe highlighted.\n\nChanging their settings will result in those parameters\nchanging upon note release. This sensitivity is\nindicated by a differently colored arc.") ? (
  change_rel_mod = 1 - change_rel_mod;
  change_rel_mod == 1 ? (
    change_vel_mod = 0;
  );
);

gfx_setfont(3, "Arial", 12 * max(1, scaling));
gfx_measurestr("[Vel]", velw, velh);
colormodel(change_vel_mod - 0.01);
label_toggle(right - velw2 - velw - 10, 0.935 * _gfx_h, " [Vel]", "Click this to change the velocity sensitivity of the parameters.\nParameters that can be linked to MIDI note velocity will\nbe highlighted.\n\nChanging their settings will result in those parameters\nbeing sensitive to MIDI note velocity. This sensitivity is\nindicated by a differently colored arc.") ? (
  change_vel_mod = 1 - change_vel_mod;
  change_vel_mod == 1 ? (
    change_rel_mod = 0;
  );
);

colormodel(1 - display_log);
label_toggle(0.02 * _gfx_w, 0.93 * _gfx_h, "[Linear] ", "Display frequencies on a linear scale") ? (display_log = 0);
colormodel(display_log);
label_toggle(gfx_x, gfx_y, "[Logarithmic]", "Display frequencies on a logarithmic scale") ? (display_log = 1);

keyboard.draw_keyboard(base_note, gfx_x + 0.01 * _gfx_w - 10, 0.935 * _gfx_h, right - velw - velw2 - gfx_x - 0.01 * _gfx_w, 0.05 * gfx_y);

midi.note_on0 ? keyboard.highlight_note(midi.active_note_mem[0]);
midi.note_on1 ? keyboard.highlight_note(midi.active_note_mem[1]);
midi.note_on2 ? keyboard.highlight_note(midi.active_note_mem[2]);
midi.note_on3 ? keyboard.highlight_note(midi.active_note_mem[3]);
midi.note_on4 ? keyboard.highlight_note(midi.active_note_mem[4]);

note_over = keyboard.note_clicked();

function handle_non_midi_click(note_over)
instance(over)
local(idx, disabled_note)
global(keyboard.over, last_cap, mouse_cap, settings_changed, midi_input)
(
  this.over ? (
    (!midi_input) ? (
      (last_cap == 0) && (mouse_cap == 1) ? (
        settings_changed = 1;
        idx = 19;
        disabled_note = 0;
        loop(5,
          (slider(idx) == note_over) ? (
            slider_automate(slider(idx) = 0);
            disabled_note = 1;
          );
          idx += 1;
        );
        idx = 19;
        (!disabled_note) ? (
          loop(5,
            (slider(idx) == 0) ? (
              (!disabled_note) ? slider_automate(slider(idx) = note_over);
              disabled_note = 1;
            );
            idx += 1;
          );
        );
      );
    );
  );
);

keyboard.handle_non_midi_click(note_over);

n_knobs = 9 + 0.65 * glide;
radius = floor(0.0315 * 18 / (2 * n_knobs) * _gfx_w);
button_size = floor(0.004 * _gfx_w);
cx = floor(2 * radius);
cy = floor(2 * radius);
knob_spacing = floor(0.61 * 8 / (n_knobs - 1) * radius);


label_font();
legacy_gain = legacyToggle.processMouseToggle(cx + 1.1 * radius, cy + 1 * radius, button_size, button_size, legacy_gain, "Don't normalize gain to register being played\n\nNote that enabling this leads to low notes\nbeing a lot louder than high notes.", mouse_x, mouse_y, mouse_cap);

voice_thievery = voiceStealingToggle.processMouseToggle(cx - 1.2 * radius, cy + 1 * radius, button_size, button_size, voice_thievery, "Enabling this mode makes the voice assignment much more aggressive.\nWhen enabled, a new note gets assigned to any released note. This can\nlead to notes being stolen (shortening their decay), but can result in far\nlower CPU use in TD mode.\n\nWhen disabled, note assignment prefers cycling through the notes.", mouse_x, mouse_y, mouse_cap);

glide = glideToggle.processMouseToggle(cx + 1.1 * radius, cy - 1.1 * radius, button_size, button_size, glide, "Monophonic mode with glide.", mouse_x, mouse_y, mouse_cap);
color_model = 1;

pass_through = passthroughToggle.processMouseToggle(cx - 1.2 * radius, cy - 1.1 * radius, button_size, button_size, pass_through, "Pass through MIDI.\n\nWhen enabled, this plugin will\nforward incoming MIDI notes.", mouse_x, mouse_y, mouse_cap);

function knob_glow(cx, cy, radius, value)
local(r_ix)
global(gfx_a)
instance()
(
  gfx_a = 0.5 * value;
  r_ix = 0;
  loop(10,
    gfx_circle(floor(cx), floor(cy), radius * 1.3 + r_ix);
    r_ix += 1;
    gfx_a *= 0.7;
  );
);

midi_recv *= 0.9;
colormodel(midi_recv);
knob_glow(cx, cy, radius, midi_recv);
playmode_knob.draw_knob(cx, cy, radius, "", 
"Play mode

Determines how the plugin responds to inputs. Dial 
for the different modes, or click with right mouse 
button to select mode from a menu.

Audio input fixes notes
  Received audio and transforms it according to the
  notes set on the keyboard at the bottom.
Audio input with MIDI notes
  Receives audio and MIDI input. Transforms the input
  audio with the MIDI notes played. Note that envelopes
  can optionally be enabled on the right (below the 
  models)
Spike impulse with MIDI notes
  Plays spikes through the resonator on MIDI notes.
  This allows you to play the plugin like a MIDI
  instrument.
Noise impulse with MIDI notes
  Plays spikes through the resonator on MIDI notes.
  This allows you to play the plugin like a MIDI
  instrument.
Constant noise with MIDI notes
  Plays noise through the resonator on MIDI notes.
  As a result, this plays a continuous note until 
  released.
Sample based impulse
  Allows dragging samples for use as impulse 
  response that drives the resonator. Each time a 
  MIDI note comes in one sample is played. If 
  multiple samples are added, they are used in a 
  round robin fashion.
", 1, 1);
playmode_knob.gfx_draw_icon(8 + floor(play_mode), 1);

playmode_knob.over ? (
  ((mouse_cap & 2) == 2) && (last_cap == 0) ? (
    menu_selection = gfx_showmenu("Audio input fixed notes|Audio input with MIDI notes|Spike impulse with MIDI notes|Noise impulse with MIDI notes|Continuous notes MIDI|Sample based impulse");
    menu_selection > 0 ? (
      play_mode = menu_selection - 1;
      menu_selection = 0;
    );
  );
);

glide ? (
  cx += 2 * radius + knob_spacing;
  glide_knob.draw_knob(cx, cy, radius, "", "Glide\n\nGlide duration", 1, 1);
  glide_knob.gfx_draw_icon(20, 1);
);

cx += 2 * radius + knob_spacing;
brightness_knob.draw_knob(cx, cy, radius, "", 
"Brightness

How bright should the impulse be that is 
played through the resonator. Note that 
linking this to the velocity is generally 
a good idea to get an expressive sound.

You can do this by clicking the [velocity]
button on the lower right.
", 1, play_mode > 1.9999);
brightness_knob.gfx_draw_icon(7, play_mode > 1.9999);
cx += 2 * radius + knob_spacing;
custom_partials.amp.over && (model == 11) ? (
  knob_glow(cx, cy, radius, 1.5 * custom_partials.amp.over * abs(sin(time_precise())));
);
position_knob.draw_knob(cx, cy, radius, "", "Relative Position", 1, 1);
position_knob.gfx_draw_icon(0, 1);
cx += 2 * radius + knob_spacing;
damp_knob.draw_knob(cx, cy, radius, "", "Frequency Independent Damping", 1, 1);
damp_knob.gfx_draw_icon(1, 1);
cx += 2 * radius + knob_spacing;
custom_partials.decay.over && (model == 11) ? (
  knob_glow(cx, cy, radius, custom_partials.decay.over * 1.5 * abs(sin(time_precise())));
);
freq_damp_knob.draw_knob(cx, cy, radius, "", "Frequency Dependent Damping", 1, 1);
freq_damp_knob.gfx_draw_icon(2, 1);
cx += 2 * radius + knob_spacing;
((custom_partials.rfreq.over || custom_partials.afreq.over) && (model == 11)) ? (
  knob_glow(cx, cy, radius, 1.5 * (custom_partials.rfreq.over || custom_partials.afreq.over) * abs(sin(time_precise())));
);
inharmonic_knob.draw_knob(cx, cy, radius, "", "Inharmonicity", 1, 1);
inharmonic_knob.gfx_draw_icon(3, 1);
cx += 2 * radius + knob_spacing;
stereo = stereoToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, stereo, "Stereoize the output.", mouse_x, mouse_y, mouse_cap);
stiffness_exp_knob.draw_knob(cx, cy, radius, "", "Input Non-Linearity", 1, 1);
stiffness_exp_knob.gfx_draw_icon(5, 1);
cx += 2 * radius + knob_spacing;
stft_selection = 1 - stftToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, 1 - stft_selection, "Time domain mode\n\nTime domain mode allows using feedback but\nrequires significantly more CPU (especially\nwhen using a large number of partials).\n\nIn addition, it runs the risk of instability, so\nwhile it can be used to obtain creative effects\nit's not really recommended for live use.", mouse_x, mouse_y, mouse_cap);
last_stft = stft_selection;

bp_resonator_mode = resonatorModeToggle.processMouseToggle(cx + 0.95 * radius, cy - 1.1 * radius, button_size, button_size, bp_resonator_mode, "Bandpass resonator\n\nBy default the resonator is a lowpass filter.\nEnabling this makes it a bandpass filter.\nThis leads to more stability, but a thinner\nless feedback prone sound.", mouse_x, mouse_y, mouse_cap);

force_fb.draw_knob(cx, cy, radius, "", "Feedback Level", 1, 1 - stft_selection);
force_fb.gfx_draw_icon(6, 1 - stft_selection);
cx += 2 * radius + knob_spacing;

max_partial = max(string5.used_partials, max(string4.used_partials, max(string3.used_partials, max(string2.used_partials, string1.used_parials))));
partials.textbox_control(cx + 0.9 * radius, cy - 1.2 * radius, 12, 1.0 - stft_selection, sprintf(22, 
"Number of partials to use.

More leads to more high frequencies but higher CPU use.
Low notes tend to require more partials. The currently 
highest requested count is: %d
", max_partial), 16);
partials.over ? (
  (mouse_cap & 2 == 2) ? (
    menu_selection = gfx_showmenu("16|32|48|64");
  );
  menu_selection ? (
    partials = 16 * menu_selection;
  );
);

stiffness_knob.draw_knob(cx, cy, radius, "", "Stiffness (tends to make things louder)", 1, 1 - stft_selection);
stiffness_knob.gfx_draw_icon(4, 1 - stft_selection);
cx += 2 * radius + knob_spacing;

choice_x = cx - radius;

choice_button1.draw_choice(0, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Metal string");
choice_button1.draw_model_icon();
choice_button2.draw_choice(1, cx - radius, cy, radius, radius, 1, "Tube");
choice_button2.draw_model_icon();
cx += radius + 4;

choice_button3.draw_choice(2, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beating");
choice_button3.draw_model_icon();
choice_button4.draw_choice(3, cx - radius, cy, radius, radius, 1, "Beam (both ends open)");
choice_button4.draw_model_icon();
cx += radius + 4;

choice_button5.draw_choice(4, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beam (one end clamped)");
choice_button5.draw_model_icon();
choice_button6.draw_choice(5, cx - radius, cy, radius, radius, 1, "Membrane");
choice_button6.draw_model_icon();
cx += radius + 4;

choice_button7.draw_choice(6, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Marimba");
choice_button7.draw_model_icon();
choice_button8.draw_choice(7, cx - radius, cy, radius, radius, 1, "Pan");
choice_button8.draw_model_icon();
cx += radius + 4;

choice_button9.draw_choice(8, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Male vowels");
choice_button9.draw_model_icon();
choice_button10.draw_choice(9, cx - radius, cy, radius, radius, 1, "Female vowels");
choice_button10.draw_model_icon();
cx += radius + 4;

choice_button11.draw_choice(11, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Custom\n\nCustom model that allows customization\nof two spectra. Interpolation between\nthese spectra is then controlled with\nthe macro controls.");
choice_button11.draw_model_icon();
choice_button12.draw_choice(12, cx - radius, cy, radius, radius, 1, "Custom\n\nCustom model that provides only a single\nspectrum.\n\nThe macro controls then retain the same\nfunction as they did for the built-in spectra.");
choice_button12.draw_model_icon();

final_gfx_x = cx;

bins = 100;

/*
gfx_set(1, 1, 1, 1);
ptr = vowel;
x = 0;
init_vowels(vowel);
loop(64100,
  gfx_circle(0.013 * x, 0.5 * gfx_h - 15 * log10(ptr[]), 1);
  x += 1;
  ptr += 1;
);
*/


function draw_collapse_rect(x, y, w, h, label)
local(over)
global(gfx_a, mouse_x, mouse_y, mouse_cap, last_cap, hinter.sethint)
(
  over = (mouse_x < (x + w)) && (mouse_x > x) && (mouse_y < (y + h)) && (mouse_y > y);
  over ? hinter.sethint(label);
  
  gfx_a = 0.5 + 0.5 * over;
  gfx_rect(x, y, w, h);
  
  over && (mouse_cap == 1) && (last_cap == 0);
);

gfx_x = 0;
gfx_y = 0;
function draw_logo(logomem, rle_mem, ys, x, y)
global(gfx_a)
local(xx, yy, offset, line, ptr, n_iter, current, count)
instance(s, i)
(
  line = 0;
  s += 1;
  colormodel(0);
  loop(230,
    xx = x + line * ys;
    offset = logomem[line];
    ptr = rle_mem + offset;
    n_iter = 0;
    yy = y;
    while((ptr[] != - 1) && (n_iter < 20)) (
      current = ptr[]; ptr += 1;
      (current > -1) ? (
        count = ptr[]; ptr += 1;
        current ? (
          gfx_a *= 0.03;
          gfx_circle(xx, yy, 3);
          gfx_circle(xx, yy, 5);
        
          i = sin(0.01 * line - 0.03 * s);
          i = i > 0 ? i : 0;
          gfx_a = 0.25 + 0.75 * pow(i, 700);
          gfx_line(xx, yy, xx, yy + ys * count, 1);
        );
        yy += ys * count;
      );
      n_iter += 1;
    );
    line += 1;
  );
);

yy = 0.02 * _gfx_h + _gfx_h * 0.9;
//logo.draw_logo(logomem, rle_mem, 0.45, gfx_w - 110, gfx_h - 22);
logo.draw_logo(logomem, rle_mem, 0.45, 6, 6);

// Ctrl + Click the logo enters dev mode
((mouse_cap == 5) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  model = 10;
  settings_changed = 1;
);

// Ctrl + Shift + RMB the logo enters test mode
((mouse_cap == 6 + 8) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  test_mode = 1 - test_mode;
  settings_changed = 1;
);


current_char = gfx_getchar();
handle_gmem_imports();
handle_dropped_files();

/* Advanced Options */

radius = floor(radius);
ys = floor(3.6 * radius);
element_height = radius;

midi_input ? (
  
  /*colormodel(use_envelopes);
  draw_collapse_rect(
    floor(choice_x), floor(3 * radius + 0.5 * button_size) + use_envelopes * floor(2 * radius) + use_envelopes * 1.5 * button_size, 
    floor((radius + 4) * 6 - 4), button_size,
    use_envelopes ? 
      "Disable envelope."
    : "Apply an envelope to the input and output of each string."
  ) ? (use_envelopes = 1 - use_envelopes);*/
  
  use_envelopes
);

(model != 11) && (model != 12) ? (
  gfx_string.draw_stft(0.02 * _gfx_w, 0.02 * _gfx_h, _gfx_w * 0.93, _gfx_h * 0.9);
  right = 0.95 * _gfx_w;
);

advanced_controls = 1;
advanced_controls ? (
  loop(2,
    gfx_x = 0;
    gfx_y = ys;
    gfx_blurto(gfx_w, ys + radius * 2.1);
  );
  
  sample_ws = floor(radius);
  sample_hs = floor(radius);
  xs = floor(radius);
  
  waves_enabled = play_mode > 5;
  
  draw_wavebox(xs, ys, sample_ws, sample_hs, 0, samplelocs[0], waves_enabled);
  process_pad(xs, ys, sample_ws, sample_hs, 0, samplelocs[0]);
  
  draw_wavebox(xs, ys + radius, sample_ws, sample_hs, 2, samplelocs[2], waves_enabled);
  process_pad(xs, ys + radius, sample_ws, sample_hs, 2, samplelocs[2]);
  
  xs += radius;
  draw_wavebox(xs, ys, sample_ws, sample_hs, 1, samplelocs[1], waves_enabled);
  process_pad(xs, ys, sample_ws, sample_hs, 1, samplelocs[1]);
  
  draw_wavebox(xs, ys + radius, sample_ws, sample_hs, 3, samplelocs[3], waves_enabled);
  process_pad(xs, ys + radius, sample_ws, sample_hs, 3, samplelocs[3]);
    
  xs += floor(radius + knob_spacing;);
  
  /* Big waveform area */
  close_up.draw_sample_big(xs, ys, 4 * radius + knob_spacing, 2 * radius, waves_enabled);
  
  cy = ys + radius;
  cx = floor(2 * radius) + (2 * radius + knob_spacing) * 3;
   
  spin_depth_knob.draw_knob(cx, cy, radius, "", 
  "Spin depth
  
  Controls how much of a spinning effect should
  be applied.", 1, 1);
  spin_depth_knob.gfx_draw_icon(21, 1);
  
  cx += 2 * radius + knob_spacing;
  
  spin_freq_knob.draw_knob(cx, cy, radius, "", 
  "Spin frequency
  
  Controls how fast the source should spin.", 1, 1);
  spin_freq_knob.gfx_draw_icon(22, 1);
  cx += 2 * radius + knob_spacing;
  
  filter_cutoff_knob.draw_knob(cx, cy, radius, "", "Filter cutoff.", 1, enable_filter);
  filter_cutoff_knob.gfx_draw_icon(23, enable_filter);
  enable_filter = filterToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, enable_filter, "Enable filter.", mouse_x, mouse_y, mouse_cap);  
  
  cx += 2 * radius + knob_spacing;
  
  filter_envelope_knob.draw_knob(cx, cy, radius, "", "Filter Envelope.", 1, use_filt_envelopes && enable_filter);
  filter_envelope_knob.gfx_draw_icon(24, use_filt_envelopes && enable_filter);
  cx += radius + knob_spacing;
  
  env_width = (final_gfx_x - cx - knob_spacing) * 0.5;
  env2.draw_envelope(cx, ys, env_width, floor(2 * radius), use_filt_envelopes && enable_filter);
  enable_filter ? (
    use_filt_envelopes = filterEnvelopeToggle.processMouseToggle(cx + env_width - button_size * 3, ys + 0.25 * radius, button_size, button_size, use_filt_envelopes, "Apply filter envelope.\n\nNote that in FD mode, only a single envelope\nis used for all strings while in time domain mode\neach string gets its own.", mouse_x, mouse_y, mouse_cap);  
  );
  
  cx += env_width + knob_spacing;
  env.draw_envelope(cx, ys, env_width, floor(2 * radius), use_envelopes);
  use_envelopes = envelopeToggle.processMouseToggle(cx + env_width - button_size * 3, ys + 0.25 * radius, button_size, button_size, use_envelopes, "Apply output envelope.", mouse_x, mouse_y, mouse_cap);
);

updated_loop ? (
  /*preview_channel.channel_update_loop();
  chan1.channel_update_loop();
  chan2.channel_update_loop();
  chan3.channel_update_loop();
  chan4.channel_update_loop();

  (!settings1.retrigger && !chan1.playing) ? chan1.start_sample(0, pitch1);
  (!settings2.retrigger && !chan1.playing) ? chan2.start_sample(1, pitch2);
  (!settings3.retrigger && !chan1.playing) ? chan3.start_sample(2, pitch3);
  (!settings4.retrigger && !chan1.playing) ? chan4.start_sample(3, pitch4);*/
  updated_loop = 0;
);


((model == 11) || (model == 12)) ? (
  right = custom_partials.draw_custom_partial_ui(0.02 * _gfx_w, cy + 1.5 * radius, 0.96 * _gfx_w, 0.935 * _gfx_h - (cy + 1.5 * radius) - 5, custom_partial_mem, MAX_CUSTOM_PARTIALS, partials_used, model==11);
);

sample_data_gfx_finalize();

gfx_x = 115; gfx_y = 3;
colormodel(0.4);
gfx_setfont(4, "Arial", 10 * max(1,scaling));
gfx_printf("v0.58 ALPHA (Warning: this plugin is not production ready and is still actively being developed)");

(model == 10) ? (
  colormodel(0.0);
  gfx_a = 0.3 * abs(sin(time_precise()));
  gfx_setfont(6, "Arial", 180);
  gfx_measurestr("DEV MODE", gw, gh);
  gfx_x = (_gfx_w - gw) / 2; gfx_y = (_gfx_h - gh) / 2;
  gfx_printf("DEV MODE")
);

gfx_setfont(4, "Arial", 10 * max(1,scaling));
hinter.drawhint();
newtime = time_precise();
delta_time = newtime - ctime;
ctime = newtime;

lx = mouse_x;
ly = mouse_y;
handle_mouse_sample_handler();
last_cap = mouse_cap;
mouse_cap == 0 ? captured = 0;

/*
gfx_x = 0;
gfx_y = 0;
gfx_set(1, 1, 1, 1);
fff = midi.note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 30;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 60;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_vel;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 90;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_state;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);
*/

loaded_sample = 0;

