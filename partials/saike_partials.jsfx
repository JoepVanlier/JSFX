desc:Partials
tags: modal effect
version: 0.01
author: Joep Vanlier
changelog: Initial commit
license: MIT
provides:
  partials_dependencies/*
about:
  # An effect which simulates different materials
  This effect takes both audio and MIDI input. Based on the model selected the incoming audio will excite
  a number of resonators that produce particular sounds. Up to 4 note polyphony is supported.

slider1:model=0<0,1,10{Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice (male),Voice (female)>-model
slider2:placeholder=0<0,1,1>-Placeholder
slider3:relative_position=0.1<0.0001,0.999,0.001>-Relative position
slider4:damp=0.1<-2,2,0.0001>-Damping
slider5:freq_damp=-4<-6,-1,0.0001>-Frequency Dependent Damping
slider6:inharmonic=-4<-4, 0, 0.0001>-Inharmonic
slider7:stiffness=4.6<0,6,0.0001>-Stiffness
slider8:stiffness_exp=2.3<1,3.0,.0001>-Stiffness Exponent
slider9:placeholder=0<0,1,1>-Placeholder
slider10:base_note=0<-12,12,1>Base note
slider11:force_fb=1<0,15,0.0001>-Forced feedback (TD only)
slider12:partials=32<16,64,16>-Partials
slider13:stereo=1<0,1,1{Off,On}>-Stereo-ize
slider18:midi_input=0<0,1,1{Off,On}>Midi input
slider62:display_log=0<0,1,1{Linear,Logarithmic}>-Display type
slider63:stft=1<0,1,1>-STFT

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import saike_kp_midi.jsfx-inc
import saike_modal.jsfx-inc
import saike_modal_stft.jsfx-inc
import saike_modal_gfx.jsfx-inc
import saike_vowel_data.jsfx-inc
import saike_modal_buffer.jsfx-inc

@init
position_knob.init_knob(0, 1, 0.1, 3);
damp_knob.init_knob(-2, 2, 0.1, 4);
freq_damp_knob.init_knob(-6, -1, -4, 5);
inharmonic_knob.init_knob(-4, 0, -4, 6);
stiffness_knob.init_knob(0, 6, 4.6, 7);
stiffness_exp_knob.init_knob(1.0, 3.0, 2.3, 8);
force_fb.init_knob(0, 15.0, 1.0, 11);
partials.init_knob(16, 64, 32, 12);

freemem = stft_mem.fft_mem(freemem, 64);

freemem = string1.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
freemem = string2.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
freemem = string3.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
freemem = string4.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
freemem = string5.string_mem(freemem, stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem);

freemem = gfx_stft_mem.fft_mem(freemem, 512);
freemem = gfx_string.string_mem(freemem, gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem);

freemem = (bessel_roots = freemem) + 2048;
memset(bessel_roots, 0, 2048);
bessel_roots[0] = 1.000000; bessel_roots[1] = 2.917295; bessel_roots[2] = 4.831885; bessel_roots[3] = 6.746213; bessel_roots[4] = 8.660476; bessel_roots[5] = 10.574713; bessel_roots[6] = 12.488940; bessel_roots[7] = 14.403161; bessel_roots[8] = 16.317378; bessel_roots[9] = 18.231593; bessel_roots[10] = 20.145807; bessel_roots[11] = 22.060020; bessel_roots[12] = 23.974232; bessel_roots[13] = 25.888443; bessel_roots[14] = 27.802654; bessel_roots[15] = 29.716865; bessel_roots[16] = 31.631075;
bessel_roots[17] = 33.545286; bessel_roots[18] = 35.459496; bessel_roots[19] = 37.373706; bessel_roots[20] = 39.287916; bessel_roots[21] = 41.202125; bessel_roots[22] = 43.116335; bessel_roots[23] = 45.030545; bessel_roots[24] = 46.944754; bessel_roots[25] = 48.858964; bessel_roots[26] = 50.773173; bessel_roots[27] = 52.687383; bessel_roots[28] = 54.601592; bessel_roots[29] = 56.515802; bessel_roots[30] = 58.430011; bessel_roots[31] = 60.344220; bessel_roots[32] = 62.258430;
bessel_roots[33] = 64.172639; bessel_roots[34] = 66.086848; bessel_roots[35] = 68.001058; bessel_roots[36] = 69.915267; bessel_roots[37] = 71.829476; bessel_roots[38] = 73.743685; bessel_roots[39] = 75.657895; bessel_roots[40] = 77.572104; bessel_roots[41] = 79.486313; bessel_roots[42] = 81.400522; bessel_roots[43] = 83.314731; bessel_roots[44] = 85.228941; bessel_roots[45] = 87.143150; bessel_roots[46] = 89.057359; bessel_roots[47] = 90.971568; bessel_roots[48] = 92.885777;
bessel_roots[49] = 94.799986; bessel_roots[50] = 96.714196; bessel_roots[51] = 98.628405; bessel_roots[52] = 100.542614; bessel_roots[53] = 102.456823; bessel_roots[54] = 104.371032; bessel_roots[55] = 106.285241; bessel_roots[56] = 108.199450; bessel_roots[57] = 110.113660; bessel_roots[58] = 112.027869; bessel_roots[59] = 113.942078; bessel_roots[60] = 115.856287; bessel_roots[61] = 117.770496; bessel_roots[62] = 119.684705; bessel_roots[63] = 121.598914; bessel_roots[64] = 123.513123;
bessel_roots[65] = 125.427332; bessel_roots[66] = 127.341542; bessel_roots[67] = 129.255751; bessel_roots[68] = 131.169960; bessel_roots[69] = 133.084169; bessel_roots[70] = 134.998378; bessel_roots[71] = 136.912587; bessel_roots[72] = 138.826796; bessel_roots[73] = 140.741005; bessel_roots[74] = 142.655214; bessel_roots[75] = 144.569423; bessel_roots[76] = 146.483633; bessel_roots[77] = 148.397842; bessel_roots[78] = 150.312051; bessel_roots[79] = 152.226260; bessel_roots[80] = 154.140469;
bessel_roots[81] = 156.054678; bessel_roots[82] = 157.968887; bessel_roots[83] = 159.883096; bessel_roots[84] = 161.797305; bessel_roots[85] = 163.711514; bessel_roots[86] = 165.625723; bessel_roots[87] = 167.539933; bessel_roots[88] = 169.454142; bessel_roots[89] = 171.368351; bessel_roots[90] = 173.282560; bessel_roots[91] = 175.196769; bessel_roots[92] = 177.110978; bessel_roots[93] = 179.025187; bessel_roots[94] = 180.939396; bessel_roots[95] = 182.853605; bessel_roots[96] = 184.767814;
bessel_roots[97] = 186.682023; bessel_roots[98] = 188.596232; bessel_roots[99] = 190.510441; bessel_roots[100] = 192.424651; bessel_roots[101] = 194.338860; bessel_roots[102] = 196.253069; bessel_roots[103] = 198.167278; bessel_roots[104] = 200.081487; bessel_roots[105] = 201.995696; bessel_roots[106] = 203.909905; bessel_roots[107] = 205.824114; bessel_roots[108] = 207.738323; bessel_roots[109] = 209.652532; bessel_roots[110] = 211.566741; bessel_roots[111] = 213.480950; bessel_roots[112] = 215.395159;
bessel_roots[113] = 217.309368; bessel_roots[114] = 219.223578; bessel_roots[115] = 221.137787; bessel_roots[116] = 223.051996; bessel_roots[117] = 224.966205; bessel_roots[118] = 226.880414; bessel_roots[119] = 228.794623; bessel_roots[120] = 230.708832; bessel_roots[121] = 232.623041; bessel_roots[122] = 234.537250; bessel_roots[123] = 236.451459; bessel_roots[124] = 238.365668; bessel_roots[125] = 240.279877; bessel_roots[126] = 242.194086; bessel_roots[127] = 244.108295; bessel_roots[128] = 246.022504; bessel_roots[129] = 247.936713; bessel_roots[130] = 249.850923; bessel_roots[131] = 251.765132; bessel_roots[132] = 253.679341;
bessel_roots[133] = 255.593550; bessel_roots[134] = 257.507759; bessel_roots[135] = 259.421968; bessel_roots[136] = 261.336177; bessel_roots[137] = 263.250386; bessel_roots[138] = 265.164595; bessel_roots[139] = 267.078804; bessel_roots[140] = 268.993013; bessel_roots[141] = 270.907222; bessel_roots[142] = 272.821431; bessel_roots[143] = 274.735640; bessel_roots[144] = 276.649849; bessel_roots[145] = 278.564059; bessel_roots[146] = 280.478268; bessel_roots[147] = 282.392477; bessel_roots[148] = 284.306686;
bessel_roots[149] = 286.220895; bessel_roots[150] = 288.135104; bessel_roots[151] = 290.049313; bessel_roots[152] = 291.963522; bessel_roots[153] = 293.877731; bessel_roots[154] = 295.791940; bessel_roots[155] = 297.706149; bessel_roots[156] = 299.620358; bessel_roots[157] = 301.534567; bessel_roots[158] = 303.448776; bessel_roots[159] = 305.362985; bessel_roots[160] = 307.277194; bessel_roots[161] = 309.191403; bessel_roots[162] = 311.105613; bessel_roots[163] = 313.019822; bessel_roots[164] = 314.934031;
bessel_roots[165] = 316.848240; bessel_roots[166] = 318.762449; bessel_roots[167] = 320.676658; bessel_roots[168] = 322.590867; bessel_roots[169] = 324.505076; bessel_roots[170] = 326.419285; bessel_roots[171] = 328.333494; bessel_roots[172] = 330.247703; bessel_roots[173] = 332.161912; bessel_roots[174] = 334.076121; bessel_roots[175] = 335.990330; bessel_roots[176] = 337.904539; bessel_roots[177] = 339.818748; bessel_roots[178] = 341.732957; bessel_roots[179] = 343.647167; bessel_roots[180] = 345.561376;
bessel_roots[181] = 347.475585; bessel_roots[182] = 349.389794; bessel_roots[183] = 351.304003; bessel_roots[184] = 353.218212; bessel_roots[185] = 355.132421; bessel_roots[186] = 357.046630; bessel_roots[187] = 358.960839; bessel_roots[188] = 360.875048; bessel_roots[189] = 362.789257; bessel_roots[190] = 364.703466; bessel_roots[191] = 366.617675; bessel_roots[192] = 368.531884; bessel_roots[193] = 370.446093; bessel_roots[194] = 372.360302; bessel_roots[195] = 374.274511; bessel_roots[196] = 376.188720; bessel_roots[197] = 378.102930; bessel_roots[198] = 380.017139;

//bessel_roots[0] = 1.000000; bessel_roots[1] = 1.639423; bessel_roots[2] = 1.870192; bessel_roots[3] = 2.403846; bessel_roots[4] = 2.860577; bessel_roots[5] = 3.278846; bessel_roots[6] = 3.980769; bessel_roots[7] = 4.192308; bessel_roots[8] = 5.225962; bessel_roots[9] = 5.649038; bessel_roots[10] = 6.591346; bessel_roots[11] = 7.240385; bessel_roots[12] = 8.956731; bessel_roots[13] = 10.802885;
//freemem = (bessel_roots = freemem) + 2048;
//memset(bessel_roots, 0, 2048);

freemem = midi.init_midi(freemem);

freemem = buffer.init_buffer(freemem, freemem + 32766);
freemem += 32768;

delay_ms = 16.12;
buffer.set_offset(delay_ms * srate / 1000);
lowcut = 0.34;
lowcut_freq = exp((1-LowCut) * log(20/22050));
hp.init_linearSVF(lowcut_freq, 0);
displayFreq = 0.5 * srate * lowcut_freq / $pi;

freemem = init_vowels(freemem);

logomem = freemem;

handle = file_open("partials_dependencies/logo.ske");
file_var(handle, logo_line_count);
file_mem(handle, logomem, logo_line_count);
rle_mem = logomem + logo_line_count + 1;
file_var(handle, count);
file_mem(handle, rle_mem, count);
file_close(handle);

freemem += 32768;

function tanh(x)
local()
global()
instance()
(
  (2/(1+exp(-2*x)) - 1)
);


function set_pars(f_0)
(
  stft ? (
    this.set_pars_stft(f_0);
  ) : (
    this.set_pars_td(f_0);
  );
);

function eval_string(f_h, on)
(
  stft ? (
    this.eval_string_stft(f_h, on);
  ) : (
    this.eval_string_td(on ? f_h : 0);
  );
);


function update_notes()
instance(notes_on, active_note_mem)
global(string1.set_pars, string2.set_pars, string3.set_pars, string4.set_pars, string5.set_pars, srate, pitch, ref_f)
local(scaling)
(
  ref_f = scaling * 2 ^ ((active_note_mem[0] - 69) / 12);

  // Update note parameters
  scaling = 440;
  pitch = scaling * 2 ^ ((active_note_mem[0] - 69) / 12);
  notes_on ? string1.set_pars(scaling * 2 ^ ((active_note_mem[0] - 69) / 12));
  notes_on > 1 ? string2.set_pars(scaling * 2 ^ ((active_note_mem[1] - 69) / 12));
  notes_on > 2 ? string3.set_pars(scaling * 2 ^ ((active_note_mem[2] - 69) / 12));
  notes_on > 3 ? string4.set_pars(scaling * 2 ^ ((active_note_mem[3] - 69) / 12));
  notes_on > 4 ? string5.set_pars(scaling * 2 ^ ((active_note_mem[4] - 69) / 12));
);

function force_update()
(
  string1.ticker += 1000;
  string2.ticker += 1000;
  string3.ticker += 1000;
  string4.ticker += 1000;
  string5.ticker += 1000;
  midi.update_notes();
);


@slider
force_update();

@block
midi.midi_block();

@sample
midi.curSample += 1;
midi_input ? (
  midi.notes_remain ? (
    midi.midi_sample();
    // Force instant reset
    force_update();
  );
);


update_global_parameters();

!midi_input ? (
  mul = pow(2, base_note / 12);
  string1.set_pars(220/2 * mul);
  string2.set_pars(329.628/2 * mul);
  string3.set_pars(261.63 * mul);
  string4.set_pars(329.628 * mul);
);

f_hn = 0;
f_b = 0;

stft ? stft_mem.read_stft(f_h);

midi_input ? (
  string1.eval_string(f_h, midi.notes_on > 0);
  string2.eval_string(f_h, midi.notes_on > 1);
  string3.eval_string(f_h, midi.notes_on > 2);
  string4.eval_string(f_h, midi.notes_on > 3);
  string5.eval_string(f_h, midi.notes_on > 4);
) : (
  string1.eval_string(f_h, 1);
  string2.eval_string(f_h, 1);
  string3.eval_string(f_h, 1);
  string4.eval_string(f_h, 1);
  string5.f_b = string5.f_hn = 0;
);

stft ? (
  stft_mem.write_stft();
  f_b = stft_mem.f_b;
  f_hn = stft_mem.f_hn;
) : (
  f_b += string1.f_b; f_hn += string1.f_hn;
  f_b += string2.f_b; f_hn += string2.f_hn;
  f_b += string3.f_b; f_hn += string3.f_hn;
  f_b += string4.f_b; f_hn += string4.f_hn;
  f_b += string5.f_b; f_hn += string5.f_hn;
);

hammer = 0;

/*
env_f = max(spl0 * f_hn, 0.995 * env_f);
sig = (rand() - 0.5);
lp = 0.4 * lp + 0.6 * sig;
f_b += 0.2 * (sig - lp) * abs(env_f);
*/

hammer ? (
  f_h = (1 + force_fb) * f_hn;
  f_h += spl0;
  mh = 4.9;
  ah = -(1.0/mh) * fdy;
  vh = vh + (1.0/srate) * ah;
  yh = yh + (1.0/srate) * vh;
  dy = - f_h + yh;
  fdy = ((dy > 0) ? (10^stiffness) * dy^stiffness_exp : 0);
  f_h = fdy;
) : (
  // No hammer
  delay = 1;
  delay ? (
    f_h = (force_fb) * f_hn;
    f_h += spl0;
    f_h = -(f_h > 0 ? (10^stiffness) * f_h^stiffness_exp : 0);
  ) : (
    f_h = f_delay;
    f_delay = (force_fb) * f_hn;
    f_delay += spl0;
    f_delay = -(f_delay > 0 ? (10^stiffness) * f_delay^stiffness_exp : 0);
  );
);

stft ? (
  f_delay = f_h = spl0;
  f_h = -(f_h > 0 ? (10^stiffness) * f_h^stiffness_exp : 0);
);


stereo ? (
  buffer.update_buffer(f_b);
  rb = buffer.read_buffer();

  /* Highpass the added comb filter signal */
  rb = hp.eval_linearSVF_HP6(rb);
  
  spl0 = f_b + 0.33 * rb;
  spl1 = f_b - 0.33 * rb;
) : (
  spl0 = spl1 = f_b;
);

@gfx
//gfx_set(0, 0, 0, 1);
//gfx_rect(0, 0, gfx_w, gfx_h);

((init_w != gfx_w) || (init_h != gfx_h) || (model != last_model)) ? (
  init_w = gfx_w;
  init_h = gfx_h;
  last_model = model;
  gfx_setimgdim(1, gfx_w, gfx_h);
  gfx_dest = 1;
  gfx_set(0, 0, 0, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);
  
  loop(100,
    xx = gfx_w * rand();
    yy = gfx_h * rand();
    colormodel(rand()*rand()*rand()); gfx_a = 0.2;
    gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
  );
  loop(5,
    gfx_x = gfx_y = 0;
    gfx_blurto(gfx_w, gfx_h)
  );
  
  gfx_dest = -1;
);


gfx_dest = 1;
xx = gfx_w * rand();
yy = gfx_h * rand();
colormodel(rand()*rand()*rand()); gfx_a = 0.2;
gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
/*
xx = 2 * gfx_w * rand();
yy = gfx_h * rand();
loop(10,
  colormodel(0); gfx_a = 0.1;
  gfx_line(xx, 1, xx - gfx_h * 2, gfx_h + 1);
  gfx_line(xx, 2, xx - gfx_h * 2, gfx_h + 2);
  gfx_a = 10;
  gfx_line(xx, 0, xx - gfx_h * 2, gfx_h);
);
*/
gfx_x = gfx_y = 0;
gfx_blurto(gfx_w, gfx_h);
gfx_dest = -1;

gfx_x = gfx_y = 0; gfx_a = 0.25;
gfx_blit(1, 1, 0);



/*
gfx_set(0.3, 0.3, 0.7, 1);
ix = 0;
loop(string1.fft_size,
  yc = 0.5 * gfx_h * sqrt(string1.coeff_mem[2 * ix]^2 + string1.coeff_mem[2 * ix + 1]^2);
  gfx_rect(2 * ix, gfx_h - yc, 1, yc);
  ix += 1;
);
*/

function simple_arrow(xx, yy, _r)
local(dr)
global()
(
  dr = ceil(0.06 * _r);
  xx = floor(xx);
  yy = floor(yy);
  _r = floor(_r);
  gfx_line(xx, yy - 0.4 * _r, xx, yy - 2 * dr - 1);
  gfx_line(xx + 1, yy - 0.4 * _r, xx + 1, yy - 2 * dr - 1);
  gfx_line(xx - 1, yy - 0.4 * _r, xx - 1, yy - 2 * dr - 1);
  gfx_triangle(xx - dr, yy - 2 * dr, xx + dr, yy - 2 * dr, xx, yy);
);

function gfx_draw_icon(id, enabled)
local(len, xp, xx, yy, dr, s, ds, cy, sy, ang1, ang2, x1, x2, y1, y2)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _r, relative_position)
( 
  colormodel(0.9);
  id == 0 ? (
    // Position
    len = ceil(0.6 * _r);
    yy = _y + 0.1 * _r;
    gfx_line(_x - len, yy, _x + len, yy, 1);
    gfx_line(_x - len, yy + 1, _x + len, yy + 1, 1);
    
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(xx, yy, _r);
  ) : ( id == 1 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 5 * relative_position / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * s - sy);
        s -= ds * s;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 2 ) ? (
    // Freq Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > 2 * (1 - relative_position) * len) ? cy -= 2 / len;
        cy = max(0, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 3 ) ? (
    // Spring
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 4.0 * relative_position;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(8.5 * len,
        cy = (1 - 0.4 * relative_position) * s - sy;
        gfx_a = 0.5 + 0.4 * cos(cy);
        
        gfx_lineto(floor(_x + xx - sy + 5 * cos(cy) * tanh(xx / len)), floor(_y - sy + yy * sin(cy)));
        s += 0.35;
        xx += 0.25;
      );
      sy -= 1;
    );
  ) : ( id == 4 ) ? (
    // Stiffness
    len = ceil(0.6 * _r);
    yy = _y + 0.35 * _r;
    dr = _r * (0.5 + relative_position);
    
    gfx_a = 1;
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(_x, _y + 0.05 * _r - 0.1 * _r * relative_position, _r);

    xx = _x - len + ceil(2 * len * relative_position);
    gfx_a = relative_position;
    simple_arrow(_x + 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    simple_arrow(_x - 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    
    gfx_a = 1;
    ang1 = $pi + asin(0.45 * _r / dr);
    ang2 = $pi - asin(0.45 * _r / dr);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
  ) : ( id == 5 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 0.5 / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 0;
      gfx_x = xx;
      gfx_y = _y + yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * pow(s, 1 + 5 * relative_position) - sy);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 6 ) ? (
    gfx_a = enabled;
    x1 = floor(_x - 0.3 * _r);
    x2 = floor(_x + 0.3 * _r);
    dr = floor(0.07 * _r);
    gfx_circle(x1, y2, dr, 1);
  
    gfx_a = 0.1 + 0.9 * relative_position * enabled;
    y1 = floor(_y - 0.3 * _r);
    y2 = floor(_y + 0.3 * _r);
    
    loop(2,
      x1 = floor(_x - 0.3 * _r);
      x2 = floor(_x + 0.3 * _r);
      loop(2,
        gfx_line(x1, y1, x1, y2 - 3 * dr);
        gfx_line(x1, y1, x1, y1);
        gfx_line(x1 + 1, y1, x2 - 1, y1);
        gfx_line(x2, y1, x2, y2 - 1);
        gfx_line(x1 + 3 * dr, y2, x2, y2);    
        gfx_line(x1 + 3 * dr, y2 + 1, x1 + 4 * dr, y2 + dr + 1);
        gfx_line(x1 + 3 * dr, y2 - 1, x1 + 4 * dr, y2 - dr - 1);
        x1 += 1;
        x2 += 1;
      );
      y1 += 1;
      y2 += 1;
    );
  );
);

function draw_model_icon()
local(s, ds, xx, yy, len, hh, xorig, yorig)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _w, _h, active, _me)
(
  colormodel(0.7); gfx_a = 1;
  (_me == 0) ? (
    len = floor(0.4 * _w);
    xx = _x + floor(0.5 * _w);
    yy = _y + 0.5 * _h;
    ds = ceil(0.05 * _w);
    s = ceil(0.2 * _w);
    
    gfx_line(xx - len, yy, xx + len, yy);
    gfx_line(xx - len, yy - ds, xx + len, yy - ds);
    gfx_line(xx - len, yy + ds, xx + len, yy + ds);
    gfx_line(xx - len, yy - 2 * ds, xx + len, yy - 2 * ds);
    gfx_line(xx - len, yy + 2 * ds, xx + len, yy + 2 * ds);
    gfx_circle(xx - ds, yy, s);
  ) : (_me == 1) ? (
    len = floor(0.25 * _h);
    ds = floor(0.08 * _w);
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    
    xx -= 3 * ds;
    loop(3,
      gfx_line(xx - ds, yy - len, xx - ds, yy + len);
      gfx_line(xx + ds, yy - len, xx + ds, yy + len);
      gfx_arc(xx, yy + len, ds, 0.5 * $pi, 1.5 * $pi);
      gfx_circle(xx, yy - len, ds);
      len -= 1;
      xx += 3 * ds;
    );
  ) : (_me == 2) ? (
    len = floor(0.3 * _w);
    ds = $pi / len;
    s = 0;
    yy = _y + 0.5 * _h;
    loop(2,
      xx = _x + floor(0.5 * _w) - len;
      gfx_x = xx;
      gfx_y = yy;
      loop(len * 2,
        gfx_lineto(xx, yy - .5 * len * sin(s));
        xx += 1;
        s += ds;
      );
      yy -= 1;
    );
  ) : (_me == 3) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 4) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_triangle(xx + 2 * len - 1, yy - 2, xx + 2 * len - ds - 1, yy - 2 * ds - 2, xx + 2 * len + ds - 1, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 5) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = 0.5 * $pi / len;
    hh = 0.12 * _h;
    loop(2 * len - 1,
      s += ds;
      colormodel(0.5); gfx_a = 0.5;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + 4 + hh * sqrt(sin(s)));
      colormodel(0.7); gfx_a = 1.0;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + hh * sqrt(sin(s)));
      xx += 1;
    );
  ) : (_me == 6) ? (
    len = floor(0.25 * _w);
    ds = floor(0.15 * _w);
    xx = _x + floor(0.47 * _w) - len;
    yy = _y + 0.5 * _h;
    gfx_line(xx, yy + len, xx + len, yy - len);
    gfx_line(xx, yy + len + 1, xx + len, yy - len + 1);
    gfx_circle(xx + len, yy - len + 1, ds / 2, 1);
    
    gfx_line(xx + ds, yy + len, xx + 2 * ds + len, yy - len + ds);
    gfx_line(xx + ds, yy + len + 1, xx + 2 * ds + len, yy - len + 1 + ds);
    gfx_circle(xx + 2 * ds + len, yy - len + 1 + ds, ds / 2, 1);
  ) : (_me == 7) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.35 * _w);
    ds = floor(0.15 * _w);
    gfx_circle(xx, yy, len, 0);
    gfx_circle(xx, yy, len + 0.5, 0);
    s = 0;
    loop(5,
      gfx_circle(xx + ds * sin(s), yy + ds * cos(s), ds, 0);
      s += 0.4 * $pi;
    );
  ) : (_me == 8 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len, 0);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len + 0.5, 0);
    xorig = xx - 0.25 * len + len / 1.41421 + 1;
    yorig = yy + 0.25 * len - len / 1.41421;
    gfx_line(xorig, yorig, xorig + 0.7 * len, yorig - 0.7 * len);
    gfx_line(xorig, yorig - 1, xorig + 0.7 * len, yorig - 0.7 * len - 1);
    xorig += 0.7 * len;
    yorig -= 0.7 * len;

    gfx_line(xorig, yorig - 1, xorig - 0.5 * len, yorig - 1);
//    gfx_line(xorig, yorig - 2, xorig - 0.5 * len, yorig - 2);
    gfx_line(xorig + 1, yorig - 1, xorig + 1, yorig + 0.5 * len);
//    gfx_line(xorig + 2, yorig - 2, xorig + 2, yorig + 0.5 * len);

  ) : (_me == 9 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.475 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx, yy - 0.5 * len, len, 0);
    gfx_circle(xx, yy - 0.5 * len, len + 0.5, 0);
    gfx_line(xx, yy + 0.5 * len + 1, xx, yy + 1.75 * len);
    gfx_line(xx - 0.5 * len, yy + 1.25 * len, xx + 0.5 * len, yy + 1.25 * len);
  );
);

gfx_string.draw_stft(0.02 * gfx_w, 0.02 * gfx_h, gfx_w * 0.93, gfx_h * 0.9);

function label_toggle(x, y, str)
local(ww, hh)
global(mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y, last_cap)
(
  gfx_x = x; gfx_y = y;
  gfx_measurestr(str, ww, hh);
  gfx_printf(str);
  
  ((mouse_cap == 1) && (last_cap == 0)) ? (
    (mouse_x > x) && (mouse_x < (x + ww)) && (mouse_y > y) && (mouse_y < (y + hh)) ? (
      1
    );
  );
);



gfx_setfont(3, "Arial", 12);
colormodel(1 - display_log - 0.01);
label_toggle(0.02 * gfx_w, 0.935 * gfx_h, "[Linear] ") ? (display_log = 0);
colormodel(display_log);
label_toggle(gfx_x, gfx_y, "[Logarithmic]") ? (display_log = 1);

keyboard.draw_keyboard(base_note, notes, 0.12 * gfx_w, 0.935 * gfx_h, gfx_w * 0.82, 0.05 * gfx_y);

midi_input ? (
  keyboard.highlight_note(midi.active_note_mem[0]);
  keyboard.highlight_note(midi.active_note_mem[1]);
  keyboard.highlight_note(midi.active_note_mem[2]);
  keyboard.highlight_note(midi.active_note_mem[3]);
  keyboard.highlight_note(midi.active_note_mem[4]);
);



radius = 0.032 * gfx_w;
button_size = 0.004 * gfx_w;
cx = 2 * radius;
cy = 2 * radius;

label_font();
position_knob.draw_knob(cx, cy, radius, "", "Relative Position", 1, 1);
position_knob.gfx_draw_icon(0, 1);
cx += 3 * radius;
damp_knob.draw_knob(cx, cy, radius, "", "Frequency Independent Damping", 1, 1);
damp_knob.gfx_draw_icon(1, 1);
cx += 3 * radius;
freq_damp_knob.draw_knob(cx, cy, radius, "", "Frequency Dependent Damping", 1, 1);
freq_damp_knob.gfx_draw_icon(2, 1);
cx += 3 * radius;
inharmonic_knob.draw_knob(cx, cy, radius, "", "Inharmonicity", 1, 1);
inharmonic_knob.gfx_draw_icon(3, 1);
cx += 3 * radius;
stereo = stereoToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, stereo, "Stereoize the output.", mouse_x, mouse_y, mouse_cap);
stiffness_knob.draw_knob(cx, cy, radius, "", "Stiffness (tends to make things louder)", 1, 1);
stiffness_knob.gfx_draw_icon(4, 1);
cx += 3 * radius;
stiffness_exp_knob.draw_knob(cx, cy, radius, "", "Input Non-Linearity", 1, 1);
stiffness_exp_knob.gfx_draw_icon(5, 1);
cx += 3 * radius;
stft = 1 - stftToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, 1 - stft, "Time domain mode\n\nTime domain mode allows using feedback but\nrequires significantly more CPU (especially\nwhen using a large number of partials).\n\nIn addition, it runs the risk of instability, so\nwhile it can be used to obtain creative effects\nit's not really recommended for live use.", mouse_x, mouse_y, mouse_cap);
force_fb.draw_knob(cx, cy, radius, "", "Feedback Level", 1, 1 - stft);
force_fb.gfx_draw_icon(6, 1 - stft);
cx += 3 * radius;
n_partials = sprintf(16, "%d", 16 * floor((partials / 16)));
partials.draw_knob(cx, cy, radius, n_partials, "Number of partials to include", 1, 1 - stft);
n_partials.gfx_draw_icon(7, 1 - stft);
cx += 3 * radius;

choice_button1.draw_choice(0, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Metal string");
choice_button1.draw_model_icon();
choice_button2.draw_choice(1, cx - radius, cy, radius, radius, 1, "Tube");
choice_button2.draw_model_icon();
cx += radius + 4;

choice_button3.draw_choice(2, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beating");
choice_button3.draw_model_icon();
choice_button4.draw_choice(3, cx - radius, cy, radius, radius, 1, "Beam (both ends open)");
choice_button4.draw_model_icon();
cx += radius + 4;

choice_button5.draw_choice(4, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beam (one end clamped)");
choice_button5.draw_model_icon();
choice_button6.draw_choice(5, cx - radius, cy, radius, radius, 1, "Membrane");
choice_button6.draw_model_icon();
cx += radius + 4;

choice_button7.draw_choice(6, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Marimba");
choice_button7.draw_model_icon();
choice_button8.draw_choice(7, cx - radius, cy, radius, radius, 1, "Pan");
choice_button8.draw_model_icon();
cx += radius + 4;


choice_button9.draw_choice(8, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Male vowels");
choice_button9.draw_model_icon();
choice_button10.draw_choice(9, cx - radius, cy, radius, radius, 1, "Female vowels");
choice_button10.draw_model_icon();
cx += radius + 4;

bins = 100;

lx = mouse_x;
ly = mouse_y;
last_cap = mouse_cap;

mouse_cap == 0 ? captured = 0;

hinter.drawhint();
newtime = time_precise();
delta_time = newtime - ctime;
ctime = newtime;

/*
gfx_set(1, 1, 1, 1);
ptr = vowel;
x = 0;
init_vowels(vowel);
loop(64100,
  gfx_circle(0.013 * x, 0.5 * gfx_h - 15 * log10(ptr[]), 1);
  x += 1;
  ptr += 1;
);
*/



//data = np.hstack((len(locations), locations, len(rle_data), rle_data))


gfx_x = 0;
gfx_y = 0;
function draw_logo(logomem, rle_mem, ys, x, y)
global(gfx_a)
local(xx, yy, offset, line, ptr, n_iter, current, count)
instance(s, i)
(
  /*loop(10,
    i += 1;
    s = i;
    i > 229 ? i -= 230;
    loop(5,
      line = s;
      s += 20;
      (s > 229) ? s -= 230;
      
      xx = x + line * ys;
      offset = logomem[line];
      ptr = rle_mem + offset;
      n_iter = 0;
      yy = y;
      while((ptr[] != - 1) && (n_iter < 20)) (
        current = ptr[]; ptr += 1;
        (current > -1) ? (
          count = ptr[]; ptr += 1;
          current ? (
            gfx_set(1.0, 0.7, 1.0, 0.2);
            gfx_line(xx, yy, xx, yy + ys * count, 1);
          );
          yy += ys * count;
        );
        n_iter += 1;
      );
    );
  );*/
  
  line = 0;
  s += 1;
  colormodel(0);
  loop(230,
    xx = x + line * ys;
    offset = logomem[line];
    ptr = rle_mem + offset;
    n_iter = 0;
    yy = y;
    while((ptr[] != - 1) && (n_iter < 20)) (
      current = ptr[]; ptr += 1;
      (current > -1) ? (
        count = ptr[]; ptr += 1;
        current ? (
          i = abs(sin(0.1 * line - 0.1 * s));
          gfx_a = 0.1 + 0.5 * pow(i, 10);
          gfx_line(xx, yy, xx, yy + ys * count, 1);
        );
        yy += ys * count;
      );
      n_iter += 1;
    );
    line += 1;
  );
);

yy = 0.02 * gfx_h + gfx_h * 0.9;
//logo.draw_logo(logomem, rle_mem, 0.45, gfx_w - 110, gfx_h - 22);
logo.draw_logo(logomem, rle_mem, 0.45, 6, 6);
