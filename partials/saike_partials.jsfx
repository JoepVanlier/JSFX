desc:Partials (Saike)
tags: modal effect, instrument
version: 0.67
author: Joep Vanlier
changelog: Support higher polyphony
license: MIT
provides:
  partials_dependencies/*
  saike_partials.jsfx.rpl
about:
  # An effect which simulates different materials
  This effect takes both audio and MIDI input. Based on the model selected the incoming audio will excite
  a number of resonators that produce particular sounds. Up to 4 note polyphony is supported.

slider1:model=0<0,12,1{Metal,Tube,Beating,Beam open,Beam clamped,Membrane,Marimba,Pan,Voice male,Voice female,Custom,Custom_Mem,Custom_Mem2>-model
slider2:inverse_brightness=0<0,1,0.0001>-Inverse Brightness
slider3:relative_position=0.1<0.0001,0.999,0.001>-Relative position
slider4:damp=0.1<-2,2,0.0001>-Damping
slider5:freq_damp=-3.5<-6,-1,0.0001>-Frequency Dependent Damping
slider6:inharmonic=-3.5<-4, 0, 0.0001>-Inharmonic
slider7:stiffness=4.6<2,6,0.0001>-Stiffness
slider8:stiffness_exp=2.3<1,3.0,.0001>-Stiffness Exponent
slider9:placeholder=0<0,1,1>-Placeholder
slider10:base_note=0<-12,12,1>-Base note
slider11:force_fb=1<0,15,0.0001>-Forced feedback (TD only)
slider12:partials=32<16,64,16>-Partials
slider13:stereo=1<0,1,1{Off,On}>-Stereo-ize
slider14:position_vel=0<-1,1,0.000001>-Position velocity sensitivity
slider15:damp_vel=0<-4,4,0.000001>-Damping velocity sensitivity
slider16:freq_damp_vel=-0.75<-5,5,0.000001>-Frequency dependent damping velocity sensitivity
slider17:inharmonic_vel=0<-4,4,0.000001>-Inharmonicity velocity sensitivity
slider18:dummy=0<0,0,1{Off,On}>-Dummy
slider19:first_note=45<0,127,1>-Midi note 1
slider20:second_note=52<0,127,1>-Midi note 2
slider21:third_note=60<0,127,1>-Midi note 3
slider22:fourth_note=64<0,127,1>-Midi note 4
slider23:fifth_note=48<0,127,1>-Midi note 5
slider24:fft_choice=1<0,4,1>-fft size

slider25:spinner_frequency=2<0,20,0.01>-Spin freq
slider26:spinner_depth=0.1<0,4,0.01>-Spin depth

slider30:filter_cutoff=0.4<0,1,0.00001>-Filter Cutoff
slider31:filter_cutoff_vel=0.25<0,1,0.00001>-Filter Cutoff Velocity Sensitivity
slider32:filter_reso=0<0,1,0.0001>-Placeholder
slider33:filter_reso_vel=0<-1,1,0.0001>-Placeholder
slider34:filter_envelope=0.5<-1,1,0.0001>-Filter Envelope
slider35:filter_envelope_vel=0<-2,2,0.00001>-Filter Envelope Velocity Sensitivity
slider36:filter_attack=0<0,2,0.0001>-Filter Attack
slider37:filter_decay=1<0,3,0.0001>-Filter Decay
slider38:filter_releaser=1.5<0,3,0.0001>-Filter Release
slider39:filter_sustain=0.3<0,1,0.0001>-Filter Sustain
slider40:damp_release=0<-4, 4, 0.000001>-Damping release mod
slider41:freq_damp_release=0<-5, 5, 0.000001>-Frequency dependent damping release mod
slider42:inharmonicity_release=0<-4,4,0.00000001>-Inharmonicity release mod

slider43:force_fb_vel=1<-15,15,0.0001>-Forced feedback Velocity Sensitivity (USE AT YOUR OWN RISK)

slider44:lf_mod=0<0,4,0.01>-Modulation
slider45:lf_mod_vel=0<-4,4,0.01>-Modulation velocity sensitivity
slider46:lf_mod2=0<0,4,0.01>-Modulation 2
slider47:lf_mod2_vel=0<-4,4,0.01>-Modulation 2 velocity sensitivity
slider51:sample_follow_note=0<0,1,1>-Follow note
slider52:glide_speed=0<0,1,1>-Glide [10-1000ms]
slider53:legacy_gain=0<0,1,1>-Legacy mode
slider54:brightness_vel=0<0,1,0.0001>-Brightness vel
slider55:play_mode=3<0,5.99,1>-Impulse mode
slider56:attack_slider=0<0,2,0.0001>-Attack
slider57:decay_slider=1<0,3,0.0001>-Decay
slider58:release_slider=1.5<0,3,0.0001>-Release
slider59:sustain_level=0.3<0,1,0.0001>-Sustain
slider60:use_envelopes=0<0,1,1>-Use Envelopes
slider61:pitch_shift=0<-24,24,0.000001>-Large pitch bend
slider62:display_log=0<0,1,1{Linear,Logarithmic}>-Display type
slider63:stft_selection=1<0,1,1>-STFT

slider64:sixth_note=45<0,127,1>-Midi note 6
slider65:seventh_note=52<0,127,1>-Midi note 7
slider66:eight_note=60<0,127,1>-Midi note 8
slider67:ninth_note=60<0,127,1>-Midi note 9
slider68:tenth_note=64<0,127,1>-Midi note 10
slider69:eleventh_note=48<0,127,1>-Midi note 11
slider70:twelfth_note=48<0,127,1>-Midi note 12

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

-- You can define a custom model in this file:
import saike_modal_custom.jsfx-inc

import saike_partials_playback.jsfx-inc
import saike_modal.jsfx-inc
import saike_modal_kp_midi.jsfx-inc
import saike_modal_stft.jsfx-inc
import saike_modal_gfx.jsfx-inc
import saike_partial_array.jsfx-inc
import saike_vowel_data.jsfx-inc
import saike_modal_buffer.jsfx-inc

import saike_partials_sample_editor.jsfx-inc

import saike_modal_impulses.jsfx-inc

import saike_partials_fx.jsfx-inc

@init
MAX_STRING = 5 + 7 * many_notes;
DRAG_ENV = 100;
DRAG_ARRAY = 200;
MAX_CUSTOM_PARTIALS = 1024;
env.init_envelope(0, 56, 57, 59, 58);
env2.init_envelope(1, 36, 37, 39, 38);

gfx_ext_retina == 0 ? gfx_ext_retina = 1;
version = 10;

string1.used_partials = string2.used_partials = string3.used_partials = string4.used_partials = string5.used_partials = 0;

string6.used_partials = string7.used_partials = string8.used_partials = string9.used_partials = string10.used_partials = string11.used_partials = string12.used_partials = 0;

// _start, _stop, _default, _slider_idx, _vel_slider_idx, _release_slider_idx
playmode_knob.init_knob(0, 5.99, 0.1, 55, 0, 0);
brightness_knob.init_knob(1, 0, 0.1, 2, 54, 0);
position_knob.init_knob(0, 1, 0.1, 3, 14, 0);
damp_knob.init_knob(-2, 2, 0.1, 4, 15, 40);
freq_damp_knob.init_knob(-6, -1, -4, 5, 16, 41);
inharmonic_knob.init_knob(-4, 0, -4, 6, 17, 42);
stiffness_knob.init_knob(3, 6, 4.6, 7, 0, 0);
stiffness_exp_knob.init_knob(1.0, 3.0, 2.3, 8, 0, 0);
force_fb.init_knob(0, 15.0, 1.0, 11, 43, 0);
partials.init_knob(16, 64, 32, 12, 0, 0);
glide_knob.init_knob(0, 1, 0, 52, 0, 0);

spin_freq_knob.init_knob(0, 20, 1, 25, 0, 0);
spin_depth_knob.init_knob(0, 4, 0, 26, 0, 0);

filter_cutoff_knob.init_knob(0, 1, 0.4, 30, 31, 0);
filter_envelope_knob.init_knob(-1, 1, 0.5, 34, 35, 0);

modulation_knob.init_knob(0, 4, 0, 44, 45, 0);
modulation2_knob.init_knob(0, 4, 0, 46, 47, 0);

function stft_init()
local()
global(
  string1.string_init, string2.string_init, string3.string_init, string4.string_init, string5.string_init, string6.string_init,
  string7.string_init, string8.string_init, string9.string_init, string10.string_init, string11.string_init, string12.string_init,
  stft_mem.init_stft,
  stft_mem.fft_size, stft_mem.fft_interval,
  fft_choice,
)
instance()
(
  stft_mem.init_stft(64 * (1 << fft_choice)) ? (
    string1.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string2.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string3.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string4.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string5.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string6.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string7.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string8.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string9.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string10.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string11.string_init(stft_mem.fft_size, stft_mem.fft_interval);
    string12.string_init(stft_mem.fft_size, stft_mem.fft_interval);
  );
);

function initialize_memory()
local(logo_handle, freemem, lowcut, lowcut_freq, delay_ms, count)
instance()
global(
  rle_mem, logomem, logo_line_count,
  gfx_stft_mem.init_stft,
  stft_mem.init_stft,
  stft_mem.fft_mem,
  string1.string_mem, string2.string_mem, string3.string_mem, string4.string_mem, string5.string_mem, string6.string_mem,
  string7.string_mem, string8.string_mem, string9.string_mem, string10.string_mem, string11.string_mem, string12.string_mem,
  string1.impulse.chan_default, string2.impulse.chan_default, string3.impulse.chan_default, string4.impulse.chan_default, string5.impulse.chan_default, string6.impulse.chan_default,
  string7.impulse.chan_default, string8.impulse.chan_default, string9.impulse.chan_default, string10.impulse.chan_default, string11.impulse.chan_default, string12.impulse.chan_default,
  stft_mem.fft_size, stft_mem.fft_interval, stft_mem.in_fft_mem, stft_mem.out_fft_mem,
  gfx_stft_mem.fft_mem, gfx_string.string_mem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem,
  gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval,
  gfx_string.string_init,
  bessel_roots,
  midi.init_midi,
  buffer.init_buffer,
  buffer.set_offset,
  hp.init_linearSVF,
  srate,
  MAX_CUSTOM_PARTIALS,
  custom_partial_mem,
  fft_choice,
  spinner.init_spinner,
  spinner.reset_spinner,
  samplelocs,
  sample_loc,
  scratchloc, copyloc,
  idx,
  N_SAMPLES, SAMPLE_SIZE,
  SAMPLE_FONT, TINY_FONT, BIG_FONT,
  tuning_memory,
)
(
  freemem = 0;
  freemem = stft_mem.fft_mem(freemem, 64 * 16);  // We allocate the maximum mem block here
  freemem = string1.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string2.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string3.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string4.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string5.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string6.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  
  freemem = string7.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string8.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string9.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string10.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string11.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  freemem = string12.string_mem(freemem, stft_mem.in_fft_mem, stft_mem.out_fft_mem);
  
  string1.impulse.chan_default(1);
  string2.impulse.chan_default(2);
  string3.impulse.chan_default(3);
  string4.impulse.chan_default(4);
  string5.impulse.chan_default(5);
  string6.impulse.chan_default(6);
  string7.impulse.chan_default(7);
  string8.impulse.chan_default(8);
  string9.impulse.chan_default(9);
  string10.impulse.chan_default(10);
  string11.impulse.chan_default(11);
  string12.impulse.chan_default(12);
  
  stft_init();
  
  freemem = gfx_stft_mem.fft_mem(freemem, 512);
  freemem = gfx_string.string_mem(freemem, gfx_stft_mem.in_fft_mem, gfx_stft_mem.out_fft_mem);
  gfx_stft_mem.init_stft(512);
  gfx_string.string_init(gfx_stft_mem.fft_size, gfx_stft_mem.fft_interval);
  
  freemem = (bessel_roots = freemem) + 2048;
  memset(bessel_roots, 0, 2048);
  bessel_roots[0] = 1.000000; bessel_roots[1] = 2.917295; bessel_roots[2] = 4.831885; bessel_roots[3] = 6.746213; bessel_roots[4] = 8.660476; bessel_roots[5] = 10.574713; bessel_roots[6] = 12.488940; bessel_roots[7] = 14.403161; bessel_roots[8] = 16.317378; bessel_roots[9] = 18.231593; bessel_roots[10] = 20.145807; bessel_roots[11] = 22.060020; bessel_roots[12] = 23.974232; bessel_roots[13] = 25.888443; bessel_roots[14] = 27.802654; bessel_roots[15] = 29.716865; bessel_roots[16] = 31.631075;
  bessel_roots[17] = 33.545286; bessel_roots[18] = 35.459496; bessel_roots[19] = 37.373706; bessel_roots[20] = 39.287916; bessel_roots[21] = 41.202125; bessel_roots[22] = 43.116335; bessel_roots[23] = 45.030545; bessel_roots[24] = 46.944754; bessel_roots[25] = 48.858964; bessel_roots[26] = 50.773173; bessel_roots[27] = 52.687383; bessel_roots[28] = 54.601592; bessel_roots[29] = 56.515802; bessel_roots[30] = 58.430011; bessel_roots[31] = 60.344220; bessel_roots[32] = 62.258430;
  bessel_roots[33] = 64.172639; bessel_roots[34] = 66.086848; bessel_roots[35] = 68.001058; bessel_roots[36] = 69.915267; bessel_roots[37] = 71.829476; bessel_roots[38] = 73.743685; bessel_roots[39] = 75.657895; bessel_roots[40] = 77.572104; bessel_roots[41] = 79.486313; bessel_roots[42] = 81.400522; bessel_roots[43] = 83.314731; bessel_roots[44] = 85.228941; bessel_roots[45] = 87.143150; bessel_roots[46] = 89.057359; bessel_roots[47] = 90.971568; bessel_roots[48] = 92.885777;
  bessel_roots[49] = 94.799986; bessel_roots[50] = 96.714196; bessel_roots[51] = 98.628405; bessel_roots[52] = 100.542614; bessel_roots[53] = 102.456823; bessel_roots[54] = 104.371032; bessel_roots[55] = 106.285241; bessel_roots[56] = 108.199450; bessel_roots[57] = 110.113660; bessel_roots[58] = 112.027869; bessel_roots[59] = 113.942078; bessel_roots[60] = 115.856287; bessel_roots[61] = 117.770496; bessel_roots[62] = 119.684705; bessel_roots[63] = 121.598914; bessel_roots[64] = 123.513123;
  bessel_roots[65] = 125.427332; bessel_roots[66] = 127.341542; bessel_roots[67] = 129.255751; bessel_roots[68] = 131.169960; bessel_roots[69] = 133.084169; bessel_roots[70] = 134.998378; bessel_roots[71] = 136.912587; bessel_roots[72] = 138.826796; bessel_roots[73] = 140.741005; bessel_roots[74] = 142.655214; bessel_roots[75] = 144.569423; bessel_roots[76] = 146.483633; bessel_roots[77] = 148.397842; bessel_roots[78] = 150.312051; bessel_roots[79] = 152.226260; bessel_roots[80] = 154.140469;
  bessel_roots[81] = 156.054678; bessel_roots[82] = 157.968887; bessel_roots[83] = 159.883096; bessel_roots[84] = 161.797305; bessel_roots[85] = 163.711514; bessel_roots[86] = 165.625723; bessel_roots[87] = 167.539933; bessel_roots[88] = 169.454142; bessel_roots[89] = 171.368351; bessel_roots[90] = 173.282560; bessel_roots[91] = 175.196769; bessel_roots[92] = 177.110978; bessel_roots[93] = 179.025187; bessel_roots[94] = 180.939396; bessel_roots[95] = 182.853605; bessel_roots[96] = 184.767814;
  bessel_roots[97] = 186.682023; bessel_roots[98] = 188.596232; bessel_roots[99] = 190.510441; bessel_roots[100] = 192.424651; bessel_roots[101] = 194.338860; bessel_roots[102] = 196.253069; bessel_roots[103] = 198.167278; bessel_roots[104] = 200.081487; bessel_roots[105] = 201.995696; bessel_roots[106] = 203.909905; bessel_roots[107] = 205.824114; bessel_roots[108] = 207.738323; bessel_roots[109] = 209.652532; bessel_roots[110] = 211.566741; bessel_roots[111] = 213.480950; bessel_roots[112] = 215.395159;
  bessel_roots[113] = 217.309368; bessel_roots[114] = 219.223578; bessel_roots[115] = 221.137787; bessel_roots[116] = 223.051996; bessel_roots[117] = 224.966205; bessel_roots[118] = 226.880414; bessel_roots[119] = 228.794623; bessel_roots[120] = 230.708832; bessel_roots[121] = 232.623041; bessel_roots[122] = 234.537250; bessel_roots[123] = 236.451459; bessel_roots[124] = 238.365668; bessel_roots[125] = 240.279877; bessel_roots[126] = 242.194086; bessel_roots[127] = 244.108295; bessel_roots[128] = 246.022504; bessel_roots[129] = 247.936713; bessel_roots[130] = 249.850923; bessel_roots[131] = 251.765132; bessel_roots[132] = 253.679341;
  bessel_roots[133] = 255.593550; bessel_roots[134] = 257.507759; bessel_roots[135] = 259.421968; bessel_roots[136] = 261.336177; bessel_roots[137] = 263.250386; bessel_roots[138] = 265.164595; bessel_roots[139] = 267.078804; bessel_roots[140] = 268.993013; bessel_roots[141] = 270.907222; bessel_roots[142] = 272.821431; bessel_roots[143] = 274.735640; bessel_roots[144] = 276.649849; bessel_roots[145] = 278.564059; bessel_roots[146] = 280.478268; bessel_roots[147] = 282.392477; bessel_roots[148] = 284.306686;
  bessel_roots[149] = 286.220895; bessel_roots[150] = 288.135104; bessel_roots[151] = 290.049313; bessel_roots[152] = 291.963522; bessel_roots[153] = 293.877731; bessel_roots[154] = 295.791940; bessel_roots[155] = 297.706149; bessel_roots[156] = 299.620358; bessel_roots[157] = 301.534567; bessel_roots[158] = 303.448776; bessel_roots[159] = 305.362985; bessel_roots[160] = 307.277194; bessel_roots[161] = 309.191403; bessel_roots[162] = 311.105613; bessel_roots[163] = 313.019822; bessel_roots[164] = 314.934031;
  bessel_roots[165] = 316.848240; bessel_roots[166] = 318.762449; bessel_roots[167] = 320.676658; bessel_roots[168] = 322.590867; bessel_roots[169] = 324.505076; bessel_roots[170] = 326.419285; bessel_roots[171] = 328.333494; bessel_roots[172] = 330.247703; bessel_roots[173] = 332.161912; bessel_roots[174] = 334.076121; bessel_roots[175] = 335.990330; bessel_roots[176] = 337.904539; bessel_roots[177] = 339.818748; bessel_roots[178] = 341.732957; bessel_roots[179] = 343.647167; bessel_roots[180] = 345.561376;
  bessel_roots[181] = 347.475585; bessel_roots[182] = 349.389794; bessel_roots[183] = 351.304003; bessel_roots[184] = 353.218212; bessel_roots[185] = 355.132421; bessel_roots[186] = 357.046630; bessel_roots[187] = 358.960839; bessel_roots[188] = 360.875048; bessel_roots[189] = 362.789257; bessel_roots[190] = 364.703466; bessel_roots[191] = 366.617675; bessel_roots[192] = 368.531884; bessel_roots[193] = 370.446093; bessel_roots[194] = 372.360302; bessel_roots[195] = 374.274511; bessel_roots[196] = 376.188720; bessel_roots[197] = 378.102930; bessel_roots[198] = 380.017139;
  
  //bessel_roots[0] = 1.0; bessel_roots[1] = 1.593340505695112; bessel_roots[2] = 2.1355487866494034; bessel_roots[3] = 2.295417267427694; bessel_roots[4] = 2.6530664045492145; bessel_roots[5] = 2.9172954551172228; bessel_roots[6] = 3.155464815408362; bessel_roots[7] = 3.5001474903090264; bessel_roots[8] = 3.5984846739581138; bessel_roots[9] = 4.058931883331434; bessel_roots[10] = 4.230439127905234; bessel_roots[11] = 4.6010445344331075; bessel_roots[12] = 4.831885262930598; bessel_roots[13] = 4.903280573212368; bessel_roots[14] = 5.412118429982582; bessel_roots[15] = 5.5403985098530635; bessel_roots[16] = 5.976540221648715; bessel_roots[17] = 6.152609171589257; bessel_roots[18] = 6.208732130572546; bessel_roots[19] = 6.746213299505839; bessel_roots[20] = 6.848991602808508; bessel_roots[21] = 7.325257332462771; bessel_roots[22] = 7.468242109085181; bessel_roots[23] = 7.514500962483965; bessel_roots[24] = 8.071028338967128; bessel_roots[25] = 8.1568737689496; bessel_roots[26] = 8.66047555520746; bessel_roots[27] = 8.781093075730398; bessel_roots[28] = 8.820447105611922; bessel_roots[29] = 9.390589484063241; bessel_roots[30] = 9.464339027734203; bessel_roots[31] = 9.98784275554081; bessel_roots[32] = 10.092254814868133; bessel_roots[33] = 10.126502295693772; bessel_roots[34] = 10.706875023386747; bessel_roots[35] = 10.77153891878896; bessel_roots[36] = 11.310212368186301; bessel_roots[37] = 11.402312929615599; bessel_roots[38] = 11.432629299891353; bessel_roots[39] = 12.020976194473256; bessel_roots[40] = 12.078559478862408; bessel_roots[41] = 12.6291936518746; bessel_roots[42] = 12.711609953449942; bessel_roots[43] = 12.738806093605008; bessel_roots[44] = 13.333546087983708; bessel_roots[45] = 13.385453180985621; bessel_roots[46] = 13.945767336219362; bessel_roots[47] = 14.020359772593565; bessel_roots[48] = 14.04501881871901; bessel_roots[49] = 14.645000185525108; bessel_roots[50] = 14.692253846444546; bessel_roots[51] = 15.260566826272614; bessel_roots[52] = 15.328702904590145; bessel_roots[53] = 15.351258321221781; bessel_roots[54] = 15.955615704418207; bessel_roots[55] = 15.998984255488747; bessel_roots[56] = 16.574020171496844; bessel_roots[57] = 16.636735502683614; bessel_roots[58] = 16.657518312060414; bessel_roots[59] = 17.265584831105425; bessel_roots[60] = 17.305660312713336; bessel_roots[61] = 17.886427390005295; bessel_roots[62] = 17.94452559782329; bessel_roots[63] = 17.963794328004976; bessel_roots[64] = 18.57504506872356; bessel_roots[65] = 18.612293459048136; bessel_roots[66] = 19.198005179702488; bessel_roots[67] = 19.252122686852257; bessel_roots[68] = 19.2700831140802; bessel_roots[69] = 19.884097430065065; bessel_roots[70] = 19.91889213498009; bessel_roots[71] = 20.50891405763646; bessel_roots[72] = 20.559563645768456; bessel_roots[73] = 20.57638224071873; bessel_roots[74] = 21.19281780880533; bessel_roots[75] = 21.22546270361489; bessel_roots[76] = 21.819275510667225; bessel_roots[77] = 21.86687651357224; bessel_roots[78] = 21.88268985777816; bessel_roots[79] = 22.501264341880123; bessel_roots[80] = 22.532010052729223; bessel_roots[81] = 23.129183209056905; bessel_roots[82] = 23.174082991117032; bessel_roots[83] = 23.18900453156058; bessel_roots[84] = 23.809482322435674; bessel_roots[85] = 23.83853799891848; bessel_roots[86] = 24.43871055527686; bessel_roots[87] = 24.481200137037135; bessel_roots[88] = 24.495325133904405; bessel_roots[89] = 25.11750756522588; bessel_roots[90] = 25.14504956579362; bessel_roots[91] = 25.747915895998187; bessel_roots[92] = 25.788241546567566; bessel_roots[93] = 25.801650764922858; bessel_roots[94] = 26.425368765399043; bessel_roots[95] = 26.45154717975952; bessel_roots[96] = 27.056846201368838; bessel_roots[97] = 27.09521818837926; bessel_roots[98] = 27.107980698055208; bessel_roots[99] = 27.73308918559399; bessel_roots[100] = 27.758032810520902; bessel_roots[101] = 28.365539713752746; bessel_roots[102] = 28.4021390098783; bessel_roots[103] = 28.41431434025919; bessel_roots[104] = 29.04068788458015; bessel_roots[105] = 29.06450807370286; bessel_roots[106] = 29.674027888190647; bessel_roots[107] = 29.709011382436476; bessel_roots[108] = 29.720651202691336; bessel_roots[109] = 30.348180626606908; bessel_roots[110] = 30.370974306991094; bessel_roots[111] = 30.982336836434303; bessel_roots[112] = 31.015841433866807; bessel_roots[113] = 31.026990878787515; bessel_roots[114] = 31.65558056431991; bessel_roots[115] = 31.677432627434925; bessel_roots[116] = 32.29048841685965; bessel_roots[117] = 32.32263430011846; bessel_roots[118] = 32.3333330276527; bessel_roots[119] = 32.962898758448766; bessel_roots[120] = 32.98388397513484; bessel_roots[121] = 33.598501067720804; bessel_roots[122] = 33.629394318203495; bessel_roots[123] = 33.639677361318086; bessel_roots[124] = 34.270144578068304; bessel_roots[125] = 34.29032914694497; bessel_roots[126] = 34.906390451675975; bessel_roots[127] = 34.936125175768225; bessel_roots[128] = 34.94602363485432; bessel_roots[129] = 35.57732601229015; bessel_roots[130] = 35.59676882275539; bessel_roots[131] = 36.21416995969524; bessel_roots[132] = 36.24283002826827; bessel_roots[133] = 36.25237163862099; bessel_roots[134] = 36.88444991544925; bessel_roots[135] = 36.90320358619262; bessel_roots[136] = 37.521851108922526; bessel_roots[137] = 37.54951159164972; bessel_roots[138] = 37.558721192132666; bessel_roots[139] = 38.191522201780415; bessel_roots[140] = 38.20963394107416; bessel_roots[141] = 38.82944385967054; bessel_roots[142] = 38.856172216310185; bessel_roots[143] = 38.8650721391612; bessel_roots[144] = 39.49854800132748; bessel_roots[145] = 39.51606032459946; bessel_roots[146] = 40.13695687011323; bessel_roots[147] = 40.16281394660802; bessel_roots[148] = 40.1714243437933; bessel_roots[149] = 40.80553178580658; bessel_roots[150] = 40.82248311800838; bessel_roots[151] = 41.44439770252031; bessel_roots[152] = 41.469438569110935; bessel_roots[153] = 41.477777687232674; bessel_roots[154] = 42.11247747097152; bessel_roots[155] = 42.12890265525675; bessel_roots[156] = 42.75177299146806; bessel_roots[157] = 42.77604765199419; bessel_roots[158] = 42.78413206518778; bessel_roots[159] = 43.41938850044695; bessel_roots[160] = 43.435319230126446; bessel_roots[161] = 44.05908858196726; bessel_roots[162] = 44.08264257742662; bessel_roots[163] = 44.090487385723776; bessel_roots[164] = 44.72626791483038; bessel_roots[165] = 44.741733102090066; bessel_roots[166] = 45.36634964360787; bessel_roots[167] = 45.38922456835874; bessel_roots[168] = 45.39684356748521; bessel_roots[169] = 46.0331184089983; bessel_roots[170] = 46.04814450117729; bessel_roots[171] = 46.67356076544521; bessel_roots[172] = 46.69579471081029; bessel_roots[173] = 46.70320053821687; bessel_roots[174] = 47.33994237990128; bessel_roots[175] = 47.354553632035845; bessel_roots[176] = 47.980726035317176; bessel_roots[177] = 48.00235397251547; bessel_roots[178] = 48.009558233526036; bessel_roots[179] = 48.646741966640775; bessel_roots[180] = 48.660960677338416; bessel_roots[181] = 49.28784910649526; bessel_roots[182] = 49.30890321860208; bessel_roots[183] = 49.31591659584141; bessel_roots[184] = 49.953519084244085; bessel_roots[185] = 49.96736580065507; bessel_roots[186] = 50.5949332539693; bessel_roots[187] = 50.61544322484067; bessel_roots[188] = 50.62227557353315; bessel_roots[189] = 51.26027545226442; bessel_roots[190] = 51.27376914888668; bessel_roots[191] = 51.90198142220047; bessel_roots[192] = 51.921974688892305; bessel_roots[193] = 51.92863512016577; bessel_roots[194] = 52.56701261910822; bessel_roots[195] = 52.580170854335584; bessel_roots[196] = 53.20899626581487; bessel_roots[197] = 53.228498239898826; bessel_roots[198] = 53.87373198281662; bessel_roots[199] = 54.51598018442653;
  
  freemem = midi.init_midi(freemem);
  
  buffer.init_buffer(freemem, freemem + 32766);
  freemem += 32768;
  
  delay_ms = 16.12;
  buffer.set_offset(delay_ms * srate / 1000);
  lowcut = 0.34;
  lowcut_freq = exp((1-LowCut) * log(20/22050));
  hp.init_linearSVF(lowcut_freq, 0);
  //displayFreq = 0.5 * srate * lowcut_freq / $pi;
  
  freemem = init_vowels(freemem);
  
  custom_partial_mem = freemem;
  freemem = alloc_model_memory_block(freemem, MAX_CUSTOM_PARTIALS);
  
  freemem = spinner.init_spinner(freemem);
  spinner.reset_spinner();
  
  logomem = freemem;
  logo_handle = file_open("partials_dependencies/logo.dat");
  file_var(logo_handle, logo_line_count);
  file_mem(logo_handle, logomem, logo_line_count);
  rle_mem = logomem + logo_line_count + 1;
  file_var(logo_handle, count);
  file_mem(logo_handle, rle_mem, count);
  file_close(logo_handle);
  
  freemem += 2048;
  
  // Input pulse data
  sample_loc = freemem;
  
  init_sample_data_defaults();
  N_SAMPLES = 4;
  
  // Sample locations are recorded as [64 byte header (first is length), sampledata]
  freemem = (samplelocs = freemem) + 128;
  idx = 0;
  loop(N_SAMPLES,
    freemem = (samplelocs[idx] = freemem) + SAMPLE_SIZE;
    idx += 1;
  );
    
  freemem = (scratchloc = freemem) + SAMPLE_SIZE;
  freemem = (copyloc = freemem) + SAMPLE_SIZE;
  freemem = (tuning_memory = freemem) + 256;
  
  SAMPLE_FONT = 5;
  TINY_FONT = 6;
  gfx_setfont(TINY_FONT, "Arial", 12);
  BIG_FONT = 7;
  gfx_setfont(BIG_FONT, "Arial", 18);
);

function tanh(x)
local()
global()
instance()
(
  (2/(1+exp(-2*x)) - 1)
);


function update_freq()
local()
global(stft, k_glide, big_tick, cSample, test_mode, _test_mode_pos)
instance(freq, target_freq)
(
  freq += k_glide * (target_freq - freq);
  
  big_tick ? (
    stft ? (
      test_mode ? (
        _test_mode_pos += 0.001;
        _test_mode_pos > 0.5 ? _test_mode_pos = 0;
        this.set_pars_stft(freq * (1 + 0.5*12 * test_mode * _test_mode_pos));
      ) : (
        this.set_pars_stft(freq);
      );
    ) : (
      freq ? this.set_pars_td(freq);
    );
  );
);

function set_pars(f_0, vel, glide)
local()
global(
  stft,
  relative_position, damp, freq_damp, inharmonic,
  position_vel, damp_vel, freq_damp_vel, inharmonic_vel,
  lf_mod, lf_mod_vel, lf_mod2, lf_mod2_vel,
)
instance(base_damp, f_damp, inharm, rel_position, freq, target_freq, last_vel, mod, mod2, new_note)
(
  // position 0 to 1
  // damp -2 to 2
  // freq_damp -6 to -1
  // inharmonic -4 to 0
  new_note = max(new_note, (last_vel != vel) && !glide);
  
  last_vel = vel;
  rel_position = min(max(0, relative_position + position_vel * vel), 1);
  base_damp = 10^(min(max(-2, damp + damp_vel * vel), 2));
  f_damp = 10^(min(max(-6, freq_damp + freq_damp_vel * vel), -1));
  mod = max(0, lf_mod + vel * lf_mod_vel);
  mod2 = max(0, lf_mod2 + vel * lf_mod2_vel);
  
  inharm = inharm * 0.8 + 0.2 * 10^(min(max(-4, inharmonic + inharmonic_vel * vel), 0));
  
  ((!glide) || (freq == 0)) ? (
    freq = f_0;
    target_freq = f_0;
  ) : (
    target_freq = f_0;
  );
);

function damp_string()
local()
global(damp, freq_damp, inharmonic, damp_vel, freq_damp_vel, damp_release, inharmonic_vel, freq_damp_release, inharmonicity_release)
instance(base_damp, f_damp, inharm, rel_position, freq, target_freq, last_vel)
( 
  base_damp = 10^(min(max(-2, damp + damp_vel * last_vel + damp_release), 2));
  f_damp = 10^(min(max(-6, freq_damp + freq_damp_vel * last_vel + freq_damp_release), -1));
  inharm = inharm * 0.8 + 0.2 * 10^(min(max(-4, inharmonic + inharmonic_vel * last_vel + inharmonicity_release), 0));
);

function eval_string(f_h, env, on)
local(input_active)
global(stft, play_mode, stft_mem.fft_size)
instance()
(
  stft ? (
    // Impulses are added at the global level below, since the STFT
    // variant only uses one STFT for the entire input.
    input_active = (play_mode >= 1) ? this.impulse.impulse_alive(stft_mem.fft_size) : 1;
    
    this.eval_string_stft(env * input_active, env, on);
  ) : (
    /* Add string specific impulse if relevant */
    (play_mode >= 1) ? (
      f_h += this.impulse.eval_impulse(this.freq);
    );
    this.eval_string_td(on ? f_h * env : 0);
  );
);

function update_env_note(vel, _state, attack_s, decay_s, sustain_level, release_s)
instance(
  last_vel, target, sustain, rate,
  k_attack, k_decay, attack_samples,
  state,
)
local()
global(srate, mlog0p05)
(
  target = vel;
  sustain = sustain_level * target;
  
  _state ? (
    // Change!
    (vel && (_state > 0)) ? (
      attack_samples = attack_s * srate;
      k_attack = mlog0p05 / attack_samples;
      k_decay = mlog0p05 / (decay_s * srate);
    ) : (
      // Note is off => release!
      attack_samples = 0;
      k_decay = mlog0p05 / (release_s * srate);
      sustain = 0;
    );
  );
  
  last_vel = vel;
);

function env_sample()
instance(state, target, sustain, 
         attack_samples,
         k_attack, k_decay)
local(current_target, rate)
global()
(
  (attack_samples > 0) ? (
    rate = k_attack;
    current_target = target;
  ) : (
    // Release and decay
    rate = k_decay;
    current_target = sustain;
  );
  attack_samples -= 1;
  
  state += rate * (current_target - state);
);

function handle_dropped_files_microtuning(tuning_memory)
local(file_handle, note_index, frequency, found_tuning, cent_scaling)
global(
  DROPPED_FILE_STR, PARSE_STR, microtuned, base_freq, reading_tuning
)
instance()
(
  DROPPED_FILE_STR = 80;
  PARSE_STR = 88;
  
  // Scaling to convert from 2^(x/1200) to exp(cent_scaling * x)
  cent_scaling = log(2) / 1200;
  gfx_getdropfile(0, DROPPED_FILE_STR) ? (
    (matchi("*.TUN", 80) == 1) ? (
      microtuned = 0;
      file_handle = file_open(DROPPED_FILE_STR);
      file_handle >= 0 ? (
        memset(tuning_memory, 0, 128);
        file_rewind(file_handle);
        
        /* Prefer exact if possible */
        found_tuning = 0;
        base_freq = 8.17579891564371;
        while(file_avail(file_handle) && (!found_tuning))
        (
          file_string(file_handle, PARSE_STR);
          (strnicmp("[Exact Tuning]", PARSE_STR, 13) == 0) ? (
            found_tuning = 1;
          );
        );
        
        /* Read the tuning */
        (found_tuning == 1) ? (
        
          found_tuning = 0;
          while(file_avail(file_handle) && (found_tuning < 2))
          (
            file_string(file_handle, PARSE_STR);
            matchi("basefreq*?=*?%f*", PARSE_STR, base_freq);
            matchi("note %d*?=*?%f*", PARSE_STR, note_index, frequency) ? (
              ((note_index > 0) && (note_index < 128)) ? (
                tuning_memory[note_index] = base_freq * exp(cent_scaling * frequency);
                found_tuning = 1;
              );
            );
            
            // Other section starts
            matchi("[*", PARSE_STR) ? (
              found_tuning = 2;
            );
          );
        );
        
        /* We didn't find an exact tuning, see if we can find a sloppy one */
        (found_tuning == 0) ? (
          /* Prefer exact if possible */
          found_tuning = 0;
          file_rewind(file_handle);
          while(file_avail(file_handle) && (!found_tuning))
          (
            file_string(file_handle, PARSE_STR);
            (strnicmp("[Tuning]", PARSE_STR, 7) == 0) ? (
              found_tuning = 1;
            );
          );
          
          /* Read the tuning */
          (found_tuning == 1) ? (
            found_tuning = 0;
            while(file_avail(file_handle) && (found_tuning == 0))
            (
              file_string(file_handle, PARSE_STR);
              matchi("note %d*?=*?%d*", PARSE_STR, note_index, frequency) ? (
                ((note_index > 0) && (note_index < 128)) ? (
                  tuning_memory[note_index] = base_freq * exp(cent_scaling * frequency);
                  found_tuning = 1;
                );
              );
              
              // Other section starts
              matchi("[*", PARSE_STR) ? (
                found_tuning = 1;
              );
            );
          );
        );
        
      
      );
      file_close(file_handle);
    );
    
    found_tuning ? (
      microtuned = 1;
    );
  );
  
  DROPPED_FILE_STR = 0;
);

function pitch_to_freq(pitch)
local(scaling, frac, temp)
global(microtuned, tuning_memory, sample_time, ln)
instance()
(
  microtuned ? (
    temp = min(127, max(0, pitch + 69));
    frac = temp - floor(temp);
    ln = temp;
    (pow(tuning_memory[temp], (1.0 - frac)) * pow(tuning_memory[temp + 1], frac))
  ) : (
    440 * 2 ^ (pitch / 12)
  );
);

function update_notes()
instance(notes_on, active_note_mem, active_note_vel, active_note_state, note_history,
         note_on0, note_on1, note_on2, note_on3, note_on4,
         note_on5, note_on6, note_on7, note_on8, note_on9, note_on10, note_on11,
         last_count)
global(string1.set_pars, string2.set_pars, string3.set_pars, string4.set_pars, string5.set_pars, string6.set_pars,
       string7.set_pars, string8.set_pars, string9.set_pars, string10.set_pars, string11.set_pars, string12.set_pars,
       pitch_shift,
       midi.pitchbend, midi.last_vel,
       use_envelopes,
       sample_follow_note,
       envelope1.update_env_note, envelope2.update_env_note, envelope3.update_env_note, envelope4.update_env_note, envelope5.update_env_note, envelope6.update_env_note,
       envelope7.update_env_note, envelope8.update_env_note, envelope9.update_env_note, envelope10.update_env_note, envelope11.update_env_note, envelope12.update_env_note,
       use_filt_envelopes,
       filt_envelope1.update_env_note, filt_envelope2.update_env_note, filt_envelope3.update_env_note, filt_envelope4.update_env_note, filt_envelope5.update_env_note, filt_envelope6.update_env_note,
       filt_envelope7.update_env_note, filt_envelope8.update_env_note, filt_envelope9.update_env_note, filt_envelope10.update_env_note, filt_envelope11.update_env_note, filt_envelope12.update_env_note,
       string1.impulse.update_impulse_note, string2.impulse.update_impulse_note, string3.impulse.update_impulse_note, string4.impulse.update_impulse_note, string5.impulse.update_impulse_note, string6.impulse.update_impulse_note,
       string7.impulse.update_impulse_note, string8.impulse.update_impulse_note, string9.impulse.update_impulse_note, string10.impulse.update_impulse_note, string11.impulse.update_impulse_note, string12.impulse.update_impulse_note,
       string1.used_partials, string2.used_partials, string3.used_partials, string4.used_partials, string5.used_partials, string6.used_partials,
       string7.used_partials, string8.used_partials, string9.used_partials, string10.used_partials, string11.used_partials, string12.used_partials,
       string1.ref_cutoff, string2.ref_cutoff, string3.ref_cutoff, string4.ref_cutoff, string5.ref_cutoff, string6.ref_cutoff,
       string7.ref_cutoff, string8.ref_cutoff, string9.ref_cutoff, string10.ref_cutoff, string11.ref_cutoff, string12.ref_cutoff,
       play_mode, midi_recv,
       inverse_brightness, brightness_vel,
       partials_used,
       glide,
       env.attack_s, env.decay_s, env.sustain_level, env.release_s
       env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s,
       single_filter_ref_cutoff,
       enable_filter,
       filter_cutoff, filter_cutoff_vel, filter_envelope, filter_envelope_vel,
       latest_note,
       string1.damp_string, string2.damp_string, string3.damp_string, string4.damp_string, string5.damp_string, string6.damp_string,
       string7.damp_string, string8.damp_string, string9.damp_string, string10.damp_string, string11.damp_string, string12.damp_string,
       string1.update_freq, string2.update_freq, string3.update_freq, string4.update_freq, string5.update_freq, string6.update_freq,
       string7.update_freq, string8.update_freq, string9.update_freq, string10.update_freq, string11.update_freq, string12.update_freq,
       pitchbend_range,
       many_notes,
       )
local(
  ref_pitch, scaling, max_vel,
  note_vel0, note_vel1, note_vel2, note_vel3, note_vel4,
  note_state0, note_state1, note_state2, note_state3, note_state4,
  
  note_vel5, note_vel6, note_vel7, note_vel8, note_vel9, note_vel10, note_vel11,
  note_state5, note_state6, note_state7, note_state8, note_state9, note_state10, note_state11,
  remainder,
)
(
  scaling = 440;
  ref_pitch = pitchbend_range * midi.pitchbend + pitch_shift - 69;
  
  midi_recv = max(midi_recv, ((note_state0 > 0) + (note_state1 > 0) + (note_state2 > 0) + (note_state3 > 0) + (note_state4 > 0)) > 0);
  many_notes ? (
    midi_recv = max(midi_recv, ((note_state5 > 0) + (note_state6 > 0) + (note_state7 > 0) + (note_state8 > 0) + (note_state9 > 0) + (note_state10 > 0) + (note_state11 > 0)));
  );
  
  latest_note = note_history[notes_on - 1];
  glide ? (
    note_on2 = note_on3 = note_on4 = 0;
    many_notes ? ( note_on5 = note_on6 = note_on7 = note_on8 = note_on9 = note_on10 = note_on11 = 0; );
    (notes_on > 0) ? (
      note_on0 = active_note_mem[latest_note];
      note_vel0 = active_note_vel[latest_note];
      note_state0 = active_note_state[latest_note];
    ) : (
      note_state0 = -1;
    );
    (notes_on > 0) ? (
      string1.set_pars(pitch_to_freq(note_on0 + ref_pitch), note_vel0, last_count > 0)+
      string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0;
    );
    
    // This is the cutoff when only a single global filter is used.
    // Happens when in STFT mode, or no velocity or envelopes are set in TD mode.
    // In all other cases, each string gets their own filter.
    single_filter_ref_cutoff = min(max(0.0, filter_cutoff + filter_cutoff_vel * midi.last_vel), 1.0);
  ) : (
    note_vel0 = active_note_vel[0];
    note_vel1 = active_note_vel[1];
    note_vel2 = active_note_vel[2];
    note_vel3 = active_note_vel[3];
    note_vel4 = active_note_vel[4];
    
    // This is the cutoff when only a single global filter is used.
    // Happens when in STFT mode, or no velocity or envelopes are set in TD mode.
    // In all other cases, each string gets their own filter.
    max_vel = max(max(max(max(note_vel0, note_vel1), note_vel2), note_vel3), note_vel4);
    single_filter_ref_cutoff = min(max(0.0, filter_cutoff + filter_cutoff_vel * max_vel), 1.0);
     
    note_on0 = active_note_mem[0];
    note_on1 = active_note_mem[1];
    note_on2 = active_note_mem[2];
    note_on3 = active_note_mem[3];
    note_on4 = active_note_mem[4];
    
    note_state0 = active_note_state[0];
    note_state1 = active_note_state[1];
    note_state2 = active_note_state[2];
    note_state3 = active_note_state[3];
    note_state4 = active_note_state[4];
    
    // Update note parameters
    note_on0 ? ( string1.set_pars(pitch_to_freq(note_on0 + ref_pitch), note_vel0, 0); string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0; );
    note_on1 ? ( string2.set_pars(pitch_to_freq(note_on1 + ref_pitch), note_vel1, 0); string2.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel1; );
    note_on2 ? ( string3.set_pars(pitch_to_freq(note_on2 + ref_pitch), note_vel2, 0); string3.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel2; );
    note_on3 ? ( string4.set_pars(pitch_to_freq(note_on3 + ref_pitch), note_vel3, 0); string4.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel3; );
    note_on4 ? ( string5.set_pars(pitch_to_freq(note_on4 + ref_pitch), note_vel4, 0); string5.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel4; );
    
    (note_state0 == -1) ? (string1.damp_string(); string1.update_freq(); );
    (note_state1 == -1) ? (string2.damp_string(); string2.update_freq(); );
    (note_state2 == -1) ? (string3.damp_string(); string3.update_freq(); );
    (note_state3 == -1) ? (string4.damp_string(); string4.update_freq(); );
    (note_state4 == -1) ? (string5.damp_string(); string5.update_freq(); );
    
    many_notes ? (
      note_vel5 = active_note_vel[5];
      note_vel6 = active_note_vel[6];
      note_vel7 = active_note_vel[7];
      note_vel8 = active_note_vel[8];
      note_vel9 = active_note_vel[9];
      note_vel10 = active_note_vel[10];
      note_vel11 = active_note_vel[11];
      
      // This is the cutoff when only a single global filter is used.
      // Happens when in STFT mode, or no velocity or envelopes are set in TD mode.
      // In all other cases, each string gets their own filter.
      max_vel = max(max(max(max(max(max(max(max_vel, note_vel5), note_vel6), note_vel7), note_vel8), note_vel9), note_vel10), note_vel11);
      single_filter_ref_cutoff = min(max(0.0, filter_cutoff + filter_cutoff_vel * max_vel), 1.0);
       
      note_on5 = active_note_mem[5];
      note_on6 = active_note_mem[6];
      note_on7 = active_note_mem[7];
      note_on8 = active_note_mem[8];
      note_on9 = active_note_mem[9];
      note_on10 = active_note_mem[10];
      note_on11 = active_note_mem[11];
      
      note_state5 = active_note_state[5];
      note_state6 = active_note_state[6];
      note_state7 = active_note_state[7];
      note_state8 = active_note_state[8];
      note_state9 = active_note_state[9];
      note_state10 = active_note_state[10];
      note_state11 = active_note_state[11];
      
      // Update note parameters
      note_on5 ? ( string6.set_pars(pitch_to_freq(note_on5 + ref_pitch), note_vel5, 0); string6.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel5; );
      note_on6 ? ( string7.set_pars(pitch_to_freq(note_on6 + ref_pitch), note_vel6, 0); string7.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel6; );
      note_on7 ? ( string8.set_pars(pitch_to_freq(note_on7 + ref_pitch), note_vel7, 0); string8.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel7; );
      note_on8 ? ( string9.set_pars(pitch_to_freq(note_on8 + ref_pitch), note_vel8, 0); string9.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel8; );
      note_on9 ? ( string10.set_pars(pitch_to_freq(note_on9 + ref_pitch), note_vel9, 0); string10.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel9; );
      note_on10 ? ( string11.set_pars(pitch_to_freq(note_on10 + ref_pitch), note_vel10, 0); string11.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel10; );
      note_on11 ? ( string12.set_pars(pitch_to_freq(note_on11 + ref_pitch), note_vel11, 0); string12.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel11; );
 
      (note_state5 == -1) ? (string6.damp_string(); string6.update_freq(); );
      (note_state6 == -1) ? (string7.damp_string(); string7.update_freq(); );
      (note_state7 == -1) ? (string8.damp_string(); string8.update_freq(); );
      (note_state8 == -1) ? (string9.damp_string(); string9.update_freq(); );
      (note_state9 == -1) ? (string10.damp_string(); string10.update_freq(); );
      (note_state10 == -1) ? (string11.damp_string(); string11.update_freq(); );
      (note_state11 == -1) ? (string12.damp_string(); string12.update_freq(); );
    );
  );
  
  use_envelopes ? (
    envelope1.update_env_note(note_vel0, note_state0, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope2.update_env_note(note_vel1, note_state1, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope3.update_env_note(note_vel2, note_state2, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope4.update_env_note(note_vel3, note_state3, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    envelope5.update_env_note(note_vel4, note_state4, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    
    many_notes ? (
      envelope6.update_env_note(note_vel5, note_state5, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
      envelope7.update_env_note(note_vel6, note_state6, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
      envelope8.update_env_note(note_vel7, note_state7, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
      envelope9.update_env_note(note_vel8, note_state8, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
      envelope10.update_env_note(note_vel9, note_state9, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
      envelope11.update_env_note(note_vel10, note_state10, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
      envelope12.update_env_note(note_vel11, note_state11, env.attack_s, env.decay_s, env.sustain_level, env.release_s);
    );
  );
  
  (use_filt_envelopes && enable_filter) ? (
    // How much range remains for the envelope?
    ((filter_envelope + filter_envelope_vel) > 0) ? (
      // Envelope going up
      remainder = 1.0 - filter_cutoff;
    ) : (
      // Envelope going down
      remainder = filter_cutoff;
    );
    
    filt_envelope1.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel0))), note_state0, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope2.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel1))), note_state1, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope3.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel2))), note_state2, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope4.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel3))), note_state3, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    filt_envelope5.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel4))), note_state4, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    
    many_notes ? (
      filt_envelope6.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel5))), note_state5, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
      filt_envelope7.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel6))), note_state6, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
      filt_envelope8.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel7))), note_state7, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
      filt_envelope9.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel8))), note_state8, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
      filt_envelope10.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel9))), note_state9, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
      filt_envelope11.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel10))), note_state10, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
      filt_envelope12.update_env_note(remainder * min(1.0, max(-1.0, (filter_envelope + filter_envelope_vel * note_vel11))), note_state11, env2.attack_s, env2.decay_s, env2.sustain_level, env2.release_s);
    );
  );
  
  (play_mode >= 1) ? (
    string1.impulse.update_impulse_note(note_state0, inverse_brightness + brightness_vel * note_vel0, sample_follow_note ? note_on0 + ref_pitch + 69 : 69);
    string2.impulse.update_impulse_note(note_state1, inverse_brightness + brightness_vel * note_vel1, sample_follow_note ? note_on1 + ref_pitch + 69 : 69);
    string3.impulse.update_impulse_note(note_state2, inverse_brightness + brightness_vel * note_vel2, sample_follow_note ? note_on2 + ref_pitch + 69 : 69);
    string4.impulse.update_impulse_note(note_state3, inverse_brightness + brightness_vel * note_vel3, sample_follow_note ? note_on3 + ref_pitch + 69 : 69);
    string5.impulse.update_impulse_note(note_state4, inverse_brightness + brightness_vel * note_vel4, sample_follow_note ? note_on4 + ref_pitch + 69 : 69);
    
    many_notes ? (
      string6.impulse.update_impulse_note(note_state5, inverse_brightness + brightness_vel * note_vel5, sample_follow_note ? note_on5 + ref_pitch + 69 : 69);
      string7.impulse.update_impulse_note(note_state6, inverse_brightness + brightness_vel * note_vel6, sample_follow_note ? note_on6 + ref_pitch + 69 : 69);
      string8.impulse.update_impulse_note(note_state7, inverse_brightness + brightness_vel * note_vel7, sample_follow_note ? note_on7 + ref_pitch + 69 : 69);
      string9.impulse.update_impulse_note(note_state8, inverse_brightness + brightness_vel * note_vel8, sample_follow_note ? note_on8 + ref_pitch + 69 : 69);
      string10.impulse.update_impulse_note(note_state9, inverse_brightness + brightness_vel * note_vel9, sample_follow_note ? note_on9 + ref_pitch + 69 : 69);
      string11.impulse.update_impulse_note(note_state10, inverse_brightness + brightness_vel * note_vel10, sample_follow_note ? note_on10 + ref_pitch + 69 : 69);
      string12.impulse.update_impulse_note(note_state11, inverse_brightness + brightness_vel * note_vel11, sample_follow_note ? note_on11 + ref_pitch + 69 : 69);
    );
  );
  
  memset(active_note_state, 0, 12);
  
  partials_used = max(string1.used_partials, max(string2.used_partials, max(string3.used_partials, max(string4.used_partials, string5.used_partials))));
  
  many_notes ? (
    partials_used = max(partials_used, max(string6.used_partials, max(string7.used_partials, max(string8.used_partials, max(string9.used_partials, max(string10.used_partials, max(string11.used_partials, string10.used_partials)))))));
  );
  last_count = notes_on;
);

function force_update()
(
  update_ticker = 0;
);

initialize_memory();
midi.reset_midi();
settings_changed = 1;

@slider
settings_changed = 1;

stft_init();

@block
(last_many_notes != many_notes) ? (
  last_many_notes = many_notes;
  settings_changed = 1;
  
  (many_notes == 1) ? (
    /* Resynchronize FFTs */
    string12.fft_idx = string11.fft_idx = string10.fft_idx = string9.fft_idx = string8.fft_idx = string7.fft_idx = string6.fft_idx = string5.fft_idx;
  );
);

MAX_STRING = 5 + 7 * many_notes;
_SVF_SAMPLING_FACTOR = 0.5 * $pi * (44100 / srate);

/* Don't switch immediately, because you might run a partial STFT */
(stft_selection != stft) ? (
  stft = stft_selection;
  settings_changed = 1;
);

spinner.block_spinner();

sample_time = 1 / srate;
glide_decay = pow(10, glide_speed * 2 - 2.5); // 12.0 / 1000;  // Decay in seconds
k_glide = - sample_time * log(0.5) / glide_decay;

midi_input = (play_mode >= 1);
(floor(play_mode) != floor(last_play_mode)) ? (
  memset(midi.active_note_mem, 0, 12);
  midi.notes_on = 0;
  settings_changed = 1;
  last_play_mode = play_mode;
);

(srate != last_srate) ? (
  prepare_impulse_globals();
  last_srate = srate;
);

mlog0p05 = 2.995732273553991; // Corresponds to time to get to 95%
env.block_envelope();
env2.block_envelope();

midi.midi_block(pass_through);

// We use the single lowpass filter in stft mode
// or when use_filt_envelopes is off and the notes
// have no velocity sensitivity on the filters.
single_filter = enable_filter && (stft || (!use_filt_envelopes && (filter_cutoff_vel == 0)));

// We use the multi filter when stft is off and 
// filt_envelopes is on
multi_filter = enable_filter && (!stft && (use_filt_envelopes || (filter_cutoff_vel != 0)));

@sample
cSample += 1;
update_global_parameters();

function update_fixed_notes()
local(change, val, ix, idx)
global(settings_changed, many_notes)
instance(active_note_mem, active_note_vel, notes_on)
(
  idx = 0;
  change = 0;
  ix = 19;
  loop(5,
    // If this one is used, store it in the active note memory.
    val = slider(ix);
    val ? (
      change = (active_note_mem[idx] != val) ? 1 : change;
      active_note_mem[idx] = val;
      active_note_vel[idx] = 1.0;
      idx += 1;
    );
    ix += 1;
  );
  
  // Extra notes
  many_notes ? (
    ix = 64;
    loop(7,
      // If this one is used, store it in the active note memory.
      val = slider(ix);
      val ? (
        change = (active_note_mem[idx] != val) ? 1 : change;
        active_note_mem[idx] = val;
        active_note_vel[idx] = 1.0;
        idx += 1;
      );
      ix += 1;
    );
  );
  
  notes_on = idx;
  val = 5 + 7 * many_notes - idx;
  loop(val,
    change = (active_note_mem[idx] != 0) ? 1 : change;
    active_note_mem[idx] = 0;
    active_note_vel[idx] = 0;
    idx += 1;
  );
  change ? (
    settings_changed = 1;
  );
);

midi.curSample += 1;
!midi_input ? (
  midi.update_fixed_notes();
);

midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

big_tick = update_ticker == 0;
update_ticker += 1;
(update_ticker > 128) ? (
  update_ticker = 0;
);

big_tick ? (
  midi.update_notes();
);
midi.note_on0 ? string1.update_freq();
midi.note_on1 ? string2.update_freq();
midi.note_on2 ? string3.update_freq();
midi.note_on3 ? string4.update_freq();
midi.note_on4 ? string5.update_freq();
many_notes ? (
  midi.note_on5 ? string6.update_freq();
  midi.note_on6 ? string7.update_freq();
  midi.note_on7 ? string8.update_freq();
  midi.note_on8 ? string9.update_freq();
  midi.note_on9 ? string10.update_freq();
  midi.note_on10 ? string11.update_freq();
  midi.note_on11 ? string12.update_freq();
);


f_hn = 0;
f_b = 0;

stft ? (
  (play_mode >= 2) ? (
    f_h += string1.impulse.eval_impulse(string1.freq) * 4;
    f_h += string2.impulse.eval_impulse(string2.freq) * 4;
    f_h += string3.impulse.eval_impulse(string3.freq) * 4;
    f_h += string4.impulse.eval_impulse(string4.freq) * 4;
    f_h += string5.impulse.eval_impulse(string5.freq) * 4;
    
    many_notes ? (
      f_h += string6.impulse.eval_impulse(string6.freq) * 4;
      f_h += string7.impulse.eval_impulse(string7.freq) * 4;
      f_h += string8.impulse.eval_impulse(string8.freq) * 4;
      f_h += string9.impulse.eval_impulse(string9.freq) * 4;
      f_h += string10.impulse.eval_impulse(string10.freq) * 4;
      f_h += string11.impulse.eval_impulse(string11.freq) * 4;
      f_h += string12.impulse.eval_impulse(string12.freq) * 4;
    );
  );
  stft_mem.read_stft(f_h);
);

// Process the envelopes (if any).
single_filter_cutoff = single_filter_ref_cutoff;

midi_input ? (
  use_envelopes ? (
    _e1 = envelope1.env_sample();
    _e2 = envelope2.env_sample();
    _e3 = envelope3.env_sample();
    _e4 = envelope4.env_sample();
    _e5 = envelope5.env_sample();
  ) : (
    _e1 = _e2 = _e3 = _e4 = _e5 = 1;
  );
  (use_filt_envelopes && enable_filter) ? (
    _fe1 = filt_envelope1.env_sample();
    _fe2 = filt_envelope2.env_sample();
    _fe3 = filt_envelope3.env_sample();
    _fe4 = filt_envelope4.env_sample();
    _fe5 = filt_envelope5.env_sample();

    single_filter ? (
      single_filter_cutoff += 
        (latest_note == 0) ? _fe1 : 
        (latest_note == 1) ? _fe2 : 
        (latest_note == 2) ? _fe3 : 
        (latest_note == 3) ? _fe4 : 
        (latest_note == 4) ? _fe5;
      single_filter_cutoff = max(0.0, min(1.0, single_filter_cutoff));
    );
  ) : (
    _fe1 = _fe2 = _fe3 = _fe4 = _fe5 = 0;
  );
) : (
  _e1 = _e2 = _e3 = _e4 = _e5 = 1;
  _fe1 = _fe2 = _fe3 = _fe4 = _fe5 = 1;
);

many_notes ? (
  midi_input ? (
    use_envelopes ? (
      _e6 = envelope6.env_sample();
      _e7 = envelope7.env_sample();
      _e8 = envelope8.env_sample();
      _e9 = envelope9.env_sample();
      _e10 = envelope10.env_sample();
      _e11 = envelope11.env_sample();
      _e12 = envelope12.env_sample();
    ) : (
      _e6 = _e7 = _e8 = _e9 = _e10 = _e11 = _e12 = 1;
    );
    (use_filt_envelopes && enable_filter) ? (
      _fe6 = filt_envelope6.env_sample();
      _fe7 = filt_envelope7.env_sample();
      _fe8 = filt_envelope8.env_sample();
      _fe9 = filt_envelope9.env_sample();
      _fe10 = filt_envelope10.env_sample();
      _fe11 = filt_envelope11.env_sample();
      _fe12 = filt_envelope12.env_sample();
  
      single_filter ? (
        single_filter_cutoff2 = single_filter_ref_cutoff;
        single_filter_cutoff2 += 
          (latest_note == 5) ? _fe6 : 
          (latest_note == 6) ? _fe7 : 
          (latest_note == 7) ? _fe8 : 
          (latest_note == 8) ? _fe9 : 
          (latest_note == 9) ? _fe10 :
          (latest_note == 10) ? _fe11 : 
          (latest_note == 11) ? _fe12;
        single_filter_cutoff = max(0.0, min(1.0, max(single_filter_cutoff, single_filter_cutoff2)));
      );
    ) : (
      _fe6 = _fe7 = _fe8 = _fe9 = _fe10 = _fe11 = _fe12 = 0;
    );
  ) : (
    _e6 = _e7 = _e8 = _e9 = _e10 = _e11 = _e12 = 1;
    _fe6 = _fe7 = _fe8 = _fe9 = _fe10 = _fe11 = _fe12 = 1;
  );
);

single_filter ? (
  (single_svf.last_freq != single_filter_cutoff) ? (
    single_svf.init_linearSVF(single_filter_cutoff, 0);
  );
);

// Process string internals
string1.eval_string(f_h, _e1, midi.note_on0);
string2.eval_string(f_h, _e2, midi.note_on1);
string3.eval_string(f_h, _e3, midi.note_on2);
string4.eval_string(f_h, _e4, midi.note_on3);
string5.eval_string(f_h, _e5, midi.note_on4);

many_notes ? (
  string6.eval_string(f_h, _e6, midi.note_on5);
  string7.eval_string(f_h, _e7, midi.note_on6);
  string8.eval_string(f_h, _e8, midi.note_on7);
  string9.eval_string(f_h, _e9, midi.note_on8);
  string10.eval_string(f_h, _e10, midi.note_on9);
  string11.eval_string(f_h, _e11, midi.note_on10);
  string12.eval_string(f_h, _e12, midi.note_on11);
);

// Write to output
stft ? (
  stft_mem.write_stft();
  f_b = stft_mem.f_b;
  f_hn = stft_mem.f_hn;
) : (
  (midi_input && use_envelopes) ? (
    /* Apply amplitude envelope */
    string1.f_b *= _e1;
    string2.f_b *= _e2;
    string3.f_b *= _e3;
    string4.f_b *= _e4;
    string5.f_b *= _e5;
    
    many_notes ? (
      string6.f_b *= _e6;
      string7.f_b *= _e7;
      string8.f_b *= _e8;
      string9.f_b *= _e9;
      string10.f_b *= _e10;
      string11.f_b *= _e11;
      string12.f_b *= _e12;
    );
  );
  
  /* Apply multi filter; only happens in td with envelopes on */
  multi_filter ? (
    _fe1 = min(1.0, max(0.0, string1.ref_cutoff + _fe1));
    (svf1.last_freq != _fe1) ? ( svf1.init_linearSVF(_fe1, 0); );
    _fe2 = min(1.0, max(0.0, string2.ref_cutoff + _fe2));
    (svf2.last_freq != _fe2) ? ( svf2.init_linearSVF(_fe2, 0); );
    _fe3 = min(1.0, max(0.0, string3.ref_cutoff + _fe3));
    (svf3.last_freq != _fe3) ? ( svf3.init_linearSVF(_fe3, 0); );
    _fe4 = min(1.0, max(0.0, string4.ref_cutoff + _fe4));
    (svf4.last_freq != _fe4) ? ( svf4.init_linearSVF(_fe4, 0); );
    _fe5 = min(1.0, max(0.0, string5.ref_cutoff + _fe5));
    (svf5.last_freq != _fe5) ? ( svf5.init_linearSVF(_fe5, 0); );
    
    string1.f_b = svf1.eval_linearSVF_LP(string1.f_b);
    string2.f_b = svf2.eval_linearSVF_LP(string2.f_b);
    string3.f_b = svf3.eval_linearSVF_LP(string3.f_b);
    string4.f_b = svf4.eval_linearSVF_LP(string4.f_b);
    string5.f_b = svf5.eval_linearSVF_LP(string5.f_b);
    
    many_notes ? (
      _fe6 = min(1.0, max(0.0, string6.ref_cutoff + _fe6));
      (svf6.last_freq != _fe6) ? ( svf6.init_linearSVF(_fe6, 0); );
      _fe7 = min(1.0, max(0.0, string7.ref_cutoff + _fe7));
      (svf7.last_freq != _fe7) ? ( svf7.init_linearSVF(_fe7, 0); );
      _fe8 = min(1.0, max(0.0, string8.ref_cutoff + _fe8));
      (svf8.last_freq != _fe8) ? ( svf8.init_linearSVF(_fe8, 0); );
      _fe9 = min(1.0, max(0.0, string9.ref_cutoff + _fe9));
      (svf9.last_freq != _fe9) ? ( svf9.init_linearSVF(_fe9, 0); );
      _fe10 = min(1.0, max(0.0, string10.ref_cutoff + _fe10));
      (svf10.last_freq != _fe10) ? ( svf10.init_linearSVF(_fe10, 0); );
      _fe11 = min(1.0, max(0.0, string11.ref_cutoff + _fe11));
      (svf11.last_freq != _fe11) ? ( svf11.init_linearSVF(_fe11, 0); );
      _fe12 = min(1.0, max(0.0, string12.ref_cutoff + _fe12));
      (svf12.last_freq != _fe12) ? ( svf12.init_linearSVF(_fe12, 0); );
      
      string6.f_b = svf6.eval_linearSVF_LP(string6.f_b);
      string7.f_b = svf7.eval_linearSVF_LP(string7.f_b);
      string8.f_b = svf8.eval_linearSVF_LP(string8.f_b);
      string9.f_b = svf9.eval_linearSVF_LP(string9.f_b);
      string10.f_b = svf10.eval_linearSVF_LP(string10.f_b);
      string11.f_b = svf11.eval_linearSVF_LP(string11.f_b);
      string12.f_b = svf12.eval_linearSVF_LP(string12.f_b);
    );
  );
  
  /* Sum to output */
  f_b += string1.f_b;
  f_b += string2.f_b;
  f_b += string3.f_b;
  f_b += string4.f_b;
  f_b += string5.f_b;
  
  f_hn += string1.f_hn;
  f_hn += string2.f_hn;
  f_hn += string3.f_hn;
  f_hn += string4.f_hn;
  f_hn += string5.f_hn;
  
  many_notes ? (
    f_b += string6.f_b;
    f_b += string7.f_b;
    f_b += string8.f_b;
    f_b += string9.f_b;
    f_b += string10.f_b;
    f_b += string11.f_b;
    f_b += string12.f_b;
    
    f_hn += string6.f_hn;
    f_hn += string7.f_hn;
    f_hn += string8.f_hn;
    f_hn += string9.f_hn;
    f_hn += string10.f_hn;
    f_hn += string11.f_hn;
    f_hn += string12.f_hn;
  );
);

// Single filter case (stft or td without envelopes)
single_filter ? (
  f_b = single_svf.eval_linearSVF_LP(f_b);
);

hammer = 0;

function soft_clip(x)
(
  (abs(x) < 1) ? 1.5 * x - 0.5 * x * x * x : sign(x)
);

amp_factor = 10^stiffness;

stft ? (
current_force_fb = force_fb + force_fb_vel * midi.last_vel;
  f_h = spl0;
  f_h = -(f_h > 0 ? 100000 * f_h ^ stiffness_exp : 0);
  //f_h = soft_clip(Adivfs*f_h) * srate;
) : (
  hammer ? (
    // WIP dynamical model (broken for now)
    mass = 4.9 * 0.001;
    mul = 100000;
    
    t_ah = f_h_last * (-1.0 / (mass * srate));
    t_vh = t_ah + t_vh;
    t_yn = t_vh / srate + t_yn;
    signal = t_yn - 370*f_hn;
    f_h = (signal > 0 ? mul * signal ^ stiffness_exp : 0);
    f_h_last = f_h;
  ) : (
    // No hammer but simple feedback
    current_force_fb = force_fb + force_fb_vel * midi.last_vel;
    f_h = tanh(current_force_fb * f_hn);
    f_h += spl0;
    f_h = -(f_h > 0 ? amp_factor * f_h ^ stiffness_exp : 0);
  );
);

stereo ? (
  buffer.update_buffer(f_b);
  rb = buffer.read_buffer();

  /* Highpass the added comb filter signal */
  rb = hp.eval_linearSVF_HP6(rb);
  
  spl0 = f_b + 0.33 * rb;
  spl1 = f_b - 0.33 * rb;
) : (
  spl0 = spl1 = f_b;
);

!stft ? (
  // Gain normalization in case of feedback system
  spl0 /= amp_factor * 0.00001;
  spl1 /= amp_factor * 0.00001;
);

settings_changed ? (
  settings_changed = 0;
  force_update();
);

spinner.eval_spinner(spl0, spl1, spinner_frequency, spinner_depth);
spl0 = spinner.outl;
spl1 = spinner.outr;

last_spl0 = spl0;
last_spl1 = spl1;

@serialize
file_var(0, version);
(version > 1) ? (
  file_var(0, env.t_max);
) : (
  env.t_max = 0.1;
  use_envelopes = 0;
);

file_var(0, MAX_CUSTOM_PARTIALS);
file_mem(0, custom_partial_mem, MAX_CUSTOM_PARTIALS * 8 + 64);

(version < 3) ? ( glide = 0; ) : ( file_var(0, glide); );
(version < 3) ? ( test_mode = 0; ) : ( file_var(0, test_mode); );
(version < 3) ? ( pass_through = 1; ) : ( file_var(0, pass_through); );
(version < 4) ? ( spinner_frequency = 0; spinner_depth = 0; );

(version >= 4) ? (
  serialize_all_samples(file_avail(0) < 0);
) : (
  idx = 0;
  loop(N_SAMPLES,
    clear_sample(idx);
    idx += 1;
  );
);

(version < 5) ? (
  // Old file format
  use_filt_envelopes = 0;
  enable_filter = 0;
  filter_cutoff = 0.4;
  filter_cutoff_vel = 0.25;
  filter_reso = 0;
  filter_reso_vel = 0;
  filter_envelope = 0.5;
  filter_envelope_vel = 0;
  filter_attack = 0;
  filter_decay = 1;
  filter_releaser = 1.5;
  filter_sustain = 0.3;
  voice_thievery = 0;
) : (
  file_var(0, use_filt_envelopes);
  file_var(0, enable_filter);
);

(version < 6) ? (
  voice_thievery = 0;
  damp_release = 0;
  freq_damp_release = 0;
  inharmonicity_release = 0;
) : (
  file_var(0, voice_thievery);
);

(version < 7) ? (
  force_fb_vel = 0;
);

(version < 8) ? (
  bp_resonator_mode = 0;
) : (
  file_var(0, bp_resonator_mode);  
);

(version < 9) ? (
  lf_mod = 0;
  lf_mod_vel = 0;
);

(version < 10) ? (
  lf_mod2 = lf_mod2_vel = 0;
  pitchbend_range = 2;
  sample_follow_note = 0;
) : (
  file_var(0, pitchbend_range);
);

file_var(0, microtuned);
microtuned ? (
  file_mem(0, tuning_memory, 128);
);

file_var(0, many_notes);

version = 10;
last_selected_sample = -1;
reset_zoom = 1;

@gfx 1040 480
_gfx_w = gfx_w;
_gfx_h = gfx_h;

//scaling = gfx_ext_retina == 2 ? 1 : 0;
scaling = _gfx_w / 1080;

//gfx_set(0, 0, 0, 1);
//gfx_rect(0, 0, gfx_w, gfx_h);

((init_w != _gfx_w) || (init_h != _gfx_h) || (model != last_model)) ? (
  init_w = _gfx_w;
  init_h = _gfx_h;
  last_model = model;
  settings_changed = 1;
  gfx_setimgdim(1, _gfx_w, _gfx_h);
  gfx_dest = 1;
  gfx_set(0, 0, 0, 1);
  gfx_rect(0, 0, _gfx_w, _gfx_h);
  
  loop(100,
    xx = _gfx_w * rand();
    yy = _gfx_h * rand();
    colormodel(rand()*rand()*rand()); gfx_a = 0.2;
    gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
  );
  loop(5,
    gfx_x = gfx_y = 0;
    gfx_blurto(_gfx_w, _gfx_h)
  );
  
  gfx_dest = -1;
);


gfx_dest = 1;
xx = _gfx_w * rand();
yy = _gfx_h * rand();
colormodel(rand()*rand()*rand()); gfx_a = 0.2;
gfx_circle(xx, yy, 50 + 50 * rand(), 1, 1);
/*
xx = 2 * gfx_w * rand();
yy = gfx_h * rand();
loop(10,
  colormodel(0); gfx_a = 0.1;
  gfx_line(xx, 1, xx - gfx_h * 2, gfx_h + 1);
  gfx_line(xx, 2, xx - gfx_h * 2, gfx_h + 2);
  gfx_a = 10;
  gfx_line(xx, 0, xx - gfx_h * 2, gfx_h);
);
*/
gfx_x = gfx_y = 0;
gfx_blurto(_gfx_w, _gfx_h);
gfx_dest = -1;

gfx_x = gfx_y = 0; gfx_a = 0.25;
gfx_blit(1, 1, 0);



/*
gfx_set(0.3, 0.3, 0.7, 1);
ix = 0;
loop(string1.fft_size,
  yc = 0.5 * gfx_h * sqrt(string1.coeff_mem[2 * ix]^2 + string1.coeff_mem[2 * ix + 1]^2);
  gfx_rect(2 * ix, gfx_h - yc, 1, yc);
  ix += 1;
);
*/

function simple_arrow(xx, yy, _r)
local(dr)
global()
(
  dr = ceil(0.06 * _r);
  xx = floor(xx);
  yy = floor(yy);
  _r = floor(_r);
  gfx_line(xx, yy - 0.4 * _r, xx, yy - 2 * dr - 1);
  gfx_line(xx + 1, yy - 0.4 * _r, xx + 1, yy - 2 * dr - 1);
  gfx_line(xx - 1, yy - 0.4 * _r, xx - 1, yy - 2 * dr - 1);
  gfx_triangle(xx - dr, yy - 2 * dr, xx + dr, yy - 2 * dr, xx, yy);
);

function gfx_draw_icon(id, enabled)
local(len, xp, xx, yy, dr, s, ds, cy, sy, ang1, ang2, x1, x2, y1, y2, i, di, rr)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _r, relative_position)
( 
  colormodel(0.9);
  id == 0 ? (
    // Position
    len = ceil(0.6 * _r);
    yy = _y + 0.1 * _r;
    gfx_line(_x - len, yy, _x + len, yy, 1);
    gfx_line(_x - len, yy + 1, _x + len, yy + 1, 1);
    
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(xx, yy, _r);
  ) : ( id == 1 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 5 * relative_position / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * s - sy);
        s -= ds * s;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 2 ) ? (
    // Freq Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > 2 * (1 - relative_position) * len) ? cy -= 2 / len;
        cy = max(0, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 3 ) ? (
    // Spring
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 4.0 * relative_position;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(8.5 * len,
        cy = (1 - 0.4 * relative_position) * s - sy;
        gfx_a = 0.5 + 0.4 * cos(cy);
        
        gfx_lineto(floor(_x + xx - sy + 5 * cos(cy) * tanh(xx / len)), floor(_y - sy + yy * sin(cy)));
        s += 0.35;
        xx += 0.25;
      );
      sy -= 1;
    );
  ) : ( id == 4 ) ? (
    // Stiffness
    len = ceil(0.6 * _r);
    yy = _y + 0.35 * _r;
    dr = _r * (0.5 + relative_position);
    
    gfx_a = 0.2 + 0.8 * enabled;
    xx = _x - len + ceil(2 * len * relative_position);
    simple_arrow(_x, _y + 0.05 * _r - 0.1 * _r * relative_position, _r);

    xx = _x - len + ceil(2 * len * relative_position);
    gfx_a = relative_position;
    simple_arrow(_x + 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    simple_arrow(_x - 0.3 * _r, _y + 0.01 * _r - 0.1 * _r * relative_position, _r);
    
    gfx_a = 0.2 + 0.8 * enabled;
    ang1 = $pi + asin(0.45 * _r / dr);
    ang2 = $pi - asin(0.45 * _r / dr);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
    
    yy += floor(0.12 * _r);
    gfx_arc(_x, yy - 1.15 * dr, dr, ang1, ang2);
    gfx_arc(_x, yy - 1.15 * dr + 0.5, dr, ang1, ang2);
  ) : ( id == 5 ) ? (
    // Decay
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    ds = 0.5 / len;
    sy = 1;
    loop(2,
      xx = _x - len;
      s = 0;
      gfx_x = xx;
      gfx_y = _y + yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * pow(s, 1 + 5 * relative_position) - sy);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 6 ) ? (
    gfx_a = enabled;
    x1 = floor(_x - 0.3 * _r);
    x2 = floor(_x + 0.3 * _r);
    dr = floor(0.07 * _r);
    gfx_circle(x1, y2, dr, 1);
  
    gfx_a = 0.1 + 0.9 * relative_position * enabled;
    y1 = floor(_y - 0.3 * _r);
    y2 = floor(_y + 0.3 * _r);
    
    loop(2,
      x1 = floor(_x - 0.3 * _r);
      x2 = floor(_x + 0.3 * _r);
      loop(2,
        gfx_line(x1, y1, x1, y2 - 3 * dr);
        gfx_line(x1, y1, x1, y1);
        gfx_line(x1 + 1, y1, x2 - 1, y1);
        gfx_line(x2, y1, x2, y2 - 1);
        gfx_line(x1 + 3 * dr, y2, x2, y2);    
        gfx_line(x1 + 3 * dr, y2 + 1, x1 + 4 * dr, y2 + dr + 1);
        gfx_line(x1 + 3 * dr, y2 - 1, x1 + 4 * dr, y2 - dr - 1);
        x1 += 1;
        x2 += 1;
      );
      y1 += 1;
      y2 += 1;
    );
  ) : ( id == 7 ) ? (
    s = 0;
    _r *= 0.8;
    loop(12,
      gfx_a = 0.5 + (s < (17 * relative_position) ? 0.5 : 0);
      !enabled ? gfx_a *= 0.2;
      gfx_line(
        _x - 0.2 * _r * sin(s),
        _y + 0.2 * _r * cos(s), 
        _x - (0.5 + 0.05 * s) * _r * sin(s),
        _y + (0.5 + 0.03 * s) * _r * cos(s)
      );
      gfx_line(
        _x - 0.2 * _r * sin(s),
        _y + 0.2 * _r * cos(s) + 1, 
        _x - (0.5 + 0.05 * s) * _r * sin(s),
        _y + (0.5 + 0.03 * s) * _r * cos(s) + 1
      );
      s += 0.35 * $pi;
    );
  ) : ( id == 8 ) ? (
    // Waveform
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 3.14 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      gfx_a = 0.8;
      loop(2 * len,
        _r = sin(0.1 * s) + sin(2.22 * s + 3) + 0.2 * sin(1.48 * s * s + 10) - 0.1;
        _r *= (1 - cos(s));
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 9 ) ? (
    // MIDI
    gfx_a = 0.17;
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 3.14 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = 0;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      loop(2 * len,
        _r = sin(0.1 * s) + sin(2.22 * s + 3) + 0.2 * sin(1.48 * s * s + 10) - 0.1;
        _r *= (1 - cos(s));
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
    
    gfx_a = 0.4;
    sy = 0;
    gfx_circle(_x, _y, 0.8 * len + 0.5 * sy, 1); 
    loop(3,
      gfx_circle(_x, _y, len + 0.5 * sy);
      sy += 1;
    );
    
    gfx_set(0, 0, 0, 0.7);
    gfx_circle(_x - 0.5 * len, _y, 0.85 * sy, 1);
    gfx_circle(_x + 0.5 * len, _y, 0.85 * sy, 1);
    gfx_circle(_x, _y - 0.5 * len, 0.85 * sy, 1);
    gfx_circle(_x - 0.5 / 1.41 * len, _y - 0.5 / 1.41 * len, 0.85 * sy, 1);
    gfx_circle(_x + 0.5 / 1.41 * len, _y - 0.5 / 1.41 * len, 0.85 * sy, 1);
  ) : ( id == 10 ) ? (
    // Spike
    gfx_line(_x - 0.5 * _r, _y + 0.25 * _r, _x + 0.5 * _r + 1, _y + 0.25 * _r);
    gfx_line(_x - 0.5 * _r, _y + 0.25 * _r - 1, _x + 0.5 * _r + 1, _y + 0.25 * _r - 1);
    simple_arrow(_x, _y - 0.35 * _r, -1.5 * _r);
  ) : ( id == 11 ) ? (
    // Noise burst
    ang2 = 0;
    loop(2,
      s = _x - 0.5 * _r;
      i = - 0.5;
      di = - 2 * i / _r;
      gfx_y = _y + 0.35 * _r;
      gfx_x = s;
      loop(_r,
        ang1 = _y + 0.35 * _r - 0.8 * _r * exp(-1.5 * i * i * _r);
        gfx_lineto(s, ang1 + ang2, 1);
        s += 1;
        i += di;
      );
      ang2 += 1;
    );
  ) : ( id == 12 ) ? (
    // Noise
    ang2 = 0;
    loop(2,
      s = _x - 0.5 * _r;
      i = - 0.5;
      di = - 2 * i / _r;
      gfx_y = _y + 0.35 * _r;
      gfx_x = s;
      loop(_r,
        rr = i * i;
        rr *= 3 * rr;
        ang1 = _y + 0.35 * _r - 0.8 * _r * exp(-1.5 * rr * _r);
        gfx_lineto(s, ang1 + ang2, 1);
        s += 1;
        i += di;
      );
      ang2 += 1;
    );
  ) : ( id == 13 ) ? (
    // Custom impulse
    len = ceil(0.6 * _r);
    yy = ceil(0.2 * _r);
    ds = 1 / len;
    sy = 1;
    loop(2,
      xx = - len;
      s = -0.2;
      gfx_x = _x + xx - 5;
      gfx_y = _y;
      gfx_a = 0.8;
      loop(2 * len,
        _r = sin(12.1 * s) + sin(9.22 * s + 3) + cos(12.22 * s + 1) - 0.1;
        _r *= cos(s) * cos(s);
        gfx_line(_x + xx - sy, _y - sy - yy * _r, _x + xx - sy, _y - sy + yy * _r);
        s += ds;
        xx += 1;
      );
      sy -= 1;
    );
  ) : ( id == 20 ) ? (
    xx = _x - 0.5 * _r;
    yy = _y + 0.3 * _r;
    rr = floor(4/50 * _r);
    
    gfx_circle(xx, yy, rr, 1);
    gfx_circle(xx + 1, yy, rr, 1);
    gfx_circle(xx + 2, yy, rr, 1);
    gfx_line(xx + rr, yy, xx + rr, yy - 0.5 * _r);
    gfx_line(xx + rr + 1, yy, xx + rr + 1, yy - 0.5 * _r);
    gfx_line(xx + rr + 2, yy, xx + rr + 2, yy - 0.5 * _r);
    
    xx = _x + 0.38 * _r;
    yy = _y + 0.1 * _r - 0.5 * _r;
    gfx_circle(xx, yy, rr, 1);
    gfx_circle(xx + 1, yy, rr, 1);
    gfx_circle(xx + 2, yy, rr, 1);
    gfx_line(xx - rr, yy, xx - rr, yy + 0.5 * _r);
    gfx_line(xx - rr + 1, yy, xx - rr + 1, yy + 0.5 * _r);
    gfx_line(xx - rr + 2, yy, xx - rr + 2, yy + 0.5 * _r);
    
    yy += 0.5 * _r;
    gfx_line(_x - 0.3 * _r, yy, xx - 4 - 0.1 * _r, yy - 0.4 * _r);
    gfx_line(_x - 0.3 * _r, yy + 1, xx - 4 - 0.1 * _r, yy - 0.4 * _r + 1);
//    gfx_circle(_x, _y, 1, 0.5);
  ) : ( id == 21 ) ? (
    // Spin depth
    _x = floor(_x);
    _y = floor(_y);
    dr = (0.65 * pow(relative_position, 0.2)) * _r;
    rr = 0.1 * _r;
    
    ds = ceil(_r / 8);
    loop(ds,
      gfx_circle(_x, _y, rr, 0, 1);
      rr += 0.5;
    );
    
    rr = -1;
    loop(8,
      gfx_line(floor(_x - rr), floor(_y - rr), floor(_x + dr * 0.707 - rr), floor(_y - dr * 0.707 - rr), 1);
      rr += 0.25;
    );
    
    rr = dr;
    loop(ds,
      gfx_circle(_x, _y, rr, 0, 1);
      rr += 0.5;
    );
    
    rr = 0.1 * _r;
    loop(ds,
      gfx_circle(floor(_x + dr * 0.707), floor(_y - dr * 0.707), rr, 0, 1);
      rr += 0.5;
    );
    
    gfx_set(0, 0, 0, 1.0);
    gfx_circle(floor(_x + dr * 0.707), floor(_y - dr * 0.707), floor(0.1 * _r), 1, 1);
    gfx_set(0, 0, 0, 1.0);
    gfx_circle(floor(_x), floor(_y), floor(0.1 * _r), 1, 1);
  ) : ( id == 22 ) ? (
    // Spin Freq
    _x = floor(_x + 0.01 * _r);
    _y = floor(_y + 0.0 * _r);
    ds = ceil(_r / 8);
    
    rr = 0.6 * _r;
    s = 0;
    loop(ds * 3,
      gfx_arc(_x, _y, rr, min(- 0.76 * $pi + s, 0.46 * $pi), 0.66 * $pi);
      rr -= 0.45;
      s += 0.25;
    );
    
    ang1 = -0.76 * $pi - 1.42 * $pi * relative_position;
    gfx_line(_x, _y, _x + rr * cos(ang1), _y - rr * sin(ang1));
    gfx_line(_x + 1, _y + 1, _x + rr * cos(ang1), _y - rr * sin(ang1));
    gfx_line(_x + 1, _y - 1, _x + rr * cos(ang1), _y - rr * sin(ang1));
  ) : ( id == 23 ) ? (
    // Filter Cutoff
    gfx_a = 0.2 + 0.8 * enabled;
    len = ceil(0.6 * _r);
    yy = ceil(0.3 * _r);
    sy = 1;
    rr = 2 * relative_position * len;
    _r = 1 / len;
    loop(2,
      xx = _x - len;
      s = 1; cy = 1;
      gfx_x = xx;
      gfx_y = _y + yy - 2 * yy - sy;
      loop(2 * len,
        gfx_lineto(xx, _y + yy - 2 * yy * cy - sy);
        (s > rr) ? cy -= min(2, 0.15 * (s - rr)) * _r;
        cy = max(-0.1, cy);
        xx += 1;
        s += 1;
      );
      sy -= 1;
    );
  ) : ( id == 24 ) ? (
    gfx_a = 0.2 + 0.8 * enabled;
    rr = 0.6 * _r;
    di = 10 / _r / (0.4);
    sy = 0;
    loop(2,
      i = 0;
      s = _x - rr;
      x2 = 2 * rr * (relative_position - 0.5);
      gfx_x = s;
      gfx_y = _y + 0.5 * rr * 2 * (relative_position - 0.5) + sy;
      loop(2 * rr,
        gfx_lineto(s, _y + sy + 0.5 * x2 - i * x2 * exp(- 0.35 * i), 1);
        s += 1;
        i += di;
      );
      sy += 1;
    );
  ) : ( id == 25 ) ? (
    gfx_a = 0.2 + 0.8 * enabled;
    rr = 0.4 * _r * (0.25 + 0.75 * relative_position);
    di = 10 / _r / (0.4);
    sy = 0;
    loop(2,
      i = 0;
      s = _x - 0.4 * _r;
      gfx_x = s;
      gfx_y = _y + sy;
      loop(0.8 * _r,
        gfx_lineto(s, _y + sy - rr * sin(- 0.35 * i), 1);
        s += 1;
        i += di;
      );
      sy += 1;
    );
  ) : ( id == 26 ) ? (
    gfx_a = 0.2 + 0.8 * enabled;
    rr = 0.8 * _r * (0 + 1.2 * relative_position);
    i = 0;
    
    gfx_line(_x, _y + 0.4 * _r, _x, _y - 0.4 * _r);
    gfx_line(_x + 1, _y + 0.4 * _r, _x + 1, _y - 0.4 * _r);
    gfx_line(_x - 1, _y + 0.4 * _r, _x - 1, _y - 0.4 * _r);
    
    loop(2,
      s = _x - 0.4 * rr;
      sy = -2;
      gfx_x = s;
      gfx_y = _y + sy;
      loop(5,
        gfx_line(s + i, _y + 0.4 * _r, s + i, _y - 0.4 * _r / (1.0 + 1.2 * abs(sy)));
        s += 0.2 * rr;
        sy += 1;
      );
      i += 1;
    );
  );
);

function draw_model_icon()
local(s, ds, xx, yy, len, hh, xorig, yorig, value)
global(gfx_x, gfx_y, gfx_a)
instance(_x, _y, _w, _h, active, _me)
(
  colormodel(0.7); gfx_a = 1;
  (_me == 0) ? (
    len = floor(0.4 * _w);
    xx = _x + floor(0.5 * _w);
    yy = _y + 0.5 * _h;
    ds = ceil(0.05 * _w);
    s = ceil(0.2 * _w);
    
    gfx_line(xx - len, yy, xx + len, yy);
    gfx_line(xx - len, yy - ds, xx + len, yy - ds);
    gfx_line(xx - len, yy + ds, xx + len, yy + ds);
    gfx_line(xx - len, yy - 2 * ds, xx + len, yy - 2 * ds);
    gfx_line(xx - len, yy + 2 * ds, xx + len, yy + 2 * ds);
    gfx_circle(xx - ds, yy, s);
  ) : (_me == 1) ? (
    len = floor(0.25 * _h);
    ds = floor(0.08 * _w);
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    
    xx -= 3 * ds;
    loop(3,
      gfx_line(xx - ds, yy - len, xx - ds, yy + len);
      gfx_line(xx + ds, yy - len, xx + ds, yy + len);
      gfx_arc(xx, yy + len, ds, 0.5 * $pi, 1.5 * $pi);
      gfx_circle(xx, yy - len, ds);
      len -= 1;
      xx += 3 * ds;
    );
  ) : (_me == 2) ? (
    len = floor(0.3 * _w);
    ds = $pi / len;
    s = 0;
    yy = _y + 0.5 * _h;
    loop(2,
      xx = _x + floor(0.5 * _w) - len;
      gfx_x = xx;
      gfx_y = yy;
      loop(len * 2,
        gfx_lineto(xx, yy - .5 * len * sin(s));
        xx += 1;
        s += ds;
      );
      yy -= 1;
    );
  ) : (_me == 3) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 4) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = ceil(0.2 * len);
    gfx_triangle(xx, yy - 2, xx - ds, yy - 2 * ds - 2, xx + ds, yy - 2 * ds - 2);
    gfx_triangle(xx + 2 * len - 1, yy - 2, xx + 2 * len - ds - 1, yy - 2 * ds - 2, xx + 2 * len + ds - 1, yy - 2 * ds - 2);
    gfx_rect(xx, yy, 2 * len, 4);
  ) : (_me == 5) ? (
    len = floor(0.3 * _w);
    xx = _x + floor(0.5 * _w) - len;
    yy = _y + 0.5 * _h;
    ds = 0.5 * $pi / len;
    hh = 0.12 * _h;
    loop(2 * len - 1,
      s += ds;
      colormodel(0.5); gfx_a = 0.5;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + 4 + hh * sqrt(sin(s)));
      colormodel(0.7); gfx_a = 1.0;
      gfx_line(xx, yy - hh * sqrt(sin(s)), xx, yy + hh * sqrt(sin(s)));
      xx += 1;
    );
  ) : (_me == 6) ? (
    len = floor(0.25 * _w);
    ds = floor(0.15 * _w);
    xx = _x + floor(0.47 * _w) - len;
    yy = _y + 0.5 * _h;
    gfx_line(xx, yy + len, xx + len, yy - len);
    gfx_line(xx, yy + len + 1, xx + len, yy - len + 1);
    gfx_circle(xx + len, yy - len + 1, ds / 2, 1);
    
    gfx_line(xx + ds, yy + len, xx + 2 * ds + len, yy - len + ds);
    gfx_line(xx + ds, yy + len + 1, xx + 2 * ds + len, yy - len + 1 + ds);
    gfx_circle(xx + 2 * ds + len, yy - len + 1 + ds, ds / 2, 1);
  ) : (_me == 7) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.35 * _w);
    ds = floor(0.15 * _w);
    gfx_circle(xx, yy, len, 0);
    gfx_circle(xx, yy, len + 0.5, 0);
    s = 0;
    loop(5,
      gfx_circle(xx + ds * sin(s), yy + ds * cos(s), ds, 0);
      s += 0.4 * $pi;
    );
  ) : (_me == 8 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.5 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len, 0);
    gfx_circle(xx - 0.25 * len, yy + 0.25 * len, len + 0.5, 0);
    xorig = xx - 0.25 * len + len / 1.41421 + 1;
    yorig = yy + 0.25 * len - len / 1.41421;
    gfx_line(xorig, yorig, xorig + 0.7 * len, yorig - 0.7 * len);
    gfx_line(xorig, yorig - 1, xorig + 0.7 * len, yorig - 0.7 * len - 1);
    xorig += 0.7 * len;
    yorig -= 0.7 * len;

    gfx_line(xorig, yorig - 1, xorig - 0.5 * len, yorig - 1);
//    gfx_line(xorig, yorig - 2, xorig - 0.5 * len, yorig - 2);
    gfx_line(xorig + 1, yorig - 1, xorig + 1, yorig + 0.5 * len);
//    gfx_line(xorig + 2, yorig - 2, xorig + 2, yorig + 0.5 * len);

  ) : (_me == 9 ) ? (
    xx = floor(_x + 0.5 * _w);
    yy = floor(_y + 0.475 * _h);
    len = floor(0.23 * _w);
    gfx_circle(xx, yy - 0.5 * len, len, 0);
    gfx_circle(xx, yy - 0.5 * len, len + 0.5, 0);
    gfx_line(xx, yy + 0.5 * len + 1, xx, yy + 1.75 * len);
    gfx_line(xx - 0.5 * len, yy + 1.25 * len, xx + 0.5 * len, yy + 1.25 * len);
  ) : (_me == 11) ? (
    xx = floor(_x + 0.18 * _w) - 1;
    yy = floor(_y + 0.75 * _h);
    len = floor((1 - 0.18*2) * _w);
    ds = floor(len / 2);
    
    ds = floor(len / 3);
    loop(ds,
      value = floor(len * abs(sin(s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 3, value, 0);
      xx += 3;
      s += 1.23;
    );
    
    xx = floor(_x + 0.18 * _w) - 1;
    ds = floor(len / 2);
    loop(ds,
      value = floor(0.5 * len * abs(sin(s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 3, value, 0);
      xx += 2;
      s += 1.23;
    );
  ) : (_me == 12 ) ? (
    xx = floor(_x + 0.18 * _w) - 1;
    yy = floor(_y + 0.75 * _h);
    len = floor((1 - 0.18*2) * _w);
    ds = floor(len / 2);
    
    loop(ds,
      value = floor(len * abs(sin(.9*s)));
      gfx_rect(xx, yy - value + 0.08 * _h, 2, value);
      xx += 2;
      s += 1.23;
    );
  );
);

function label_toggle(x, y, str, hint)
local(ww, hh, over)
global(mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y, last_cap, hinter.sethint)
(
  gfx_x = x; gfx_y = y;
  gfx_measurestr(str, ww, hh);
  gfx_printf(str);
  
  over = (mouse_x > x) && (mouse_x < (x + ww)) && (mouse_y > y) && (mouse_y < (y + hh));
  over ? hinter.sethint(hint);
  
  ((mouse_cap == 1) && (last_cap == 0)) ? (
    over ? 1
  );
);

gfx_setfont(3, "Arial", 12 * max(1, scaling));
gfx_measurestr("[Rel]", velw2, velh2);
colormodel(change_rel_mod - 0.01);
label_toggle(right - velw - 5, 0.935 * _gfx_h, " [Rel]", "Click this to change the release sensitivity of the parameters.\nParameters that can be linked to MIDI note velocity will\nbe highlighted.\n\nChanging their settings will result in those parameters\nchanging upon note release. This sensitivity is\nindicated by a differently colored arc.") ? (
  change_rel_mod = 1 - change_rel_mod;
  change_rel_mod == 1 ? (
    change_vel_mod = 0;
  );
);

gfx_setfont(3, "Arial", 12 * max(1, scaling));
gfx_measurestr("[Vel]", velw, velh);
colormodel(change_vel_mod - 0.01);
label_toggle(right - velw2 - velw - 10, 0.935 * _gfx_h, " [Vel]", "Click this to change the velocity sensitivity of the parameters.\nParameters that can be linked to MIDI note velocity will\nbe highlighted.\n\nChanging their settings will result in those parameters\nbeing sensitive to MIDI note velocity. This sensitivity is\nindicated by a differently colored arc.") ? (
  change_vel_mod = 1 - change_vel_mod;
  change_vel_mod == 1 ? (
    change_rel_mod = 0;
  );
);

microtuned ? (
  gfx_setfont(3, "Arial", 12 * max(1, scaling));
  gfx_measurestr("[Clr]", velw3, velh3);
  colormodel(microtuned - 0.01);
  label_toggle(right + 4, 0.935 * _gfx_h, " [Clr]", "Clear tuning file.") ? (
    microtuned = 1 - microtuned;
  );
);


colormodel(1 - display_log);
label_toggle(0.02 * _gfx_w, 0.93 * _gfx_h, "[Linear] ", "Display frequencies on a linear scale") ? (display_log = 0);
colormodel(display_log);
label_toggle(gfx_x, gfx_y, "[Logarithmic]", "Display frequencies on a logarithmic scale") ? (display_log = 1);

keyboard.draw_keyboard(base_note, gfx_x + 0.01 * _gfx_w - 10, 0.935 * _gfx_h, right - velw - velw2 - gfx_x - 0.01 * _gfx_w, 0.05 * gfx_y);

midi.note_on0 ? keyboard.highlight_note(midi.active_note_mem[0]);
midi.note_on1 ? keyboard.highlight_note(midi.active_note_mem[1]);
midi.note_on2 ? keyboard.highlight_note(midi.active_note_mem[2]);
midi.note_on3 ? keyboard.highlight_note(midi.active_note_mem[3]);
midi.note_on4 ? keyboard.highlight_note(midi.active_note_mem[4]);

many_notes ? (
  midi.note_on5 ? keyboard.highlight_note(midi.active_note_mem[5]);
  midi.note_on6 ? keyboard.highlight_note(midi.active_note_mem[6]);
  midi.note_on7 ? keyboard.highlight_note(midi.active_note_mem[7]);
  midi.note_on8 ? keyboard.highlight_note(midi.active_note_mem[8]);
  midi.note_on9 ? keyboard.highlight_note(midi.active_note_mem[9]);
  midi.note_on10 ? keyboard.highlight_note(midi.active_note_mem[10]);
  midi.note_on11 ? keyboard.highlight_note(midi.active_note_mem[11]);
  midi.note_on12 ? keyboard.highlight_note(midi.active_note_mem[12]);
);

note_over = keyboard.note_clicked();

function handle_non_midi_click(note_over)
instance(over)
local(idx, disabled_note)
global(keyboard.over, last_cap, mouse_cap, settings_changed, midi_input)
(
  this.over ? (
    (!midi_input) ? (
      (last_cap == 0) && (mouse_cap == 1) ? (
        settings_changed = 1;
        disabled_note = 0;
        // Note 1 - 5
        idx = 19;
        loop(5,
          (slider(idx) == note_over) ? (
            slider_automate(slider(idx) = 0);
            disabled_note = 1;
          );
          idx += 1;
        );
        // Note 6 - 12
        idx = 64;
        loop(7,
          (slider(idx) == note_over) ? (
            slider_automate(slider(idx) = 0);
            disabled_note = 1;
          );
          idx += 1;
        );
        
        (!disabled_note) ? (
          // Note 1 - 5
          idx = 19;
          loop(5,
            (slider(idx) == 0) ? (
              (!disabled_note) ? slider_automate(slider(idx) = note_over);
              disabled_note = 1;
            );
            idx += 1;
          );
          
          // Note 6 - 12
          idx = 64;
          loop(7,
            (slider(idx) == 0) ? (
              (!disabled_note) ? slider_automate(slider(idx) = note_over);
              disabled_note = 1;
            );
            idx += 1;
          );
        );
      );
    );
  );
);

keyboard.handle_non_midi_click(note_over);

n_knobs = 9 + 0.65 * glide;
radius = floor(0.0315 * 18 / (2 * n_knobs) * _gfx_w);
button_size = floor(0.004 * _gfx_w);
cx = floor(2 * radius);
cy = floor(2 * radius);
knob_spacing = floor(0.61 * 8 / (n_knobs - 1) * radius);


label_font();
legacy_gain = legacyToggle.processMouseToggle(cx + 1.1 * radius, cy + 1 * radius, button_size, button_size, legacy_gain, "Don't normalize gain to register being played\n\nNote that enabling this leads to low notes\nbeing a lot louder than high notes.", mouse_x, mouse_y, mouse_cap);

//voice_thievery = voiceStealingToggle.processMouseToggle(cx - 1.2 * radius, cy + 1 * radius, button_size, button_size, voice_thievery, "Enabling this mode makes the voice assignment much more aggressive.\nWhen enabled, a new note gets assigned to any released note. This can\nlead to notes being stolen (shortening their decay), but can result in far\nlower CPU use in TD mode.\n\nWhen disabled, note assignment prefers cycling through the notes.", mouse_x, mouse_y, mouse_cap);
many_notes = manyNotesToggle.processMouseToggle(cx - 1.2 * radius, cy + 1 * radius, button_size, button_size, many_notes, "Higher polyphony\n\nEnabling this mode bumps the number of voices from 5 to 12.\n\nNote that this comes at the cost of extra CPU use\neven when you don't use them.", mouse_x, mouse_y, mouse_cap);

glide = glideToggle.processMouseToggle(cx + 1.1 * radius, cy - 1.1 * radius, button_size, button_size, glide, "Monophonic mode with glide.", mouse_x, mouse_y, mouse_cap);
color_model = 1;

pass_through = passthroughToggle.processMouseToggle(cx - 1.2 * radius, cy - 1.1 * radius, button_size, button_size, pass_through, "Pass through MIDI.\n\nWhen enabled, this plugin will\nforward incoming MIDI notes.", mouse_x, mouse_y, mouse_cap);

function knob_glow(cx, cy, radius, value)
local(r_ix)
global(gfx_a)
instance()
(
  gfx_a = 0.5 * value;
  r_ix = 0;
  loop(10,
    gfx_circle(floor(cx), floor(cy), radius * 1.3 + r_ix);
    r_ix += 1;
    gfx_a *= 0.7;
  );
);

midi_recv *= 0.9;
colormodel(midi_recv);
knob_glow(cx, cy, radius, midi_recv);
playmode_knob.draw_knob(cx, cy, radius, "", 
"Play mode

Determines how the plugin responds to inputs. Dial 
for the different modes, or click with right mouse 
button to select mode from a menu.

Audio input fixes notes
  Received audio and transforms it according to the
  notes set on the keyboard at the bottom.
Audio input with MIDI notes
  Receives audio and MIDI input. Transforms the input
  audio with the MIDI notes played. Note that envelopes
  can optionally be enabled on the right (below the 
  models)
Spike impulse with MIDI notes
  Plays spikes through the resonator on MIDI notes.
  This allows you to play the plugin like a MIDI
  instrument.
Noise impulse with MIDI notes
  Plays spikes through the resonator on MIDI notes.
  This allows you to play the plugin like a MIDI
  instrument.
Constant noise with MIDI notes
  Plays noise through the resonator on MIDI notes.
  As a result, this plays a continuous note until 
  released.
Sample based impulse
  Allows dragging samples for use as impulse 
  response that drives the resonator. Each time a 
  MIDI note comes in one sample is played. If 
  multiple samples are added, they are used in a 
  round robin fashion.
", 1, 1);
playmode_knob.gfx_draw_icon(8 + floor(play_mode), 1);

playmode_knob.over ? (
  ((mouse_cap & 2) == 2) && (last_cap == 0) ? (
    menu_selection = gfx_showmenu(
    sprintf(10, "%sAudio input fixed notes|%sAudio input with MIDI notes|%sSpike impulse with MIDI notes|%sNoise impulse with MIDI notes|%sContinuous notes MIDI|%sSample based impulse|>Pitch bend|%s00|%s01|%s02|%s03|%s04|%s05|%s06|%s07|%s08|%s09|%s10|%s11|%s12",
    (play_mode >= 0) && (play_mode < 1) ? "!" : "",
    (play_mode >= 1) && (play_mode < 2) ? "!" : "",
    (play_mode >= 2) && (play_mode < 3) ? "!" : "",
    (play_mode >= 3) && (play_mode < 4) ? "!" : "",
    (play_mode >= 4) && (play_mode < 5) ? "!" : "",
    (play_mode >= 5) && (play_mode < 6) ? "!" : "",
    (pitchbend_range == 0) ? "!" : "",
    (pitchbend_range == 1) ? "!" : "",
    (pitchbend_range == 2) ? "!" : "",
    (pitchbend_range == 3) ? "!" : "",
    (pitchbend_range == 4) ? "!" : "",
    (pitchbend_range == 5) ? "!" : "",
    (pitchbend_range == 6) ? "!" : "",
    (pitchbend_range == 7) ? "!" : "",
    (pitchbend_range == 8) ? "!" : "",
    (pitchbend_range == 9) ? "!" : "",
    (pitchbend_range == 10) ? "!" : "",
    (pitchbend_range == 11) ? "!" : "",
    (pitchbend_range == 12) ? "!" : ""
    )
    );
    menu_selection > 0 ? (
      menu_selection < 6 ? (
        play_mode = menu_selection - 1;
        menu_selection = 0;
      ) : (
        pitchbend_range = menu_selection - 7;
      );
    );
  );
);

glide ? (
  cx += 2 * radius + knob_spacing;
  glide_knob.draw_knob(cx, cy, radius, "", "Glide\n\nGlide duration", 1, 1);
  glide_knob.gfx_draw_icon(20, 1);
);

cx += 2 * radius + knob_spacing;
brightness_knob.draw_knob(cx, cy, radius, "", 
"Brightness

How bright should the impulse be that is 
played through the resonator. Note that 
linking this to the velocity is generally 
a good idea to get an expressive sound.

You can do this by clicking the [velocity]
button on the lower right.
", 1, play_mode > 1.9999);
brightness_knob.gfx_draw_icon(7, play_mode > 1.9999);
cx += 2 * radius + knob_spacing;
custom_partials.amp.over && (model == 11) ? (
  knob_glow(cx, cy, radius, 1.5 * custom_partials.amp.over * abs(sin(time_precise())));
);
position_knob.draw_knob(cx, cy, radius, "", "Relative Position", 1, 1);
position_knob.gfx_draw_icon(0, 1);
cx += 2 * radius + knob_spacing;
damp_knob.draw_knob(cx, cy, radius, "", "Frequency Independent Damping", 1, 1);
damp_knob.gfx_draw_icon(1, 1);
cx += 2 * radius + knob_spacing;
custom_partials.decay.over && (model == 11) ? (
  knob_glow(cx, cy, radius, custom_partials.decay.over * 1.5 * abs(sin(time_precise())));
);
freq_damp_knob.draw_knob(cx, cy, radius, "", "Frequency Dependent Damping", 1, 1);
freq_damp_knob.gfx_draw_icon(2, 1);
cx += 2 * radius + knob_spacing;
((custom_partials.rfreq.over || custom_partials.afreq.over) && (model == 11)) ? (
  knob_glow(cx, cy, radius, 1.5 * (custom_partials.rfreq.over || custom_partials.afreq.over) * abs(sin(time_precise())));
);
inharmonic_knob.draw_knob(cx, cy, radius, "", "Inharmonicity", 1, 1);
inharmonic_knob.gfx_draw_icon(3, 1);
cx += 2 * radius + knob_spacing;
stereo = stereoToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, stereo, "Stereoize the output.", mouse_x, mouse_y, mouse_cap);
stiffness_exp_knob.draw_knob(cx, cy, radius, "", "Input Non-Linearity", 1, 1);
stiffness_exp_knob.gfx_draw_icon(5, 1);
cx += 2 * radius + knob_spacing;
stft_selection = 1 - stftToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, 1 - stft_selection, "Time domain mode\n\nTime domain mode allows using feedback but\nrequires significantly more CPU (especially\nwhen using a large number of partials).\n\nIn addition, it runs the risk of instability, so\nwhile it can be used to obtain creative effects\nit's not really recommended for live use.", mouse_x, mouse_y, mouse_cap);
last_stft = stft_selection;

bp_resonator_mode = resonatorModeToggle.processMouseToggle(cx + 0.95 * radius, cy - 1.1 * radius, button_size, button_size, bp_resonator_mode, "Bandpass resonator\n\nBy default the resonator is a lowpass filter.\nEnabling this makes it a bandpass filter.\nThis leads to more stability, but a thinner\nless feedback prone sound.", mouse_x, mouse_y, mouse_cap);

stft_selection ? (
  modulation2_knob.draw_knob(cx, cy, radius, "", "High frequency unison\n\nIncreasing this adds extra partials close to the\npartials of the sound. This creates a unison-like\nsound.", 1, stft_selection);
  modulation2_knob.gfx_draw_icon(26, stft_selection);
  cx += 2 * radius + knob_spacing;
  
  modulation_knob.draw_knob(cx, cy, radius, "", "Partial fluctuation\n\nIncreasing this adds extra partials close to the\npartials of the sound. This creates a chorus-like\nsound.", 1, stft_selection);
  modulation_knob.gfx_draw_icon(25, stft_selection);
) : (
  force_fb.draw_knob(cx, cy, radius, "", "Feedback Level", 1, 1 - stft_selection);
  force_fb.gfx_draw_icon(6, 1 - stft_selection);
  cx += 2 * radius + knob_spacing;

  max_partial = max(string5.used_partials, max(string4.used_partials, max(string3.used_partials, max(string2.used_partials, string1.used_parials))));
  partials.textbox_control(cx + 0.9 * radius, cy - 1.2 * radius, 12, 1.0 - stft_selection, sprintf(22, 
  "Number of partials to use.
  
  More leads to more high frequencies but higher CPU use.
  Low notes tend to require more partials. The currently 
  highest requested count is: %d
  ", max_partial), 16);
  partials.over ? (
    (mouse_cap & 2 == 2) ? (
      menu_selection = gfx_showmenu("16|32|48|64");
    );
    menu_selection ? (
      partials = 16 * menu_selection;
    );
  );

  stiffness_knob.draw_knob(cx, cy, radius, "", "Stiffness (tends to make things louder)", 1, 1 - stft_selection);
  stiffness_knob.gfx_draw_icon(4, 1 - stft_selection);
);
cx += 2 * radius + knob_spacing;

choice_x = cx - radius;

choice_button1.draw_choice(0, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Metal string");
choice_button1.draw_model_icon();
choice_button2.draw_choice(1, cx - radius, cy, radius, radius, 1, "Tube");
choice_button2.draw_model_icon();
cx += radius + 4;

choice_button3.draw_choice(2, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beating");
choice_button3.draw_model_icon();
choice_button4.draw_choice(3, cx - radius, cy, radius, radius, 1, "Beam (both ends open)");
choice_button4.draw_model_icon();
cx += radius + 4;

choice_button5.draw_choice(4, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Beam (one end clamped)");
choice_button5.draw_model_icon();
choice_button6.draw_choice(5, cx - radius, cy, radius, radius, 1, "Membrane");
choice_button6.draw_model_icon();
cx += radius + 4;

choice_button7.draw_choice(6, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Marimba");
choice_button7.draw_model_icon();
choice_button8.draw_choice(7, cx - radius, cy, radius, radius, 1, "Pan");
choice_button8.draw_model_icon();
cx += radius + 4;

choice_button9.draw_choice(8, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Male vowels");
choice_button9.draw_model_icon();
choice_button10.draw_choice(9, cx - radius, cy, radius, radius, 1, "Female vowels");
choice_button10.draw_model_icon();
cx += radius + 4;

choice_button11.draw_choice(11, cx - radius, cy - 1.1 * radius, radius, radius, 1, "Custom\n\nCustom model that allows customization\nof two spectra. Interpolation between\nthese spectra is then controlled with\nthe macro controls.");
choice_button11.draw_model_icon();
choice_button12.draw_choice(12, cx - radius, cy, radius, radius, 1, "Custom\n\nCustom model that provides only a single\nspectrum.\n\nThe macro controls then retain the same\nfunction as they did for the built-in spectra.");
choice_button12.draw_model_icon();

final_gfx_x = cx;

bins = 100;

/*
gfx_set(1, 1, 1, 1);
ptr = vowel;
x = 0;
init_vowels(vowel);
loop(64100,
  gfx_circle(0.013 * x, 0.5 * gfx_h - 15 * log10(ptr[]), 1);
  x += 1;
  ptr += 1;
);
*/


function draw_collapse_rect(x, y, w, h, label)
local(over)
global(gfx_a, mouse_x, mouse_y, mouse_cap, last_cap, hinter.sethint)
(
  over = (mouse_x < (x + w)) && (mouse_x > x) && (mouse_y < (y + h)) && (mouse_y > y);
  over ? hinter.sethint(label);
  
  gfx_a = 0.5 + 0.5 * over;
  gfx_rect(x, y, w, h);
  
  over && (mouse_cap == 1) && (last_cap == 0);
);

gfx_x = 0;
gfx_y = 0;
function draw_logo(logomem, rle_mem, ys, x, y)
global(gfx_a)
local(xx, yy, offset, line, ptr, n_iter, current, count)
instance(s, i)
(
  line = 0;
  s += 1;
  colormodel(0);
  loop(230,
    xx = x + line * ys;
    offset = logomem[line];
    ptr = rle_mem + offset;
    n_iter = 0;
    yy = y;
    while((ptr[] != - 1) && (n_iter < 20)) (
      current = ptr[]; ptr += 1;
      (current > -1) ? (
        count = ptr[]; ptr += 1;
        current ? (
          gfx_a *= 0.03;
          gfx_circle(xx, yy, 3);
          gfx_circle(xx, yy, 5);
        
          i = sin(0.01 * line - 0.03 * s);
          i = i > 0 ? i : 0;
          gfx_a = 0.25 + 0.75 * pow(i, 700);
          gfx_line(xx, yy, xx, yy + ys * count, 1);
        );
        yy += ys * count;
      );
      n_iter += 1;
    );
    line += 1;
  );
);

yy = 0.02 * _gfx_h + _gfx_h * 0.9;
//logo.draw_logo(logomem, rle_mem, 0.45, gfx_w - 110, gfx_h - 22);
logo.draw_logo(logomem, rle_mem, 0.45, 6, 6);

// Ctrl + Click the logo enters dev mode
((mouse_cap == 5) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  model = 10;
  settings_changed = 1;
);

// Ctrl + Shift + RMB the logo enters test mode
((mouse_cap == 6 + 8) && (last_cap == 0) && (mouse_x < 120) && (mouse_y < 25)) ? (
  test_mode = 1 - test_mode;
  settings_changed = 1;
);


current_char = gfx_getchar();
handle_gmem_imports();
handle_dropped_files();

/* Advanced Options */

radius = floor(radius);
ys = floor(3.6 * radius);
element_height = radius;

midi_input ? (
  
  /*colormodel(use_envelopes);
  draw_collapse_rect(
    floor(choice_x), floor(3 * radius + 0.5 * button_size) + use_envelopes * floor(2 * radius) + use_envelopes * 1.5 * button_size, 
    floor((radius + 4) * 6 - 4), button_size,
    use_envelopes ? 
      "Disable envelope."
    : "Apply an envelope to the input and output of each string."
  ) ? (use_envelopes = 1 - use_envelopes);*/
  
  use_envelopes
);

(model != 11) && (model != 12) ? (
  gfx_string.draw_stft(0.02 * _gfx_w, 0.02 * _gfx_h, _gfx_w * 0.93, _gfx_h * 0.9);
  right = 0.95 * _gfx_w;
);

advanced_controls = 1;
advanced_controls ? (
  loop(2,
    gfx_x = 0;
    gfx_y = ys;
    gfx_blurto(gfx_w, ys + radius * 2.1);
  );
  
  sample_ws = floor(radius);
  sample_hs = floor(radius);
  xs = floor(radius);
  
  waves_enabled = play_mode > 5;
  
  draw_wavebox(xs, ys, sample_ws, sample_hs, 0, samplelocs[0], waves_enabled);
  process_pad(xs, ys, sample_ws, sample_hs, 0, samplelocs[0]);
  
  draw_wavebox(xs, ys + radius, sample_ws, sample_hs, 2, samplelocs[2], waves_enabled);
  process_pad(xs, ys + radius, sample_ws, sample_hs, 2, samplelocs[2]);
  
  xs += radius;
  draw_wavebox(xs, ys, sample_ws, sample_hs, 1, samplelocs[1], waves_enabled);
  process_pad(xs, ys, sample_ws, sample_hs, 1, samplelocs[1]);
  
  draw_wavebox(xs, ys + radius, sample_ws, sample_hs, 3, samplelocs[3], waves_enabled);
  process_pad(xs, ys + radius, sample_ws, sample_hs, 3, samplelocs[3]);
    
  xs += floor(radius + knob_spacing;);
  
  /* Big waveform area */
  close_up.draw_sample_big(xs, ys, 4 * radius + knob_spacing, 2 * radius, waves_enabled);
  
  cy = ys + radius;
  cx = floor(2 * radius) + (2 * radius + knob_spacing) * 3;
   
  spin_depth_knob.draw_knob(cx, cy, radius, "", 
  "Spin depth
  
  Controls how much of a spinning effect should
  be applied.", 1, 1);
  spin_depth_knob.gfx_draw_icon(21, 1);
  
  cx += 2 * radius + knob_spacing;
  
  spin_freq_knob.draw_knob(cx, cy, radius, "", 
  "Spin frequency
  
  Controls how fast the source should spin.", 1, 1);
  spin_freq_knob.gfx_draw_icon(22, 1);
  cx += 2 * radius + knob_spacing;
  
  filter_cutoff_knob.draw_knob(cx, cy, radius, "", "Filter cutoff.", 1, enable_filter);
  filter_cutoff_knob.gfx_draw_icon(23, enable_filter);
  enable_filter = filterToggle.processMouseToggle(cx - 1.1 * radius, cy - 1.1 * radius, button_size, button_size, enable_filter, "Enable filter.", mouse_x, mouse_y, mouse_cap);  
  
  cx += 2 * radius + knob_spacing;
  
  filter_envelope_knob.draw_knob(cx, cy, radius, "", "Filter Envelope.", 1, use_filt_envelopes && enable_filter);
  filter_envelope_knob.gfx_draw_icon(24, use_filt_envelopes && enable_filter);
  cx += radius + knob_spacing;
  
  env_width = (final_gfx_x - cx - knob_spacing) * 0.5;
  env2.draw_envelope(cx, ys, env_width, floor(2 * radius), use_filt_envelopes && enable_filter);
  enable_filter ? (
    use_filt_envelopes = filterEnvelopeToggle.processMouseToggle(cx + env_width - button_size * 3, ys + 0.25 * radius, button_size, button_size, use_filt_envelopes, "Apply filter envelope.\n\nNote that in FD mode, only a single envelope\nis used for all strings while in time domain mode\neach string gets its own.", mouse_x, mouse_y, mouse_cap);  
  );
  
  cx += env_width + knob_spacing;
  env.draw_envelope(cx, ys, env_width, floor(2 * radius), use_envelopes);
  use_envelopes = envelopeToggle.processMouseToggle(cx + env_width - button_size * 3, ys + 0.25 * radius, button_size, button_size, use_envelopes, "Apply output envelope.", mouse_x, mouse_y, mouse_cap);
);

updated_loop ? (
  /*preview_channel.channel_update_loop();
  chan1.channel_update_loop();
  chan2.channel_update_loop();
  chan3.channel_update_loop();
  chan4.channel_update_loop();

  (!settings1.retrigger && !chan1.playing) ? chan1.start_sample(0, pitch1);
  (!settings2.retrigger && !chan1.playing) ? chan2.start_sample(1, pitch2);
  (!settings3.retrigger && !chan1.playing) ? chan3.start_sample(2, pitch3);
  (!settings4.retrigger && !chan1.playing) ? chan4.start_sample(3, pitch4);*/
  updated_loop = 0;
);


((model == 11) || (model == 12)) ? (
  right = custom_partials.draw_custom_partial_ui(0.02 * _gfx_w, cy + 1.5 * radius, 0.96 * _gfx_w, 0.935 * _gfx_h - (cy + 1.5 * radius) - 5, custom_partial_mem, MAX_CUSTOM_PARTIALS, partials_used, model==11);
);

handle_dropped_files_microtuning(tuning_memory);
sample_data_gfx_finalize();

gfx_x = 115; gfx_y = 3;
colormodel(0.4);
gfx_setfont(4, "Arial", 10 * max(1,scaling));
gfx_printf("v0.67 ALPHA (Warning: this plugin is not production ready and is still actively being developed)");

(model == 10) ? (
  colormodel(0.0);
  gfx_a = 0.3 * abs(sin(time_precise()));
  gfx_setfont(6, "Arial", 180);
  gfx_measurestr("DEV MODE", gw, gh);
  gfx_x = (_gfx_w - gw) / 2; gfx_y = (_gfx_h - gh) / 2;
  gfx_printf("DEV MODE")
);

gfx_setfont(4, "Arial", 10 * max(1,scaling));
hinter.drawhint();
newtime = time_precise();
delta_time = newtime - ctime;
ctime = newtime;

lx = mouse_x;
ly = mouse_y;
handle_mouse_sample_handler();
last_cap = mouse_cap;
mouse_cap == 0 ? captured = 0;

/*
gfx_x = 0;
gfx_y = 0;
gfx_set(1, 1, 1, 1);
fff = midi.note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 30;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_mem;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 60;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_vel;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);

gfx_x = 0;
gfx_y = 90;
gfx_set(1, 1, 1, 1);
fff = midi.active_note_state;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);
*/

/*
gfx_x = 0;
gfx_y = 90;
gfx_set(1, 1, 1, 1);
fff = midi.sustain_history;
loop(30,
  gfx_printf("%f  ", fff[]);
  fff += 1;
);
*/

loaded_sample = 0;

/*
gfx_x = gfx_y = 0;ix = 0;
loop(128,
  gfx_printf("%f ", tuning_memory[ix]);
  ix += 1;
);
*/

