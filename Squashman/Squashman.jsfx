desc:Squashman (NOT READY FOR USE)
tags: multiband saturation plugin (WORK IN PROGRESS)
version: 0.03
author: Joep Vanlier
changelog: + Did work on gain control via GUI.
license: MIT

Uses technique from: Parker et al, "REDUCING THE ALIASING OF NONLINEAR WAVESHAPING USING CONTINUOUS-TIME CONVOLUTION",
Proceedings of the 19th International Conference on Digital Audio Effects (DAFx-16), Brno, Czech Republic, September 5â€“9, 2016
I have only implemented the rect version, since the linear one depends on Li2 and LUTs aren't so fast in JSFX.

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:Cuts=1<0,4,1>Cuts
slider2:Freq1=0.5<0,1,.0001>-Frequency 1
slider3:Freq2=0.5<0,1,.0001>-Frequency 2
slider4:Freq3=0.5<0,1,.0001>-Frequency 3
slider5:Freq4=0.5<0,1,.0001>-Frequency 4

slider10:Drive1=0<-40,60,1>-Drive 1 (dB)
slider11:Drive2=0<-40,60,1>-Drive 2 (dB)
slider12:Drive3=0<-40,60,1>-Drive 3 (dB)
slider13:Drive4=0<-40,60,1>-Drive 4 (dB)
slider14:Drive5=0<-40,60,1>-Drive 5 (dB)

slider20:Ceil1=0<-26,0,1>-Ceiling 1 (dB)
slider21:Ceil2=0<-26,0,1>-Ceiling 2 (dB)
slider22:Ceil3=0<-26,0,1>-Ceiling 3 (dB)
slider23:Ceil4=0<-26,0,1>-Ceiling 4 (dB)
slider24:Ceil5=0<-26,0,1>-Ceiling 5 (dB)

slider63:2<0,1,1>Oversampling
slider64:0<0,1,1>Fix DC?

@init 
driveMax = 60;
driveMin = -40;
driveRange = driveMax - driveMin;

function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );

function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 
  
function calcFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, slope, yshift)
  local(buf1, buf2, buf3, yOut, i, prec, ty)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

function calcIncrementalFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, mxpos, lastpeak)
  local(mx, buf1, buf2, buf3, yOut, i, ty, buf4, buf5, mf, c, x0, y1, y2, y3, mxtmp, sum, N_use, peak, tpeak)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize/2 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize/2 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
  );

function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

function drawGrid()  
  global(   fftSize, srate,
            grid_color_r, grid_color_g, grid_color_b, grid_color_a, 
            backface_color_r, backface_color_g, backface_color_b, backface_color_a )
  instance(x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset )
  local(xx, i, wsc, N)
  (    
    i = 0;
    
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);

    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    
    i = 0;
    wsc = w/log(1+fftSize*0.5-hzoffset);
    loop(21,
      xx = x + log(1+i*fftSize/srate-hzoffset)*wsc;
      gfx_line(xx, y, xx, y+h);
      i < 10 ? i += 2 :
      i < 100 ? i += 20 :
      i < 1000 ? i += 200 :
      i < 10000 ? i += 2000 :
      i < 100000 ? i += 20000;
    );
    
    N = 8;
    xx = y;
    loop(N,
      xx += h/8;
      gfx_line(x, xx, x+w, xx);
    );
  );
  
function drawLine(x1, y1, x2, y2)
  local(dx, dy, x, smooth)
  global(gfx_x, gfx_y)
  instance()
  (
    smooth = 1;
    x1 = floor(x1);
    x2 = floor(x2);
    gfx_x=x1;
    gfx_y=y1;
    x2 = floor(x2);
    y2 = floor(y2);
    
    smooth ? (
      (x2 - x1) > 4 ? (
        dx = 1.0/(x2-x1);
        dy = (y2 - y1)*6*dx;
        x = 0;
        loop(x2-x1,
          x2 = x1 + 1;
          y2 = y1 + dy * ( x - x*x );
          
          gfx_line(x1, y1-1, x2, y2-1, 1);
          gfx_lineto(x2,y2,1);
          x1 = x2;
          y1 = y2;
          x = x + dx;
        );
      ) : (
        gfx_line(x1, y1-1, x2, y2-1, 1);
        gfx_lineto(x2,y2,1);
      );
    ) : (
      gfx_line(x1, y1-1, x2, y2-1, 1);
      gfx_lineto(x2,y2,1); 
    );
  );

bandClickRange = 10;
overRange = 10;

function isOver(mx, my)
  instance(x, y, w, h)
  global(overRange)
  local()
  (
    ( ( mx >= (x-overRange) ) && ( mx <= (x+w+overRange) ) && ( my >= (y-overRange) ) && ( my <= (y+h+overRange) ) ) ? 1 : 0;
  );

function fftWindow_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, lx, ly, lcap, cap, thisUI, htime, hint,
           x_over, dragging, hzoffset
           x1, x2, x3, x4, x5,
           v1, v2, v3, v4, v5,
           h1, h2, h3, h4, h5, )
  global(dnoisefloor_freq, dsteps_fft, mouse_wheel, lastUI, fftSize,
         bandClickRange, cuts,
         Freq1, Freq2, Freq3, Freq4,
         Drive1, Drive2, Drive3, Drive4, Drive5,
         driveMin, driveMax )
  local(dx, dy, over,
        F1, F2, F3, F4,
        hfft, lmin, wsc)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    x_over = -1;
    
    ( cap == 3 && mouse_cap & 1 == 1 ) ? (
      dy = mouse_y - ly;
      
      dragging == 1 ? ( Drive1 -= 100*dy/h; Drive1 = max(min(Drive1, driveMax), driveMin); );
      dragging == 2 ? ( Drive2 -= 100*dy/h; Drive2 = max(min(Drive2, driveMax), driveMin); );
      dragging == 3 ? ( Drive3 -= 100*dy/h; Drive3 = max(min(Drive3, driveMax), driveMin); );
      dragging == 4 ? ( Drive4 -= 100*dy/h; Drive4 = max(min(Drive4, driveMax), driveMin); );
      dragging == 5 ? ( Drive5 -= 100*dy/h; Drive5 = max(min(Drive5, driveMax), driveMin); );
      
    ) : ( cap == 2 && mouse_cap & 1 == 1 ) ? (
      // Dragging a band frequency
      dx = mouse_x - lx;
      
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
      
      hfft = 0.5*fftSize;
      lmin = log(20/22050);
      wsc = w/log(1+fftSize*0.5-hzoffset);
      
      dragging == 1 ? ( 
        F1 = 1-log( (exp((x1 - x + dx)/wsc) + hzoffset)/hfft )/lmin;
        slider_automate( Freq1 = F1 );
        slider_automate( Freq2 = (F2 - F1) / (1-F1) );        
      );
      dragging == 2 ? ( 
        F2 = 1-log( (exp((x2 - x + dx)/wsc) + hzoffset)/hfft )/lmin; 
        slider_automate( Freq2 = (F2 - Freq1) / (1-Freq1) );
        slider_automate( Freq3 = (F3 - F2) / (1-F2) );
      );
      dragging == 3 ? ( 
        F3 = 1-log( (exp((x3 - x + dx)/wsc) + hzoffset)/hfft )/lmin; 
        slider_automate( Freq3 = (F3 - F2) / (1-F2) );
        slider_automate( Freq4 = (F4 - F3) / (1-F3) );
      );
      dragging == 4 ? ( 
        F4 = 1-log( (exp((x4 - x + dx)/wsc) + hzoffset)/hfft )/lmin; 
        slider_automate( Freq4 = (F4 - F3) / (1-F3) );
      );

    ) : ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dnoisefloor_freq -= .5*(mouse_y-ly);
      dnoisefloor_freq > 35 ? dnoisefloor_freq = 35;
      dnoisefloor_freq < -15 ? dnoisefloor_freq = -15;
    ) : ( 
      // Not already capped
      ( v1.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        v1.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 2; dragging = 1; )
      ) : ( v2.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        v2.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 2; dragging = 2; )
      ) : ( v3.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        v3.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 2; dragging = 3; )
      ) : ( v4.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        v4.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 2; dragging = 4; )
      ) : ( v5.isOver(mouse_x, mouse_y) ) && ( cuts > 4 ) ? (
        v5.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 2; dragging = 5; )
      ) : ( h1.isOver(mouse_x, mouse_y) ) ? (
        h1.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 3; dragging = 1; )
      ) : ( h2.isOver(mouse_x, mouse_y) ) && ( cuts > 0 ) ? (
        h2.over = 1;      
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 3; dragging = 2; )
      ) : ( h3.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        h3.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 3; dragging = 3; )
      ) : ( h4.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        h4.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 3; dragging = 4; )
      ) : ( h5.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        h5.over = 1;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 ) ? ( cap = 3; dragging = 5; )
      ) : (
        cap = 0;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
          cap = 1;
        );
      );
    );
    
    mouse_wheel > 0 && over ? lastUI = thisUI;
    
    abs(floor(mouse_wheel/240)) > 0 && over ?
    (
      dsteps_fft += floor(mouse_wheel/240);
      dsteps_fft > 8 ? dsteps_fft = 8;
      dsteps_fft < -4 ? dsteps_fft = -4;
      mouse_wheel = 0;
    );
    
    lx = mouse_x;
    ly = mouse_y;
    lcap = mouse_cap;
    
    over
  );

function drawFFT(fill, oversamplingFactor, r, g, b, a)
  global(retina_scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate, gfx_mode, dsteps_fft )
  instance(hstep, x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset, highlighted)
  local(copyval, stepsize, buf, i, ixsc, txl, tx, ty, wsc, fill, tx0, lx0, lx, ly, ty2, ly2, fill_slast, fill_slmin, cum, cumelem)
  (
    this.calcFFT();
 
    cum = -10000000;
    cumelem = 0;
    i = 0;
    ixsc = 0;
    wsc = w/log(1+fftsize*0.5-hzoffset);
    fill_slmin = y;

    buf = fftLoc + fftsize*0.5 - 2;
    stepsize = floor((4+dsteps_fft)*retina_scaling);
    copyval = buf[];
    loop( stepsize*200,
      (buf+=1)[] = copyval;
    );
     
    gfx_r = r;
    gfx_g = g;
    gfx_b = b;
    gfx_a = a;
 
    hstep = .5 * stepsize;
    buf = fftLoc;
    txl = x;
    lx = x;
    ly = y - max(buf[], -floorLevel)*h / floorLevel;
    buf += 1;
    loop(fftsize*0.5+stepsize*200,
      tx = floor(x + log(1.0+ixsc-hzoffset)*wsc);
      cum = max(cum, buf[]);
      cumelem += 1;
      
      ( (tx != txl) && (tx-txl > stepsize) && tx > x && i && ( tx < (x+w+stepsize) ) ) ? // 
      ( 
        ty = y - max(cum, -floorLevel)*h / floorLevel;
        //ty = y - log(cum)+100;
        txl = floor(tx);
        
        tx = min(tx, x+w);
        (fill) ? 
        (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0 ? 
          (
            gfx_triangle(lx0-hstep,max(y+h,ly),lx0-hstep,ly,tx0-1-hstep,ty,tx0-1-hstep,max(y+h,ty));
          ) : (
            tx0 > fill_slast ? 
            (
              fill_slast < h ? gfx_line(fill_slast,h,fill_slast,fill_slmin);
              fill_slmin=h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          
          fill_slast=tx0;        
        );
        
        (fill==0) ? (
          drawLine(lx-hstep, ly, tx-hstep, ty);
        );
        
        lx=tx; ly=ty; ly2=ty2; cum = -1000000; cumelem = 0;
      );
      
      buf+=1; i+=1; ixsc+=oversamplingFactor;
    );
  );
  
function drawLineFFT(peakLocation)
  global(retina_scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate)
  instance(x, y, w, h, hzoffset)
  local(wsc, tx, base, i)
  (
    wsc = w/log(1+fftSize*0.5-hzoffset);
    base = fftSize*peakLocation;
    tx = floor(x + log(1.0+base-hzoffset)*wsc);
    drawLine(tx, y, tx, y+h);
  );
  
function f_trafo(freq)
  local()
  global()
  instance()
  (
    exp( (1-freq) * log(20/22050) )
  );  
  
function updateBands()
  global(Freq1,   Freq2,  Freq3,  Freq4,
         Ceil1,   Ceil2,  Ceil3,  Ceil4,
         Drive1,  Drive2, Drive3, Drive4, Drive5
         fftSize, driveRange, driveMax)
  instance(x, y, w, h, hzoffset,
           x1, x2, x3, x4, x5, /* Frequencies */
           y1, y2, y3, y4, y5  /* Drives      */
           )
  local(F1, F2, F3, F4, F5, wsc, hfft, lmin, irange, dmax)
  (
    F1 = Freq1;
    F2 = Freq1  + Freq2 * (1 - Freq1);
    F3 = F2     + Freq3 * (1 - F2);
    F4 = F3     + Freq4 * (1 - F3);
    
    hfft = 0.5*fftSize;
    lmin = log(20/22050);
    
    wsc = w/log(1+fftSize*0.5-hzoffset);
    x1 = ( x + log( hfft * exp( (1-F1) * lmin ) - hzoffset ) * wsc );
    x2 = ( x + log( hfft * exp( (1-F2) * lmin ) - hzoffset ) * wsc );
    x3 = ( x + log( hfft * exp( (1-F3) * lmin ) - hzoffset ) * wsc );
    x4 = ( x + log( hfft * exp( (1-F4) * lmin ) - hzoffset ) * wsc );
    x5 = ( x + log( hfft * exp( lmin ) - hzoffset ) * wsc );
       
    iRange = 1/driveRange;
    dmax = iRange * driveMax;
    
    y1 = y+h*(dmax-iRange*Drive1);
    y2 = y+h*(dmax-iRange*Drive2);
    y3 = y+h*(dmax-iRange*Drive3);
    y4 = y+h*(dmax-iRange*Drive4);
    y5 = y+h*(dmax-iRange*Drive5);
  );

function fancyLineV(x1, y1, x2, y2)
  local(dx)
  global()
  instance(x, y, w, h, over)
  (
    dx = 5; 
    
    x = x1 - .5*dx;
    y = y1;
    w = dx;
    h = y2-y1;
  
    gfx_set(.2, .2, .2, 1);
    gfx_rect(x, y, w, h);
    gfx_set(.5, .5, .5, 1);    
    dx = 3; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(.7, .7, .7, 1);
    dx = 2; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    
    over ? ( 
      gfx_set(1,1,1,.7);
      gfx_rect(x, y, w, h);
    );
    
    over = 0;
  );

function fancyLineH(x1, y1, x2, y2)
  local(dy)
  global()
  instance(x, y, w, h, over)
  (
    dy = 5;
    
    x = x1;
    y = y1 - .5*dy;
    w = x2-x1;
    h = dy;
  
    gfx_set(.2, .2, .2, 1);
    gfx_rect(x, y, w, h);
    gfx_set(.5, .5, .5, 1);    
    dy = 3; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(.7, .7, .7, 1);
    dy = 2; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    
    over ? ( 
      gfx_set(1,1,1,.7);
      gfx_rect(x, y, w, h);
    );
    
    over = 0;    
  );
  
function drawBands()
  global(Cuts)
  instance(x, y, w, h, 
           x1, x2, x3, x4, x5, // Band frequency screen positions
           y1, y2, y3, y4, y5, // Band drive positions
           v1, v2, v3, v4, v5, // Frequency handles
           h1, h2, h3, h4, h5, // Drive handles
           x_over)
  local()
  (
    //wsc = w/log(1+fftsize*0.5-hzoffset);
    //tx = floor(x + log(1.0+F1-hzoffset)*wsc);
    //hzoffset  = 20/srate;
    //tx = x+w*(Freq1-hzoffset);
    gfx_set(1,1,1,1);
    
    (Cuts > 0) ? (
      v1.fancyLineV(x1, y, x1, y+h);
    );
    (Cuts > 1) ? (
      v2.fancyLineV(x2, y, x2, y+h);
    );
    (Cuts > 2) ? (
      v3.fancyLineV(x3, y, x3, y+h);
    );
    (Cuts > 3) ? (
      v4.fancyLineV(x4, y, x4, y+h);
    );
    (Cuts > 4) ? (
      v5.fancyLineV(x5, y, x5, y+h);
    );
    
    gfx_rect(x_over-3, y, 5, h);
    
    ( Cuts == 0 ) ? (
       h1.fancyLineH(x, y1, x+w-2, y1);
    ) : ( Cuts == 1 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       h2.fancyLineH(x1, y2, x+w-2, y2);
    ) : ( Cuts == 2 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       h3.fancyLineH(x2, y3, x+w-2, y3);
    ) : ( Cuts == 3 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       h4.fancyLineH(x3, y4, x+w-2, y4);
    ) : ( Cuts == 4 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       h4.fancyLineH(x3, y4, x4-2, y4);
       h5.fancyLineH(x4, y5, x+w-2, y5);
    );
    
    //this.drawLineFFT(.5*f_trafo(F1));
    //this.drawLineFFT(.5*f_trafo(F2));
    //this.drawLineFFT(.5*f_trafo(F3));
    //this.drawLineFFT(.5*f_trafo(F4));
    
  );  
  
function initSpectrum(memoryOffset, fftSize, srate)
  global(newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 20*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );

bpos=0;

// MEMORY LAYOUT
fftSize     = 2*8192;
bufferDist  = 65536;
audioBufIn  = 0;
audioBufOut = bufferDist;

// INITIALIZATION
spectrumIn.initSpectrum(audioBufIn, fftSize, srate);
spectrumOut.initSpectrum(audioBufOut, fftSize, srate);

@serialize
file_var(0,dnoisefloor_freq);
file_var(0,dsteps_fft);

file_var(0,solo1);
file_var(0,solo2);
file_var(0,solo3);
file_var(0,solo4);
file_var(0,solo5);
file_var(0,placeholder);
file_var(0,placeholder);

file_var(0,mute1);
file_var(0,mute2);
file_var(0,mute3);
file_var(0,mute4);
file_var(0,mute5);
file_var(0,placeholder);
file_var(0,placeholder);

@slider

@block
!mute1 ? play1 = 1;
!mute2 ? play2 = 1;
!mute3 ? play3 = 1;
!mute4 ? play4 = 1;
!mute5 ? play5 = 1;

( solo1 || solo2 || solo3 || solo4 || solo5 ) ? ( play1 = play2 = play3 = play4 = play5 = 0; );
solo1 ? play1 = 1;
solo2 ? play2 = 1;
solo3 ? play3 = 1;
solo4 ? play4 = 1;
solo5 ? play5 = 1;

@sample
  // Generate windowed sinc filter at memory location FIR
  // Inputs are:
  //    fir   - Memory location to store windowed sinc
  //    nt    - Number of taps
  //    bw    - Fractional bandwidth
  //     g    - Gain
  function sinc(fir, nt, bw, g)
    local(a, ys, yg, yw, i, pibw2, pifc2, pidnt2, hnt)
    global()
    (
      pibw2   = 2.0*$pi*bw;
      pidnt2  = 2.0*$pi/nt;
      hnt     = 0.5*nt;
      i       = 1;
          
      loop(nt-1,
        // Sinc width
        a  = (i - hnt) * pibw2;
          
        // Sinc
        ys = (a != 0) ? sin(a)/a : 1.0;
   
        // Window gain
        yg = g * (4.0 * bw);
          
        // Hamming window (could be replaced with Kaiser in the future)
        yw = 0.54 - 0.46 * cos(i * pidnt2);
           
        // Calc FIR coeffs
        fir[i-1] = yw * yg * ys;
        
        i += 1;
      );
    );
  
  // Generate sinc filters for a specific upsampling ratio
  //
  // Upsampling leads to a sample followed by N-1 zeroes. Hence 
  // to compute each subsample, we only need 1/Nth of the taps.
  // This is why we set up a specific filter for each subsample.
  // i.e. for N=4, you get something like f1*Zn + f5*Zn-1 + ...
  //
  // Inputs:
  //    N_in            - oversampling factor
  //    tapsPerFilter   - Taps per subfilter (should be 8 in this implementation)
  //    targetmem       - Location to store the coefficients
  //    tmp             - Working memory
  function updateSincFilter(N_in, tapsPerFilter, targetmem, tmp)
    local(nHist, iFilt, nTaps)
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N, delta)
    global()
    (
      N       = N_in;
      nHist   = tapsPerFilter;
      loc     = 0;
      coeffs  = targetmem;
      nTaps   = N*nHist;
      
      // Memory being set is conservatively large.
      memset(coeffs,0,10000);
      memset(tmp,0,10000);
      
      sinc(tmp, nTaps, .5/N, .5*N);
      
      // Divide sinc over the different filters
      iFilt = 0; // Filter idx for which subsample this filter is
      delta = 0; // Sample idx
      loop(nTaps,
        coeffs[delta + iFilt*100] = tmp[];
        iFilt += 1;
        iFilt == N ? ( iFilt = 0; delta += 1 );
        tmp += 1;
      );
    );
  
  // Generate downsample filter
  // Here, the full N*nHist tap filter has to be evaluated for every sample, 
  // but only every Nth sample has to be evaluated.
  function updateSincDownsampleFilter(N_in, nTaps_in, histmem, coeffmem)
    global()
    instance(hist, hend, hptr, coeffs, loc, N, delta, nTaps)
    local()
    (
      N       = N_in;
      hist    = histmem;
      coeffs  = coeffmem;
      nTaps   = nTaps_in;
      hptr    = hist;
      hend    = hist + nTaps;
      
      memset(coeffs,0,10000);
      sinc(coeffs, nTaps, .5/N, .5);
    );
    
  function advanceHist(sample)
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, nTaps)
    (
      hptr += 1;
      ( hptr == hend ) ? hptr = hist;
      hptr[] = sample;
    );
  
  function sincDownSample()
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, hm1, hptr2, out, cfptr)
    (
      hm1   = hist-1;
      hptr2 = hptr;
      cfptr = coeffs;
      out   = 0;
      
      loop(nTaps,
        out = out + hptr2[] * cfptr[];
        
        cfptr += 1;
        hptr2 -= 1;
        ( hptr2 == hm1 ) ? hptr2 = hend-1;
      );
      
      out
    );
  
  function resetSincDown()
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, hm1, hptr2)
    (
      hm1   = hist-1;
      hptr2 = hptr;
      
      loop(nTaps,
        hptr2[] = 0;
        
        hptr2 -= 1;
        ( hptr2 == hm1 ) ? hptr2 = hend-1;
      );
    );
  
  // Maintain input sample history. Hardcoded for speed.
  // Note h7 is omitted because for integer upsampling it is always zero!
  function advanceSinc(sample)
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt)
    (
      h6 = h5;
      h5 = h4;
      h4 = h3;
      h3 = h2;
      h2 = h1;
      h1 = h0;
      h0 = sample;
      loc = 0;
    );
  
  function resetSincUp()
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt)
    (
      h0 = h1 = h2 = h3 = h4 = h5 = h6 = 0;
    );
  
  // Note h7 is omitted because for integer upsampling it is always zero!
  function getSubSample()
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt, out)
    (
      filt = coeffs + loc;
  
      out =  filt[] * h0 + filt[1] * h1 + filt[2] * h2 + filt[3] * h3 + filt[4] * h4 + filt[5] * h5 + filt[6] * h6;
  
      loc += 100;
      out
    );

  function F0(x, em2x)
  local()
  global()
  instance()
  (
    x - log(2/(1 + em2x))
  );
  
  function tanh_prec(x, em2x)
  local() 
  global()
  instance()
  (
    (2/(1+em2x))-1
  );
  
  function tanh(x)
  local()
  global()
  instance()
  (
    (2/(1+exp(-2*x)))-1
  );
  
  function antialiased_tanh_rect(x)
  local(eps, em2x, F0_xn)
  global(slider4)
  instance(antialias, F0_xnm1, xnm1,diff)
  (
    354 < abs(x) ? (
      antialias = sign(x);
      x         = antialias * 354;
      F0_xn     = 354 - log(2);
    ) : (
      em2x      = exp(-2*x);
      F0_xn     = F0(x, em2x);
      diff      = ( x - xnm1 );
      eps       = 0.0000000001;
      antialias = (abs(diff) > eps) ? ( F0_xn - F0_xnm1 ) / diff : tanh(.5*(x+xnm1));
    );
    
    F0_xnm1   = F0_xn;
    xnm1      = x;

    antialias
  ); 

  function fix_dc(x)
  local()
  global()
  instance(DC_fixed, prev)
  (
    DC_fixed=0.999*DC_fixed + x - prev;
    prev=x;
    DC_fixed
  );

  function init_LR(freq)
    global(srate, slider54)
    local(g, res)
    instance(k, a1, a2, a3)
    (
      g = tan( .5 * $pi * exp( (1-freq) * log(20/22050) ) );
      k = 2;
      
      a1 = 1/(1+g*(g+k));
      a2 = g*a1;
      a3 = g*a2;
    ); 

  function init_LR2(freq)
    global(srate, slider54)
    local(g, res)
    instance(k, a1, a2, a3)
    (
      g = tan( .5 * $pi * exp( (1-freq) * log(20/22050) ) );
      k = sqrt(2); /* Note the different peak resonance because we're combining 2 SVFs into the Linkwitz-Riley structure */

      a1 = 1/(1+g*(g+k));
      a2 = g*a1;
      a3 = g*a2;
    ); 
  
  function reset_LR()
    global()
    local()
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq, k, a1, a2, a3)
    (
      ic1eq = ic2eq = 0;  
    );  

  function eval_LRLP(v0)
    global()
    local(v1, v2, v3)
    instance(ic3eq, ic4eq, k, a1, a2, a3)
    (
      v3 = v0 - ic4eq;
      v1 = a1 * ic3eq + a2 * v3;
      v2 = ic4eq + a2 * ic3eq + a3 * v3;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      
      v2
    ); 
 
  function eval_LRAP(v0)
    global()
    local(v1, v2, v3)
    instance(ic5eq, ic6eq, k, a1, a2, a3)
    (
      v3 = v0 - ic6eq;
      v1 = a1 * ic5eq + a2 * v3;
      v2 = ic6eq + a2 * ic5eq + a3 * v3;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;    
      
      v0 - 2*k*v1
    );    

  function eval_LR2(v0)
    global()
    local(v1, v2, v3, all)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;    
      
      all = v0 - 2 * k * v1;
 
      lp = this.eval_LRLP(v2); 
      hp = all - lp;
    );    

  function updateCoeffs()
  local()
  global(Cuts, Freq1, Freq2, Freq3, Freq4)
  instance( F1, F2, F3, F4
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            lcuts)
  (
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
  
      (cuts==1) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
      ) : (cuts==2) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
        LF2.init_LR2(F2);
        RF2.k  = LF2.k;
        RF2.a1 = LF2.a1;
        RF2.a2 = LF2.a2;
        RF2.a3 = LF2.a3;
        
        LA_F2.init_LR(F2);
        RA_F2.k  = LA_F2.k;
        RA_F2.a1 = LA_F2.a1;
        RA_F2.a2 = LA_F2.a2;
        RA_F2.a3 = LA_F2.a3;
      ) : (cuts == 3) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
        LF2.init_LR2(F2);
        RF2.k  = LF2.k;
        RF2.a1 = LF2.a1;
        RF2.a2 = LF2.a2;
        RF2.a3 = LF2.a3;
        LF3.init_LR2(F3);
        RF3.k  = LF3.k;
        RF3.a1 = LF3.a1;
        RF3.a2 = LF3.a2;
        RF3.a3 = LF3.a3;
        
        // All-passes for maintaining the phase relation between the bands
        LA_F2.init_LR(F2);
        LA_F3.init_LR(F3);
        
        RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
        RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
        RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
        RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
  
        RA_F2.k  = LA_F2.k;
        RA_F2.a1 = LA_F2.a1;
        RA_F2.a2 = LA_F2.a2;
        RA_F2.a3 = LA_F2.a3;
      ) : (cuts == 4) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
        LF2.init_LR2(F2);
        RF2.k  = LF2.k;
        RF2.a1 = LF2.a1;
        RF2.a2 = LF2.a2;
        RF2.a3 = LF2.a3;
        LF3.init_LR2(F3);
        RF3.k  = LF3.k;
        RF3.a1 = LF3.a1;
        RF3.a2 = LF3.a2;
        RF3.a3 = LF3.a3;
        LF4.init_LR2(F4);
        RF4.k  = LF4.k;
        RF4.a1 = LF4.a1;
        RF4.a2 = LF4.a2;
        RF4.a3 = LF4.a3;
        
        // All-passes for maintaining the phase relation between the bands
        LA_F2.init_LR(F2);
        LA_F3.init_LR(F3);
        LA_F4.init_LR(F4);
        
        RA_F4.k  = RA_F4_2.k  = RA_F4_3.k  = LA_F4_2.k  = LA_F4_3.k  = LA_F4.k;
        RA_F4.a1 = RA_F4_2.a1 = RA_F4_3.a1 = LA_F4_2.a1 = LA_F4_3.a1 = LA_F4.a1;
        RA_F4.a2 = RA_F4_2.a2 = RA_F4_3.a2 = LA_F4_2.a2 = LA_F4_3.a2 = LA_F4.a2;
        RA_F4.a3 = RA_F4_2.a3 = RA_F4_3.a3 = LA_F4_2.a3 = LA_F4_3.a3 = LA_F4.a3;
        
        RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
        RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
        RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
        RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
  
        RA_F2.k  = LA_F2.k;
        RA_F2.a1 = LA_F2.a1;
        RA_F2.a2 = LA_F2.a2;
        RA_F2.a3 = LA_F2.a3;
      );
  );
  
  function resetBands()
  local()
  global()
  instance( b1, b2, b3, b4 )
  (
    b1.r = b1.l = b2.r = b2.l = b3.r = b3.l = b4.r = b4.l = 0;
  );
  
  // Make sure the delay is the same on all bands (identical number of filters)
  function splitBands(sl, sr)
  local()
  global(Cuts)
  instance( LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            b1, b2, b3, b4, b5, lcuts )
  (
    ( lcuts != cuts ) ? (
      lcuts = cuts;
      this.resetBands();
    );
  
    (cuts==0) ? (
      b1.l = sl;
      b1.r = sr;
    ) : (cuts==1) ? (
      LF1.eval_LR2(sl);
      b1.l = LF1.lp;
      b2.l = LF1.hp;
      
      RF1.eval_LR2(sr);
      b1.r = RF1.lp;
      b2.r = RF1.hp;
    ) : (cuts==2) ? (
      LF1.eval_LR2(sl);
      b1.l   = LA_F2.eval_LRAP(LF1.lp);
      
      LF2.eval_LR2(LF1.hp);
      b2.l   = LF2.lp;
      b3.l   = LF2.hp;
      
      RF1.eval_LR2(sr);
      b1.r   = RA_F2.eval_LRAP(RF1.lp);
      
      RF2.eval_LR2(RF1.hp);
      b2.r   = RF2.lp;
      b3.r   = RF2.hp;
    ) : (cuts == 3) ? (
      LF1.eval_LR2(sl);
      b1.l   = LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp));
      
      LF2.eval_LR2(LF1.hp);
      b2.l   = LA_F3_2.eval_LRAP(LF2.lp);
      
      LF3.eval_LR2(LF2.hp);
      b3.l   = LF3.lp;
      b4.l   = LF3.hp;
      
      RF1.eval_LR2(sr);
      b1.r   = RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp));
      
      RF2.eval_LR2(RF1.hp);
      b2.r   = RA_F3_2.eval_LRAP(RF2.lp);
      
      RF3.eval_LR2(RF2.hp);
      b3.r   = RF3.lp;
      b4.r   = RF3.hp;
    ) : (cuts == 4) ? (
      LF1.eval_LR2(sl);
      b1.l   = LA_F4.eval_LRAP(LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp)));
      
      LF2.eval_LR2(LF1.hp);
      b2.l   = LA_F4_2.eval_LRAP(LA_F3_2.eval_LRAP(LF2.lp));
      
      LF3.eval_LR2(LF2.hp);
      b3.l   = LA_F4_3.eval_LRAP(LF3.lp);
      
      LF4.eval_LR2(LF3.hp);
      b4.l   = LF4.lp;
      b5.l   = LF4.hp;
      
      RF1.eval_LR2(sr);
      b1.r   = RA_F4.eval_LRAP(RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp)));
      
      RF2.eval_LR2(RF1.hp);
      b2.r   = RA_F4_2.eval_LRAP(RA_F3_2.eval_LRAP(RF2.lp));
      
      RF3.eval_LR2(RF2.hp);
      b3.r   = RA_F4_3.eval_LRAP(RF3.lp);
      
      RF4.eval_LR2(RF3.hp);
      b4.r   = RF4.lp;
      b5.r   = RF4.hp;
    );
  );
  
  function processBand(drive, inceil, play)
  global(antialiased_tanh_rect)
  instance(l, r)
  local(preamp, ceiling, inv_ceiling)
  (
    play ? (
      preamp      = 10^(drive/20);
      ceiling     = 10^(-inceil/20);
      inv_ceiling = 10^(inceil/20);
      
      l *= preamp;
      r *= preamp;
      l *= ceiling;
      r *= ceiling;
      
      l = this.ch0.antialiased_tanh_rect(l);
      r = this.ch1.antialiased_tanh_rect(r);
      //l = tanh(l);
      //r = tanh(r);
      
      l *= inv_ceiling;
      r *= inv_ceiling;
    ) : (
      l = 0;
      r = 0;
    );
  );
  
  function processBands()
  local(BW2)
  global( Drive1, Drive2, Drive3, Drive4, Drive5, 
          Ceil1,  Ceil2,  Ceil3,  Ceil4,  Ceil5,
          play1,  play2,  play3,  play4,  play5 )
  instance(b1, b2, b3, b4, b5, F1, F2, F3, F4, F5)
  (
    //F1, F2, F3, F4
    b1.processBand(Drive1, Ceil1, play1);
    b2.processBand(Drive2, Ceil2, play2);
    b3.processBand(Drive3, Ceil3, play3);
    b4.processBand(Drive4, Ceil4, play4);
    b5.processBand(Drive5, Ceil5, play5);
  );
  
  spectrumIn.feedSample(.5*(spl0+spl1));

  // Split signal into bands
  filterBank.updateCoeffs();
  filterBank.splitBands(spl0, spl1);
  filterBank.processBands();
  
  spl0 = filterBank.b1.l + filterBank.b2.l + filterBank.b3.l + filterBank.b4.l + filterBank.b5.l;
  spl1 = filterBank.b1.r + filterBank.b2.r + filterBank.b3.r + filterBank.b4.r + filterBank.b5.r;
  
  
  //spl0=spl1=filterBank.b2.l;
  //spl0 = spl1 = filterBank.b1.l;
  
  slider64 ? (
    spl0 = dc0.fix_dc(spl0);
    spl1 = dc1.fix_dc(spl1);
  );
  
  spectrumOut.feedSample(.5*(spl0+spl1));
  
@gfx 600 300
  function createGUI()
  (
    scaling   = gfx_ext_retina;
    spectrumX = 0;
    spectrumY = 0;
    spectrumW = gfx_w;
    spectrumH = gfx_h - 150 * (1+scaling);
    spectrumIn.setWindowLocation(spectrumX,  spectrumY, spectrumW, spectrumH);
    spectrumOut.setWindowLocation(spectrumX, spectrumY, spectrumW, spectrumH);
  );

  bg_color_r = 47/255;
  bg_color_g = 65/255;
  bg_color_b = 75/255;
  bg_color_a = 1;
  fft_out_r = .8;
  fft_out_g = .8;
  fft_out_b = .8;
  fft_out_a = 1.0;
  fft_in_r = .13;
  fft_in_g = .13;
  fft_in_b = .23;
  fft_in_a = .6;
  grid_color_r = .73;
  grid_color_g = .73;
  grid_color_b = .76;
  grid_color_a = .2;
  backface_color_r = .2;
  backface_color_g = .2;
  backface_color_b = .3;
  backface_color_a = .1;

  gfx_r=bg_color_r;
  gfx_g=bg_color_g;
  gfx_b=bg_color_b;
  gfx_a=bg_color_a;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w,spectrumH);
  gfx_gradrect(0, 0, gfx_w, spectrumH, gfx_r, gfx_g, gfx_b, gfx_a, .0001, .0001, .0001, .0001, -.0001, -.0001, .0001, .0001);
  gfx_gradrect(0, 0, gfx_w, spectrumH, gfx_r, gfx_g, gfx_b, .3, .0001, .0001, .0006, .0001, -.0001, -.0001, .0001, .0001);
  gfx_gradrect(0, 0, gfx_w, spectrumH, 0, 0, 0, 0, 0, -.001, -.0006, .0001, -.0001, -.0001, .001, -.00008);
  
  createGUI();
  
  gfx_r = 1;
  spectrumIn.drawGrid();
  spectrumIn.floorLevel = 25 + dnoisefloor_freq;
  spectrumOut.floorLevel = 25 + dnoisefloor_freq;
  spectrumIn.drawFFT(1, 1, fft_in_r, fft_in_g, fft_in_b, fft_in_a);
  spectrumOut.drawFFT(0, 1, fft_out_r, fft_out_g, fft_out_b, fft_out_a);
  spectrumIn.fftWindow_processMouse(mouse_x, mouse_y, mouse_cap);
  spectrumIn.updateBands();
  spectrumIn.drawBands();
  
  gfx_x = gfx_y = 30;
  gfx_setfont(1,"ARIAL",30);
  gfx_printf("THIS PLUGIN IS *NOT* READY FOR USE. CHECK BACK LATER");
