desc:Squashman (Saike)
tags: multiband saturation plugin
version: 0.85
author: Joep Vanlier
changelog: Make sure modulation tab does not occlude frequency indicator.
provides: Squashman_Dependencies/*
about:
  # Squashman
  Squashman is a multi-band saturation / distortion plugin that allows modulation of several of its parameters.
  [Screenshot](https://i.imgur.com/egp00QC.png)
  ### Demos
  You can find a demo of the plugin [here](https://www.youtube.com/watch?v=mK0xAhq4pK4)
  ### Features:
  - Flexible band count, up to five bands can be used to manipulate sound
  - 24 db/oct Linkwitz Riley crossover filters
  - Graphical user interface
  - Optional high quality oversampling  
  - 25 modulatable waveshapers and 4 fixed ones.
  - Several modulation sources (4 LFOs, 2 MIDI triggered and/or loopable envelopes).

Thanks to tviler / samuele pizzi / RCJacH / BethHarmon (inflator waveshaper curves).

license: MIT

import squashman_upsamplers.jsfx-inc
import widgets.jsfx-inc
import envelopes.jsfx-inc
import squashman_agc.jsfx-inc

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:Cuts=1<0,4,1>-Cuts
slider2:Freq1=0.5<0,1,.0001>-Frequency 1
slider3:Freq2=0.5<0,1,.0001>-Frequency 2
slider4:Freq3=0.5<0,1,.0001>-Frequency 3
slider5:Freq4=0.5<0,1,.0001>-Frequency 4

slider6:sDrive1=0<-40,60,.1>-Drive 1 (dB)
slider7:sDrive2=0<-40,60,.1>-Drive 2 (dB)
slider8:sDrive3=0<-40,60,.1>-Drive 3 (dB)
slider9:sDrive4=0<-40,60,.1>-Drive 4 (dB)
slider10:sDrive5=0<-40,60,.1>-Drive 5 (dB)

slider11:sGain1=0<-60,40,.1>-Gain 1 (dB)
slider12:sGain2=0<-60,40,.1>-Gain 2 (dB)
slider13:sGain3=0<-60,40,.1>-Gain 3 (dB)
slider14:sGain4=0<-60,40,.1>-Gain 4 (dB)
slider15:sGain5=0<-60,40,.1>-Gain 5 (dB)

slider16:Mode1=0<0,24,1>-Mode 1
slider17:Mode2=0<0,24,1>-Mode 2
slider18:Mode3=0<0,24,1>-Mode 3
slider19:Mode4=0<0,24,1>-Mode 4
slider20:Mode5=0<0,24,1>-Mode 5

slider21:sModifier1=0<0,1,.001>-Modifier1
slider22:sModifier2=0<0,1,.001>-Modifier2
slider23:sModifier3=0<0,1,.001>-Modifier3
slider24:sModifier4=0<0,1,.001>-Modifier4
slider25:sModifier5=0<0,1,.001>-Modifier5

slider26:sDelay1=0<0,1,.001>-Delay1
slider27:sDelay2=0<0,1,.001>-Delay2
slider28:sDelay3=0<0,1,.001>-Delay3
slider29:sDelay4=0<0,1,.001>-Delay4
slider30:sDelay5=0<0,1,.001>-Delay5

slider31:sFeedback1=0<0,.99,.001>-Feedback1
slider32:sFeedback2=0<0,.99,.001>-Feedback2
slider33:sFeedback3=0<0,.99,.001>-Feedback3
slider34:sFeedback4=0<0,.99,.001>-Feedback4
slider35:sFeedback5=0<0,.99,.001>-Feedback5

slider36:sDryWet1=1<0,1,.001>-Dry/Wet 1
slider37:sDryWet2=1<0,1,.001>-Dry/Wet 2
slider38:sDryWet3=1<0,1,.001>-Dry/Wet 3
slider39:sDryWet4=1<0,1,.001>-Dry/Wet 4
slider40:sDryWet5=1<0,1,.001>-Dry/Wet 5

slider41:Widen1=0<0,1,1>-Widen 1
slider42:Widen2=0<0,1,1>-Widen 2
slider43:Widen3=0<0,1,1>-Widen 3
slider44:Widen4=0<0,1,1>-Widen 4
slider45:Widen5=0<0,1,1>-Widen 5

/* Placholder */
slider46:Verb1=0<0,1,1>-Verb 1
slider47:Verb2=0<0,1,1>-Verb 2
slider48:Verb3=0<0,1,1>-Verb 3
slider49:Verb4=0<0,1,1>-Verb 4
slider50:Verb5=0<0,1,1>-Verb 5

slider51:AGC=0<0,1,1>-Gain compensation

slider53:LFO_amnt1=1<0,1,1>-LFO1 Amount
slider54:LFO_amnt2=1<0,1,1>-LFO2 Amount
slider55:LFO_amnt3=1<0,1,1>-LFO3 Amount
slider56:LFO_amnt4=1<0,1,1>-LFO4 Amount

slider57:LFO_freq1=0<0,1,1>-LFO1 Frequency
slider58:LFO_freq2=0<0,1,1>-LFO2 Frequency
slider59:LFO_freq3=0<0,1,1>-LFO3 Frequency
slider60:LFO_freq4=0<0,1,1>-LFO4 Frequency

slider61:Inertia=1<0,1,1{No,Yes}>-Inertia
slider62:masterGainSlider=0<-26,26,.1>-Master Gain
slider63:Oversampling=1<1,4,1>-Oversampling
slider64:fixDC=1<0,2,1>-Fix DC options

@init
  modulator1.t = 0;
  modulator2.t = 0;
  modulator3.t = 0;
  modulator4.t = 0;

  logten        = log(10);
  logten005     = 0.05 * log(10);
  COMBO_SMALL   = 16;
  COMBO_BIG     = 11;
  GRID_FONT     = 15;
  HINT_FONT     = 14;
  KNOB_FONT     = 13;
  KNOB_FONT2    = 12;
  TOGGLE_FONT   = 10;
  BAND_FONT     = 9;
  ENVELOPE_FONT = 8;
  SLIDER_FONT   = 7;
  BUTTON_FONT   = 6;
  gfx_ext_retina = 1;

  function f_trafo(freq)
  local()
  global()
  instance()
  (
    exp( (1-freq) * log(20/22050) )
  );

  envWindow1.resetEnvelope(1,1);
  envWindow2.resetEnvelope(1,1);

  ///////////////////////////////
  /* Envelope follower section */
  ///////////////////////////////
  function init_follower(atk, release)
    local(csrate)
    instance(at, rt, LPF)
    global(srate)
    (
      csrate = srate;
      at = ( atk > 0 ) ? exp(-1/(.5*.001*atk*csrate)) : 0;
      rt = exp(-1/(.5*.001*release*csrate));
    );
  
  function eval_follower(x)
    local()
    instance(state, at, rt, x)
    global()
    (
      x > state ? (
        state = at * state + ( 1.0 - at ) * x;
      ) : (
        state = rt * state + ( 1.0 - rt ) * x;
      );
      
      state
    );

  ///////////////////////
  /* Allpass filter    */
  ///////////////////////
  function init_AP(freq, k_in)
    global(Oversampling)
    local(g, res)
    instance(k, a1, a2, a3)
    (
      g = ( (1/Oversampling) * .5 * $pi * exp( (1-freq) * log(20/22050) ) );
      k = k_in;
      
      a1 = 1/(1+g*(g+k));
      a2 = g*a1;
      a3 = g*a2;
    ); 

  function eval_AP(v0)
    global()
    local(v1, v2, v3)
    instance(ic1eq, ic2eq, k, a1, a2, a3)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;    
      
      v0 - 2*k*v1
    );

  ///////////////////////
  /* Modulator section */
  ///////////////////////
  function modulator()
    global(srate)
    local()
    instance( invpi2, twopi, invsrate, reset, modvalue, scaled_modvalue, modrate, t, modmax, scale )
    (
      modvalue = 0;
      scaled_modvalue = 0;
      scale = 0;
      reset = 1;
      modmax = 1;
      invsrate = 1.0/srate;
      invpi2 = .5/$pi;
      twopi = 2*$pi;
    );    

  function updateModSettings(_shape, _tempo_sync, _resetOnMIDI)
    local()
    global()
    instance(shape, resetOnMIDI, tempo_sync)
    (
      shape       = _shape;
      tempo_sync  = _tempo_sync;
      resetOnMIDI = _resetOnMIDI;
    );

  modulator1.modulator();
  modulator2.modulator();
  modulator3.modulator();
  modulator4.modulator();    

  function updateModRate(slidervalue)
    local(cTime, cRate)
    global(updatered, slider38, cTempo)
    instance( invsrate, reset, modvalue, scaled_modvalue, modrate, lastinput, t, tempo_sync )
    (
      ( lastinput != (slidervalue + 10*tempo_sync) ) ? (
        lastinput = slidervalue + 10*tempo_sync;
      
        (!tempo_sync) ? (
          modrate = (1+slidervalue)^4 - 1;
        ) : (
          cTime = slidervalue;
          cRate = ( cTime < 0.0196078 ) ? 256
          : ( cTime < 0.0392157 ) ? 224
          : ( cTime < 0.0588235 ) ? 192
          : ( cTime < 0.0784314 ) ? 160
          : ( cTime < 0.0980392 ) ? 144
          : ( cTime < 0.117647 ) ? 128
          : ( cTime < 0.137255 ) ? 112
          : ( cTime < 0.156863 ) ? 96
          : ( cTime < 0.176471 ) ? 80
          : ( cTime < 0.196078 ) ? 64
          : ( cTime < 0.215686 ) ? 56
          : ( cTime < 0.235294 ) ? 48
          : ( cTime < 0.254902 ) ? 40
          : ( cTime < 0.27451 ) ? 32
          : ( cTime < 0.294118 ) ? 28
          : ( cTime < 0.313725 ) ? 24
          : ( cTime < 0.333333 ) ? 16
          : ( cTime < 0.352941 ) ? 8
          : ( cTime < 0.372549 ) ? 7
          : ( cTime < 0.392157 ) ? 6
          : ( cTime < 0.411765 ) ? 5.33333
          : ( cTime < 0.431373 ) ? 5
          : ( cTime < 0.45098 ) ? 4
          : ( cTime < 0.470588 ) ? 3
          : ( cTime < 0.485196 ) ? 2.66667
          : ( cTime < 0.495196 ) ? 2
          : ( cTime < 0.509804 ) ? 1.33333
          : ( cTime < 0.529412 ) ? 1.16667
          : ( cTime < 0.54902 ) ? 1
          //: ( cTime < 0.568627 ) ? 0.9375
          : ( cTime < 0.588235 ) ? 0.875
          : ( cTime < 0.607843 ) ? 0.833333
          //: ( cTime < 0.627451 ) ? 0.8125
          : ( cTime < 0.647059 ) ? 0.75
          //: ( cTime < 0.666667 ) ? 0.6875
          : ( cTime < 0.686275 ) ? 0.666667
          : ( cTime < 0.705882 ) ? 0.625
          : ( cTime < 0.72549 ) ? 0.5625
          : ( cTime < 0.745098 ) ? 0.5
          : ( cTime < 0.764706 ) ? 0.4375
          : ( cTime < 0.784314 ) ? 0.375
          : ( cTime < 0.803922 ) ? 0.333333
          : ( cTime < 0.823529 ) ? 0.3125
          : ( cTime < 0.843137 ) ? 0.25
          : ( cTime < 0.862745 ) ? 0.1875
          : ( cTime < 0.882353 ) ? 0.166667
          : ( cTime < 0.901961 ) ? 0.125
          : ( cTime < 0.921569 ) ? 0.0833333
          : ( cTime < 0.941176 ) ? 0.0625
          : ( cTime < 0.960784 ) ? 0.0416667
          : ( cTime < 0.980392 ) ? 0.03125
          : 0.015625;
          
          modrate = .25 * (cTempo/60) / cRate;
      );
    );
  );
  
  function updateScale(value)
    instance(scale)
    global()
    local()
    (
      scale = value;
    );
  
  function getScale()
    instance(scale)
    global()
    local()
    (
      scale
    );
  
  function updateModulator(alpha)
    instance( invpi2, twopi, invsrate, reset, modvalue, scaled_modvalue, modrate, t, lastt, lastrand, scale, shape, resetOnMIDI, newmod )
    global()
    local(ct, st)
    (
        t = t + modrate*invsrate;
        (resetOnMIDI) && reset == 1 ? ( t = 0; reset = 0; lastt = -1; );
  
        newmod = ( shape == 0 ) ? .5 + .5 * cos(twopi*t)
        : ( shape==1 )  ? .5 + .5 * sin(twopi*t)
        : ( shape==2 )  ? ( ct = cos($pi*t); ct*ct )
        : ( shape==3 )  ? ( st = sin($pi*t); st*st )
        : ( shape==4 )  ? ( t-floor(t) )
        : ( shape==5 )  ? ( 1-t+floor(t) )
        : ( shape==6 )  ? ( exp(-4*(t-floor(t))) )
        : ( shape==7 )  ? ( min((15*(t-floor(t))),1)*exp(-4*(t-floor(t))) )
        : ( shape==8 )  ? ( 1-exp(-4*(t-floor(t))) )
        : ( shape==9 ) ? ( ( t > (lastt+1) ) ? ( lastt = lastt+1; lastrand=rand() ); lastrand )
        : ( shape==10 ) ? ( ( t > (lastt+1) ) ? ( lastt = lastt+1; lastrand=rand() ); exp(-4*lastrand*(t-floor(t))) )
        : ( shape==11 ) ? ( ( t > (lastt+1) ) ? ( lastt = lastt+1; lastrand=rand() ); min((15*(.2+.8*lastrand)*(t-floor(t))),1)*exp(-4*lastrand*(t-floor(t))) )
        : ( shape==12 ) ? ( exp(-t) )    
        : ( shape==13 ) ? ( min((15*t),1)*exp(-t) )
        : ( shape==14 ) ? ( (t-floor(t)) < .0625 )
        : ( shape==15 ) ? ( (t-floor(t)) < .125 )
        : ( shape==16 ) ? ( (t-floor(t)) < .25 )
        : ( shape==17 ) ? ( (t-floor(t)) < .5 )
        : ( shape==18 ) ? ( (3*t-floor(3*t)) < .5 )
        : ( shape==19 ) ? ( ((8*t-floor(8*t)) < .5) * (.5 + .5*cos(twopi*t)) )
        : ( shape==20 ) ? ( ((4*t-floor(4*t)) < .25) * (.5 + .5*cos(twopi*t)) * .5 + .5 * ((3*t-floor(3*t)) > .25) * (.5 + .5*sin(twopi*t)) )
        : ( shape==21 ) ? ( ((8*t-floor(8*t)) < .25) * (.5 + .5*cos(twopi*t)) * .5 + .5 * ((6*t-floor(6*t)) > .25) * (.5 + .5*sin(twopi*t)) )
        : ( shape==22 ) ? ( ((8*t-floor(8*t)) < .5) * .5 + .5 * ((3*t-floor(6*t)) < .5) * (.5+.5*sin(twopi*t)) )
        : ( shape==23 ) ? ( 1-2*abs(t-floor(t)-0.5) )
        : ( shape==24 ) ? ( sin(twopi*t)*.3+.5 + sin(2*twopi*t)*.2 )
        : ( shape==25 ) ? ( sin(twopi*t)*.2+.5 + sin(2*twopi*t)*.2 + sin(4*twopi*t)*.1 );
    
        modvalue = modvalue*alpha + (1-alpha) * newmod;
        scaled_modvalue = modvalue * scale;
    );
  
  /* Smoothing ? */
  function getvalue( tval )
    instance( t, modvalue, reset, smoothing )
    global()
    local()
    (
      t = tval;
      
      this.updateModulator(smoothing ? 0.7 : 0);
      modvalue
    );
        
  function create_mod_window(_x, _y, _w, _h, _r, _g, _b, _a)
    instance(x, y, w, h, mod, r, g, b, a)
    local()
    global()
    (
      mod.modulator();
      x = _x;
      y = _y+1;
      w = _w;
      h = _h-2;
      r = _r;
      g = _g;
      b = _b;
      a = _a;
    );
    
  function draw_modulator(shape, tcur)
    instance(x, y, w, h, mod, r, g, b, a)
    local(dx, t, lx, ly, nx, ny)
    global(gfx_a)
    (
      gfx_set( 0, 0, 0, .1 );
      gfx_rect( x, y, w, h );
          
      gfx_set( r, g, b, a*.8 );
      gfx_line(x, y, x, y+h);
      gfx_line(x+1, y, x+w-1, y);
      gfx_line(x+w, y, x+w, y+h);
      gfx_line(x+1, y+h, x+w-1, y+h);
      
      gfx_set( r, g, b, a );
      dx = .5/w;
      lx = x;
      ly = 0.5 * h + y;
      t = 0;
      mod.shape = shape;
      loop(2*w,
        ny = y + h - h*mod.getValue(t);
        nx = lx + .5;
        
        gfx_line( lx, ly, nx, ny );
        
        lx = nx;
        ly = ny;
        t = t + dx;
      );
      
      tcur -= floor(tcur);
      gfx_line( x+tcur*w, y, x+tcur*w, y+h );
      gfx_a = .5*gfx_a;
      gfx_line( x+tcur*w-1, y, x+tcur*w-1, y+h );
      gfx_a = .5*gfx_a;
      gfx_line( x+tcur*w-2, y, x+tcur*w-2, y+h );
    );  

  function prepLerp(slideridx_in, memloc_in, currentValue, linear)
    instance(slideridx, ptr, memloc, cur_x, cur_y, next, delta, nextVal, prevVal)
    local(next_x, next_y, dx)
    global(samplesblock)
    (
      ( linear ) ? (
        slideridx = slideridx_in;
        memloc = memloc_in;
      
        nextVal = currentValue;
        (samplesblock > 0) && ( samplesblock < 44100 ) ? (
          delta = (nextVal - prevVal) / (samplesblock);
          cur_y = prevVal;
        ) : (
          delta = 0;
          cur_y = nextVal;
        );
        
        // This ensures we never change delta (curSample is never negative)
        next = -10000;
        prevVal = nextVal;
      ) : (
        slideridx = slideridx_in;
        memloc = memloc_in;
        
        cur_x = 0;
        cur_y = currentValue;
        
        // Fetch the points
        ptr = memloc;
        while( (next_x = slider_next_chg(slideridx, next_y)) > -1 )
        (
          ptr[] = cur_x;
          ptr += 1;
          ptr[] = (next_y - cur_y) / (next_x - cur_x);
          ptr += 1;
          
          cur_x = next_x;
          cur_y = next_y;
        );
        ptr[]  = samplesblock;
        ptr[1] = 0;
        ptr[2] = -100;
              
        ptr = memloc;
        cur_y = currentValue;
        delta = 0;
        
        next = ptr[];
        prevVal = cur_y;
      );
    );

  function lerpSample()
    instance(slideridx, ptr, memloc, cur_x, cur_y, delta, next)
    global(curSample, potato)
    local()
    (
      ( next == curSample ) ? (
        ptr += 1;
        delta = ptr[];
        ptr += 1;
        next = ptr[];
      );
      
      cur_y += delta
    );

  function initBands()
  local()
  global()
  instance(lg1, lg2, lg3, lg4, lg5, b1, b2, b3, b4, b5)
  (
    lg1 = lg2 = lg3 = lg4 = lg5 = -1000000;
    b1.ldrive = b2.ldrive = b3.ldrive = b4.ldrive = b5.ldrive = -1000000;
    b1.lpan = b2.lpan = b3.lpan = b4.lpan = b5.lpan = -100000;
  );

  function getBandPre(bandIdx)
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    ( bandIdx == 0 ) ? ( .5*b1.pre )
    : ( bandIdx == 1 ) ? ( .5*b2.pre )
    : ( bandIdx == 2 ) ? ( .5*b3.pre )
    : ( bandIdx == 3 ) ? ( .5*b4.pre )
    : ( bandIdx == 4 ) ? ( .5*b5.pre )
  );
  
  function getBandPost(bandIdx)
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    ( bandIdx == 0 ) ? ( .5*b1.post )
    : ( bandIdx == 1 ) ? ( .5*b2.post )
    : ( bandIdx == 2 ) ? ( .5*b3.post )
    : ( bandIdx == 3 ) ? ( .5*b4.post )
    : ( bandIdx == 4 ) ? ( .5*b5.post )
  );

function kot_lut(xloc, yloc)
  instance()
  local(ptr)
  global()
  (
    ptr = xloc;
    (ptr)[] = 0.0000000000000000000000000000000000000000000000000000000000000000000000;
    (ptr+=1)[] = 0.0000002272750297187890897817106163406042362851167126791551709175109863;
    (ptr+=1)[] = 0.0000004545523573290177498923273543413037245386476570274680852890014648;
    (ptr+=1)[] = 0.0000006818365740679524598656354242298682777345675276592373847961425781;
    (ptr+=1)[] = 0.0000009091391466737206086479107687570166973500818130560219287872314453;
    (ptr+=1)[] = 0.0000011364898614403173784817655672663150312473590020090341567993164062;
    (ptr+=1)[] = 0.0000013639665515893442292920476749396030413663538638502359390258789062;
    (ptr+=1)[] = 0.0000015917727765245184593455828048202960189883015118539333343505859375;
    (ptr+=1)[] = 0.0000018204409785609454137613903365600087624898151261731982231140136719;
    (ptr+=1)[] = 0.0000020513638719805324137448500343428037240300909616053104400634765625;
    (ptr+=1)[] = 0.0000022881844022928005752545114331875097946067398879677057266235351562;
    (ptr+=1)[] = 0.0000023369165300198341795830971057146285829730913974344730377197265625;
    (ptr+=1)[] = 0.0000023863436474180246963706659296677869974701025057584047317504882812;
    (ptr+=1)[] = 0.0000024366131224582609724751362106909269300558662507683038711547851562;
    (ptr+=1)[] = 0.0000024879035715163015945897238140327445421462471131235361099243164062;
    (ptr+=1)[] = 0.0000025404314853906905902029833566047045678715221583843231201171875000;
    (ptr+=1)[] = 0.0000025944592603240052647252302658875677821015415247529745101928710938;
    (ptr+=1)[] = 0.0000026503049319491250363943143919520650797494454309344291687011718750;
    (ptr+=1)[] = 0.0000027083539732545147541483560038599875952058937400579452514648437500;
    (ptr+=1)[] = 0.0000027690735942301342131213661573729822862333094235509634017944335938;
    (ptr+=1)[] = 0.0000028330300736588281070612964362975816356993163935840129852294921875;
    (ptr+=1)[] = 0.0000028664312687454564579359050924267648952081799507141113281250000000;
    (ptr+=1)[] = 0.0000029009097659996159753012685833528649936852161772549152374267578125;
    (ptr+=1)[] = 0.0000029365742958318774165327701142214067431268631480634212493896484375;
    (ptr+=1)[] = 0.0000029735445626418528360600766757837476461645564995706081390380859375;
    (ptr+=1)[] = 0.0000030119523524056179028356161619939257434452883899211883544921875000;
    (ptr+=1)[] = 0.0000030519427520501930822414624056015952646703226491808891296386718750;
    (ptr+=1)[] = 0.0000030936754918975680455760658010833097364411514718085527420043945312;
    (ptr+=1)[] = 0.0000031373264235994869768590562197907445352029753848910331726074218750;
    (ptr+=1)[] = 0.0000031830891472378593251113358675308262490943889133632183074951171875;
    (ptr+=1)[] = 0.0000032311768026458596567206203037381229137281479779630899429321289062;
    (ptr+=1)[] = 0.0000032818240415242349736159224032894243805458245333284139633178710938;
    (ptr+=1)[] = 0.0000033352891986002126872086666342642757854264345951378345489501953125;
    (ptr+=1)[] = 0.0000033918566819180485770327329597684240525268251076340675354003906250;
    (ptr+=1)[] = 0.0000034518396043778417216045528714829515593010000884532928466796875000;
    (ptr+=1)[] = 0.0000035155826808714051744846409985889579274953575804829597473144531250;
    (ptr+=1)[] = 0.0000035834654178215151178405264986714939823286840692162513732910156250;
    (ptr+=1)[] = 0.0000036559056246363073292308595862998288339440478011965751647949218750;
    (ptr+=1)[] = 0.0000037333632795692510365683641770928602454659994691610336303710937500;
    (ptr+=1)[] = 0.0000038163447857542747194297717838740169327138573862612247467041015625;
    (ptr+=1)[] = 0.0000039054076567958125965149968061851382117311004549264907836914062500;
    (ptr+=1)[] = 0.0000040011656752680690022944305639374107386174728162586688995361328125;
    (ptr+=1)[] = 0.0000041042945718534878992030633104715064973788685165345668792724609375;
    (ptr+=1)[] = 0.0000042155382776677333941982642184775897931103827431797981262207031250;
    (ptr+=1)[] = 0.0000043357158076219526877362504813095966937908087857067584991455078125;
    (ptr+=1)[] = 0.0000044657288385119806739141298801420987274468643590807914733886718750;
    (ptr+=1)[] = 0.0000046065700519521183580102553778434781861506053246557712554931640625;
    (ptr+=1)[] = 0.0000047593323193481105662502525510682005460694199427962303161621093750;
    (ptr+=1)[] = 0.0000049252188138949295193838757989102106193968211300671100616455078125;
    (ptr+=1)[] = 0.0000051055541431626049890578691869968963601422728970646858215332031250;
    (ptr+=1)[] = 0.0000053017966052763776071184848026618396943376865237951278686523437500;
    (ptr+=1)[] = 0.0000055155516820938343426888178511191540565050672739744186401367187500;
    (ptr+=1)[] = 0.0000057485868942271102884555497580798544277058681473135948181152343750;
    (ptr+=1)[] = 0.0000060028481553591214552306060125985709419182967394590377807617187500;
    (ptr+=1)[] = 0.0000062804777771751482123440031568595287581047159619629383087158203125;
    (ptr+=1)[] = 0.0000065838342915038130284243605983007796567108016461133956909179687500;
    (ptr+=1)[] = 0.0000069155142730754847230794681023358094762443215586245059967041015625;
    (ptr+=1)[] = 0.0000072783763648173485470834961907904414601944154128432273864746093750;
    (ptr+=1)[] = 0.0000076755677279836502242393175832191332119691651314496994018554687500;
    (ptr+=1)[] = 0.0000081105531618558816169331504575268354528816416859626770019531250000;
    (ptr+=1)[] = 0.0000085871471624484472975457477472716050215240102261304855346679687500;
    (ptr+=1)[] = 0.0000085871471624484659322705873418790645246190251782536506652832031250;
    (ptr+=1)[] = 0.0000090011886777615967647828143505250864109257236123085021972656250000;
    (ptr+=1)[] = 0.0000094468827383713019590731618801981994693051092326641082763671875000;
    (ptr+=1)[] = 0.0000099267602501288379382004406492612247348006349056959152221679687500;
    (ptr+=1)[] = 0.0000104435544875849889250290364328677128469280432909727096557617187500;
    (ptr+=1)[] = 0.0000110002172751887835580771046739556595639442093670368194580078125000;
    (ptr+=1)[] = 0.0000115999364623186860016271909623597480276657734066247940063476562500;
    (ptr+=1)[] = 0.0000122461547955997655871525700566060379514965461567044258117675781250;
    (ptr+=1)[] = 0.0000129425903002325456308315571041234193216951098293066024780273437500;
    (ptr+=1)[] = 0.0000136932582909924210044262660179725799025618471205234527587890625000;
    (ptr+=1)[] = 0.0000145024951432066187767891407567333317274460569024085998535156250000;
    (ptr+=1)[] = 0.0000153749839644346761617296759361295244161738082766532897949218750000;
    (ptr+=1)[] = 0.0000163157823188307988669827619521157657800358720123767852783203125000;
    (ptr+=1)[] = 0.0000173303521683185159844940020912318345835956279188394546508789062500;
    (ptr+=1)[] = 0.0000184245922078317219371113022674535386613570153713226318359375000000;
    (ptr+=1)[] = 0.0000196048727860490104623128471139636985753895714879035949707031250000;
    (ptr+=1)[] = 0.0000208780736183554699401249132861835278163198381662368774414062500000;
    (ptr+=1)[] = 0.0000222516245152946834004979714816130353938206098973751068115234375000;
    (ptr+=1)[] = 0.0000237335493676272404959919082312325144812348298728466033935546875000;
    (ptr+=1)[] = 0.0000253325136483904640662297158559823628820595331490039825439453125000;
    (ptr+=1)[] = 0.0000270578757131753265508748024226193251706718001514673233032226562500;
    (ptr+=1)[] = 0.0000289197422023221323999792736758607247793406713753938674926757812500;
    (ptr+=1)[] = 0.0000309290278730203741408728845829756437524338252842426300048828125000;
    (ptr+=1)[] = 0.0000330975202155234414437730283697902677886304445564746856689453125000;
    (ptr+=1)[] = 0.0000354379492360112522634368881213617896719370037317276000976562500000;
    (ptr+=1)[] = 0.0000379640628192202280832660832299296771452645771205425262451171875000;
    (ptr+=1)[] = 0.0000406907081169949504237046133958699556387728080153465270996093750000;
    (ptr+=1)[] = 0.0000436339194445857010045200508052687382587464526295661926269531250000;
    (ptr+=1)[] = 0.0000468110132050467188662319639735898135768366046249866485595703125000;
    (ptr+=1)[] = 0.0000502406904036941214376603415114885820003109984099864959716796875000;
    (ptr+=1)[] = 0.0000539431473595174259681901685059557394197327084839344024658203125000;
    (ptr+=1)[] = 0.0000579401952689646983869417584678274124598829075694084167480468750000;
    (ptr+=1)[] = 0.0000622553893299282879846695548664570196706335991621017456054687500000;
    (ptr+=1)[] = 0.0000669141681903553774005480314635008198820287361741065979003906250000;
    (ptr+=1)[] = 0.0000719440045470298001305253787762694628327153623104095458984375000000;
    (ptr+=1)[] = 0.0000773745677860820750808973356171804880432318896055221557617187500000;
    (ptr+=1)[] = 0.0000832378996280706091523415857125201000599190592765808105468750000000;
    (ptr+=1)[] = 0.0000895686038174703554048949882826491375453770160675048828125000000000;
    (ptr+=1)[] = 0.0000964040509795407459621083279266429144627181813120841979980468750000;
    (ptr+=1)[] = 0.0001037845998573449021610062836806775976583594456315040588378906250000;
    (ptr+=1)[] = 0.0001117538362386594940267245390508321634115418419241905212402343750000;
    (ptr+=1)[] = 0.0001203588309872411106753870013719165399379562586545944213867187500000;
    (ptr+=1)[] = 0.0001296504187060145015485124186938037382788024842739105224609375000000;
    (ptr+=1)[] = 0.0001396834986818906330571787854921694815857335925102233886718750000000;
    (ptr+=1)[] = 0.0001505173598938311493779934613357340822403784841299057006835937500000;
    (ptr+=1)[] = 0.0001622160320082327274529565563909727643476799130439758300781250000000;
    (ptr+=1)[] = 0.0001748486644395512478247778354045749438228085637092590332031250000000;
    (ptr+=1)[] = 0.0001884899357202318931694962067524556914577260613441467285156250000000;
    (ptr+=1)[] = 0.0002032204956034545657427708986730863216507714241743087768554687500000;
    (ptr+=1)[] = 0.0002191274425159670977917431011761095760448370128870010375976562500000;
    (ptr+=1)[] = 0.0002363048391875718424234159575902936012425925582647323608398437500000;
    (ptr+=1)[] = 0.0002548542695098295431978263625438785311416722834110260009765625000000;
    (ptr+=1)[] = 0.0002748854399206281866156753590502148654195480048656463623046875000000;
    (ptr+=1)[] = 0.0002965168288748602190736669559356641912017948925495147705078125000000;
    (ptr+=1)[] = 0.0003198763882461248906491357857362345384899526834487915039062500000000;
    (ptr+=1)[] = 0.0003451023008118097234672716489001231821021065115928649902343750000000;
    (ptr+=1)[] = 0.0003723437983059212823613859377758217306109145283699035644531250000000;
    (ptr+=1)[] = 0.0004017620448825965067535248564922767400275915861129760742187500000000;
    (ptr+=1)[] = 0.0004335310912204847454132217166034024558030068874359130859375000000000;
    (ptr+=1)[] = 0.0004678389049163486027721470250639868027064949274063110351562500000000;
    (ptr+=1)[] = 0.0005048884832679128784049815692469564964994788169860839843750000000000;
    (ptr+=1)[] = 0.0005448990550337146207202088099563752621179446578025817871093750000000;
    (ptr+=1)[] = 0.0005881073782844700855929054306159287079935893416404724121093750000000;
    (ptr+=1)[] = 0.0006347691420293359717760828253574345581000670790672302246093750000000;
    (ptr+=1)[] = 0.0006851604799148061164873468875669004773953929543495178222656250000000;
    (ptr+=1)[] = 0.0007395796049574564993284164771125688275787979364395141601562500000000;
    (ptr+=1)[] = 0.0007983485749882848975592097851006201381096616387367248535156250000000;
    (ptr+=1)[] = 0.0008618151992602169839119419236794783500954508781433105468750000000000;
    (ptr+=1)[] = 0.0009303550975060245276440640260773307090857997536659240722656250000000;
    (ptr+=1)[] = 0.0010043739236364871997980730000676885538268834352493286132812500000000;
    (ptr+=1)[] = 0.0010843097672432007103071605058630666462704539299011230468750000000000;
    (ptr+=1)[] = 0.0011706357471231657995519581660914809617679566144943237304687500000000;
    (ptr+=1)[] = 0.0012638628121790008475289202038993607857264578342437744140625000000000;
    (ptr+=1)[] = 0.0013645427662763371431248193843543958791997283697128295898437500000000;
    (ptr+=1)[] = 0.0014732715349657825656959353466390894027426838874816894531250000000000;
    (ptr+=1)[] = 0.0015906926934087053417121726539562587277032434940338134765625000000000;
    (ptr+=1)[] = 0.0017175012763924329961540138356212992221117019653320312500000000000000;
    (ptr+=1)[] = 0.0018544478929904625614383251175354416773188859224319458007812500000000;
    (ptr+=1)[] = 0.0020023431702267499750214074794030238990671932697296142578125000000000;
    (ptr+=1)[] = 0.0021620625520510157631381975562590014305897057056427001953125000000000;
    (ptr+=1)[] = 0.0023345514820352487699028909418075272697024047374725341796875000000000;
    (ptr+=1)[] = 0.0025208310004734692071071133767645733314566314220428466796875000000000;
    (ptr+=1)[] = 0.0027220037890199849477113058782151711056940257549285888671875000000000;
    (ptr+=1)[] = 0.0029392606986508688915460396628986927680671215057373046875000000000000;
    (ptr+=1)[] = 0.0031738877995947083893168993995459459256380796432495117187500000000000;
    (ptr+=1)[] = 0.0034272739949687638406905509924627040163613855838775634765625000000000;
    (ptr+=1)[] = 0.0037009192431938535070012896710522909415885806083679199218750000000000;
    (ptr+=1)[] = 0.0039964434378653096793798660257834853837266564369201660156250000000000;
    
    ptr = yloc;
    (ptr)[] = 0.0000000000000000000000000000000000000000000000000000000000000000000000;
    (ptr+=1)[] = 0.0499974111809210614021381502425356302410364151000976562500000000000000;
    (ptr+=1)[] = 0.0999792173768255937327253946023120079189538955688476562500000000000000;
    (ptr+=1)[] = 0.1499298481753241485403549404509249143302440643310546875000000000000000;
    (ptr+=1)[] = 0.1998338172182716476754649193026125431060791015625000000000000000000000;
    (ptr+=1)[] = 0.2496758163419069420640994394489098340272903442382812500000000000000000;
    (ptr+=1)[] = 0.2994409285040193213767167890182463452219963073730468750000000000000000;
    (ptr+=1)[] = 0.3491151514740411521131591143785044550895690917968750000000000000000000;
    (ptr+=1)[] = 0.3986867321580635503686096399178495630621910095214843750000000000000000;
    (ptr+=1)[] = 0.4481496137509251576069857492257142439484596252441406250000000000000000;
    (ptr+=1)[] = 0.4975123872180225448325074921740451827645301818847656250000000000000000;
    (ptr+=1)[] = 0.5073758787107911505387392026023007929325103759765625000000000000000000;
    (ptr+=1)[] = 0.5172376106452808430802292605221737176179885864257812500000000000000000;
    (ptr+=1)[] = 0.5270984116941410668744083523051813244819641113281250000000000000000000;
    (ptr+=1)[] = 0.5369593103710098569436581783520523458719253540039062500000000000000000;
    (ptr+=1)[] = 0.5468215771201838659720806390396319329738616943359375000000000000000000;
    (ptr+=1)[] = 0.5566867752774767863499505438085179775953292846679687500000000000000000;
    (ptr+=1)[] = 0.5665568227708185355950831763038877397775650024414062500000000000000000;
    (ptr+=1)[] = 0.5764340668222130981135364891088102012872695922851562500000000000000000;
    (ptr+=1)[] = 0.5863213743882237372062604663369711488485336303710937500000000000000000;
    (ptr+=1)[] = 0.5962222416513892619960301999526564031839370727539062500000000000000000;
    (ptr+=1)[] = 0.6011790568521447886141118033265229314565658569335937500000000000000000;
    (ptr+=1)[] = 0.6061409265706914073490452210535295307636260986328125000000000000000000;
    (ptr+=1)[] = 0.6111085283863871842058301808719988912343978881835937500000000000000000;
    (ptr+=1)[] = 0.6160826093403891645650105601816903799772262573242187500000000000000000;
    (ptr+=1)[] = 0.6210639929004470038975682655291166156530380249023437500000000000000000;
    (ptr+=1)[] = 0.6260535866233817303694308975536841899156570434570312500000000000000000;
    (ptr+=1)[] = 0.6310523905849797499101327957760076969861984252929687500000000000000000;
    (ptr+=1)[] = 0.6360615066539747619600575490039773285388946533203125000000000000000000;
    (ptr+=1)[] = 0.6410821486944094926840875814377795904874801635742187500000000000000000;
    (ptr+=1)[] = 0.6461156537890432316473265927925240248441696166992187500000000000000000;
    (ptr+=1)[] = 0.6511634945856613621018027515674475580453872680664062500000000000000000;
    (ptr+=1)[] = 0.6562272928782366676614401512779295444488525390625000000000000000000000;
    (ptr+=1)[] = 0.6613088345459712247276229390990920364856719970703125000000000000000000;
    (ptr+=1)[] = 0.6664100859854046321473219904873985797166824340820312500000000000000000;
    (ptr+=1)[] = 0.6715332121841049994870331829588394612073898315429687500000000000000000;
    (ptr+=1)[] = 0.6766805965990945193055949857807718217372894287109375000000000000000000;
    (ptr+=1)[] = 0.6818548630191798576305473034153692424297332763671875000000000000000000;
    (ptr+=1)[] = 0.6870588996079370902592131642450112849473953247070312500000000000000000;
    (ptr+=1)[] = 0.6922958853433357484519206082040909677743911743164062500000000000000000;
    (ptr+=1)[] = 0.6975693190910515761871124595927540212869644165039062500000000000000000;
    (ptr+=1)[] = 0.7028830515715597249126744827663060277700424194335937500000000000000000;
    (ptr+=1)[] = 0.7082413205062993988292419089702889323234558105468750000000000000000000;
    (ptr+=1)[] = 0.7136487892557192846965108401491306722164154052734375000000000000000000;
    (ptr+=1)[] = 0.7191105892920591768913141095254104584455490112304687500000000000000000;
    (ptr+=1)[] = 0.7246323668824904418173105113964993506669998168945312500000000000000000;
    (ptr+=1)[] = 0.7302203343939188684430519060697406530380249023437500000000000000000000;
    (ptr+=1)[] = 0.7358813266695874988343462064221967011690139770507812500000000000000000;
    (ptr+=1)[] = 0.7416228629697880769811035861494019627571105957031250000000000000000000;
    (ptr+=1)[] = 0.7474532150147404907514214755792636424303054809570312500000000000000000;
    (ptr+=1)[] = 0.7533814817172148625701311175362206995487213134765625000000000000000000;
    (ptr+=1)[] = 0.7594176712459478340022656084329355508089065551757812500000000000000000;
    (ptr+=1)[] = 0.7655727911185274958683066870435141026973724365234375000000000000000000;
    (ptr+=1)[] = 0.7718589470842863731192551313142757862806320190429687500000000000000000;
    (ptr+=1)[] = 0.7782894516239639015608986483130138367414474487304687500000000000000000;
    (ptr+=1)[] = 0.7848789429634490666387591772945597767829895019531250000000000000000000;
    (ptr+=1)[] = 0.7916435155737018281030259458930231630802154541015625000000000000000000;
    (ptr+=1)[] = 0.7986008632077307156649226271838415414094924926757812500000000000000000;
    (ptr+=1)[] = 0.8057704356078413399089299673505593091249465942382812500000000000000000;
    (ptr+=1)[] = 0.8131736101015950568537959952664095908403396606445312500000000000000000;
    (ptr+=1)[] = 0.8208338793920220144428867570240981876850128173828125000000000000000000;
    (ptr+=1)[] = 0.8208338793920222364874916820554062724113464355468750000000000000000000;
    (ptr+=1)[] = 0.8271644661145211019359635429282207041978836059570312500000000000000000;
    (ptr+=1)[] = 0.8336904435532230817074150763801299035549163818359375000000000000000000;
    (ptr+=1)[] = 0.8404273115375370251101116991776507347822189331054687500000000000000000;
    (ptr+=1)[] = 0.8473917767812859658249635685933753848075866699218750000000000000000000;
    (ptr+=1)[] = 0.8546018442958019933897162445646245032548904418945312500000000000000000;
    (ptr+=1)[] = 0.8620769152647821398360861167020630091428756713867187500000000000000000;
    (ptr+=1)[] = 0.8698378917483061689708279118349310010671615600585937500000000000000000;
    (ptr+=1)[] = 0.8779072885853479446538472075189929455518722534179687500000000000000000;
    (ptr+=1)[] = 0.8863093528609788940286762226605787873268127441406250000000000000000000;
    (ptr+=1)[] = 0.8950701912948123561974966833076905459165573120117187500000000000000000;
    (ptr+=1)[] = 0.9042179058893267118435232987394556403160095214843750000000000000000000;
    (ptr+=1)[] = 0.9137827381483989430677183918305672705173492431640625000000000000000000;
    (ptr+=1)[] = 0.9237972221350448931431742494169156998395919799804687500000000000000000;
    (ptr+=1)[] = 0.9342963465798540534379412747512105852365493774414062500000000000000000;
    (ptr+=1)[] = 0.9453177261740420833646680875972378998994827270507812500000000000000000;
    (ptr+=1)[] = 0.9569017820787704131646478344919160008430480957031250000000000000000000;
    (ptr+=1)[] = 0.9690919315497310559948118680040352046489715576171875000000000000000000;
    (ptr+=1)[] = 0.9819347864061586106387835570785682648420333862304687500000000000000000;
    (ptr+=1)[] = 0.9954803598581729584537924893083982169628143310546875000000000000000000;
    (ptr+=1)[] = 1.0097822809358110163202582043595612049102783203125000000000000000000000;
    (ptr+=1)[] = 1.0248980154254179186779083465808071196079254150390625000000000000000000;
    (ptr+=1)[] = 1.0408890918001190151187529409071430563926696777343750000000000000000000;
    (ptr+=1)[] = 1.0578213301140302338154697281424887478351593017578125000000000000000000;
    (ptr+=1)[] = 1.0757650711947601696039100716006942093372344970703125000000000000000000;
    (ptr+=1)[] = 1.0947954026921198344979302419233135879039764404296875000000000000000000;
    (ptr+=1)[] = 1.1149923775952734761318652090267278254032135009765625000000000000000000;
    (ptr+=1)[] = 1.1364412196838580282332031856640242040157318115234375000000000000000000;
    (ptr+=1)[] = 1.1592325089941781790514596650609746575355529785156250000000000000000000;
    (ptr+=1)[] = 1.1834623387176239628360008282470516860485076904296875000000000000000000;
    (ptr+=1)[] = 1.2092324329583503672580491183907724916934967041015625000000000000000000;
    (ptr+=1)[] = 1.2366502124099083559372047602664679288864135742187500000000000000000000;
    (ptr+=1)[] = 1.2658287922116928658766710213967598974704742431640625000000000000000000;
    (ptr+=1)[] = 1.2968868929605754658496152842417359352111816406250000000000000000000000;
    (ptr+=1)[] = 1.3299486420285153709386349873966537415981292724609375000000000000000000;
    (ptr+=1)[] = 1.3651432379294943242342696976265870034694671630859375000000000000000000;
    (ptr+=1)[] = 1.4026044454623378676672018627868965268135070800781250000000000000000000;
    (ptr+=1)[] = 1.4424698837334435363999318724381737411022186279296875000000000000000000;
    (ptr+=1)[] = 1.4848800629864284950087949255248531699180603027343750000000000000000000;
    (ptr+=1)[] = 1.5299771195580593730056762069580145180225372314453125000000000000000000;
    (ptr+=1)[] = 1.5779031914700860639300117327366024255752563476562500000000000000000000;
    (ptr+=1)[] = 1.6287983705310296045354334637522697448730468750000000000000000000000000;
    (ptr+=1)[] = 1.6827981609377185012732525137835182249546051025390625000000000000000000;
    (ptr+=1)[] = 1.7400303700759223168859080033143982291221618652343750000000000000000000;
    (ptr+=1)[] = 1.8006113557045633211117774408194236457347869873046875000000000000000000;
    (ptr+=1)[] = 1.8646415565671323744112442000187002122402191162109375000000000000000000;
    (ptr+=1)[] = 1.9322002427930706769387825261219404637813568115234375000000000000000000;
    (ptr+=1)[] = 2.0033394408492455340820015408098697662353515625000000000000000000000000;
    (ptr+=1)[] = 2.0780770184165233693818208848824724555015563964843750000000000000000000;
    (ptr+=1)[] = 2.1563889609469497621319078461965546011924743652343750000000000000000000;
    (ptr+=1)[] = 2.2382009374882709806797720375470817089080810546875000000000000000000000;
    (ptr+=1)[] = 2.3233793419586739048554591136053204536437988281250000000000000000000000;
    (ptr+=1)[] = 2.4117221095406158326568402117118239402770996093750000000000000000000000;
    (ptr+=1)[] = 2.5029497459795853053776681917952373623847961425781250000000000000000000;
    (ptr+=1)[] = 2.5966971661018054540193134016590192914009094238281250000000000000000000;
    (ptr+=1)[] = 2.6925071067624020137998286372749134898185729980468750000000000000000000;
    (ptr+=1)[] = 2.7898260409720516683762525644851848483085632324218750000000000000000000;
    (ptr+=1)[] = 2.8880036473634849158997894846834242343902587890625000000000000000000000;
    (ptr+=1)[] = 2.9862969466416284802789959940128028392791748046875000000000000000000000;
    (ptr+=1)[] = 3.0838801617003297472763279074570164084434509277343750000000000000000000;
    (ptr+=1)[] = 3.1798611471809872242033634393010288476943969726562500000000000000000000;
    (ptr+=1)[] = 3.2733048325503455444618339242879301309585571289062500000000000000000000;
    (ptr+=1)[] = 3.3632635172023128689033910632133483886718750000000000000000000000000000;
    (ptr+=1)[] = 3.4488130696746019943077499192440882325172424316406250000000000000000000;
    (ptr+=1)[] = 3.5290931864350043589695360424229875206947326660156250000000000000000000;
    (ptr+=1)[] = 3.6033489800320319673687663453165441751480102539062500000000000000000000;
    (ptr+=1)[] = 3.6709704526379631772670109057798981666564941406250000000000000000000000;
    (ptr+=1)[] = 3.7315260425215535100562647130573168396949768066406250000000000000000000;
    (ptr+=1)[] = 3.7847865529069855128341259842272847890853881835937500000000000000000000;
    (ptr+=1)[] = 3.8307364572718167750053908093832433223724365234375000000000000000000000;
    (ptr+=1)[] = 3.8695707876329894503442119457758963108062744140625000000000000000000000;
    (ptr+=1)[] = 3.9016774013682433697169926745118573307991027832031250000000000000000000;
    (ptr+=1)[] = 3.9276061421605548140689734282204881310462951660156250000000000000000000;
    (ptr+=1)[] = 3.9480279732894896227435310720466077327728271484375000000000000000000000;
    (ptr+=1)[] = 3.9636883003303475803136279864702373743057250976562500000000000000000000;
    (ptr+=1)[] = 3.9753592301354792049039588164305314421653747558593750000000000000000000;
    (ptr+=1)[] = 3.9837953659684881557723201694898307323455810546875000000000000000000000;
    (ptr+=1)[] = 3.9896969703921958405601344566093757748603820800781250000000000000000000;
    (ptr+=1)[] = 3.9936830958126972035415747086517512798309326171875000000000000000000000;
    (ptr+=1)[] = 3.9962758099085142760031885700300335884094238281250000000000000000000000;
    (ptr+=1)[] = 3.9978951735278598356160273397108539938926696777343750000000000000000000;
    (ptr+=1)[] = 3.9988633867338578831152062775800004601478576660156250000000000000000000;
    (ptr+=1)[] = 3.9994156749684628415764109377050772309303283691406250000000000000000000;
    (ptr+=1)[] = 3.9997151312716319182527513476088643074035644531250000000000000000000000;
    (ptr+=1)[] = 3.9998688563346247448748727038037031888961791992187500000000000000000000;
    (ptr+=1)[] = 3.9999432486297279432108098262688145041465759277343750000000000000000000;
    (ptr+=1)[] = 3.9999770287013616254512271552812308073043823242187500000000000000000000;
    (ptr+=1)[] = 3.9999913492087468824820462032221257686614990234375000000000000000000000;
  );

  /* Very flat 6-pole butterworth made of cascade of cytomics' SVF */
  function init_HP6(freq)
    global(srate)
    local(res)
    instance(g, a1_1, a1_2, a1_3, a2_1, a2_2, a2_3, k1, k2, k3)
    (
      g = tan( $pi * freq );
      
      k1  = 1.93185165257814; // sqrt(2+sqrt(3))
      a1_1 = 1/(1+g*(g+k1));
      
      k2 = 1.41421356474619; // sqrt(2)
      a1_2 = 1/(1+g*(g+k2));
      
      k3 = 0.517638090205042; // sqrt(2-sqrt(3))
      a1_3 = 1/(1+g*(g+k3));
      
      a2_1 = g*a1_1;
      a2_2 = g*a1_2;
      a2_3 = g*a1_3;
    );

  function eval_HP6(v0)
    global()
    local(v1, v2, hp)
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq,
             g, a1_1, a1_2, a1_3, a2_1, a2_2, a2_3, k1, k2, k3)
    (
      v1 = a1_1 * ic1eq + a2_1*(v0-ic2eq);
      v2 = ic2eq + g*v1;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;
      hp    = v0 - k1*v1 - v2;
      
      v1 = a1_2 * ic3eq + a2_2*(hp-ic4eq);
      v2 = ic4eq + g*v1;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      hp    = hp - k2*v1 - v2;
      
      v1 = a1_3 * ic5eq + a2_3*(hp-ic6eq);
      v2 = ic6eq + g*v1;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;
      
      hp    = hp - k3*v1 - v2;
    );   

dc0.init_HP6(17/srate);
dc1.init_HP6(17/srate);

maxCuts = 4;
driveMax = 60;
driveMin = -40;
driveRange = driveMax - driveMin;
gainMin = -60;
gainMax = 26;
overSamplingMax = 4;
overSamplingMin = 1;

releaseMax = 5000;
releaseMin = 200;
attackMax = 300;
attackMin = 2;

attackRange = attackMax - attackMin;
iAttackRange = 1/attackRange;

releaseRange = releaseMax - releaseMin;
iReleaseRange = 1/releaseRange;

filterBank.initBands();

// Precompute some things
gainRange = ( gainMax - gainMin );
iGainRange = 1.0 / gainRange;
iDriveRange = 1.0 / driveRange;

overSamplingRange = (oversamplingMax - oversamplingMin);
iOversamplingRange = 1.0 / overSamplingRange;

f1Attack = max(attackMin,min(attackMax,f1Attack));
f1Decay = max(releaseMin,min(releaseMax,f1Decay));
f2Attack = max(attackMin,min(attackMax,f2Attack));
f2Decay = max(releaseMin,min(releaseMax,f2Decay));

///////////////////
/* SLIDER LAYOUT */
///////////////////
/* Keep these updated with the slider locations */
frequencyLocation = 2;
driveLocation     = 6;
gainLocation      = 11;
modeLocation      = 16;
modifierLocation  = 21;
delayLocation     = 26;
feedbackLocation  = 31;
drywetLocation    = 36;
widenLocation     = 41;
verbLocation      = 46;
modLocation       = 51;
LFO_frequencies   = 57;
LFO_amounts       = 53;

/* Shift slider data right (for different bands) */
function shiftRight(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx-1);
      midx = midx - 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeft(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx+1);
      midx = midx + 1;
    );
  );
  
/* Shift slider data right (for different bands) */
function shiftRightMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      midx[] = midx[-1];
      midx -= 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeftMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      midx[] = midx[1];
      midx += 1;
    );
  );  

/* Make room for a new band in the slider data */
function addBand(idx)
  local(midx)
  instance()
  (
    shiftRight( driveLocation,     idx, maxCuts );
    shiftRight( modeLocation,      idx, maxCuts );
    shiftRight( modifierLocation,  idx, maxCuts );
    shiftRight( delayLocation,     idx, maxCuts );
    shiftRight( feedbackLocation,  idx, maxCuts );
    shiftRight( gainLocation,      idx, maxCuts );
    shiftRight( drywetLocation,    idx, maxCuts );
    shiftRight( widenLocation,     idx, maxCuts );
    shiftRight( verbLocation,      idx, maxCuts );
    shiftRight( modLocation,       idx, maxCuts );
    shiftRight( frequencyLocation, idx, maxCuts-1 );
    
    shiftRightMem(shapeMod1Value,   idx, maxCuts );
    shiftRightMem(shapeMod1Type,    idx, maxCuts );
    shiftRightMem(shapeMod2Value,   idx, maxCuts );
    shiftRightMem(shapeMod2Type,    idx, maxCuts );
    shiftRightMem(shapeDrive1Value, idx, maxCuts );
    shiftRightMem(shapeDrive1Type,  idx, maxCuts );
    shiftRightMem(shapeDrive2Value, idx, maxCuts );
    shiftRightMem(shapeDrive2Type,  idx, maxCuts );
    shiftRightMem(drywetMod1Value,  idx, maxCuts );
    shiftRightMem(drywetMod1Type,   idx, maxCuts );
    shiftRightMem(gainMod1Value,    idx, maxCuts );
    shiftRightMem(gainMod1Type,     idx, maxCuts );
    shiftRightMem(delayMod1Value,   idx, maxCuts );
    shiftRightMem(delayMod1Type,    idx, maxCuts );
    shiftRightMem(fbMod1Value,      idx, maxCuts );
    shiftRightMem(fbMod1Type,       idx, maxCuts );
    shiftRightMem(drivePanning,     idx, maxCuts );
    
    /* drivePanning1, drivePanning2, drivePanning3, drivePanning4, drivePanning5 */
    /* fbToggle1 fbToggle2 fbToggle3 fbToggle4 fbToggle5 */
    
    cuts = cuts + 1;
  );
  
/* Remove a band and move other slider data accordingly */  
function remBand(idx)
  local(midx)
  instance()
  (
    shiftLeft( driveLocation,     idx, maxCuts );
    shiftLeft( modeLocation,      idx, maxCuts );
    shiftLeft( modifierLocation,  idx, maxCuts );
    shiftLeft( delayLocation,     idx, maxCuts );
    shiftLeft( feedbackLocation,  idx, maxCuts );
    shiftLeft( gainLocation,      idx, maxCuts );
    shiftLeft( drywetLocation,    idx, maxCuts );
    shiftLeft( widenLocation,     idx, maxCuts );
    shiftLeft( verbLocation,      idx, maxCuts );
    shiftLeft( modLocation,       idx, maxCuts );
    shiftLeft( frequencyLocation, idx, maxCuts-1 );
    
    shiftLeftMem(shapeMod1Value,   idx, maxCuts );
    shiftLeftMem(shapeMod1Type,    idx, maxCuts );
    shiftLeftMem(shapeMod2Value,   idx, maxCuts );
    shiftLeftMem(shapeMod2Type,    idx, maxCuts );
    shiftLeftMem(shapeDrive1Value, idx, maxCuts );
    shiftLeftMem(shapeDrive1Type,  idx, maxCuts );
    shiftLeftMem(shapeDrive2Value, idx, maxCuts );
    shiftLeftMem(shapeDrive2Type,  idx, maxCuts );
    shiftLeftMem(drywetMod1Value,  idx, maxCuts );
    shiftLeftMem(drywetMod1Type,   idx, maxCuts );
    shiftLeftMem(gainMod1Value,    idx, maxCuts );
    shiftLeftMem(gainMod1Type,     idx, maxCuts );
    shiftLeftMem(delayMod1Value,   idx, maxCuts );
    shiftLeftMem(delayMod1Type,    idx, maxCuts );
    shiftLeftMem(fbMod1Value,      idx, maxCuts );
    shiftLeftMem(fbMod1Type,       idx, maxCuts );
    shiftLeftMem(drivePanning,     idx, maxCuts );
        
    /* drivePanning1, drivePanning2, drivePanning3, drivePanning4, drivePanning5 */
    /* fbToggle1 fbToggle2 fbToggle3 fbToggle4 fbToggle5 */
    
    cuts = cuts - 1;
  );  
  
nShapers = 34;
nModulators = 9;

function hasShapeMod(curitem)
  local()
  global()
  instance()
  (
    ( curitem == 0 ) ? ( 0 )
    : ( curitem == 1 ) ? ( 0 )
    : ( curitem == 2 ) ? ( 0 )
    : ( curitem == 3 ) ? ( 1 )
    : ( curitem == 4 ) ? ( 0 )
    : ( curitem == 5 ) ? ( 0 )
    : ( curitem == 6 ) ? ( 1 )
    : ( curitem == 7 ) ? ( 1 )
    : ( curitem == 8 ) ? ( 1 )
    : ( curitem == 9 ) ? ( 1 )
    : ( curitem == 10 ) ? ( 1 )
    : ( curitem == 11 ) ? ( 1 )
    : ( curitem == 12 ) ? ( 1 )
    : ( curitem == 13 ) ? ( 1 )
    : ( curitem == 14 ) ? ( 1 )
    : ( curitem == 15 ) ? ( 1 )
    : ( curitem == 16 ) ? ( 1 )
    : ( curitem == 17 ) ? ( 1 ) /* Bad connection */
    : ( curitem == 18 ) ? ( 1 ) /* Hill */
    : ( curitem == 19 ) ? ( 1 ) /* King of tone */
    : ( curitem == 20 ) ? ( 1 ) /* Chebychev Even */
    : ( curitem == 21 ) ? ( 1 ) /* Chebychev Odd */
    : ( curitem == 22 ) ? ( 1 ) /* Gaussian */
    : ( curitem == 23 ) ? ( 1 ) /* Soft square */
    : ( curitem == 24 ) ? ( 1 ) /* Ripple */
    : ( curitem == 25 ) ? ( 1 ) /* Squeezy */
    : ( curitem == 26 ) ? ( 1 ) /* Slope clamper */
    : ( curitem == 27 ) ? ( 1 ) /* Sat man */
    : ( curitem == 28 ) ? ( 1 ) /* Sloper */
    : ( curitem == 29 ) ? ( 1 ) /* Weird overdrive */
    : ( curitem == 30 ) ? ( 1 ) /* Phase rotater */
    : ( curitem == 31 ) ? ( 1 ) /* Power */
    : ( curitem == 32 ) ? ( 1 ) /* Inflator clip */
    : ( curitem == 33 ) ? ( 1 ) /* Inflator 6 dB */
  );

/* Feed sample to FFT */
function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );

/* Initialize FFT windowing function */
function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 

/* Calculate current spectrum */
function calcFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, slope, yshift)
  local(buf1, buf2, buf3, yOut, i, prec, ty)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

/* Set location of a window */
function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

// Draws the basic box for the FFT
function drawBackface()
  instance(x, y, w, h)
  global(backface_color_r, backface_color_g, backface_color_b, backface_color_a,
         grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local()
  (
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
  );

// Draws the FFT Grid, frequency axis and dB axis
function drawGrid()  
  global(   fftSize, srate, gfx_x, gfx_y, grid_alpha, scaling, GRID_FONT,
             )
  instance(x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset,
           grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local(xx, i, wsc, N, xl)
  (    
    this.drawBackface();
    
    i = 0;
    wsc = w/log(1+fftSize*0.5-hzoffset);
    xl = x;
    gfx_y = y+h+2;
    
    gfx_setfont(GRID_FONT);
    loop(32,
      xx = x + log(i*fftSize/srate-hzoffset)*wsc;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(xx, y, xx, y+h);
      
      ( (xx - xl) > 40 ) ? (
        gfx_set( 1, 1, 1, 1 );
        gfx_x = xx+2;
        gfx_line(xx, y+h, xx, y+h+7);
        (i>999) ? (
          gfx_printf("%dk", .001*i);
        ) : (
          gfx_printf("%d", i);
        );
        xl = xx;
      );
      
      gfx_set( .2, .2, .2, grid_alpha );
      gfx_line(xx, y, xx, y+h);
      
      ( i < 100 ) ? (i += 10) :
      ( i < 500 ) ? (i += 100) :
      ( i < 1000 ) ? (i += 200) :
      ( i < 10000 ) ? (i += 1000) :
      ( i < 100000 ) ? (i += 10000);
    );
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    N = 8;
    xx = y;
    i = 0;
    gfx_measurestr("8", wsc, xl);
    loop(N,
      gfx_set( 1, 1, 1, 1 );
      gfx_x = x+w-20;
      gfx_y = xx-.5*xl;
      i > 0 ? gfx_printf("-%d", 4.41*i*floorLevel/N);
      
      gfx_set( .2, .2, .2, grid_alpha );
      gfx_line(x, xx+1, x+w, xx+1);
      
      xx += h/N;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(x, xx, x+w, xx);
      i += 1;
    );
  );
  
function drawLine(x1, y1, x2, y2)
  local(dx, dy, x, smooth)
  global(gfx_x, gfx_y)
  instance()
  (
    smooth = 1;
    x1 = floor(x1);
    x2 = floor(x2);
    gfx_x=x1;
    gfx_y=y1;
    x2 = floor(x2);
    y2 = floor(y2);
    
    smooth ? (
      (x2 - x1) > 4 ? (
        dx = 1.0/(x2-x1);
        dy = (y2 - y1)*6*dx;
        x = 0;
        loop(x2-x1,
          x2 = x1 + 1;
          y2 = y1 + dy * ( x - x*x );

          gfx_line(x1-1, y1-1, x2-1, y2-1, 1);          
          gfx_line(x1, y1-1, x2, y2-1, 1);
          gfx_lineto(x2,y2,1);
          x1 = x2;
          y1 = y2;
          x = x + dx;
        );
      ) : (
        gfx_line(x1, y1-1, x2, y2-1, 1);
        gfx_lineto(x2,y2,1);
      );
    ) : (
      gfx_line(x1, y1-1, x2, y2-1, 1);
      gfx_lineto(x2,y2,1); 
    );
  );

bandClickRange = 10;
overRange = 10;

function isOver(mx, my)
  instance(x, y, w, h)
  global(overRange)
  local()
  (
    ( ( mx >= (x-overRange) ) && ( mx <= (x+w+overRange) ) && ( my >= (y-overRange) ) && ( my <= (y+h+overRange) ) ) ? 1 : 0;
  );

function clamp(value, mini, maxi)
  local()
  global()
  (
    max(min(value,maxi),mini)
  );

function overRect(x, y, w, h, mx, my)
  local()
  global()
  (
    ( (mx > x) && (mx < (x+w) ) && (my > y) && (my < (y+h) ) )
  );

function pixelToWindowRatio(x_loc)
  instance(x, y, w, h, hzoffset)
  global(fftSize)
  local(lmin, wsc, hfft)
  (
    hfft  = 0.5*fftSize;
    lmin  = log(20/22050);
    wsc   = w/log(1+fftSize*0.5-hzoffset);
    
    1-log( (exp((x_loc)/wsc) + hzoffset)/hfft )/lmin
  );

function fftWindow_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, lx, ly, lcap, cap, thisUI, htime, hint,
           x_over, dragging, lastLeftClick
           x1, x2, x3, x4, x5,
           v1, v2, v3, v4, v5,
           h1, h2, h3, h4, h5, 
           c1, c2, c3, c4, c5,
           i1, i2, i3, i4, i5,
           F1hz, F2hz, F3hz, F4hz)
  global(dnoisefloor_freq, dsteps_fft, mouse_wheel, lastUI, fftSize,
         bandClickRange, cuts,
         Freq1, Freq2, Freq3, Freq4,
         bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5,
         sDrive1, sDrive2, sDrive3, sDrive4, sDrive5,
         sGain1, sGain2, sGain3, sGain4, sGain5,
         mute1, mute2, mute3, mute4, mute5,
         solo1, solo2, solo3, solo4, solo5,
         driveMin, driveMax, maxCuts,
         gainMin, gainMax, hinter.updateHintTime,
         selectedBand, gfx_x, gfx_y, srate )
  local(dx, dy, over, dys,
        F1, F2, F3, F4,
        leftClick, rightClick, doubleClick,
        cTime, mpos, shift, ctrl)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    leftClick   = ( mouse_cap & 1 == 1 && lcap & 1 == 0 );
    rightClick  = ( mouse_cap & 2 == 2 && lcap & 2 == 0 );
    doubleClick = 0;
    shift       = ( mouse_cap & 8 );
    ctrl        = ( mouse_cap & 4 );
    
    leftClick ? (
       time_precise(cTime);
       ( ( cTime - lastLeftClick ) < .25 ) ? (
          leftClick = 0;
          doubleClick = 1;
       );
       lastLeftClick = cTime;
    );
    
    x_over = -1;
    
    /*gfx_x = 0;
    gfx_y = 0;
    gfx_set(1,1,1,1);
    gfx_printf("%g", this.pixelToWindowRatio(mouse_x));*/
    
    F1 = Freq1;
    F2 = Freq1  + Freq2 * (1 - Freq1);
    F3 = F2     + Freq3 * (1 - F2);
    F4 = F3     + Freq4 * (1 - F3);
    
    F1hz = 0.5 * f_trafo(F1) * srate;
    F2hz = 0.5 * f_trafo(F2) * srate;
    F3hz = 0.5 * f_trafo(F3) * srate;
    F4hz = 0.5 * f_trafo(F4) * srate;
    
    ( cap == 4 && mouse_cap & 1 == 1 ) ? (
      dy = mouse_y - ly;
          
      dys = 100*dy/h;
      dragging == 1 ? ( sGain1 -= dys; sGain1 = clamp(sGain1, gainMin, gainMax); shift ? ( sDrive1 = clamp(sDrive1+dys, driveMin, driveMax); ) );
      dragging == 2 ? ( sGain2 -= dys; sGain2 = clamp(sGain2, gainMin, gainMax); shift ? ( sDrive2 = clamp(sDrive2+dys, driveMin, driveMax); ) );
      dragging == 3 ? ( sGain3 -= dys; sGain3 = clamp(sGain3, gainMin, gainMax); shift ? ( sDrive3 = clamp(sDrive3+dys, driveMin, driveMax); ) );
      dragging == 4 ? ( sGain4 -= dys; sGain4 = clamp(sGain4, gainMin, gainMax); shift ? ( sDrive4 = clamp(sDrive4+dys, driveMin, driveMax); ) );
      dragging == 5 ? ( sGain5 -= dys; sGain5 = clamp(sGain5, gainMin, gainMax); shift ? ( sDrive5 = clamp(sDrive5+dys, driveMin, driveMax); ) );  
    ) : ( cap == 3 && mouse_cap & 1 == 1 ) ? (
      dy = mouse_y - ly;
      
      dys = 100*dy/h;
      dragging == 1 ? ( sDrive1 -= dys; sDrive1 = clamp(sDrive1, driveMin, driveMax); shift ? ( sGain1 = clamp(sGain1+dys, gainMin, gainMax); ) );
      dragging == 2 ? ( sDrive2 -= dys; sDrive2 = clamp(sDrive2, driveMin, driveMax); shift ? ( sGain2 = clamp(sGain2+dys, gainMin, gainMax); ) );
      dragging == 3 ? ( sDrive3 -= dys; sDrive3 = clamp(sDrive3, driveMin, driveMax); shift ? ( sGain3 = clamp(sGain3+dys, gainMin, gainMax); ) );
      dragging == 4 ? ( sDrive4 -= dys; sDrive4 = clamp(sDrive4, driveMin, driveMax); shift ? ( sGain4 = clamp(sGain4+dys, gainMin, gainMax); ) );
      dragging == 5 ? ( sDrive5 -= dys; sDrive5 = clamp(sDrive5, driveMin, driveMax); shift ? ( sGain5 = clamp(sGain5+dys, gainMin, gainMax); ) );
      
    ) : ( cap == 2 && mouse_cap & 1 == 1 ) ? (
      // Dragging a band frequency
      dx = mouse_x - lx;
      
      dragging == 1 ? ( 
        F1 = this.pixelToWindowRatio(x1 - x + dx);
        Freq1 = clamp( F1, 0, 1 );
        slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-F1), 0, 1 ) );
        slider_automate( Freq1 );
      );
      dragging == 2 ? ( 
        F2 = this.pixelToWindowRatio(x2 - x + dx);
        Freq2 = clamp( (F2 - Freq1) / (1-Freq1), 0, 1 );
        F2 = Freq1  + Freq2 * (1 - Freq1);
        slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1) );
        slider_automate( Freq2 );
      );
      dragging == 3 ? ( 
        F3 = this.pixelToWindowRatio(x3 - x + dx);
        Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1 );
        F3 = F2     + Freq3 * (1 - F2);
        slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
        slider_automate( Freq3 );
      );
      dragging == 4 ? ( 
        F4 = this.pixelToWindowRatio(x4 - x + dx);
        slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
      );

    ) : ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dnoisefloor_freq -= .5*(mouse_y-ly);
      dnoisefloor_freq > 35 ? dnoisefloor_freq = 35;
      dnoisefloor_freq < -15 ? dnoisefloor_freq = -15;
    ) : ( 
      // Not already capped
      cap = 0;
      
      /* Toggle mute/solo */
      ( c1.isOver(mouse_x, mouse_y) == 1 ) ? (
        c1.over = 1;
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        leftClick  ? ( ctrl ? ( bypassBand1 = 1 - bypassBand1) : (
                       mute1 = 1-mute1; solo1 ? (mute1 = 1; solo1 = 0; selectedBand = 0; ); ); );
        rightClick ? ( solo1 = 1-solo1; selectedBand = 0; 
                       ((solo1 == 1) && (shift==0)) ? (solo2=solo3=solo4=solo5=0;); );
      ) : ( c2.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c2.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand2 = 1 - bypassBand2) : (
                       mute2 = 1-mute2; solo2 ? (mute2 = 1; solo2 = 0; selectedBand = 1;); ); );
        rightClick ? ( solo2 = 1-solo2; selectedBand = 1;
                       ((solo2 == 1) && (shift==0)) ? (solo1=solo3=solo4=solo5=0;); );
      ) : ( c3.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c3.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand3 = 1 - bypassBand3) : (
                       mute3 = 1-mute3; solo3 ? (mute3 = 1; solo3 = 0; selectedBand = 2; ); ); );
        rightClick ? ( solo3 = 1-solo3; selectedBand = 2;
                       ((solo3 == 1) && (shift==0)) ? (solo1=solo2=solo4=solo5=0;); );
      ) : ( c4.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c4.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand4 = 1 - bypassBand4) : (
                        mute4 = 1-mute4; solo4 ? (mute4 = 1; solo4 = 0; selectedBand = 3; ); ); );
        rightClick ? ( solo4 = 1-solo4; selectedBand = 3;
                       ((solo4 == 1) && (shift==0)) ? (solo1=solo2=solo3=solo5=0;); );
      ) : ( c5.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c5.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand5 = 1 - bypassBand5) : (
                       mute5 = 1-mute5; solo5 ? (mute5 = 1; solo5 = 0; selectedBand = 4; ); ); );
        rightClick ? ( solo5 = 1-solo5; selectedBand = 4;
                       ((solo5 == 1) && (shift==0)) ? (solo1=solo2=solo3=solo4=0;); );
        
      /* Drag frequency */
      ) : ( v1.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v1.over = 1;
        leftClick ? ( cap = 2; dragging = 1; );
        rightClick ? ( 
          Freq2 = ( Freq2 * ( 1 - Freq1 ) + ( Freq1 - 0 ) ) / ( 1 - 0 );
          remBand(0);
        );
      ) : ( v2.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v2.over = 1;
        leftClick ? ( cap = 2; dragging = 2; );
        rightClick ? ( 
          Freq3 = ( Freq3 * ( 1 - Freq2 ) + ( Freq2 - 0 ) ) / ( 1 - 0 );
          remBand(1);
        );
      ) : ( v3.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");    
        v3.over = 1;
        leftClick ? ( cap = 2; dragging = 3; );
        rightClick ? ( 
          Freq4 = ( Freq4 * ( 1 - Freq3 ) + ( Freq3 - 0 ) ) / ( 1 - 0 );
          remBand(2);
        );
      ) : ( v4.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v4.over = 1;
        leftClick ? ( cap = 2; dragging = 4; );
        rightClick ? ( remBand(3); );
      ) : ( v5.isOver(mouse_x, mouse_y) ) && ( cuts > 4 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");     
        v5.over = 1;
        leftClick ? ( cap = 2; dragging = 5; );
        rightClick ? ( remBand(4); );
      
      /* Drag drive */
      ) : ( h1.isOver(mouse_x, mouse_y) ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h1.over = 1;
        leftClick ? ( cap = 3; dragging = 1; selectedBand = 0; );
        doubleClick ? ( sDrive1 = 0; selectedBand = 0; shift ? sgain1 = 0; );
      ) : ( h2.isOver(mouse_x, mouse_y) ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h2.over = 1;
        leftClick ? ( cap = 3; dragging = 2; selectedBand = 1; );
        doubleClick ? ( sDrive2 = 0; selectedBand = 1; shift ? sgain2 = 0;);
      ) : ( h3.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h3.over = 1;
        leftClick ? ( cap = 3; dragging = 3; selectedBand = 2; );
        doubleClick ? ( sDrive3 = 0; selectedBand = 2; shift ? sgain3 = 0;);
      ) : ( h4.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h4.over = 1;
        leftClick ? ( cap = 3; dragging = 4; selectedBand = 3; );
        doubleClick ? ( sDrive4 = 0; selectedBand = 3; shift ? sgain4 = 0;);
      ) : ( h5.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");            
        h5.over = 1;
        leftClick ? ( cap = 3; dragging = 5; selectedBand = 4; );
        doubleClick ? ( sDrive5 = 0; selectedBand = 4; shift ? sgain5 = 0;);
        
      /* Drag gain */
      ) : ( i1.isOver(mouse_x, mouse_y) ) ? (
        hinter.updateHintTime("LMB + Drag - Modify post gain\nDouble LMB - Reset post gain to zero\nShift + LMB + Drag - Modify gain while reducing drive");
        i1.over = 1;
        leftClick ? ( cap = 4; dragging = 1; selectedBand = 0; );
        doubleClick ? ( sgain1 = 0; selectedBand = 0; shift ? sDrive1 = 0; );
      ) : ( i2.isOver(mouse_x, mouse_y) ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify post gain\nDouble LMB - Reset post gain to zero\nShift + LMB + Drag - Modify gain while reducing drive");
        i2.over = 1;
        leftClick ? ( cap = 4; dragging = 2; selectedBand = 1; );
        doubleClick ? ( sgain2 = 0; selectedBand = 1; shift ? sDrive2 = 0; );
      ) : ( i3.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify post gain\nDouble LMB - Reset post gain to zero\nShift + LMB + Drag - Modify gain while reducing drive");
        i3.over = 1;
        leftClick ? ( cap = 4; dragging = 3; selectedBand = 2; );
        doubleClick ? ( sgain3 = 0; selectedBand = 2; shift ? sDrive3 = 0; );
      ) : ( i4.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify post gain\nDouble LMB - Reset post gain to zero\nShift + LMB + Drag - Modify gain while reducing drive");
        i4.over = 1;
        leftClick ? ( cap = 4; dragging = 4; selectedBand = 3; );
        doubleClick ? ( sgain4 = 0; selectedBand = 3; shift ? sDrive4 = 0; );
      ) : ( i5.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify post gain\nDouble LMB - Reset post gain to zero\nShift + LMB + Drag - Modify gain while reducing drive");    
        i5.over = 1;
        leftClick ? ( cap = 4; dragging = 5; selectedBand = 4; );
        doubleClick ? ( sgain5 = 0; selectedBand = 4; shift ? sDrive5 = 0; );        
        
      /* Handle clicks within the bands (creating a new band or selecting a band) */
      ) : ( overRect( h1.x, y, h1.w, h, mouse_x, mouse_y ) ) ? (
        leftClick ? selectedBand = 0;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(0);
          mpos = this.pixelToWindowRatio(mouse_x);
          Freq2 = ( Freq2 * (1-0) + 0 - mpos ) / ( 1 - mpos );
          Freq1 = mpos;
        );
      ) : ( overRect( h2.x, y, h2.w, h, mouse_x, mouse_y ) && ( cuts > 0 )  ) ? (
        leftClick ? selectedBand = 1;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(1);
          mpos = this.pixelToWindowRatio(mouse_x);
          Freq3 = ( Freq3 * (1-Freq1) + Freq1 - mpos ) / ( 1 - mpos );
          Freq2 = ( mpos - Freq1 ) / ( 1 - Freq1 );
        );
      ) : ( overRect( h3.x, y, h3.w, h, mouse_x, mouse_y ) && ( cuts > 1 ) ) ? (
        leftClick ? selectedBand = 2;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(2);
          mpos = this.pixelToWindowRatio(mouse_x);
          F2 = Freq1  + Freq2 * (1 - Freq1);
          Freq4 = ( Freq4 * (1-F2) + F2 - mpos ) / ( 1 - mpos );
          Freq3 = ( mpos - F2 ) / ( 1 - F2 );
        );
      ) : ( overRect( h4.x, y, h4.w, h, mouse_x, mouse_y ) && ( cuts > 2 ) ) ? (
        leftClick ? selectedBand = 3;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(3);
          mpos = this.pixelToWindowRatio(mouse_x);
          F2 = Freq1  + Freq2 * (1 - Freq1);
          F3 = F2     + Freq3 * (1 - F2);
          Freq4 = ( mpos - F3 ) / ( 1 - F3 );
        );
      ) : ( overRect( h5.x, y, h5.w, h, mouse_x, mouse_y ) && ( cuts > 3 ) ) ? (
        leftClick ? selectedBand = 4;
      ) : (
        cap = 0;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
          cap = 1;
        );
      );
    );
    
    mouse_wheel > 0 && over ? lastUI = thisUI;
    
    abs(floor(mouse_wheel/240)) > 0 && over ?
    (
      dsteps_fft += floor(mouse_wheel/240);
      dsteps_fft > 8 ? dsteps_fft = 8;
      dsteps_fft < -4 ? dsteps_fft = -4;
      mouse_wheel = 0;
    );
    
    lx = mouse_x;
    ly = mouse_y;
    lcap = mouse_cap;
    
    over
  );

function drawFFT(fill, oversamplingFactor, r, g, b, a)
  global(scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate, gfx_mode, dsteps_fft )
  instance(hstep, x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset)
  local(copyval, stepsize, buf, i, ixsc, txl, tx, ty, wsc, fill, tx0, lx0, lx, ly, ty2, ly2, fill_slast, fill_slmin, cum, cumelem)
  (
    this.calcFFT();
 
    cum = -10000000;
    cumelem = 0;
    i = 0;
    ixsc = 0;
    wsc = w/log(1+fftsize*0.5-hzoffset);
    fill_slmin = y;

    buf = fftLoc + fftsize*0.5 - 2;
    stepsize = floor((4+dsteps_fft)*(1+scaling));
    copyval = buf[];
    loop( stepsize*200,
      (buf+=1)[] = copyval;
    );
     
    gfx_r = r;
    gfx_g = g;
    gfx_b = b;
    gfx_a = a;
 
    hstep = .5 * stepsize;
    buf = fftLoc;
    txl = x;
    lx = x;
    ly = y - max(buf[], -floorLevel)*h / floorLevel;
    buf += 1;
    loop(fftsize*0.5+stepsize*200,
      tx = floor(x + log(1.0+ixsc-hzoffset)*wsc);
      cum = max(cum, buf[]);
      cumelem += 1;
      
      ( (tx != txl) && (tx-txl > stepsize) && tx > x && i && ( tx < (x+w+stepsize) ) ) ? // 
      ( 
        ty = y - max(cum, -floorLevel)*h / floorLevel;
        //ty = y - log(cum)+100;
        txl = floor(tx);
        
        tx = min(tx, x+w);
        (fill) ? 
        (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0 ? 
          (
            gfx_triangle(lx0-hstep,max(y+h,ly),lx0-hstep,ly,tx0-1-hstep,ty,tx0-1-hstep,max(y+h,ty));
          ) : (
            tx0 > fill_slast ? 
            (
              fill_slast < h ? gfx_line(fill_slast,h,fill_slast,fill_slmin);
              fill_slmin=h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          
          fill_slast=tx0;        
        );
        
        (fill==0) ? (
          drawLine(lx-hstep, ly, tx-hstep, ty);
        );
        
        lx=tx; ly=ty; ly2=ty2; cum = -1000000; cumelem = 0;
      );
      
      buf+=1; i+=1; ixsc+=oversamplingFactor;
    );
  );
  
function drawLineFFT(peakLocation)
  global(fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate)
  instance(x, y, w, h, hzoffset)
  local(wsc, tx, base, i)
  (
    wsc = w/log(1+fftSize*0.5-hzoffset);
    base = fftSize*peakLocation;
    tx = floor(x + log(1.0+base-hzoffset)*wsc);
    drawLine(tx, y, tx, y+h);
  );
  
function updateBands()
  global(Freq1,   Freq2,   Freq3,   Freq4,
         Ceil1,   Ceil2,   Ceil3,   Ceil4,
         sDrive1, sDrive2, sDrive3, sDrive4, sDrive5,
         sGain1,  sGain2,  sGain3,  sGain4,  sGain5,
         Drive1,  Drive2,  Drive3,  Drive4,  Drive5,
         Gain1,   Gain2,   Gain3,   Gain4,   Gain5,
         fftSize, driveRange, driveMax, gainRange, gainMax)
  instance(x, y, w, h, hzoffset,
           x1,  x2,  x3,  x4,  x5,  /* Frequencies          */
           y1,  y2,  y3,  y4,  y5,  /* Drives               */
           g1,  g2,  g3,  g4,  g5   /* Post gains           */
           y1m, y2m, y3m, y4m, y5m, /* Drives post-mod      */
           g1m, g2m, g3m, g4m, g5m  /* Post gains post-mod  */
           )
  local(F1, F2, F3, F4, F5, wsc, hfft, lmin, irange, dmax)
  (
    F1 = Freq1;
    F2 = Freq1  + Freq2 * (1 - Freq1);
    F3 = F2     + Freq3 * (1 - F2);
    F4 = F3     + Freq4 * (1 - F3);
    
    hfft = 0.5*fftSize;
    lmin = log(20/22050);
    
    wsc = w/log(1+fftSize*0.5-hzoffset);
    x1 = ( x + log( hfft * exp( (1-F1) * lmin ) - hzoffset ) * wsc );
    x2 = ( x + log( hfft * exp( (1-F2) * lmin ) - hzoffset ) * wsc );
    x3 = ( x + log( hfft * exp( (1-F3) * lmin ) - hzoffset ) * wsc );
    x4 = ( x + log( hfft * exp( (1-F4) * lmin ) - hzoffset ) * wsc );
    x5 = ( x + log( hfft * exp( lmin ) - hzoffset ) * wsc );
       
    iRange = 1/driveRange;
    dmax = iRange * driveMax;
    
    y1 = y+h*(dmax-iRange*sDrive1);
    y2 = y+h*(dmax-iRange*sDrive2);
    y3 = y+h*(dmax-iRange*sDrive3);
    y4 = y+h*(dmax-iRange*sDrive4);
    y5 = y+h*(dmax-iRange*sDrive5);
    
    y1m = y+h*(dmax-iRange*Drive1);
    y2m = y+h*(dmax-iRange*Drive2);
    y3m = y+h*(dmax-iRange*Drive3);
    y4m = y+h*(dmax-iRange*Drive4);
    y5m = y+h*(dmax-iRange*Drive5);
    
    iRange = 1 / gainRange;
    dmax = iRange * gainMax;
    g1 = y+h*(dmax-iRange*sGain1);
    g2 = y+h*(dmax-iRange*sGain2);
    g3 = y+h*(dmax-iRange*sGain3);
    g4 = y+h*(dmax-iRange*sGain4);
    g5 = y+h*(dmax-iRange*sGain5);
    
    g1m = y+h*(dmax-iRange*Gain1);
    g2m = y+h*(dmax-iRange*Gain2);
    g3m = y+h*(dmax-iRange*Gain3);
    g4m = y+h*(dmax-iRange*Gain4);
    g5m = y+h*(dmax-iRange*Gain5);
  );

lineR = 1;
lineG = .9;
lineB = 1.0;
lineA = .95;
lineHighlightR = 0;
lineHighlightG = .7;
lineHighlightB = .5;
  
function drawGroupRect(x, y, w, h, r, g, b, a)  
  local()
  instance()
  global()
  (
    gfx_set(r, g, b, a);
    gfx_line(x, y, x+w, y);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y+h, x+w, y+h);
    
    gfx_set(r, g, b, a*.5);
    gfx_line(x, y+h+1, x+w, y+h+1);
    gfx_line(x+w+1, y, x+w+1, y+h);
  );  
  
function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function resetBuffer()
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    memset(scopebuffer, 0, scopebuffermax - scopebuffer + 1);
  );
  
function initBufferLen(scopebuffer_in, bufferlen)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffer + bufferlen;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );  
  
function draw_buffer(x, y, w, h, mul, fill)
  instance(scopeptr, scopebuffer, scopebuffermax)
  globals(gfx_x, gfx_y)
  local(len, scopeptr2, lx, ly, xx, dx, lptr, yy, lastx, lasty, isc, yref)
  (
    xx = x;
    len = scopebuffermax-scopebuffer;
    dx = floor(len/w);
    scopeptr2 = scopeptr;
    
    lptr = floor((scopeptr2)/dx)*dx;
    gfx_x = xx;
    gfx_y = y+h;
    isc = h;
    yref = y+h;
    ly = y+h;
    loop((scopebuffermax-scopeptr2)/dx - 1,
      yy = yref - h*min(1,lptr[]);
      
      lptr += dx;
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
    
    lptr = floor((scopebuffer)/dx)*dx;
    loop((scopeptr2 - scopebuffer)/dx - 1,
      lptr += dx;
      yy = yref - h*min(1,lptr[]);
      
      fill ? (
        gfx_triangle( xx-1, y+h,
                      xx-1, ly,
                      xx, y+h,
                      xx, yy);
      ) : (
        gfx_lineto(xx, yy);
      );
      
      ly = yy;
      xx += 1;
    );
  );  
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
  
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    c2 * (1.0-frac) + c1 * frac
  );
  
function readBufferNoInterp()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c1
  );  
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );  
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    memset( scopebuffer, 0, MAXBUFFERSIZE );
    scopeptr = scopebuffer;
  );   
  
  /* Linear phase DC blocker (WIP) */
  /* Unfinished but based on: "DC Blocker Algorithms", R. G. Lyons et al. */
  function init_blocker(dc_mem1, dc_mem2, dc_mem3, dc_mem4)
  local()
  instance(MA1, MA2, MA3, MA4, q1, q2, q3, q4, g1, g2, g3, g4)
  global()
  (
    MA1.initBuffer(dc_mem1, dc_mem1+2048);
    MA2.initBuffer(dc_mem2, dc_mem2+2048);
    MA3.initBuffer(dc_mem3, dc_mem3+2048);
    MA4.initBuffer(dc_mem4, dc_mem4+2048);
    
    MA1.resetBuffer();
    MA2.resetBuffer();
    MA3.resetBuffer();
    MA4.resetBuffer();
    
    q1 = q2 = q3 = q4 = g1 = g2 = g3 = g4 = 0;
    
    MA1.setOffset(511);
    MA2.setOffset(511);
    MA3.setOffset(511);
    MA4.setOffset(511);
  );
  
function fix_dc_strong(x)
local(f, x2, x3, x4, x5)
global()
instance(MA1, MA2, MA3, MA4, 
         q1, g1,
         q2, g2,
         q3, g3,
         q4, g4,
         D,
         )
(
  D = 1/512;

  MA1.updateBuffer(x);
  f = x - q1;
  g1 = f + g1;
  x2 = g1 * D;
    
  MA2.updateBuffer(x2);
  f = x2 - q2;
  g2 = f + g2;
  x3 = g2 * D;
  
  MA3.updateBuffer(x3);
  f = x3 - q3;
  g3 = f + g3;
  x4 = g3 * D;
  
  MA4.updateBuffer(x4);
  f = x4 - q4;
  g4 = f + g4;
  x5 = g3 * D;
    
  q1 = MA1.readBufferNoInterp();
  q2 = MA2.readBufferNoInterp();
  q3 = MA3.readBufferNoInterp();
  q4 = MA4.readBufferNoInterp();
  
  q1 - x5;
);  
  
function fancyLineV(x1, y1, x2, y2)
  local(dx)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dx = 5;
    
    x = x1 - .5*dx;
    y = y1;
    w = dx;
    h = y2-y1;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x-2, y, w+5, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x-4, y, w+9, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x-7, y, w+15, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x-10, y, w+20, h);
    );
  
    gfx_set(.2*lineR, .2*lineG, .2*lineB, lineA);
    gfx_rect(x, y, w, h);
    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dx = 3; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dx = 2; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(lineR, lineG, lineB, lineA);
    dx = 1; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    
    over ? ( 
      gfx_set(1,1,1,.4*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;
  );

function fancyLineH(x1, y1, x2, y2)
  local(dy)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dy = 5;    
    
    x = x1;
    y = y1 - .5*dy;
    w = x2-x1;
    h = dy;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-2, w, h+5);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-4, w, h+9);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x, y-7, w, h+15);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x, y-10, w, h+20);
    );  
  
    gfx_set(.2*lineR, .2*lineG, .2*lineB, lineA);
    gfx_rect(x, y, w, h);
    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dy = 3; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dy = 2; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(lineR, lineG, lineB, lineA);
    dy = 1; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    
    over ? ( 
      gfx_set(1,1,1,.7*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;    
  );
  
function fancyLineH2(x1, y1, x2, y2)
  local(dy)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dy = 5;    
    
    x = x1;
    y = y1 - .5*dy;
    w = x2-x1;
    h = dy;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-2, w, h+5);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-4, w, h+9);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x, y-7, w, h+15);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x, y-10, w, h+20);
    );  
  
    gfx_set(lineR, lineG, .5*lineB, lineA);
    dy = 1; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    
    over ? ( 
      gfx_set(1,1,1,.7*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;    
  );  
  
function dbDiff(s1, s2)
  local(bh, eps)
  global(spectrumIn.floorLevel)
  ( 
    eps = 0.000000000000001;
    bh = 20*(log10(max(s2,eps))-log10(max(s1,eps)))/(4.41*spectrumIn.floorLevel)
  );
  
function vGainMeter(x, y, h, diff)
  local(offs, ww, ystart, steps)
  global()
  (
    ww    = 12;
    offs  = 3;
    
    diff < (-(h-y)/h) ? diff = -(h-y)/h;
    
    gfx_set(1,0,0,.1);
    diff > 0 ? (
      y = y-h*diff;
      gfx_rect(x+offs, y, ww, h*diff);
    ) : (
      gfx_rect(x+offs, y, ww, -h*diff);
    );
    steps = abs(h*diff);
    
    gfx_set(.4,.8,0,1);
    loop(steps / 2,
      gfx_line(x+offs, y, x+ww+3, y);
      y = y + 2;
    );
  );
  
function modLine(yref, x1, ymod, x2)
(
  gfx_set(0,0,0,.2);
  
  (ymod > yref) ? (
    gfx_rect(x1, yref, x2-x1, ymod-yref);
  ) : (
    gfx_rect(x1, ymod, x2-x1, yref-ymod);
  );
);

function hzLabel(offset, label)
  local(lww, lhh, cy, dy2)
  global(gfx_x, gfx_y, hzLabelW, hzLabelH, lineR, lineG, lineB, lineA)
  instance(x, y, w, h, over)
  (
    cy = y + h - offset;
    
    gfx_measurestr("888888", hzLabelW, hzLabelH);

    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dy2 = 3; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dy2 = 2; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);
    gfx_set(lineR, lineG, lineB, lineA);
    dy2 = 1; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);

    gfx_set( 1, 1, 1, .8 );
    gfx_rect(x-.5*hzLabelW-1, cy-1, hzLabelW+2, hzLabelH+2);
    
    gfx_set( 0, 0, 0, 1 );
    gfx_rect(x-.5*hzLabelW, cy, hzLabelW, hzLabelH);

    sprintf(19, "%d", label);
    gfx_measurestr(19, lww, lhh);
    gfx_set( 1, 1, 1, 1 );    
    gfx_x = x - .5 *lww;
    gfx_y = cy;
    gfx_printf(19, label);
  );

function drawBands()
  global(Cuts, stest, scaling,
           mute1, mute2, mute3, mute4, mute5,
           solo1, solo2, solo3, solo4, solo5,
           bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5,
           selectedBand, 
           filterBank.getBandPre, filterBank.getBandPost )
  instance(xc, dx, x, y, w, h, 
           x1, x2, x3, x4, x5, // Band frequency screen positions
           y1, y2, y3, y4, y5, // Band drive positions
           v1, v2, v3, v4, v5, // Frequency handles
           h1, h2, h3, h4, h5, // Drive handles
           c1, c2, c3, c4, c5, // Circle handles
           g1, g2, g3, g4, g5, // Gain meters
           i1, i2, i3, i4, i5, // Gain handles
           y1m, y2m, y3m, y4m, y5m, /* Drives post-mod      */
           g1m, g2m, g3m, g4m, g5m  /* Post gains post-mod  */
           F1Hz, F2Hz, F3Hz, F4Hz, F5Hz,
           x_over)
  local(hz_offset)
  (
    xc = x;
    dx = 5;
    while(xc<x+w) (
      gfx_set(0,0,0,1);
      gfx_line(xc, y+.6*h+1, xc+dx, y+.6*h+1);
      gfx_line(xc, y+.6*h-1, xc+dx, y+.6*h-1);
      gfx_set(0.6,0.6,0.6,1);
      gfx_line(xc, y+.6*h, xc+dx, y+.6*h);
      xc = xc + 2*dx;
    );
    
    xc = x;
    dx = 5;
    gfx_set(0,0,0,.3);
    gfx_line(x, y+.3*h, x+w, y+.3*h);
    gfx_line(x, y+.3*h+2, x+w, y+.3*h+2);
 
    hz_offset = 50*(1+scaling);
    (Cuts > 0) ? (
      gfx_set(1,1,1,1); v1.fancyLineV(x1, y, x1, y+h);
      v1.hzLabel(hz_offset, F1hz);
      g1.vGainMeter(x, y1, h, dbDiff(filterBank.getBandPre(0), filterBank.getBandPost(0)));
    );
    (Cuts > 1) ? (
      gfx_set(1,1,1,1); v2.fancyLineV(x2, y, x2, y+h);
      v2.hzLabel(hz_offset, F2hz);
      g2.vGainMeter(x1, y2, h, dbDiff(filterBank.getBandPre(1), filterBank.getBandPost(1)));
    );
    (Cuts > 2) ? (
      gfx_set(1,1,1,1); v3.fancyLineV(x3, y, x3, y+h);
      v3.hzLabel(hz_offset, F3hz);
      g3.vGainMeter(x2, y3, h, dbDiff(filterBank.getBandPre(2), filterBank.getBandPost(2)));
    );
    (Cuts > 3) ? (
      gfx_set(1,1,1,1); v4.fancyLineV(x4, y, x4, y+h);
      v4.hzLabel(hz_offset, F4hz);
      g4.vGainMeter(x3, y4, h, dbDiff(filterBank.getBandPre(3), filterBank.getBandPost(3)));
    );
    (Cuts > 4) ? (
      gfx_set(1,1,1,1); v5.fancyLineV(x5, y, x5, y+h);
      v5.hzLabel(hz_offset, F5hz);
      g5.vGainMeter(x4, y5, h, dbDiff(filterBank.getBandPre(4), filterBank.getBandPost(4)));
    );
    
    gfx_rect(x_over-3, y, 5, h);
    ( Cuts == 0 ) ? (
       modLine(y1, x, y1m, x+w-2);
       h1.fancyLineH(x, y1, x+w-2, y1);
       i1.fancyLineH2(x, g1, x+w-2, g1);
       c1.fancyCircle(x + .5*w, y1, 0, mute1, solo1, bypassBand1);
       stest = filterBank.getBandPre(0);
    ) : ( Cuts == 1 ) ? (
       modLine(y1, x,  y1m, x1-2);
       h1.fancyLineH(x,  y1, x1-2, y1);
       i1.fancyLineH2(x,  g1, x1-2, g1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       modLine(y2, x1, y2m, x+w-2);
       h2.fancyLineH(x1, y2, x+w-2, y2);
       i2.fancyLineH2(x1, g2, x+w-2, g2);
       c2.fancyCircle(x1 + .5*(w-x1), y2, 0, mute2, solo2, bypassBand2);
    ) : ( Cuts == 2 ) ? (
       modLine(y1, x,  y1m, x1-2);
       h1.fancyLineH(x,  y1, x1-2, y1);
       i1.fancyLineH2(x,  g1, x1-2, g1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       modLine(y2, x1, y2m, x2-2);
       h2.fancyLineH(x1, y2, x2-2, y2);
       i2.fancyLineH2(x1, g2, x2-2, g2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       modLine(y3, x2, y3m, x+w-2);
       h3.fancyLineH(x2, y3, x+w-2, y3);
       i3.fancyLineH2(x2, g3, x+w-2, g3);       
       c3.fancyCircle(x2 + .5*(w-x2), y3, 0, mute3, solo3, bypassBand3);
    ) : ( Cuts == 3 ) ? (
       modLine(y1, x,  y1m, x1-2);
       h1.fancyLineH(x,  y1, x1-2, y1);
       i1.fancyLineH2(x,  g1, x1-2, g1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       modLine(y2, x1, y2m, x2-2);
       h2.fancyLineH(x1, y2, x2-2, y2);
       i2.fancyLineH2(x1, g2, x2-2, g2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       modLine(y3, x2, y3m, x3-2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       i3.fancyLineH2(x2, g3, x3-2, g3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3, bypassBand3);
       modLine(y4, x3, y4m, x+w-2);
       h4.fancyLineH(x3, y4, x+w-2, y4);
       i4.fancyLineH2(x3, g4, x+w-2, g4);
       c4.fancyCircle(x3 + .5*(w-x3), y4, 0, mute4, solo4, bypassBand4);
    ) : ( Cuts == 4 ) ? (
       modLine(y1, x,  y1m, x1-2);
       h1.fancyLineH(x,  y1, x1-2, y1);
       i1.fancyLineH2(x,  g1, x1-2, g1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       modLine(y2, x1, y2m, x2-2);
       h2.fancyLineH(x1, y2, x2-2, y2);
       i2.fancyLineH2(x1, g2, x2-2, g2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       modLine(y3, x2, y3m, x3-2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       i3.fancyLineH2(x2, g3, x3-2, g3);       
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3, bypassBand3);
       modLine(y4, x3, y4m, x4-2);
       h4.fancyLineH(x3, y4, x4-2, y4);
       i4.fancyLineH2(x3, g4, x4-2, g4);       
       c4.fancyCircle(x3 + .5*(x4-x3), y4, 0, mute4, solo4, bypassBand4);
       modLine(y5, x4, y5m, x+w-2);
       h5.fancyLineH(x4, y5, x+w-2, y5);
       i5.fancyLineH2(x4, g5, x+w-2, g5);       
       c5.fancyCircle(x4 + .5*(w-x4), y5, 0, mute5, solo5, bypassBand5);
    );
    
    selectedBand == 0 ? gfx_muladdrect( h1.x, y, h1.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 1 ? gfx_muladdrect( h2.x, y, h2.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 2 ? gfx_muladdrect( h3.x, y, h3.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 3 ? gfx_muladdrect( h4.x, y, h4.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 4 ? gfx_muladdrect( h5.x, y, h5.w, h, 1, 1, 1, .6, .05, .05, .105 );

  );  
  
function initSpectrum(memoryOffset, fftSize, srate)
  global(newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 20*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );
  
  
  function F0(x, em2x)
  local()
  global()
  instance()
  (
    x - log(2/(1 + em2x))
  );
  
  function tanh_prec(x, em2x)
  local() 
  global()
  instance()
  (
    (2/(1+em2x))-1
  );
  
  function tanh(x)
  local()
  global()
  instance()
  (
    (2/(1+exp(-2*x)))-1
  );
  
  function qtanh(x)
  local(a, b, x2)
  global()
  instance()
  (
    (abs(x) > 4.97) ? (
      sign(x)
    ) : (
      x2 = x * x;
      a = x * (135135.0 + x2 * (17325.0 + x2 * (378.0 + x2)));
      b = 135135.0 + x2 * (62370.0 + x2 * (3150.0 + x2 * 28.0));
      a / b
    );
  );
  
  function antialiased_tanh_rect(x)
  local(eps, em2x, F0_xn)
  global(slider4)
  instance(antialias, F0_xnm1, xnm1,diff)
  (
    354 < abs(x) ? (
      antialias = sign(x);
      x         = antialias * 354;
      F0_xn     = 354 - log(2);
    ) : (
      em2x      = exp(-2*x);
      F0_xn     = F0(x, em2x);
      diff      = ( x - xnm1 );
      eps       = 0.0000000001;
      antialias = (abs(diff) > eps) ? ( F0_xn - F0_xnm1 ) / diff : tanh(.5*(x+xnm1));
    );
    
    F0_xnm1   = F0_xn;
    xnm1      = x;

    antialias
  );
  
  // Approximation to W(exp(x))
  function lambertExpApprox(x)  
    local(ex, approx, v, c, p, t, f)
    global()
    instance()
    (
      ex = exp(x);
      
      approx = sqrt(2*$e*ex + 2) - 1;
      v = log(ex + 1);
      v = v - log(v);
      c = abs(ex + 1/$e);
      c = (c > 1.45);
      approx = (1 - c)*approx + c*v;
      loop(2,
        p = exp(approx);
        t = approx*p - ex;
        t = t/(p*(approx + 1) - 0.5*(approx + 2.0)*t/(approx + 1));
        approx = approx - t;
      );
      
      approx
    );
    
  function folder_init(cutoff, reso)
    local(RL, Vt, iVt)
    instance(dc_scum, alpha, beta, delta)
    global()
    (
      RL      = (8000+49000*cutoff);
      iVt     = 38.663779771110423755026291370244; //1/.025864;
      dc_scum = .1 * reso;
      
      alpha   = 0.0001333333333333333397 * RL;
      beta    = (alpha + 1) * iVt;
      delta   = log( RL * .00000000000000001 * iVt );
    );      
    
  function folder_eval(sample)
    local(lambda)
    instance(alpha, beta, delta)
    global()
    (
      lambda = sign(sample);
      .025864 * lambda * lambertExpApprox( lambda * beta * sample + delta ) - alpha * sample
    );    
  
  function resetBandMeter()
  local()
  global()
  instance(in, pre, post)
  (
    in = pre = post = 0;
  );
  
  function kot_lut(icOut)
  global(kot_LUT_x, kot_LUT_y)
  local(x1, x2, y1, y2, ptr, ptr2)
  (
    icOut > 0.0031 ?
    (
      4;
    ) : (
      ptr   = kot_LUT_x;
      ptr2  = kot_LUT_y;
      while( icOut > ptr[] )
      (
        ptr += 1;
        ptr2 += 1;
      );
            
      y2 = ptr2[];
      y1 = (ptr2-1)[]; 
      x2 = ptr[];
      x1 = (ptr-1)[];
            
      ((y2-y1) / (x2-x1)) * (icOut - x1) + y1;
    );
  );
  
  function sinh(x)
  local(ex)
  (
    ex = exp(x);
    .5 * ( exp(x) - 1/ex )
  );
  
  function cosh(x)
  local(ex)
  (
    ex = exp(x);
    .5 * ( exp(x) + 1/ex )
  );
  
  function inflator_clip(in, modifier)
  local(s0, s0_2, s0_3, a, b, c, d)
  global()
  (
    a = modifier + 1.0;
    b = 1.0 - modifier - modifier;
    c = modifier - 1.0;
    d = 0.25 * modifier * modifier - 0.5 * modifier + 0.25;
    
    s0 = abs(in);
    s0 = s0 > 1.0 ? 1.0 : s0;
    s0_2 = s0 * s0;
    s0_3 = s0_2 * s0;
    s0 = a * s0 + b * s0_2 + c * s0_3 - d * (s0_2 - 2.0 * s0_3 + s0_2 * s0_2);
    s0 *= sign(in);
    s0
  );
  
  function inflator_6db(in, modifier)
  local(s0, s0_2, s0_3, a, b, c, d)
  global()
  (
    a = modifier + 1.0;
    b = 1.0 - modifier - modifier;
    c = modifier - 1.0;
    d = 0.25 * modifier * modifier - 0.5 * modifier + 0.25;
  
    s0 = abs(in);
    s0_2 = s0 * s0;
    s0_3 = s0_2 * s0;
    s0 = (s0 >= 2.0) ? (0.0) : (s0 > 1.0) ? (2.0 * s0 - s0_2) : (a * s0 + b * s0_2 + c * s0_3 - d * (s0_2 - 2.0 * s0_3 + s0_2 * s0_2));
    s0 *= sign(in);
    s0
  );
  
  /* TO DO: Merge crossovers with control */
  function processBand(drive, pan, play, mode, modifier, fbl, fbr)
  global(antialiased_tanh_rect, side, bjt, overSampling, srate, logten005, legacy_pan)
  instance(l, r, inL, inR, in, pre, post, t, panl, panr, preampl, preampr, ldrive, lpan, lastl, lastr, ttime, lastrin, lastlin)
  local(inv_ceiling, factor, depth, idepth, pre_l, pre_r,
        tl, tr, t2l, t2r, t3l, t3r, t4r, t4l, ll, rr, dc_corr, loc, tc, g, dg, dt, dl, dr, dl2, dr2, alpha, beta, intl, intr, ddl, ddr)
  (
    play ? (
      in = max(in, abs(inL+inR));
      
      l = inL;
      r = inR;

      side ? (
        tc = l;
        l = (l + r)*.5;
        r = (tc - r)*.5;
      );
      
      (ldrive != drive) ? (
        preampl = exp(logten005*drive);
        preampr = exp(logten005*drive);
        ldrive = drive;
      );
      
      (lpan!=pan) ? (
        //panl = cos($pi*(pan*.5+.5)/2)*1.4142135623730950488016887242097;
        //panr = sin($pi*(pan*.5+.5)/2)*1.4142135623730950488016887242097;
        panl = cos($pi*(pan*.25+.25))*1.4142135623730950488016887242097;
        panr = sin($pi*(pan*.25+.25))*1.4142135623730950488016887242097;
        lpan = pan;
      );
      
      pre_l = l;
      pre_r = r;
      
      l *= panl * preampl;
      r *= panr * preampr;
      
      l += fbl;
      r += fbr;
      
      pre = max(pre, abs(l+r));

      //l = this.ch0.antialiased_tanh_rect(l);
      //r = this.ch1.antialiased_tanh_rect(r);
      ( mode == 0 ) ? (
        /* Tanh */
        l = tanh(l);
        r = tanh(r);
      ) : ( mode == 1 ) ? (
        /* Tanh-like */
        l = .5*l;
        r = .5*r;
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      ) : ( mode == 2 ) ? (
        /* Smooth */
        l = 1.399 * l;
        r = 1.399 * r;
        l = sign(l)*(1-exp(-abs(l)));
        r = sign(r)*(1-exp(-abs(r)));
      ) : ( mode == 3 ) ? (
        /* Asymmetric */
        l = l - (1-side)*modifier;
        r = r - (1-side)*modifier;
        
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        dc_corr = 0;
        
        t = l*l;
        l = l - 0.17 * t - 0.17 * t*l + dc_corr;
        
        t = r*r;
        r = r - 0.17 * t - 0.17 * t*r + dc_corr;
      ) : ( mode == 4 ) ? (
        /* Rapid saturation */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        t = l*l;
        l = 1.23950091*l/(1+0.89322598*abs(l)-2.07339946*t+1.43974791*abs(l)*t);
        t = r*r;
        r = 1.23950091*r/(1+0.89322598*abs(r)-2.07339946*t+1.43974791*abs(r)*t);
      ) : ( mode == 5 ) ? (
        /* Almost linear */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        t = l*l;
        l = 0.55054001*l/(1-1.27438856*abs(l)+0.84846189*t);
        t = r*r;
        r = 0.55054001*r/(1-1.27438856*abs(r)+0.84846189*t);
      ) : ( mode == 6 ) ? (
        /* Crossover distortion */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        // Amount of plateau
        factor = -15.09587456 + 11*modifier;
        
        t = l*l;
        l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-exp(factor*t));
        t = r*r;
        r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-exp(factor*t));
      ) : ( mode == 7 ) ? (
        /* Heavy crossover distortion */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        factor = -15.09587456 + 11*modifier;
        t = l*l;
        l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-sin(15*t)*exp(factor*t));
        t = r*r;
        r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-sin(15*t)*exp(factor*t));
      ) : ( mode == 8 ) ? (
        /* Very heavy crossover distortion */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        factor = -15.09587456 + 11*modifier;
        t = l*l;
        l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-sin(45*t*t)*sin(5*l)*exp(factor*t));
        t = r*r;
        r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-sin(45*t*t)*sin(5*r)*exp(factor*t));
      ) : ( mode == 9 ) ? (
        /* Sine */
        l = sin(1.5*l*(1+2*modifier));
        r = sin(1.5*r*(1+2*modifier));
      ) : ( mode == 10 ) ? (
        /* Octaver up */
        l = 2*abs(l)-1+modifier;
        r = 2*abs(r)-(1-side)*(1-modifier);
        l = 1.399 * l;
        r = 1.399 * r;
        l = sign(l)*(1-exp(-abs(l)));
        r = sign(r)*(1-exp(-abs(r)));
      ) : ( mode == 11 ) ? (
        /* Wavefolder */
        this.ch0.folder_init(0, 1);
        this.ch1.folder_init(0, 1);
        l = -this.ch0.folder_eval(l+modifier);
        t = l*l;
        l = l / (1+t*t);
        r = -this.ch1.folder_eval(r+(1-side)*modifier);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 12 ) ? (
        /* Serge wavefolder */
        l = .5*l;
        r = .5*r;
        this.ch0.folder_init(modifier, 1);
        this.ch1.folder_init(modifier, 1);
        l = -this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        t = l*l;
        l = l / (1+t*t);
        r = -this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 14 ) ? (
        /* Wavenuker */
        l = .5*l/(1+l);
        r = .5*r/(1+r);
        this.ch0.folder_init(modifier, 1);
        this.ch1.folder_init(modifier, 1);
        l = -this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        t = l*l;
        l = l / (1+t*t);
        r = -this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 13 ) ? (
        /* Asymmetric Chunker */
        l = .5*l;
        r = .5*r;
        this.ch0.folder_init(modifier, 0);
        this.ch1.folder_init(modifier, 0);
        l = l-this.ch0.folder_eval(l);
        l = l+this.ch0.folder_eval(l*l);
        t = l*l;
        l = l / (1+t*t);
        r = r-this.ch0.folder_eval(r);
        r = r+this.ch0.folder_eval(r*r);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 15 ) ? (
        /* Bitcrusher */
        depth   = 16 - pow(modifier, .25)*15.5;
        idepth  = 1/depth;
        l = floor( l * depth + 0.5 ) * idepth;
        r = floor( r * depth + 0.5 ) * idepth;
        
        l = .5*l;
        r = .5*r;
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      ) : ( mode == 16 ) ? (
        /* Bitcrusher */
        depth   = 2;
        idepth  = 1/depth;
        l = sin(5*(.3+modifier)*l);
        r = sin(5*(.3+modifier)*r);
        l = floor( l * depth + 1.5*modifier - .5 ) * idepth;
        r = floor( r * depth + 1.5*modifier - .5 ) * idepth;
        
        l = .5*l;
        r = .5*r;
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      ) : ( mode == 17 ) ? (
        /* Bad connection */
        tl = tanh(1.5*l);
        tr = tanh(1.5*r);
        l = (abs(l*20^(1-modifier))>.5) * tl*tl*tl;
        r = (abs(r*20^(1-modifier))>.5) * tr*tr*tr;
      ) : ( mode == 18 ) ? (
        /* Hill */
        ( modifier >= 0.5 ) ? (
          t = 1 + 8 * (modifier-.5);
        ) : (
          t = .75 + .5 * modifier;
        );

        tl = pow(abs(l), t);
        tr = pow(abs(r), t);
        l = (tl/(1+tl)) * sign(l);
        r = (tr/(1+tr)) * sign(r);
      ) : ( mode == 19 ) ? (
        /* KOT */
        l = sign(l)*(kot_lut(.000005*(abs(l)*(1-modifier)+modifier*l*l)));
        r = sign(r)*(kot_lut(.000005*(abs(r)*(1-modifier)+modifier*r*r)));
      ) : ( mode == 20 ) ? (
        /* Chebychev odd
        /* t2l and t2r contain current chevychev polynomial */
        /* tl and tr contains the current tally */
        l = l;
        r = r;
        t3l = 1;
        t3r = 1;
        ll = t4l = 0;
        rr = t4r = 0;
        
        /* Recursive formulation of chebychev poly's */
        modifier = 1-modifier;
        modifier = modifier*modifier;
        modifier = 1-modifier;
        modifier = 10*modifier;
        modifier = modifier + 2;
        loop(modifier,
          t2l = l * t3l - t4l;
          t2r = r * t3r - t4r;
          
          t4l = t3l;
          t4r = t3r;
          t3l = t2l;
          t3r = t2r;
          
          loc = (modifier-floor(modifier));
          tl = t2l*loc + (1-loc)*ll;
          tr = t2r*loc + (1-loc)*rr;
          
          t2l = l * t3l - t4l;
          t2r = r * t3r - t4r;
          
          t4l = t3l;
          t4r = t3r;
          t3l = t2l;
          t3r = t2r;
          
          ll = t4l;
          rr = t4r;
        );
        
        l = tanh(tl);
        r = tanh(tr);
 
      ) : ( mode == 21 ) ? (
        /* Chebychev even
        /* t2l and t2r contain current chevychev polynomial */
        /* tl and tr contains the current tally */
        l = l;
        r = r;
        t3l = 1;
        t3r = 1;
        ll = t4l = 0;
        rr = t4r = 0;
        
        /* Recursive formulation of chebychev poly's */
        modifier = 1-modifier;
        modifier = modifier*modifier;
        modifier = 1-modifier;
        modifier = 10*modifier;
        modifier = modifier + 2;
        loop(modifier,
          t2l = l * t3l - t4l;
          t2r = r * t3r - t4r;
          
          t4l = t3l;
          t4r = t3r;
          t3l = t2l;
          t3r = t2r;          
          
          ll = t4l;
          rr = t4r;
          
          t2l = l * t3l - t4l;
          t2r = r * t3r - t4r;
          
          t4l = t3l;
          t4r = t3r;
          t3l = t2l;
          t3r = t2r;
        );
        
        loc = (modifier-floor(modifier));
        tl = t2l*loc + (1-loc)*ll;
        tr = t2r*loc + (1-loc)*rr;
        
        loc = 4*((modifier*.5)-floor(modifier*.5));
        loc >= 2 ?
        (
          t = 2-(loc-1);
        ) : (
          t = (loc-1);
        );

        l = tanh((tl-t+.5*l));
        r = tanh((tr-t+.5*r));
 
      ) : ( mode == 22 ) ?
      (
        /* Gaussians */
        tl = l-1;
        tr = r-1;
        t3l = l+1;
        t3r = r+1;
        t2l = -.5/(1-.99*modifier);
        l=exp(tl*tl*t2l) - exp(t3l*t3l*t2l);
        r=exp(tr*tr*t2l) - exp(t3r*t3r*t2l);
      ) : ( mode == 23 ) ?
      (
        /* Soft square */
        l = clamp(l,-1,1);
        r = clamp(r,-1,1);
        
        tl = l-1;
        tr = r-1;
        t3l = l+1;
        t3r = r+1;
        t2l = -.5/(.5-.499*modifier);
        l=exp(tl*tl*t2l) - exp(t3l*t3l*t2l);
        r=exp(tr*tr*t2l) - exp(t3r*t3r*t2l);
      ) : ( mode == 24 ) ?
      (
        /* Ripple */
        l = clamp(l,-2,1);
        r = clamp(r,-2,1);
        
        t4l = modifier+1;
        tl = abs(l+sin(t4l*l))-l;
        tr = abs(r+sin(t4l*r))-l;
        t3l = abs(l+cos(t4l*l))+r;
        t3r = abs(r+cos(t4l*r))+r;
        t2l = -.5/(.5-.4*modifier);
        l=tanh((exp(tl*tl*t2l) - exp(t3l*t3l*t2l))*abs(l));
        r=tanh((exp(tr*tr*t2l) - exp(t3r*t3r*t2l))*abs(r));
      ) : ( mode == 25 ) ? (
        /* Warm hug */
        l = tanh(l - modifier*tanh(6*l+modifier) + tanh(4*modifier*l-modifier));
        r = tanh(r - modifier*tanh(6*r+(1-side)*modifier) + tanh(4*modifier*r-(1-side)*modifier));
        
        // Flattened:
//        l = -1 + 2/(exp(-2*l + 2*modifier*(-1 + 2/(exp(-12*l - 2*modifier) + 1)) + 2 - 4/(exp(-8*l*modifier + 2*modifier) + 1)) + 1);
//        r = -1 + 2/(exp(2*modifier*(-1 + 2/(exp(-2*modifier*(1 - side) - 12*r) + 1)) - 2*r + 2 - 4/(exp(-8*modifier*r + 2*modifier*(1 - side)) + 1)) + 1);
      ) : ( mode == 26 ) ? (
        tl = l;
        tr = r;
        t2l = 44100*overSampling/(srate);
        l = tanh(lastl+.3*tanh((150+5000*modifier)*(l-lastl)*t2l));
        r = tanh(lastr+.3*tanh((150+5000*modifier)*(r-lastr)*t2l));
        
        lastl = tl;
        lastr = tr;
      ) : ( mode == 27 ) ? (
        l = 8*l;
        r = 8*r;
        
        modifier = 5-5*modifier;
         
        loop(6,
          t3r = l - modifier * lastl;
          t2r = .6*atan(t3r);
          dg = 1 + .6*modifier / ( 1 + t2r*t2r );
          g = lastl - t2r;
          lastl = lastl - g / dg;
        );
        l = lastl;

        loop(6,
          t3r = r - modifier * lastr;
          t2r = .6*atan(t3r);
          dg = 1 + .6*modifier / ( 1 + t2r*t2r );
          g = lastr - t2r;
          lastr = lastr - g / dg;
        );
        r = lastr;
        
      ) : ( mode == 28 ) ? (
        tl = l;
        tr = r;
        t2l = 44100*overSampling/(srate);
        
        t3l = (l-lastl)*t2l;
        t3r = (r-lastr)*t2l;
        l = tanh(l/(1+130000*modifier*t3l*t3l));
        r = tanh(r/(1+130000*modifier*t3r*t3r));
        
        lastl = tl;
        lastr = tr;
      )  : ( mode == 29 ) ? (
        /* Weird overdrive */
        t2l = .2+(1-.5*modifier);
        l=tanh(10*l)-exp(-10*(l-t2l)*(l-t2l))+exp(-10*(l+t2l)*(l+t2l));

        r=tanh(10*r)-exp(-10*(r-t2l)*(r-t2l))+exp(-10*(r+t2l)*(r+t2l));
      ) : ( mode == 30 ) ? (
        /* Phaserdrive */
        this.lF.init_AP(modifier, 1);
        this.rF.init_AP(modifier, 1);
        this.lF2.init_AP(modifier, .75);
        this.rF2.init_AP(modifier, .75);
        
        t2l = (1/preampl);
        t2r = (1/preampl);
        l = t2l*atan(l);
        r = t2r*atan(r);
        
        l = this.lF.eval_AP(l);
        r = this.rF.eval_AP(r);
        
        l = t2l*atan(preampl*l);
        r = t2r*atan(preampr*r);

        l = this.lF2.eval_AP(l);
        r = this.rF2.eval_AP(r);

        l = atan(preampl*l);
        r = atan(preampr*r);
      ) : ( mode == 31 ) ? (
        /* Power */
        dt = 44100/overSampling/srate;
        
        // Find zero crossings
        /* dl contains spikes corresponding to direction changes */
        l = tanh(70*(l-.005));
        dl = ((l - lastlin))*overSampling;
        lastlin = l;
        
        r = tanh(70*(r-.005));
        dr = ((r - lastrin))*overSampling;
        lastrin = r;
        
        // Determine the slow and the fast response
        lastl = lastl + .2*modifier*(dl-lastl)/overSampling;
        intl = intl + .01625*dt*(.25*l-intl)*(1+5.5*abs(intl));

        lastr = lastr + .2*modifier*(dr-lastr)/overSampling;
        intr = intr + .01625*dt*(.25*r-intr)*(1+5.5*abs(intr));
        
        l = (2*lastl+intl);
        r = (2*lastr+intr);
      ) : ( mode == 32 ) ? (
        // Clipped inflator
        l = inflator_clip(l, modifier);
        r = inflator_clip(r, modifier);
      ) : ( mode == 33 ) ? (
        // Non-clipped inflator
        l = inflator_6db(l, modifier);
        r = inflator_6db(r, modifier);
      ) : (
        l = 0;
        r = 0;
      );
      
      !legacy_pan ? (
        l = l * panl + (1 - panl) * pre_l;
        r = r * panr + (1 - panr) * pre_r;
      );
      
      side ? (
        tc = l;
        l = (l + r);
        r = (tc - r);
      );
      
      post = max(post, abs(l+r));
    ) : (
      l = 0;
      r = 0;
    );
  ); 
  
  function processBands()
  local(BW2)
  global( Drive1,    Drive2,    Drive3,     Drive4,     Drive5, 
          DrivePan1, DrivePan2, DrivePan3,  DrivePan4,  DrivePan5,
          Gain1,     Gain2,     Gain3,      Gain4,      Gain5,
          DryWet1,   DryWet2,   DryWet3,    DryWet4,    DryWet5,
          play1,     play2,     play3,      play4,      play5,
          Mode1,     Mode2,     Mode3,      Mode4,      Mode5,
          Feedback1, Feedback2, Feedback3,  Feedback4,  Feedback5,
          Modifier1, Modifier2, Modifier3,  Modifier4,  Modifier5,
          fbToggle1, fbToggle2, fbToggle3,  fbToggle4,  fbToggle5,
          logten005,
          cuts )
  instance(b1, b2, b3, b4, b5, F1, F2, F3, F4, F5, 
           bufferL1, bufferL2, bufferL3, bufferL4, bufferL5, 
           bufferR1, bufferR2, bufferR3, bufferR4, bufferR5,
           fbL1,     fbL2,     fbL3,     fbL4,     fbL5
           fbR1,     fbR2,     fbR3,     fbR4,     fbR5,
           g1,       g2,       g3,       g4,       g5,
           lg1,      lg2,      lg3,      lg4,      lg5 )
  (
    fbToggle1 ? ( fbL1 = Feedback1 * bufferL1.readBuffer();
                  fbR1 = Feedback1 * bufferR1.readBuffer(); ) : ( fbL1 = fbR1 = 0; );
    b1.processBand(Drive1, DrivePan1, play1, Mode1, Modifier1, fbL1, fbR1);
    fbToggle1 ? ( bufferL1.updateBuffer(b1.l); bufferR1.updateBuffer(b1.r); );

    (cuts) ? (
      fbToggle2 ? ( fbL2 = Feedback2 * bufferL2.readBuffer();
                    fbR2 = Feedback2 * bufferR2.readBuffer(); ) : ( fbL2 = fbR2 = 0; );
      b2.processBand(Drive2, DrivePan2, play2, Mode2, Modifier2, fbL2, fbR2);
      fbToggle2 ? ( bufferL2.updateBuffer(b2.l); bufferR2.updateBuffer(b2.r); );
      
      (cuts > 1) ? (
        fbToggle3 ? ( fbL3 = Feedback3 * bufferL3.readBuffer();
                      fbR3 = Feedback3 * bufferR3.readBuffer(); ) : ( fbL3 = fbR3 = 0; );
        b3.processBand(Drive3, DrivePan3, play3, Mode3, Modifier3, fbL3, fbR3);
        fbToggle3 ? ( bufferL3.updateBuffer(b3.l); bufferR3.updateBuffer(b3.r); );
        
        (cuts > 2) ? (
          fbToggle4 ? ( fbL4 = Feedback4 * bufferL4.readBuffer();
                        fbR4 = Feedback4 * bufferR4.readBuffer(); ) : ( fbL4 = fbR4 = 0; );
          b4.processBand(Drive4, DrivePan4, play4, Mode4, Modifier4, fbL4, fbR4);
          fbToggle4 ? ( bufferL4.updateBuffer(b4.l); bufferR4.updateBuffer(b4.r); );
    
          (cuts > 3) ? (
            fbToggle5 ? ( fbL5 = Feedback5 * bufferL5.readBuffer();
                          fbR5 = Feedback5 * bufferR5.readBuffer(); ) : ( fbL5 = fbR5 = 0; );
            b5.processBand(Drive5, DrivePan5, play5, Mode5, Modifier5, fbL5, fbR5);
            fbToggle5 ? ( bufferL5.updateBuffer(b5.l); bufferR5.updateBuffer(b5.r); );
          );
        );
      );
    );
    
    ( lg1 != Gain1 ) ? ( g1 = exp(logten005*Gain1); lg1 = Gain1; );
    ( lg2 != Gain2 ) ? ( g2 = exp(logten005*Gain2); lg2 = Gain2; );
    ( lg3 != Gain3 ) ? ( g3 = exp(logten005*Gain3); lg3 = Gain3; );
    ( lg4 != Gain4 ) ? ( g4 = exp(logten005*Gain4); lg4 = Gain4; );
    ( lg5 != Gain5 ) ? ( g5 = exp(logten005*Gain5); lg5 = Gain5; );

    play1 ? (
      b1.l = g1*b1.l*DryWet1 + b1.inL*(1-DryWet1);
      b1.r = g1*b1.r*DryWet1 + b1.inR*(1-DryWet1);
    );
    play2 ? (
      b2.l = g2*b2.l*DryWet2 + b2.inL*(1-DryWet2);
      b2.r = g2*b2.r*DryWet2 + b2.inR*(1-DryWet2);
    );
    play3 ? (
      b3.l = g3*b3.l*DryWet3 + b3.inL*(1-DryWet3);
      b3.r = g3*b3.r*DryWet3 + b3.inR*(1-DryWet3);
    );
    play4 ? (
      b4.l = g4*b4.l*DryWet4 + b4.inL*(1-DryWet4);
      b4.r = g4*b4.r*DryWet4 + b4.inR*(1-DryWet4);
    );
    play5 ? (
      b5.l = g5*b5.l*DryWet5 + b5.inL*(1-DryWet5);
      b5.r = g5*b5.r*DryWet5 + b5.inR*(1-DryWet5);
    );
  );
  
  function resetMeters()
  local()
  global()
  instance(b1, b2, b3, b4, b5)
  (
    b1.resetBandMeter();
    b2.resetBandMeter();
    b3.resetBandMeter();
    b4.resetBandMeter();
    b5.resetBandMeter();                
  );  
  
  function getBandIn(bandIdx)
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    ( bandIdx == 0 ) ? ( .5*b1.in )
    : ( bandIdx == 1 ) ? ( .5*b2.in )
    : ( bandIdx == 2 ) ? ( .5*b3.in )
    : ( bandIdx == 3 ) ? ( .5*b4.in )
    : ( bandIdx == 4 ) ? ( .5*b5.in )
  );
  
function drawShaper(drive, waveform_display)
  global( play1,        play2,      play3,      play4,      play5,
          Mode1,        Mode2,      Mode3,      Mode4,      Mode5,
          Modifier1,    Modifier2,  Modifier3,  Modifier4,  Modifier5,
          selectedBand
          fft_out_r, fft_out_g, fft_out_b, fft_out_a,
          mouse_x, mouse_y, mouse_cap, drawMode
          )
  instance(x, y, w, h, hm, calc, displayDrive, lastleft)
  local(steps, cx, dx, ds, s, s2, ll, lr, mode, ol, or, modifier)
  (
    steps = 26;
    steps = 126;
    s = -1 * (1.0 - waveform_display);
    dx = w / steps;
    ds = 2 / steps;
    hm = h - 2;
    displayDrive = drive;
    
    (mouse_x > x) && (mouse_x < (x+w)) && (mouse_y > y) && (mouse_y < (y+h)) ? (
      (lastleft == 0) && (mouse_cap & 1) ? (
        drawMode = 1.0 - drawMode;
      );
    );
    lastleft = mouse_cap & 1;
    
    ll = 0;
    lr = 0;
    cx = x;
    gfx_set(fft_out_r, fft_out_g, fft_out_b, fft_out_a);
    
    ( selectedBand == 0 ) ? (
      mode = Mode1;
      modifier = Modifier1;
    ) : ( selectedBand == 1 ) ? (
      mode = Mode2;
      modifier = Modifier2;
    ) : ( selectedBand == 2 ) ? (
      mode = Mode3;
      modifier = Modifier3;
    ) : ( selectedBand == 3 ) ? (
      mode = Mode4;
      modifier = Modifier4;
    ) : ( selectedBand == 4 ) ? (    
      mode = Mode5;
      modifier = Modifier5;
    );
    
    calc.inL = s;
    calc.inR = s;
    /* Trigger a forced refresh */
    calc.ldrive = -9999;
    calc.lpan = -9999;
    calc.processBand(displayDrive, 0, 1, mode, modifier, 0, 0);
    ll = calc.l*.5 + .5;
    lr = calc.r*.5 + .5;
    loop(steps,
      s += ds;
      
      s2 = waveform_display ? sin($pi * s) : s;
      calc.inL = s2;
      calc.inR = s2;
      
      calc.processBand(displayDrive, 0, 1, mode, modifier, 0, 0);      
      ol = calc.l*.5 + .5;
      or = calc.r*.5 + .5;
      
      gfx_line(cx, y+h-ll*hm, cx+dx, y+h-ol*hm);
      gfx_line(cx, y+h-lr*hm, cx+dx, y+h-or*hm);
      gfx_line(cx, y+h-ll*hm-1, cx+dx, y+h-ol*hm-1);
      gfx_line(cx, y+h-lr*hm-1, cx+dx, y+h-or*hm-1);
      
      ll = ol;
      lr = or;
      cx += dx;
    );
  );

function drawVolumes(pre, post)
  local(thc, iDisplayDrive)
  instance(x, y, w, h, displayDrive, hot1, hot2, xv, yv, xv2, yv2, xs, ys)
  global()
  (
    iDisplayDrive = 10^(-displayDrive/20);
    
    thc = 3;
    
    xv = min(1,pre * iDisplayDrive);
    yv = min(1,post);
    
    xv2 = max(xv2*.97, xv);
    yv2 = max(yv2*.97, yv);
    
    hot1 = .8*hot1 + .2*2*xv*xv*(xv-0.5);
    gfx_set(1, 1-hot1, 1-3*hot1, .5);
    gfx_rect(floor(x+.5*w*(1-xv))-1, y+h+1, floor(w*xv)+2, thc+2);
    gfx_set(1, 1-hot1, 1-3*hot1, 1);
    gfx_rect(floor(x+.5*w*(1-xv)), y+h+2, floor(w*xv)+1, thc);
    
    hot2 = .8*hot2 + .2*2*yv*yv*(yv-0.5);
    gfx_set(1, 1-hot2, 1-3*hot2, .5);
    gfx_rect(x-thc-2, floor(y+.5*h*(1-yv))+1, thc+2, floor(h*yv)+2);
    gfx_set(1, 1-hot2, 1-3*hot2, 1);
    gfx_rect(x-thc-1, floor(y+.5*h*(1-yv))+2, thc, floor(h*yv));
    
    gfx_set(1, 1, 1, .1);
    gfx_rect(floor(x+.5*w*(1-xv2))-1, y+h+1, floor(w*xv2)+2, thc+2);
    
    gfx_set(1, 1, 1, .1);
    gfx_rect(x-thc-2, floor(y+.5*h*(1-yv2))-1, thc+2, floor(h*yv2)+2);
    
    gfx_set(1,1,1,.15);
    gfx_rect(floor(x+.5*w*(1-xv)), y, 1, h);
    gfx_rect(floor(x+.5*w*(1+xv)), y, 1, h);
  );

function initDelays()
  local()
  global(delayBuf1, delayBuf2, delayBuf3, delayBuf4, delayBuf5, 
         delayBuf6, delayBuf7, delayBuf8, delayBuf9, delayBuf10,
         bufferDist)
  instance(bufferL1, bufferL2, bufferL3, bufferL4, bufferL5,
           bufferR1, bufferR2, bufferR3, bufferR4, bufferR5)
  (
    bufferL1.initBuffer(delayBuf1, delayBuf1+bufferDist-1);
    bufferL2.initBuffer(delayBuf2, delayBuf2+bufferDist-1);
    bufferL3.initBuffer(delayBuf3, delayBuf3+bufferDist-1);
    bufferL4.initBuffer(delayBuf4, delayBuf4+bufferDist-1);
    bufferL5.initBuffer(delayBuf5, delayBuf5+bufferDist-1);
    bufferR1.initBuffer(delayBuf6, delayBuf6+bufferDist-1);
    bufferR2.initBuffer(delayBuf7, delayBuf7+bufferDist-1);
    bufferR3.initBuffer(delayBuf8, delayBuf8+bufferDist-1);
    bufferR4.initBuffer(delayBuf9, delayBuf9+bufferDist-1);
    bufferR5.initBuffer(delayBuf10, delayBuf10+bufferDist-1);
  );

// MEMORY LAYOUT
fftSize     = 2*8192;
bufferDist  = 65536;
audioBufIn  = 0;
audioBufOut = bufferDist;

delayBuf1   = 2*bufferDist;
delayBuf2   = 3*bufferDist;
delayBuf3   = 4*bufferDist;
delayBuf4   = 5*bufferDist;
delayBuf5   = 6*bufferDist;
delayBuf6   = 7*bufferDist;
delayBuf7   = 8*bufferDist;
delayBuf8   = 9*bufferDist;
delayBuf9   = 10*bufferDist;
delayBuf10  = 11*bufferDist;

mod_mem1    = 12*bufferDist;
mod_mem2    = 12*bufferDist+10000;
mod_mem3    = 12*bufferDist+20000;
mod_mem4    = 12*bufferDist+30000;
mod_mem5    = 12*bufferDist+40000;
kot_LUT_x   = 12*bufferDist+50000;
kot_LUT_y   = 12*bufferDist+60000;

kot_lut(kot_LUT_x, kot_LUT_y);

note_mem       = 14*bufferDist;
memset(note_mem, -1337, 10000);

/* Non-slider params */
shapeMod1Value    = 15*bufferDist;
shapeMod1Type     = shapeMod1Value+20;
shapeMod2Value    = shapeMod1Type+20;
shapeMod2Type     = shapeMod2Value+20;

LFO_types         = shapeMod2Type+20;
LFO_tsync         = LFO_types+10;
LFO_retrig        = LFO_tsync+10;

shapeDrive1Value  = LFO_retrig + 10;
shapeDrive1Type   = shapeDrive1Value + 20;
shapeDrive2Value  = shapeDrive1Type +20;
shapeDrive2Type   = shapeDrive2Value + 20;

lfoFModType       = shapeDrive2Type + 20;
lfoFModValue      = lfoFModType + 20;

lfoAModType       = lfoFModValue + 20;
lfoAModValue      = lfoAModType + 20;

drywetMod1Value   = lfoAModValue + 20;
drywetMod1Type    = drywetMod1Value + 20;

gainMod1Value     = drywetMod1Type + 20;
gainMod1Type      = gainMod1Value + 20;

delayMod1Value    = gainMod1Type + 20;
delayMod1Type     = delayMod1Value + 20;

fbMod1Value       = delayMod1Type + 20;
fbMod1Type        = fbMod1Value + 20;

drivePanning      = fbMod1Type + 20;

block_list        = 16*65536;

envWindow1.setEnvMemory(17*65536, 18*65536);
envWindow2.setEnvMemory(19*65536, 20*65536);
envWindow1.initEnvelope(envX, envY, envW, envH*.45, 6, "MOD 5", env_bg_r, env_bg_g, env_bg_b, env_bg_a );    
envWindow2.initEnvelope(envX, envY+.555*envH, envW, envH*.45, 6, "MOD 6", env_bg_r, env_bg_g, env_bg_b, env_bg_a );

inBuf.initBufferLen(22*65536, 65532);
dynBuf1.initBufferLen(23*65536, 65532);
dynBuf2.initBufferLen(24*65536, 65532);

blockerMem = 25*65536; blockerStep = 4096;
ma_dc0.init_blocker(blockerMem, blockerMem+blockerStep, blockerMem+2*blockerStep, blockerMem+3*blockerStep);
blockerMem = 26*65536; 
ma_dc1.init_blocker(blockerMem, blockerMem+blockerStep, blockerMem+2*blockerStep, blockerMem+3*blockerStep);

filterBank.initDelays();

freemem = 27 * 65536;
freemem = in_level.level_estimator(freemem, 0.3);
freemem = out_level.level_estimator(freemem, 0.3);

// INITIALIZATION
spectrumIn.initSpectrum(audioBufIn, fftSize, srate);
spectrumOut.initSpectrum(audioBufOut, fftSize, srate);

drivePan1          = drivePanning[0];
drivePan2          = drivePanning[1];
drivePan3          = drivePanning[2];
drivePan4          = drivePanning[3];
drivePan5          = drivePanning[4];
cMasterGainSlider  = masterGainSlider;

c_sDrive1 = sDrive1;
c_sDrive2 = sDrive2;
c_sDrive3 = sDrive3;
c_sDrive4 = sDrive4;
c_sDrive5 = sDrive5;

c_sGain1 = sGain1;
c_sGain2 = sGain2;
c_sGain3 = sGain3;
c_sGain4 = sGain4;
c_sGain5 = sGain5;

@serialize
writing = file_avail(0) < 0;

envWindow1.setEnvMemory(17*65536, 18*65536);
envWindow2.setEnvMemory(19*65536, 20*65536);

block_list    = 16*65536;

(file_avail(0)>=0) ? (
  memset(block_list, 0, 255);
);

file_var(0,dnoisefloor_freq);
file_var(0,dsteps_fft);

file_var(0,solo1);
file_var(0,solo2);
file_var(0,solo3);
file_var(0,solo4);
file_var(0,solo5);
file_var(0,placeholder);
file_var(0,placeholder);

file_var(0,mute1);
file_var(0,mute2);
file_var(0,mute3);
file_var(0,mute4);
file_var(0,mute5);
file_var(0,placeholder);
file_var(0,placeholder);

file_var(0,fb1Toggle);
file_var(0,fb2Toggle);
file_var(0,fb3Toggle);
file_var(0,fb4Toggle);
file_var(0,fb5Toggle);

!writing ? (
  memset(shapeMod1Value, 0, 16);
  memset(shapeMod1Type, 0, 16);
  memset(shapeMod2Value, 0, 16);
  memset(shapeMod2Type, 0, 16);
);

file_mem(0,shapeMod1Value,16);
file_mem(0,shapeMod1Type,16);
file_mem(0,shapeMod2Value,16);
file_mem(0,shapeMod2Type,16);

file_var(0,bypassBand1);
file_var(0,bypassBand2);
file_var(0,bypassBand3);
file_var(0,bypassBand4);
file_var(0,bypassBand5);

file_mem(0,LFO_types,8);
file_mem(0,LFO_tsync,8);
file_mem(0,LFO_retrig,8);

file_mem(0,block_list,256);

!writing ? (
  memset(shapeDrive1Value, 0, 16);
  memset(shapeDrive1Type, 0, 16);
  memset(shapeDrive2Value, 0, 16);
  memset(shapeDrive2Type, 0, 16);
);

file_mem(0,shapeDrive1Value, 16);
file_mem(0,shapeDrive1Type, 16);
file_mem(0,shapeDrive2Value, 16);
file_mem(0,shapeDrive2Type, 16);

file_var(0,fbToggle1);
file_var(0,fbToggle2);
file_var(0,fbToggle3);
file_var(0,fbToggle4);
file_var(0,fbToggle5);

file_var(0,modVisible);

envWindow1.serializeEnvelope();
envWindow2.serializeEnvelope();
envWindow1.initEnvelope(envX, envY, envW, envH*.45, 6, "MODULATOR 5", env_bg_r, env_bg_g, env_bg_b, env_bg_a );    
envWindow2.initEnvelope(envX, envY+.555*envH, envW, envH*.45, 6, "MODULATOR 6", env_bg_r, env_bg_g, env_bg_b, env_bg_a );

!writing ? (
  memset(lfoFModType, 0, 16);
  memset(lfoFModValue, 0, 16);
  memset(lfoAModType, 0, 16);
  memset(lfoAModValue, 0, 16);
);

file_mem(0,lfoFModType,16);
file_mem(0,lfoFModValue,16);
file_mem(0,lfoAModType,16);
file_mem(0,lfoAModValue,16);
file_var(0,viewDynamics);

file_var(0, f1Attack);
file_var(0, f1Decay);
file_var(0, f2Attack);
file_var(0, f2Decay);
file_var(0, f1Threshold);
file_var(0, f2Threshold);
file_var(0, f1Thresholded);
file_var(0, f2Thresholded);

!writing ? (
  memset(drywetMod1Value, 0, 16);
  memset(drywetMod1Type, 0, 16);
  memset(gainMod1Value, 0, 16);
  memset(gainMod1Type, 0, 16);
  memset(delayMod1Value, 0, 16);
  memset(delayMod1Type, 0, 16);
  memset(fbMod1Value, 0, 16);
  memset(fbMod1Type, 0, 16);
  envInputGain = 0;
);

file_mem(0,drywetMod1Value,16);
file_mem(0,drywetMod1Type,16);
file_mem(0,gainMod1Value,16);
file_mem(0,gainMod1Type,16);
file_mem(0,delayMod1Value,16);
file_mem(0,delayMod1Type,16);
file_mem(0,fbMod1Value,16);
file_mem(0,fbMod1Type,16);

file_var(0,envInputGain);

!writing ? (
  memset(drivePanning, 0, 16);
  side = 0;
);
file_mem(0, drivePanning,16);

// Was this preset using the incorrect panning system?
!writing ? (
  legacy_pan = 0;
  ix = 0;
  loop(8,
    (abs(drivePanning[ix])) > 0 ? legacy_pan = 1;
    ix += 1;
  );
);

file_var(0,side);

// Force initialization if not writing
!writing ? ( agc_gain_reduction = 0; );
file_var(0, agc_gain_reduction);
file_var(0, drawMode);

file_var(0, legacy_pan);

len = file_avail(0);
(len != 0) ? (
  file_var(0, envWindow1.noloop);
  file_var(0, envWindow2.noloop);
) : (
  envWindow1.noloop = 0;
  envWindow2.noloop = 0;
);

f1Attack = max(attackMin,min(attackMax,f1Attack));
f1Decay = max(releaseMin,min(releaseMax,f1Decay));
f2Attack = max(attackMin,min(attackMax,f2Attack));
f2Decay = max(releaseMin,min(releaseMax,f2Decay));

@slider

@block
function inertiaSmoothing(newval)
  instance(prev, val, boost)
  global()
  local(error, diff)
  (
    error   = (val - newval);
    diff    = val - prev;
    prev    = val;
    boost   = min(1, max(0, 15*abs(diff)-.1));
    val     = val - .3 * error - .7 * error * boost;
  );

envWindow1.updateEnvRate();
envWindow2.updateEnvRate();

follow1.init_follower(f1Attack, f1Decay);
follow2.init_follower(f2Attack, f2Decay);

!mute1 ? play1 = 1 : play1 = 0;
!mute2 ? play2 = 1 : play2 = 0;
!mute3 ? play3 = 1 : play3 = 0;
!mute4 ? play4 = 1 : play4 = 0;
!mute5 ? play5 = 1 : play5 = 0;

( solo1 || solo2 || solo3 || solo4 || solo5 ) ? ( play1 = play2 = play3 = play4 = play5 = 0; );
solo1 ? play1 = 1;
solo2 ? play2 = 1;
solo3 ? play3 = 1;
solo4 ? play4 = 1;
solo5 ? play5 = 1;

curFIRdelay = getFIRdelay(overSampling); 

( fixDC == 1 ) ? (
  curFIRdelay = curFIRdelay + 511;
);

( pdc_delay != curFIRdelay ) ? (
  pdc_top_ch = 2;
  pdc_delay = curFIRdelay;
);

// Sample accurate lerp or inertial based?
Inertia ?
(
  modifierLerp1.prepLerp(25, mod_mem1, inertia_mod1.inertiaSmoothing( sModifier1 ), 1);
  modifierLerp2.prepLerp(26, mod_mem2, inertia_mod2.inertiaSmoothing( sModifier2 ), 1);
  modifierLerp3.prepLerp(27, mod_mem3, inertia_mod3.inertiaSmoothing( sModifier3 ), 1);
  modifierLerp4.prepLerp(28, mod_mem4, inertia_mod4.inertiaSmoothing( sModifier4 ), 1);
  modifierLerp5.prepLerp(29, mod_mem5, inertia_mod5.inertiaSmoothing( sModifier5 ), 1);
) :
(
  modifierLerp.prepLerp(13, mod_mem, Cutoff, 0);
);

modulator1.updateModSettings(LFO_types[0], LFO_tsync[0], LFO_retrig[0]);
modulator2.updateModSettings(LFO_types[1], LFO_tsync[1], LFO_retrig[1]);
modulator3.updateModSettings(LFO_types[2], LFO_tsync[2], LFO_retrig[2]);
modulator4.updateModSettings(LFO_types[3], LFO_tsync[3], LFO_retrig[3]);  

linearEnvInputGain = exp(3.5*envInputGain);

/* Store midi messages for use once they come up */
notePtr = note_mem;
while (midirecv(offset,msg1,msg2,msg3)) (
    noteOn = msg1>$x8F&&msg1<$xA0 && msg3!=0;
    noteOff = (msg1>$x7F&&msg1<$x90) || (msg1>$x89&&msg1<$xA0 && msg3==0);
    mwCC = (msg1>$xAF&&msg1<$xC0);
      
    noteOn ? (
    notePtr[] = offset;
    notePtr += 1;
    notePtr[] = msg3;
    notePtr += 1;
    notePtr[] = msg2;
    notePtr += 1;
  ) : ( noteOff ) ? (
    notePtr[] = offset;
    notePtr += 1;
    notePtr[] = -1;
    notePtr += 1;
  ) : ( mwCC ) ? (
    ( slider45 > 9 && slider45 < 11 ) ? (
      notePtr[] = offset;
      notePtr += 1;
      notePtr[] = -2;
      notePtr += 1;
      notePtr[] = msg2;
      notePtr += 1;
      notePtr[] = msg3;
      notePtr += 1;
    );
  );
  
  midisend(offset,msg1,msg2,msg3); // passthrough MIDI events
);
notePtr[]       = -1337;    // Signal end of note buffer
notePtr         = note_mem;
curSample       = 0;        // Current sample in block
notes_remain    = 1;        // End of the note buffer?
note_next       = notePtr[];  

cTempo          = tempo; 

invblock = 1.0 / samplesblock;

d_drivePan1 = (drivePanning[0] - drivePan1) * invblock;
d_drivePan2 = (drivePanning[1] - drivePan2) * invblock;
d_drivePan3 = (drivePanning[2] - drivePan3) * invblock;
d_drivePan4 = (drivePanning[3] - drivePan4) * invblock;
d_drivePan5 = (drivePanning[4] - drivePan5) * invblock;
d_MasterGainSlider = (masterGainSlider - cMasterGainSlider) * invblock;

d_sDrive1 = (sDrive1 - c_sDrive1) * invblock;
d_sDrive2 = (sDrive2 - c_sDrive2) * invblock;
d_sDrive3 = (sDrive3 - c_sDrive3) * invblock;
d_sDrive4 = (sDrive4 - c_sDrive4) * invblock;
d_sDrive5 = (sDrive5 - c_sDrive5) * invblock;

d_sGain1 = (sGain1 - c_sGain1) * invblock;
d_sGain2 = (sGain2 - c_sGain2) * invblock;
d_sGain3 = (sGain3 - c_sGain3) * invblock;
d_sGain4 = (sGain4 - c_sGain4) * invblock;
d_sGain5 = (sGain5 - c_sGain5) * invblock;

/* Horrible, but saves performance */
shapeMod1Type0     = shapeMod1Type[0];
shapeMod1Value0    = shapeMod1Value[0];
shapeMod2Type0     = shapeMod2Type[0];
shapeMod2Value0    = shapeMod2Value[0];
shapeDrive1Type0   = shapeDrive1Type[0];
shapeDrive1Value0  = shapeDrive1Value[0];
shapeDrive2Type0   = shapeDrive2Type[0];
shapeDrive2Value0  = shapeDrive2Value[0];

shapeMod1Type1     = shapeMod1Type[1];
shapeMod1Value1    = shapeMod1Value[1];
shapeMod2Type1     = shapeMod2Type[1];
shapeMod2Value1    = shapeMod2Value[1];
shapeDrive1Type1   = shapeDrive1Type[1];
shapeDrive1Value1  = shapeDrive1Value[1];
shapeDrive2Type1   = shapeDrive2Type[1];
shapeDrive2Value1  = shapeDrive2Value[1];

shapeMod1Type2     = shapeMod1Type[2];
shapeMod1Value2    = shapeMod1Value[2];
shapeMod2Type2     = shapeMod2Type[2];
shapeMod2Value2    = shapeMod2Value[2];
shapeDrive1Type2   = shapeDrive1Type[2];
shapeDrive1Value2  = shapeDrive1Value[2];
shapeDrive2Type2   = shapeDrive2Type[2];
shapeDrive2Value2  = shapeDrive2Value[2];

shapeMod1Type3     = shapeMod1Type[3];
shapeMod1Value3    = shapeMod1Value[3];
shapeMod2Type3     = shapeMod2Type[3];
shapeMod2Value3    = shapeMod2Value[3];
shapeDrive1Type3   = shapeDrive1Type[3];
shapeDrive1Value3  = shapeDrive1Value[3];
shapeDrive2Type3   = shapeDrive2Type[3];
shapeDrive2Value3  = shapeDrive2Value[3];

shapeMod1Type4     = shapeMod1Type[4];
shapeMod1Value4    = shapeMod1Value[4];
shapeMod2Type4     = shapeMod2Type[4];
shapeMod2Value4    = shapeMod2Value[4];
shapeDrive1Type4   = shapeDrive1Type[4];
shapeDrive1Value4  = shapeDrive1Value[4];
shapeDrive2Type4   = shapeDrive2Type[4];
shapeDrive2Value4  = shapeDrive2Value[4];

lfoFModType0       = lfoFModType[0];
lfoFModType1       = lfoFModType[1];
lfoFModType2       = lfoFModType[2];
lfoFModType3       = lfoFModType[3];

lfoFModValue0      = lfoFModValue[0];
lfoFModValue1      = lfoFModValue[1];
lfoFModValue2      = lfoFModValue[2];
lfoFModValue3      = lfoFModValue[3];

lfoAModType0       = lfoAModType[0];
lfoAModType1       = lfoAModType[1];
lfoAModType2       = lfoAModType[2];
lfoAModType3       = lfoAModType[3];

lfoAModValue0      = lfoAModValue[0];
lfoAModValue1      = lfoAModValue[1];
lfoAModValue2      = lfoAModValue[2];
lfoAModValue3      = lfoAModValue[3];

drywetMod1Type0    = drywetMod1Type[0];
drywetMod1Type1    = drywetMod1Type[1];
drywetMod1Type2    = drywetMod1Type[2];
drywetMod1Type3    = drywetMod1Type[3];
drywetMod1Type4    = drywetMod1Type[4];

drywetMod1Value0   = drywetMod1Value[0];
drywetMod1Value1   = drywetMod1Value[1];
drywetMod1Value2   = drywetMod1Value[2];
drywetMod1Value3   = drywetMod1Value[3];
drywetMod1Value4   = drywetMod1Value[4];

gainMod1Type0      = gainMod1Type[0];
gainMod1Type1      = gainMod1Type[1];
gainMod1Type2      = gainMod1Type[2];
gainMod1Type3      = gainMod1Type[3];
gainMod1Type4      = gainMod1Type[4];

gainMod1Value0     = gainMod1Value[0];
gainMod1Value1     = gainMod1Value[1];
gainMod1Value2     = gainMod1Value[2];
gainMod1Value3     = gainMod1Value[3];
gainMod1Value4     = gainMod1Value[4];

delayMod1Type0     = delayMod1Type[0];
delayMod1Type1     = delayMod1Type[1];
delayMod1Type2     = delayMod1Type[2];
delayMod1Type3     = delayMod1Type[3];
delayMod1Type4     = delayMod1Type[4];

delayMod1Value0    = delayMod1Value[0];
delayMod1Value1    = delayMod1Value[1];
delayMod1Value2    = delayMod1Value[2];
delayMod1Value3    = delayMod1Value[3];
delayMod1Value4    = delayMod1Value[4];

fbMod1Type0        = fbMod1Type[0];
fbMod1Type1        = fbMod1Type[1];
fbMod1Type2        = fbMod1Type[2];
fbMod1Type3        = fbMod1Type[3];
fbMod1Type4        = fbMod1Type[4];

fbMod1Value0       = fbMod1Value[0];
fbMod1Value1       = fbMod1Value[1];
fbMod1Value2       = fbMod1Value[2];
fbMod1Value3       = fbMod1Value[3];
fbMod1Value4       = fbMod1Value[4];

@sample
drivePan1 += d_drivePan1;
drivePan2 += d_drivePan2;
drivePan3 += d_drivePan3;
drivePan4 += d_drivePan4;
drivePan5 += d_drivePan5;

c_sDrive1 += d_sDrive1;
c_sDrive2 += d_sDrive2;
c_sDrive3 += d_sDrive3;
c_sDrive4 += d_sDrive4;
c_sDrive5 += d_sDrive5;

c_sGain1 += d_sGain1;
c_sGain2 += d_sGain2;
c_sGain3 += d_sGain3;
c_sGain4 += d_sGain4;
c_sGain5 += d_sGain5;

cMasterGainSlider += d_MasterGainSlider;

  /* MIDI Handling */
  // Take notes from the stack until we hit the end marker -1
  (notes_remain) ? (
    while( note_next == curSample ) (
      notePtr += 1;
      (notePtr[] > 0) ? ( // note-on
        modulator1.reset = 1;
        modulator2.reset = 1;
        modulator3.reset = 1;
        modulator4.reset = 1;
        notesOn = notesOn + 1;
        lastVel_cur = notePtr[]/127;
        
        envWindow1.resetEnvelope(lastVel_cur, 0);
        envWindow2.resetEnvelope(lastVel_cur, 0);
        notePtr += 1;
        lastNote = notePtr[];      
      ) : (notePtr[] == -1) ? ( // note-off
        notesOn = notesOn - 1;
        notesOn = max(0, notesOn);
      ) : (notePtr[] == -2) ? ( // CC
        notePtr += 1;
        cur_cc = notePtr[]; // msg3
        notePtr += 1;
        cur_cc == 1 ? (
          cc_target = notePtr[]/128; // msg2
        )
      );
      notePtr += 1;
      
      // Avoid constantly dereferencing by picking up the next one
      note_next = notePtr[];
      notes_remain = note_next != -1337;
    );
  );


  /* LFO Modulators */
  function fetchModulationAmount(ref, type, value)
  local(m_value)
  global(m1_value, m2_value, m3_value, m4_value, m5_value, m6_value, m7_value, m8_value)
  instance()
  (
    m_value = (type == 1) ? m1_value
    : (type == 2) ? m2_value
    : (type == 3) ? m3_value
    : (type == 4) ? m4_value
    : (type == 5) ? m5_value
    : (type == 6) ? m6_value
    : (type == 7) ? m7_value
    : (type == 8) ? m8_value;
    ref += value * m_value;

    ( ref > 1 ) ? ( ref = 1 )
    : ( ref < 0 ) ? ( ref = 0 );
    
    ref
  );
 
  function fetchModulationAmountMinMax(ref, type, value, mini, maxi)
  local(range, m_value)
  global(m1_value, m2_value, m3_value, m4_value, m5_value, m6_value, m7_value, m8_value)
  instance()
  (
    m_value = (type == 1) ? m1_value
    : (type == 2) ? m2_value
    : (type == 3) ? m3_value
    : (type == 4) ? m4_value
    : (type == 5) ? m5_value
    : (type == 6) ? m6_value
    : (type == 7) ? m7_value
    : (type == 8) ? m8_value;
    
    range = maxi - mini;
    ref += value * m_value * range;

    ( ref > maxi ) ? ( ref = maxi )
    : ( ref < mini ) ? ( ref = mini );
    
    ref
  );      
  
  function fetchLFOModulationAmount(ref, type, value)
  local()
  global(m5_value, m6_value, m7_value, m8_value)
  instance()
  (
    (type == 1)   ? ( ref += value * m5_value; )
    : (type == 2) ? ( ref += value * m6_value; )
    : (type == 3) ? ( ref += value * m7_value; )
    : (type == 3) ? ( ref += value * m8_value; );
    
    ( ref > 1 ) ? ( ref = 1 )
    : ( ref < 0 ) ? ( ref = 0 );
    
    ref
  );
  
  signal = .5*linearEnvInputGain*(abs(spl0)+abs(spl1));
  smoothedSignal = max(signal*.001 + smoothedSignal*0.999, signal);
  inBuf.updateBuffer(smoothedSignal);
  inputGain = log10(max(.001, signal));
  
  f1Thresholded ? (
    m7_value = follow1.eval_follower((signal>f1Threshold) ? 1 : 0);
  ) : (
    m7_value = exp(logten*follow1.eval_follower(inputGain));
  );
  ( m7_value > 1 ) ? ( m7_value = 1 )
  : ( m7_value < 0 ) ? ( m7_value = 0 );
  
  f2Thresholded ? (  
    m8_value = follow2.eval_follower((signal>f2Threshold) ? 1 : 0);
  ) : (
    m8_value = exp(logten*follow2.eval_follower(inputGain));
  );
  ( m8_value > 1 ) ? ( m8_value = 1 )
  : ( m8_value < 0 ) ? ( m8_value = 0 );
  
  m5_value = envWindow1.evaluateEnvelope(notesOn);
  m6_value = envWindow2.evaluateEnvelope(notesOn);
  
  dynBuf1.updateBuffer(m7_value);
  dynBuf2.updateBuffer(m8_value);
  
  LFO_amount1 = LFO_amnt1;
  LFO_amount2 = LFO_amnt2;
  LFO_amount3 = LFO_amnt3;
  LFO_amount4 = LFO_amnt4;
  
  lfoAModType0 ? LFO_amount1 = fetchLFOModulationAmount(LFO_amount1, lfoAModType0, lfoAModValue0);
  lfoAModType1 ? LFO_amount2 = fetchLFOModulationAmount(LFO_amount2, lfoAModType1, lfoAModValue1);
  lfoAModType2 ? LFO_amount3 = fetchLFOModulationAmount(LFO_amount3, lfoAModType2, lfoAModValue2);
  lfoAModType3 ? LFO_amount4 = fetchLFOModulationAmount(LFO_amount4, lfoAModType3, lfoAModValue3);

  modulator1.modrate ? ( m1_value = LFO_amount1 * modulator1.updateModulator(.7) );
  modulator2.modrate ? ( m2_value = LFO_amount2 * modulator2.updateModulator(.7) );
  modulator3.modrate ? ( m3_value = LFO_amount3 * modulator3.updateModulator(.7) );
  modulator4.modrate ? ( m4_value = LFO_amount4 * modulator4.updateModulator(.7) );

  LFO_F1 = LFO_freq1;
  LFO_F2 = LFO_freq2;
  LFO_F3 = LFO_freq3;
  LFO_F4 = LFO_freq4;
  
  lfoFModType0 ? LFO_F1 = fetchLFOModulationAmount(LFO_F1, lfoFModType0, lfoFModValue0);
  lfoFModType1 ? LFO_F2 = fetchLFOModulationAmount(LFO_F2, lfoFModType1, lfoFModValue1);
  lfoFModType2 ? LFO_F3 = fetchLFOModulationAmount(LFO_F3, lfoFModType2, lfoFModValue2);
  lfoFModType3 ? LFO_F4 = fetchLFOModulationAmount(LFO_F4, lfoFModType3, lfoFModValue3);
  
  modulator1.updateScale(LFO_amount1);
  modulator2.updateScale(LFO_amount2);
  modulator3.updateScale(LFO_amount3);
  modulator4.updateScale(LFO_amount4);
  
  modulator1.updateModRate(LFO_F1);
  modulator2.updateModRate(LFO_F2);
  modulator3.updateModRate(LFO_F3);
  modulator4.updateModRate(LFO_F4);

  Modifier1 = modifierLerp1.lerpSample();
  shapeMod1Type0 ? Modifier1 = fetchModulationAmount(Modifier1, shapeMod1Type0, shapeMod1Value0);
  shapeMod2Type0 ? Modifier1 = fetchModulationAmount(Modifier1, shapeMod2Type0, shapeMod2Value0);
  Drive1 = c_sDrive1;
  shapeDrive1Type0 ? Drive1 = fetchModulationAmountMinMax(Drive1, shapeDrive1Type0, shapeDrive1Value0, driveMin, driveMax);
  shapeDrive2Type0 ? Drive1 = fetchModulationAmountMinMax(Drive1, shapeDrive2Type0, shapeDrive2Value0, driveMin, driveMax);
  Gain1 = c_sGain1;
  gainMod1Type0 ? Gain1 = fetchModulationAmountMinMax(Gain1, gainMod1Type0, gainMod1Value0, gainMin, gainMax);
  DryWet1 = sDryWet1;
  drywetMod1Type0 ? DryWet1 = fetchModulationAmount(DryWet1, drywetMod1Type0, drywetMod1Value0);
  DryWet1 = DryWet1 * (1-bypassBand1);
  Delay1 = sDelay1;
  delayMod1Type0 ? Delay1 = fetchModulationAmount(Delay1, delayMod1Type0, delayMod1Value0);
  FeedBack1 = sFeedback1;
  fbMod1Type0 ? FeedBack1 = fetchModulationAmount(FeedBack1, fbMod1Type0, fbMod1Value0);
  
  ( cuts > 0 ) ? (
    Modifier2 = modifierLerp2.lerpSample();
    shapeMod1Type1 ? Modifier2 = fetchModulationAmount(Modifier2, shapeMod1Type1, shapeMod1Value1);
    shapeMod2Type1 ? Modifier2 = fetchModulationAmount(Modifier2, shapeMod2Type1, shapeMod2Value1);
    Drive2 = c_sDrive2;
    shapeDrive1Type1 ? Drive2 = fetchModulationAmountMinMax(Drive2, shapeDrive1Type1, shapeDrive1Value1, driveMin, driveMax);
    shapeDrive2Type1 ? Drive2 = fetchModulationAmountMinMax(Drive2, shapeDrive2Type1, shapeDrive2Value1, driveMin, driveMax);
    Gain2 = c_sGain2;
    gainMod1Type1 ? Gain2 = fetchModulationAmountMinMax(Gain2, gainMod1Type1, gainMod1Value1, gainMin, gainMax);
    DryWet2 = sDryWet2;
    drywetMod1Type1 ? DryWet2 = fetchModulationAmount(DryWet2, drywetMod1Type1, drywetMod1Value1);
    DryWet2 = DryWet2 * (1-bypassBand2);
    Delay2 = sDelay2;
    delayMod1Type1 ? Delay2 = fetchModulationAmount(Delay2, delayMod1Type1, delayMod1Value1);
    FeedBack2 = sFeedback2;
    fbMod1Type1 ? FeedBack2 = fetchModulationAmount(FeedBack2, fbMod1Type1, fbMod1Value1);

    ( cuts > 1 ) ? (
      Modifier3 = modifierLerp3.lerpSample();
      shapeMod1Type2 ? Modifier3 = fetchModulationAmount(Modifier3, shapeMod1Type2, shapeMod1Value2);
      shapeMod2Type2 ? Modifier3 = fetchModulationAmount(Modifier3, shapeMod2Type2, shapeMod2Value2);
      Drive3 = c_sDrive3;
      shapeDrive1Type2 ? Drive3 = fetchModulationAmountMinMax(Drive3, shapeDrive1Type2, shapeDrive1Value2, driveMin, driveMax);
      shapeDrive2Type2 ? Drive3 = fetchModulationAmountMinMax(Drive3, shapeDrive2Type2, shapeDrive2Value2, driveMin, driveMax);
      Gain3 = c_sGain3;
      gainMod1Type2 ? Gain3 = fetchModulationAmountMinMax(Gain3, gainMod1Type2, gainMod1Value2, gainMin, gainMax);
      DryWet3 = sDryWet3;
      drywetMod1Type2 ? DryWet3 = fetchModulationAmount(DryWet3, drywetMod1Type2, drywetMod1Value2);
      DryWet3 = DryWet3 * (1-bypassBand3); 
      Delay3 = sDelay3;
      delayMod1Type2 ? Delay3 = fetchModulationAmount(Delay3, delayMod1Type2, delayMod1Value2);
      FeedBack3 = sFeedback3;
      fbMod1Type2 ? FeedBack3 = fetchModulationAmount(FeedBack3, fbMod1Type2, fbMod1Value2);

      ( cuts > 2 ) ? (
        Modifier4 = modifierLerp4.lerpSample();
        shapeMod1Type3 ? Modifier4 = fetchModulationAmount(Modifier4, shapeMod1Type3, shapeMod1Value3);
        shapeMod2Type3 ? Modifier4 = fetchModulationAmount(Modifier4, shapeMod2Type3, shapeMod2Value3);
        Drive4 = c_sDrive4;
        shapeDrive1Type3 ? Drive4 = fetchModulationAmountMinMax(Drive4, shapeDrive1Type3, shapeDrive1Value3, driveMin, driveMax);
        shapeDrive2Type3 ? Drive4 = fetchModulationAmountMinMax(Drive4, shapeDrive2Type3, shapeDrive2Value3, driveMin, driveMax);
        Gain4 = c_sGain4;
        gainMod1Type3 ? Gain4 = fetchModulationAmountMinMax(Gain4, gainMod1Type3, gainMod1Value3, gainMin, gainMax);
        DryWet4 = sDryWet4;
        drywetMod1Type3 ? DryWet4 = fetchModulationAmount(DryWet4, drywetMod1Type3, drywetMod1Value3);
        DryWet4 = DryWet4 * (1-bypassBand4);
        Delay4 = sDelay4;
        delayMod1Type3 ? Delay4 = fetchModulationAmount(Delay4, delayMod1Type3, delayMod1Value3);
        FeedBack4 = sFeedback4;
        fbMod1Type3 ? FeedBack4 = fetchModulationAmount(FeedBack4, fbMod1Type3, fbMod1Value3);
 
        ( cuts > 3 ) ? (
          Modifier5 = modifierLerp5.lerpSample();
          shapeMod1Type4 ? Modifier5 = fetchModulationAmount(Modifier5, shapeMod1Type4, shapeMod1Value4);
          shapeMod2Type4 ? Modifier5 = fetchModulationAmount(Modifier5, shapeMod2Type4, shapeMod2Value4);
          Drive5 = c_sDrive5;
          shapeDrive1Type4 ? Drive5 = fetchModulationAmountMinMax(Drive5, shapeDrive1Type4, shapeDrive1Value4, driveMin, driveMax);
          shapeDrive2Type4 ? Drive5 = fetchModulationAmountMinMax(Drive5, shapeDrive2Type4, shapeDrive2Value4, driveMin, driveMax);
          Gain5 = c_sGain5;
          gainMod1Type4 ? Gain5 = fetchModulationAmountMinMax(Gain5, gainMod1Type4, gainMod1Value4, gainMin, gainMax);
          DryWet5 = sDryWet5;
          drywetMod1Type4 ? DryWet5 = fetchModulationAmount(DryWet5, drywetMod1Type4, drywetMod1Value4);
          DryWet5 = DryWet5 * (1-bypassBand5);
          Delay5 = sDelay5;
          delayMod1Type4 ? Delay5 = fetchModulationAmount(Delay5, delayMod1Type4, delayMod1Value4);
          FeedBack5 = sFeedback5;
          fbMod1Type4 ? FeedBack5 = fetchModulationAmount(FeedBack5, fbMod1Type4, fbMod1Value4);
        );
      );
    );
  );

  /* Simple monopole */
  function fix_dc(x)
  local()
  global()
  instance(DC_fixed, prev)
  (
    DC_fixed=0.995*DC_fixed + x - prev;
    prev=x;
  
    DC_fixed
  );

  function init_LR2(freq)
    global(srate, iOverSampling)
    local(f0, ct, st, div)
    instance(k, a1, a2, a3)
    (
      f0 = iOverSampling * .5 * $pi * exp( (1-freq) * log(20/22050) );
      k = sqrt(2); /* Note the different peak resonance because we're combining 2 SVFs into the Linkwitz-Riley structure */

      ct = cos(f0);
      st = sin(f0);
      div = 1.0 / (1.0 + k * st * ct);
      a1 = ct * ct * div;
      a2 = st * ct * div;
      a3 = st * st * div;
    ); 
  
  function reset_LR()
    global()
    local()
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq, k, a1, a2, a3)
    (
      ic1eq = ic2eq = 0;  
    );  

  function eval_LRLP(v0)
    global()
    local(v1, v2, v3)
    instance(ic3eq, ic4eq, k, a1, a2, a3)
    (
      v3 = v0 - ic4eq;
      v1 = a1 * ic3eq + a2 * v3;
      v2 = ic4eq + a2 * ic3eq + a3 * v3;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      
      v2
    ); 
 
  function eval_LRAP(v0)
    global()
    local(v1, v2, v3)
    instance(ic5eq, ic6eq, k, a1, a2, a3)
    (
      v3 = v0 - ic6eq;
      v1 = a1 * ic5eq + a2 * v3;
      v2 = ic6eq + a2 * ic5eq + a3 * v3;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;    
      
      v0 - 2*k*v1
    );    

  function eval_LR2(v0)
    global()
    local(v1, v2, v3, all)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;    
      
      all = v0 - 2 * k * v1;
 
      lp = this.eval_LRLP(v2); 
      hp = all - lp;
    );

  function updateCoeffs()
  local()
  global(Cuts, Freq1, Freq2, Freq3, Freq4, overSampling)
  instance( F1, F2, F3, F4
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            lcuts,
            lF1, lF2, lF3, lF4,
            lOversampling,
            updateRequired
            )
  (
      updateRequired = 0;
      updateRequired = ( 
        ( lF1 != Freq1 ) ||
        ( lF2 != Freq2 ) ||
        ( lF3 != Freq3 ) ||
        ( lF4 != Freq4 ) ||
        ( lOversampling != overSampling ) );
      
      updateRequired ? (
        lF1 = Freq1;
        lF2 = Freq2;
        lF3 = Freq3;
        lF4 = Freq4;
        lOversampling = overSampling;
      
        F1 = Freq1;
        F2 = Freq1  + Freq2 * (1 - Freq1);
        F3 = F2     + Freq3 * (1 - F2);
        F4 = F3     + Freq4 * (1 - F3);
          
        (cuts==1) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
        ) : (cuts==2) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          
          LA_F2.init_LR2(F2);
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 3) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          LF3.init_LR2(F3);
          RF3.k  = LF3.k;
          RF3.a1 = LF3.a1;
          RF3.a2 = LF3.a2;
          RF3.a3 = LF3.a3;
          
          // All-passes for maintaining the phase relation between the bands
          LA_F2.init_LR2(F2);
          LA_F3.init_LR2(F3);
          
          RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
          RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
          RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
          RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
    
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 4) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          LF3.init_LR2(F3);
          RF3.k  = LF3.k;
          RF3.a1 = LF3.a1;
          RF3.a2 = LF3.a2;
          RF3.a3 = LF3.a3;
          LF4.init_LR2(F4);
          RF4.k  = LF4.k;
          RF4.a1 = LF4.a1;
          RF4.a2 = LF4.a2;
          RF4.a3 = LF4.a3;
          
          // All-passes for maintaining the phase relation between the bands
          LA_F2.init_LR2(F2);
          LA_F3.init_LR2(F3);
          LA_F4.init_LR2(F4);
          
          RA_F4.k  = RA_F4_2.k  = RA_F4_3.k  = LA_F4_2.k  = LA_F4_3.k  = LA_F4.k;
          RA_F4.a1 = RA_F4_2.a1 = RA_F4_3.a1 = LA_F4_2.a1 = LA_F4_3.a1 = LA_F4.a1;
          RA_F4.a2 = RA_F4_2.a2 = RA_F4_3.a2 = LA_F4_2.a2 = LA_F4_3.a2 = LA_F4.a2;
          RA_F4.a3 = RA_F4_2.a3 = RA_F4_3.a3 = LA_F4_2.a3 = LA_F4_3.a3 = LA_F4.a3;
          
          RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
          RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
          RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
          RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
    
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        );
    );
  );  
  
  function updateDelays()
  local(d1, d2, d3, d4, d5, scale)
  global(Delay1, Delay2, Delay3, Delay4, Delay5,
         fbToggle1, fbToggle2,  fbToggle3,  fbToggle4,  fbToggle5, srate, overSampling)
  instance(bufferL1,  bufferL2,   bufferL3,   bufferL4,   bufferL5,
           bufferR1,  bufferR2,   bufferR3,   bufferR4,   bufferR5 )
  (
    scale = 0.04*srate*overSampling;
    fbToggle1 ? ( d1 = scale * (exp(Delay1)-1) + 2; bufferL1.setOffset(d1); bufferR1.setOffset(d1) );
    fbToggle2 ? ( d2 = scale * (exp(Delay2)-1) + 2; bufferL2.setOffset(d2); bufferR2.setOffset(d2) );
    fbToggle3 ? ( d3 = scale * (exp(Delay3)-1) + 2; bufferL3.setOffset(d3); bufferR3.setOffset(d3) );
    fbToggle4 ? ( d4 = scale * (exp(Delay4)-1) + 2; bufferL4.setOffset(d4); bufferR4.setOffset(d4) );
    fbToggle5 ? ( d5 = scale * (exp(Delay5)-1) + 2; bufferL5.setOffset(d5); bufferR5.setOffset(d5) );
  );
  
  function resetBands()
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    b1.r = b1.l = b2.r = b2.l = b3.r = b3.l = b4.r = b4.l = b5.l = 0;
  );  
  
  // Make sure the delay is the same on all bands (identical number of filters)
  function splitBands(sl, sr)
  local()
  global(Cuts)
  instance( LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            b1, b2, b3, b4, b5, lcuts )
  (
    ( lcuts != cuts ) ? (
      lcuts = cuts;
      this.resetBands();
    );
  
    (cuts==0) ? (
      b1.inL = sl;
      b1.inR = sr;
    ) : (cuts==1) ? (
      LF1.eval_LR2(sl);
      b1.inL = LF1.lp;
      b2.inL = LF1.hp;
      
      RF1.eval_LR2(sr);
      b1.inR = RF1.lp;
      b2.inR = RF1.hp;
    ) : (cuts==2) ? (
      LF1.eval_LR2(sl);
      b1.inL   = LA_F2.eval_LRAP(LF1.lp);
      
      LF2.eval_LR2(LF1.hp);
      b2.inL   = LF2.lp;
      b3.inL   = LF2.hp;
      
      RF1.eval_LR2(sr);
      b1.inR   = RA_F2.eval_LRAP(RF1.lp);
      
      RF2.eval_LR2(RF1.hp);
      b2.inR   = RF2.lp;
      b3.inR   = RF2.hp;
    ) : (cuts == 3) ? (
      LF1.eval_LR2(sl);
      b1.inL   = LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp));
      
      LF2.eval_LR2(LF1.hp);
      b2.inL   = LA_F3_2.eval_LRAP(LF2.lp);
      
      LF3.eval_LR2(LF2.hp);
      b3.inL   = LF3.lp;
      b4.inL   = LF3.hp;
      
      RF1.eval_LR2(sr);
      b1.inR   = RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp));
      
      RF2.eval_LR2(RF1.hp);
      b2.inR   = RA_F3_2.eval_LRAP(RF2.lp);
      
      RF3.eval_LR2(RF2.hp);
      b3.inR   = RF3.lp;
      b4.inR   = RF3.hp;
    ) : (cuts == 4) ? (
      LF1.eval_LR2(sl);
      b1.inL   = LA_F4.eval_LRAP(LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp)));
      
      LF2.eval_LR2(LF1.hp);
      b2.inL   = LA_F4_2.eval_LRAP(LA_F3_2.eval_LRAP(LF2.lp));
      
      LF3.eval_LR2(LF2.hp);
      b3.inL   = LA_F4_3.eval_LRAP(LF3.lp);
      
      LF4.eval_LR2(LF3.hp);
      b4.inL   = LF4.lp;
      b5.inL   = LF4.hp;
      
      RF1.eval_LR2(sr);
      b1.inR   = RA_F4.eval_LRAP(RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp)));
      
      RF2.eval_LR2(RF1.hp);
      b2.inR   = RA_F4_2.eval_LRAP(RA_F3_2.eval_LRAP(RF2.lp));
      
      RF3.eval_LR2(RF2.hp);
      b3.inR   = RA_F4_3.eval_LRAP(RF3.lp);
      
      RF4.eval_LR2(RF3.hp);
      b4.inR   = RF4.lp;
      b5.inR   = RF4.hp;
    );
  );
  
  function processSample()
  (
    filterBank.splitBands(inL, inR);
    filterBank.processBands();
    
    // Delays need less frequent updating
    (update_delays > 7) ? (
      filterBank.updateDelays();
      update_delays = 0;
    ) : (
      update_delays += 1;
    );
    
    outL = filterBank.b1.l + filterBank.b2.l + filterBank.b3.l + filterBank.b4.l + filterBank.b5.l;
    outR = filterBank.b1.r + filterBank.b2.r + filterBank.b3.r + filterBank.b4.r + filterBank.b5.r;
  );
  
  spectrumIn.feedSample(.5*(spl0+spl1));

  // Split signal into bands
  iOverSampling = 1/Oversampling;
  filterBank.updateCoeffs();
  
  inL = spl0;
  inR = spl1;
  
  ( Oversampling == 1 ) ? (
    processSample();
    spl0 = outL;
    spl1 = outR;
  ) : (
    upsampleL.updateUpHist(overSampling, inL);
    upsampleR.updateUpHist(overSampling, inR);
    
    f = 0;
    loop(overSampling,
      f += 1;
      inL = overSampling*upsampleL.upSample(overSampling);
      inR = overSampling*upsampleR.upSample(overSampling);
  
      processSample();
      downL.updateDownHist(overSampling, outL);
      downR.updateDownHist(overSampling, outR);
      
      ( f == 1 ) ? (
        spl0 = downL.downSample(overSampling);
        spl1 = downR.downSample(overSampling);
      );
    );
  );
   
  ( fixDC == 2 ) ? (
    spl0 = dc0.eval_HP6(spl0);
    spl1 = dc1.eval_HP6(spl1);
  ) : ( fixDC == 1 ) ? (
    spl0 = ma_dc0.fix_dc_strong(spl0);
    spl1 = ma_dc1.fix_dc_strong(spl1);
  );
  
  // Only update RMS when audio is playing
  AGC ? (
    pklvl = 0.999 * pklvl + 0.001 * max(abs(inL), abs(inR));
    (pklvl > 0.001) ? (
      in_level.eval_gain(inL, inR);
      out_level.eval_gain(spl0, spl1);
    );
    
    in_level.got_full_buf ? (
      out_total = out_level.sum_l + out_level.sum_r;
      correction = (out_total > 0.0001) ? sqrt((in_level.sum_l + in_level.sum_r) / out_total) : 1;
    );
    
    spl0 *= correction;
    spl1 *= correction;
  ) : agc_gain_reduction ? (
    spl0 *= agc_gain_reduction;
    spl1 *= agc_gain_reduction;
  );
  
  gBoost = exp(logten005*cMasterGainSlider);
  spl0 *= gBoost;
  spl1 *= gBoost;
  
  spectrumOut.feedSample(.5*(spl0+spl1));
  
  curSample += 1;
  
@gfx 1080 800

  function createGUI(stripStart)
  (
    scaling   = gfx_ext_retina-1;
    spectrumX = 0;
    spectrumY = 0;
    spectrumW = gfx_w - 200*0;
    spectrumH = gfx_h - 175 * ( 1 + modVisible ) * (1+scaling);
    bottomRow = gfx_h - 175 * (1+scaling);
    topRow    = spectrumH;
    
    fontface = "Arial";
    gfx_setfont(BAND_FONT,      fontface, 20*(1+scaling));
    gfx_setfont(COMBO_SMALL,    fontface, 11*(1+scaling));
    gfx_setfont(COMBO_BIG,      fontface, 14*(1+scaling));  
    gfx_setfont(GRID_FONT,      fontface, 14*(1+scaling));
    gfx_setfont(HINT_FONT,      fontface, 14*(1+scaling));
    gfx_setfont(KNOB_FONT,      fontface, 14*(1+scaling));
    gfx_setfont(KNOB_FONT2,     fontface, 13*(1+scaling));
    gfx_setfont(TOGGLE_FONT,    fontface, 14*(1+scaling));
    gfx_setfont(ENVELOPE_FONT,  fontface, 12*(1+scaling));
    gfx_setfont(SLIDER_FONT,    fontface, 10*(1+scaling));
    gfx_setfont(BUTTON_FONT,    fontface, 12*(1+scaling));
    
    spectrumIn.setWindowLocation(spectrumX,  spectrumY, spectrumW, spectrumH);
    spectrumOut.setWindowLocation(spectrumX, spectrumY, spectrumW, spectrumH);
    shaperWnd.setWindowLocation(stripStart*(1+scaling), bottomRow + 25*(1+scaling), 125*(1+scaling), 125*(1+scaling));
  );

  /* Gradients are buffered to save rendering perf */
  function drawGradients(w, h, spectrumH, gradient_bg)
  instance(lw, lh, lSpectrumH)
  global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
         gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
  local( oldDest, oldMode)
  (
    oldMode = gfx_mode;
    gfx_mode = 0;
    gfx_set(1,1,1,1);
    ( ( lw != w ) || ( lh != h ) || (spectrumH != lSpectrumH) ) ? (
      /* Only draw gradients when size changes */
      gfx_x = gfx_y = 0;
      lw = w;
      lh = h;
      lSpectrumH = spectrumH;
      oldDest = gfx_dest;
      gfx_setimgdim(gradient_bg, w, h);
      gfx_dest = gradient_bg;
      gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);
      gfx_rectto(w,spectrumH);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, gfx_a, .0001, .001, .0001, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, .3, .0001, .001, .0006, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, 0, 0, 0, 0, 0, -.001, -.0006, .0001, -.0001, -.0001, .01, -.00008);
      gfx_gradrect(0, spectrumH, w, h-spectrumH, 0, 0, .0, 1.0, .0001, .0001, .0002, 0, 0, 0, .0005, 0);
      gfx_dest = oldDest;
    );
    
    gfx_x = gfx_y = 0;
    gfx_blit(gradient_bg, 1, 0);
    gfx_mode = oldMode;
  );

  /* Draw a vertical label */
  function drawVertLabel(x, y, stridx, labelW, font, labelBuffer)
  local(oldDest, oldMode, strw, strh)
  global(gfx_dest, gfx_mode, gfx_x, gfx_y,
         font_color_r, font_color_g, font_color_b, font_color_a)
  instance()
  (
    oldDest = gfx_dest;
    oldMode = gfx_mode;
    gfx_setimgdim(labelBuffer, labelW, labelW);
    gfx_dest = labelBuffer;
        
    gfx_setfont(font);
    gfx_measurestr(stridx, strw, strh);
    gfx_set(0,0,0,1);
    gfx_rect(0,0, labelW, strh);
    gfx_set(font_color_r,font_color_g,font_color_b,font_color_a);
    gfx_x = .5 * labelW - .5 * strw; gfx_y = 0;
    gfx_drawstr(stridx);
    gfx_dest = oldDest;
    
    gfx_x = x;
    gfx_y = y;
    gfx_mode = 1;
    gfx_blit(labelBuffer, 1, 1.5*$pi);
    gfx_mode = oldMode;
  );
  
  function getFbToggle(band)
  global(fbToggle1, fbToggle2, fbToggle3, fbToggle4, fbToggle5)
  local()
  instance()
  (
    ( band == 0 ) ? ( fbToggle1 )
    : ( band == 1 ) ? ( fbToggle2 )
    : ( band == 2 ) ? ( fbToggle3 )
    : ( band == 3 ) ? ( fbToggle4 )
    : ( band == 4 ) ? ( fbToggle5 )
  );  
  
  function setFbToggle(band, value)
  global(fbToggle1, fbToggle2, fbToggle3, fbToggle4, fbToggle5)
  local()
  instance()
  (
    ( band == 0 ) ? ( fbToggle1 = value )
    : ( band == 1 ) ? ( fbToggle2 = value )
    : ( band == 2 ) ? ( fbToggle3 = value )
    : ( band == 3 ) ? ( fbToggle4 = value )
    : ( band == 4 ) ? ( fbToggle5 = value )
  );
  
  function getBypassToggle(band)
  global(bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5)
  local()
  instance()
  (
    ( band == 0 ) ? ( bypassBand1 )
    : ( band == 1 ) ? ( bypassBand2 )
    : ( band == 2 ) ? ( bypassBand3 )
    : ( band == 3 ) ? ( bypassBand4 )
    : ( band == 4 ) ? ( bypassBand5 )
  );
  
  function setBypassToggle(band, value)
  global(bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5)
  local()
  instance()
  (
    ( band == 0 ) ? ( bypassBand1 = value )
    : ( band == 1 ) ? ( bypassBand2 = value )
    : ( band == 2 ) ? ( bypassBand3 = value )
    : ( band == 3 ) ? ( bypassBand4 = value )
    : ( band == 4 ) ? ( bypassBand5 = value )
  );

  function getPan(band)
  global(drivePanning)
  local()
  instance()
  (
    ( band == 0 ) ? ( drivePanning[] )
    : ( band == 1 ) ? ( drivePanning[1] )
    : ( band == 2 ) ? ( drivePanning[2] )
    : ( band == 3 ) ? ( drivePanning[3] )
    : ( band == 4 ) ? ( drivePanning[4] )
  );
  
  function setPan(band, pan)
  global(drivePanning)
  local()
  instance()
  (
    ( band == 0 ) ? ( drivePanning[] = pan; )
    : ( band == 1 ) ? ( drivePanning[1] = pan; )
    : ( band == 2 ) ? ( drivePanning[2] = pan; )
    : ( band == 3 ) ? ( drivePanning[3] = pan; )
    : ( band == 4 ) ? ( drivePanning[4] = pan; )
  );  
  
  bg_color_r = 47/255;
  bg_color_g = 65/255;
  bg_color_b = 75/255;
  bg_color_a = 1;
  fft_out_r = .8;
  fft_out_g = .8;
  fft_out_b = .8;
  fft_out_a = 1.0;
  fft_in_r = .13;
  fft_in_g = .13;
  fft_in_b = .23;
  fft_in_a = .6;
  grid_color_r = .73;
  grid_color_g = .73;
  grid_color_b = .76;
  grid_color_a = .2;
  grid_alpha = .1 * (1+.5*abs(sin(2*time_precise())));
  backface_color_r = .2;
  backface_color_g = .2;
  backface_color_b = .3;
  backface_color_a = .1;
  font_color_r = .8;
  font_color_g = .8;
  font_color_b = .8;
  font_color_a = .8;
  knob_font_color_r = .5;
  knob_font_color_g = .7;
  knob_font_color_b = 1;
  knob_font_color_a = 1;
  highlight_color_r = .5;
  highlight_color_g = .7+.2*abs(sin(2*time_precise()));
  highlight_color_b = .9;
  highlight_color_a = .6+.4*abs(sin(2*time_precise()));
  disabled_color_r = .4;
  disabled_color_g = .4;
  disabled_color_b = .4;
  disabled_color_a = .8;
  widget_r = .3;
  widget_g = .3;
  widget_b = .3;
  widget_a = 1.0;
  toggle_r = 1.0;
  toggle_g = .3;
  toggle_b = .3;
  toggle_a = 1.0;
  group_r = .2;
  group_g = .3;
  group_b = .4;
  group_a = 1.0;
  mod1_color_r = 1;
  mod1_color_g = .37;
  mod1_color_b = 1;
  mod1_color_a = 1;
  mod2_color_r = .1;
  mod2_color_b = .2;
  mod2_color_g = 1;
  mod2_color_a = 1;
  envelope_curve_r = .6;
  envelope_curve_g = .6;
  envelope_curve_b = 1;
  envelope_curve_a = 1.0;
  
  selectionbutton_color_r = 77/255;
  selectionbutton_color_g = 95/255;
  selectionbutton_color_b = 205/255;
  selectionbutton_color_a = .6;
  
  widgetcolor_r = 0.1;
  widgetcolor_g = 0.1;
  widgetcolor_b = 0.1;
  widgetcolor_a = 1.0;
  
  env_bg_r = .3;
  env_bg_g = .4;
  env_bg_b = .8; 
  env_bg_a = 1;
  
  stripStart = 35; 
  createGUI(stripStart);
  gradient.drawGradients(gfx_w, gfx_h, spectrumH, 2);
  
  globalTime = time_precise();
  delta_time = globalTime - lastGlobalTime;
  lastGlobalTime = globalTime;
  
  gfx_r = 1;
  spectrumIn.drawGrid();
  spectrumIn.floorLevel = 25 + dnoisefloor_freq;
  spectrumOut.floorLevel = 25 + dnoisefloor_freq;
  spectrumIn.drawFFT(1, 1, fft_in_r, fft_in_g, fft_in_b, fft_in_a);
  spectrumOut.drawFFT(0, 1, fft_out_r, fft_out_g, fft_out_b, fft_out_a);
  spectrumIn.updateBands();
  spectrumIn.drawBands();  
  
  !comboboxOpen ? spectrumIn.fftWindow_processMouse(mouse_x, mouse_y, mouse_cap);  
  
  ////////////
  /* Shaper */
  ////////////
  currentPos = (210+stripStart)*(1+scaling);
  shaperLocationX = currentPos-60*(1+scaling);
  //drawGroupRect(shaperLocationX, groupTop, groupWidth, miniknobWidth*8+miniknobPadY*4, group_r, group_g, group_b, group_a);  
  
  /* Combobox to select envelope for shaper */
  comboModulatorYSize = 11*(1+scaling);
  comboModulatorXSize = 9*(1+scaling);
  shaperModulator1.combobox(shaperLocationX+2, bottomRow + 25*(1+scaling), comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  shaperModulator1.combobox_setcuritem(shapeMod1Type[selectedBand]);
  shaperModulator1.value = shapeMod1Value[selectedBand];
  shaperModulator1.combomodulator_draw();
  shaperModulator1.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    shapeMod1Type[selectedBand]  = shaperModulator1.curItem;
    shapeMod1Value[selectedBand] = shaperModulator1.value;
  );

  /* Combobox to select envelope for shaper */
  shaperModulator2.combobox(shaperLocationX+2, bottomRow + (25+comboModulatorYSize), comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  shaperModulator2.combobox_setcuritem(shapeMod2Type[selectedBand]);
  shaperModulator2.value = shapeMod2Value[selectedBand];
  shaperModulator2.combomodulator_draw();
  shaperModulator2.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    shapeMod2Type[selectedBand]  = shaperModulator2.curItem;
    shapeMod2Value[selectedBand] = shaperModulator2.value;
  );
  
  /* Knob which controls shaper modifier */
  modifierKnob.active = hasShapeMod(slider(modeLocation+selectedBand));
  modifierKnob.value = slider(modifierLocation+selectedBand);
  modifierKnob.value2 = shaperModulator1.value;
  modifierKnob.value3 = shaperModulator2.value;
  modifierKnob.drawKnob(currentPos, bottomRow + 75*(1+scaling), 30*(1+scaling), "Shape Mod", "Modify shaper curve.");
  modifierKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(modifierLocation+selectedBand) = modifierKnob.value );
  
  /* Combobox to select shaper */
  shaperSelect.dangerousElements=block_list;
  shaperSelect.combobox(currentPos-60*(1+scaling), bottomRow + 150*(1+scaling)-20*(1+scaling), 120*(1+scaling), 20*(1+scaling), .4, .4, .8, 1, nShapers, 1, 1, 2, COMBO_BIG, "Waveshaper selection." );
  shaperSelect.combobox_setcuritem(slider(modeLocation+selectedBand));
  shaperSelect.combobox_draw();  
  shaperSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( 
    slider_automate( slider(modeLocation+selectedBand)=shaperSelect.curitem; ); 
  );
  
  groupTop       = bottomRow + 25*(1+scaling);
  mod2Top        = groupTop + 4*miniKnobWidth + miniKnobPadY + 4;
  
  bigKnobDist   = 130*(1+scaling);
  groupDistance = 85*(1+scaling);
  miniknobWidth = 14*(1+scaling);
  miniknobPadX  = 5*(1+scaling);
  miniknobPadY  = 5*(1+scaling);  
  buttonPad     = 6*(1+scaling);
  buttonSize    = 6*(1+scaling); 
  groupWidth    = miniknobWidth*4+miniknobPadX*2;
  modulatorOff  = groupWidth - comboModulatorXSize - 3;
  
  ////////////
  /* Drive */
  ////////////
  currentPos = currentPos + bigKnobDist;
  /* Combobox to select envelope for drive */
  driveModulator1.combobox(currentPos+2 - 60*(1+scaling), bottomRow + 25*(1+scaling), comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  driveModulator1.combobox_setcuritem(shapeDrive1Type[selectedBand]);
  driveModulator1.value = shapeDrive1Value[selectedBand];
  driveModulator1.combomodulator_draw();
  driveModulator1.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    shapeDrive1Type[selectedBand]  = driveModulator1.curItem;
    shapeDrive1Value[selectedBand] = driveModulator1.value;
  );
  
  /* Combobox to select envelope for drive */
  driveModulator2.combobox(currentPos+2 - 60*(1+scaling), bottomRow + (25+comboModulatorYSize), comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  driveModulator2.combobox_setcuritem(shapeDrive2Type[selectedBand]);
  driveModulator2.value = shapeDrive2Value[selectedBand];
  driveModulator2.combomodulator_draw();
  driveModulator2.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    shapeDrive2Type[selectedBand]  = driveModulator2.curItem;
    shapeDrive2Value[selectedBand] = driveModulator2.value;
  );  
  
  /* Knob which controls drive */
  driveKnob.active = 1;
  driveKnob.value = (slider(driveLocation+selectedBand) - driveMin)*iDriveRange;
  driveKnob.value2 = driveModulator1.value;
  driveKnob.value3 = driveModulator2.value;
  driveKnob.label = sprintf(19, "%d dB", slider(driveLocation+selectedBand));
  driveKnob.drawKnob(currentPos, bottomRow + 75*(1+scaling), 30*(1+scaling), "Drive", "Modify band drive.");
  driveKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.4) ? slider_automate( slider(driveLocation+selectedBand) = driveKnob.value * driveRange + driveMin );  
  
  panSlider.value = getPan(selectedBand)*.5+.5;
  panSlider.drawSimpleSlider(currentPos-45*(1+scaling), bottomRow + 150*(1+scaling)-20*(1+scaling), 90*(1+scaling), 20*(1+scaling), .4, .4, .8, 1, "Drive pan");
  panSlider.simpleSlider_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? setPan(selectedBand, 2*panSlider.value - 1);
  
  msToggle.drawToggle(currentPos + 2.45*miniknobWidth + miniknobPadX, bottomRow + 150*(1+scaling)-122*(1+scaling), buttonSize, buttonSize, side, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Mid/Side mode?");
  side = msToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  
  gfx_x = currentPos-40*(1+scaling);
  gfx_y = bottomRow + 149*(1+scaling)-15*(1+scaling);
  gfx_set(font_color_r, font_color_g, font_color_b, font_color_a);
  side ? (
    gfx_printf("M");
    gfx_x = currentPos+33*(1+scaling);
    gfx_printf("S");
  ) : (
    gfx_printf("L");
    gfx_x = currentPos+33*(1+scaling);
    gfx_printf("R");
  );
  
  //////////////////////////
  /* Gain dry/wet section */
  //////////////////////////
  currentPos = currentPos + .8*groupDistance;
  drawGroupRect(currentPos, groupTop, groupWidth, miniknobWidth*8+miniknobPadY*4, group_r, group_g, group_b, group_a);
  gainKnob.active = 1;

  bypassToggle.invert = 1;  
  bypassToggle.drawToggle(currentPos - 2*buttonPad + groupWidth, groupTop + buttonPad, buttonSize, buttonSize, getBypassToggle(selectedBand), widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable waveshaper for this band.");
  setBypassToggle( selectedBand, bypassToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap) );
  
  postGainModulator.value = gainMod1Value[selectedBand];
  postGainModulator.combobox(currentPos + buttonPad, groupTop + miniKnobPadY, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  postGainModulator.combobox_setcuritem(gainMod1Type[selectedBand]);
  postGainModulator.value = gainMod1Value[selectedBand];
  postGainModulator.combomodulator_draw();
  postGainModulator.combobox_draw_top();
  postGainModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    gainMod1Type[selectedBand]  = postGainModulator.curItem;
    gainMod1Value[selectedBand] = postGainModulator.value;
  );
  
  /* Gain controls */
  gainKnob.value = ( slider(gainLocation+selectedBand) - gainMin ) * iGainRange;
  gainKnob.value2 = postGainModulator.value;
  gainKnob.drawKnob(currentPos + 2*miniknobWidth + miniknobPadX, groupTop + 2*miniKnobWidth + miniKnobPadY, miniknobWidth, "Gain", "Set post-gain for this band.\nNote when dragging drive, hold shift\nto move this one in opposite direction.\n");
  gainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.7) ? slider_automate( slider(gainLocation+selectedBand) = gainKnob.value * gainRange + gainMin );
  
  /* Dry/wet modulator controls */
  drywetModulator1.value = drywetMod1Value[selectedBand];
  drywetModulator1.combobox(currentPos + buttonPad, mod2Top, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  drywetModulator1.combobox_setcuritem(drywetMod1Type[selectedBand]);
  drywetModulator1.value = drywetMod1Value[selectedBand];
  drywetModulator1.combomodulator_draw();
  drywetModulator1.combobox_draw_top();
  drywetModulator1.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    drywetMod1Type[selectedBand]  = drywetModulator1.curItem;
    drywetMod1Value[selectedBand] = drywetModulator1.value;
  );

  /* Dry/Wet controls */
  drywetKnob.active = 1;
  drywetKnob.value = slider(drywetLocation+selectedBand);
  drywetKnob.value2 = drywetModulator1.value;
  drywetKnob.drawKnob(currentPos + 2*miniknobWidth + miniknobPadX, groupTop + 6*miniKnobWidth + 2*miniKnobPadY, miniknobWidth, "Dry/Wet", "Modify dry/wet ratio for this band.");
  drywetKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? slider_automate( slider(drywetLocation+selectedBand) = drywetKnob.value );

  ///////////////////
  /* Delay Section */
  ///////////////////
  currentPos = currentPos + groupDistance;
  drawGroupRect(currentPos, groupTop, groupWidth, miniknobWidth*8+miniknobPadY*4, group_r, group_g, group_b, group_a);
  
  /* Delay modulator controls */
  delayModulator.value = delayMod1Value[selectedBand];
  delayModulator.combobox(currentPos + buttonPad, groupTop + miniKnobPadY, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  delayModulator.combobox_setcuritem(delayMod1Type[selectedBand]);
  delayModulator.value = delayMod1Value[selectedBand];
  delayModulator.combomodulator_draw();
  delayModulator.combobox_draw_top();
  delayModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    delayMod1Type[selectedBand]  = delayModulator.curItem;
    delayMod1Value[selectedBand] = delayModulator.value;
  );
  
  /* Delay controls */
  delayKnob.active = 1;
  delayKnob.value = slider(delayLocation+selectedBand);
  delayKnob.value2 = delayModulator.value;
  delayKnob.drawKnob(currentPos + 2*miniknobWidth + miniknobPadX, groupTop + 2*miniKnobWidth + miniKnobPadY, miniknobWidth, "Delay", "Set delay time for feedback.");
  delayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(delayLocation+selectedBand) = delayKnob.value );

  /* Feedback modulator controls */
  fbModulator.value = fbMod1Value[selectedBand];
  fbModulator.combobox(currentPos + buttonPad, mod2Top, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 2, 1, 1, COMBO_SMALL, "Select modulator." );
  fbModulator.combobox_setcuritem(fbMod1Type[selectedBand]);
  fbModulator.value = fbMod1Value[selectedBand];
  fbModulator.combomodulator_draw();
  fbModulator.combobox_draw_top();
  fbModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    fbMod1Type[selectedBand]  = fbModulator.curItem;
    fbMod1Value[selectedBand] = fbModulator.value;
  );

  /* Feedback control */
  feedbackKnob.value2 = fbModulator.value;
  feedbackKnob.active = 1;
  feedbackKnob.value = slider(feedbackLocation+selectedBand);
  feedbackKnob.drawKnob(currentPos + 2*miniknobWidth + miniknobPadX, groupTop + 6*miniKnobWidth + 2*miniKnobPadY, miniknobWidth, "Feedback", "Set feedback gain for feedback");
  feedbackKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(feedbackLocation+selectedBand) = feedbackKnob.value );

  delayToggle.drawToggle(currentPos + - 2*buttonPad + groupWidth, groupTop + buttonPad, buttonSize, buttonSize, getFbToggle(selectedBand), widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable feedback system");
  setFbToggle(selectedBand, delayToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap));

  /* Widening Section */
  /*widenKnob.active = 1;
  widenKnob.value = slider(widenLocation+selectedBand);
  drawGroupRect(postShaperKnob + 3*groupDistance, groupTop, miniknobWidth*4+miniknobPadX*2, miniknobWidth*8+miniknobPadY*4, group_r, group_g, group_b, group_a);
  widenKnob.drawKnob(postShaperKnob + 3*groupDistance + 2*miniknobWidth + miniknobPadX, groupTop + 2*miniKnobWidth + miniKnobPadY, miniknobWidth, "Widen", "Set delay time for feedback.");
  widenKnob.processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(widenLocation+selectedBand) = widenKnob.value );
  */

  /*feedbackKnob.active = 1;
  feedbackKnob.value = slider(feedbackLocation+selectedBand);
  feedbackKnob.drawKnob(postShaperKnob + 2*groupDistance + 2*miniknobWidth + miniknobPadX, groupTop + 6*miniKnobWidth + 2*miniKnobPadY, miniknobWidth, "Feedback", "Set feedback gain for feedback");
  feedbackKnob.processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(feedbackLocation+selectedBand) = feedbackKnob.value );*/

  masterLoc = gfx_w - 220*(1+scaling);
  /////////////////
  /* LFO Section */
  /////////////////
  function drawLFOGroup( yLocation, LFO_loc, lfoIdx, tcur )
  instance()//tempoSync, midiTrigger)
  local(mc, strw, strh, comboModulatorXSize, comboModulatorYSize)
  global(groupWidth, miniknobWidth, miniKnobPadX, miniKnobPadY, buttonSize, scaling, BAND_FONT, COMBO_BIG, 
         group_r, group_g, group_b, group_a,
         widget_r, widget_g, widget_b, widget_a,
         toggle_r, toggle_g, toggle_b, toggle_a,
         mod_r, mod_g, mod_b, mod_a,
         mouse_x, mouse_y, mouse_cap, gfx_x, gfx_y,
         nTimeDivisions, nLFOtypes, 
         LFO_types, LFO_tsync, LFO_retrig, LFO_frequencies, LFO_amounts,
         nModulators, COMBO_SMALL,
         lfoFModType, lfoFModValue,
         lfoAModType, lfoAModValue
         )
  (
    drawGroupRect(LFO_loc, yLocation, 2*groupWidth, miniknobWidth*8+miniknobPadY*4, group_r, group_g, group_b, group_a);
    gfx_x = LFO_loc + 8*miniKnobWidth + 8*(1+scaling);
    gfx_y = yLocation + 2*(1+scaling);
    
    gfx_set(widget_r, widget_g, widget_b, widget_a);
    gfx_setfont(BAND_FONT);
    gfx_printf("%d", lfoIdx+1);
    
    yLocation += 3*(1+scaling);
    
    /*----------------*/
    /* LFO toggles    */
    /*----------------*/
    /* Temposync and retrigger buttons */
    this.tempoSync.label = "Sync";
    this.tempoSync.drawToggle(LFO_loc + 4*miniknobWidth + 4*miniknobPadX, yLocation + 4*miniKnobWidth + 5.5*miniKnobPadY, buttonSize, buttonSize, LFO_tsync[lfoIdx], widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Sync to host tempo");
    LFO_tsync[lfoIdx] = this.tempoSync.processMouseToggle(mouse_x, mouse_y, mouse_cap);
      
    /* Temposync and retrigger buttons */
    this.midiTrigger.label = "Trigger";
    this.midiTrigger.drawToggle(LFO_loc + 4*miniknobWidth + 4*miniknobPadX, yLocation + 4*miniKnobWidth + 9.5*miniKnobPadY, buttonSize, buttonSize, LFO_retrig[lfoIdx], widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Retrigger on MIDI");
    LFO_retrig[lfoIdx] = this.midiTrigger.processMouseToggle(mouse_x, mouse_y, mouse_cap);
    
    /*----------------*/
    /* Freq select    */
    /*----------------*/
    /* Hidden combobox for selecting tempo */
    LFO_tsync[lfoIdx] ? (
      this.lfo1TempoSelect.combobox(LFO_loc + miniknobWidth + miniknobPadX, yLocation + miniKnobWidth + miniKnobPadY, 2*miniknobWidth, 2*miniknobWidth, .4, .4, .8, 1, nTimeDivisions, 4, 1, 4, COMBO_BIG, "LFO selection." );
      this.lfo1TempoSelect.open ? (
        this.lfo1TempoSelect.w = 8*miniknobWidth;
        this.lfo1TempoSelect.h = 20*(1+scaling);
      );
      //this.lfo1TempoSelect.combobox_draw();
      mc = 0;
      ( this.lfo1TempoSelect.open ) ? mc = mouse_cap;
      ( mouse_cap & 2 ) ? ( mc = mc | 1 );
      this.lfo1TempoSelect.combobox_processMouse(mouse_x, mouse_y, mc) ? ( 
        slider_automate( slider(LFO_frequencies+lfoIdx) = indexToTime(this.lfo1TempoSelect.curitem) );
      );
    );
    
    /* Combobox to select envelope for frequency */
    comboModulatorYSize = 11*(1+scaling);
    comboModulatorXSize = 9*(1+scaling);
    this.lfoFModulator.combobox(LFO_loc+5*(1+scaling), yLocation + 25*(1+scaling) - miniKnobWidth - miniKnobPadY-2*(1+scaling), comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators-4, 5, 1, 1, COMBO_SMALL, "Select modulator." );
    this.lfoFModulator.combobox_setcuritem(lfoFModType[lfoIdx]);
    this.lfoFModulator.value = lfoFModValue[lfoIdx];
    this.lfoFModulator.combomodulator_draw();
    this.lfoFModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
      lfoFModType[lfoIdx]  = this.lfoFModulator.curItem;
      lfoFModValue[lfoIdx] = this.lfoFModulator.value;
    );
    
    this.lfo1FreqKnob.value = slider(LFO_frequencies+lfoIdx);
    this.lfo1FreqKnob.value2 = lfoFModValue[lfoIdx];
    this.lfo1FreqKnob.active = 1;
    this.lfo1FreqKnob.drawKnob(LFO_loc + 2*miniknobWidth + miniknobPadX, yLocation + 2*miniKnobWidth + miniKnobPadY, miniknobWidth, "Rate", "Set LFO 1 frequency.\n");
    this.lfo1FreqKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( slider(LFO_frequencies+lfoIdx) = this.lfo1FreqKnob.value );
    
    LFO_tsync[lfoIdx] ? (
      this.lfo1FreqKnob.label = getModRateSliderText(slider(LFO_frequencies+lfoIdx));
    ) : (
      this.lfo1FreqKnob.label = "";
    );

    /*----------------*/
    /* LFO Amount     */
    /*----------------*/
    /* Combobox to select envelope for amount */
    this.lfoAModulator.combobox(LFO_loc+5*(1+scaling)+4*miniKnobWidth+2*miniKnobPadY, yLocation + 25*(1+scaling) - miniKnobWidth - miniKnobPadY-2*(1+scaling), comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators-4, 5, 1, 1, COMBO_SMALL, "Select modulator." );
    this.lfoAModulator.combobox_setcuritem(lfoAModType[lfoIdx]);
    this.lfoAModulator.value = lfoAModValue[lfoIdx];
    this.lfoAModulator.combomodulator_draw();
    this.lfoAModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
      lfoAModType[lfoIdx]  = this.lfoAModulator.curItem;
      lfoAModValue[lfoIdx] = this.lfoAModulator.value;
    );
    
    this.lfo1AmntKnob.value = slider(LFO_amounts+lfoIdx);
    this.lfo1AmntKnob.value2 = lfoAModValue[lfoIdx];
    this.lfo1AmntKnob.active = 1;
    this.lfo1AmntKnob.drawKnob(LFO_loc + 6*miniknobWidth + 3*miniknobPadX, yLocation + 2*miniKnobWidth + miniKnobPadY, miniknobWidth, "Amount", "Set LFO 1 frequency.\n");
    this.lfo1AmntKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( slider(LFO_amounts+lfoIdx) = this.lfo1AmntKnob.value );
    
    /*----------------*/
    /* LFO type       */
    /*----------------*/
    mod_r = .3; mod_g = .45; mod_b = .9; mod_a = 1;
    this.mwnd.create_mod_window(LFO_loc + 2*miniknobPadX, yLocation + 4*miniKnobWidth + 4*miniKnobPadY, 4*miniknobWidth, 3*miniknobWidth, mod_r, mod_g, mod_b, mod_a);
    this.mwnd.draw_modulator(LFO_types[lfoIdx], tcur);
    
    /* Hidden combobox */
    this.lfo1TypeSelect.combobox(LFO_loc + 2*miniknobPadX, yLocation + 4*miniKnobWidth + 4*miniKnobPadY, 4*miniknobWidth, 3*miniknobWidth, .4, .4, .8, 1, nLFOtypes, 3, 1, 2, COMBO_BIG, "LFO selection." );
    this.lfo1TypeSelect.combobox_setcuritem( LFO_types[lfoIdx] );
    this.lfo1TypeSelect.open ? (
      this.lfo1TypeSelect.w = 8*miniknobWidth;
      this.lfo1TypeSelect.h = 20*(1+scaling);
    );
    this.lfo1TypeSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( 
      LFO_types[lfoIdx] = this.lfo1TypeSelect.curitem; 
    );    
  );
  
  function drawLFOtops()
  instance()
  global(miniknobWidth, scaling)
  local()
  (
    this.lfo1TypeSelect.open ? (
      this.lfo1TypeSelect.w = 8*miniknobWidth;
      this.lfo1TypeSelect.h = 20*(1+scaling);
    );
    this.lfo1TypeSelect.combobox_draw_top();
    
    this.lfo1TempoSelect.open ? (
      this.lfo1TempoSelect.w = 8*miniknobWidth;
      this.lfo1TempoSelect.h = 20*(1+scaling);
    );
    this.lfo1TempoSelect.combobox_draw_top();
    
    this.lfoFModulator.combobox_draw_top();
    this.lfoAModulator.combobox_draw_top();
  );
  
  LFO_loc = masterLoc - groupDistance - groupWidth;
  //drawLFOGroup(groupTop, LFO_loc, 0, modulator1.t);
  
  modVisible ? (
    lfoDist = 155*(1+scaling);
    panel1.drawLFOGroup(topRow + 35*(1+scaling), 32*(1+scaling), 0, modulator1.t);
    panel2.drawLFOGroup(topRow + 35*(1+scaling), 32*(1+scaling) + lfoDist, 1, modulator2.t);
    panel3.drawLFOGroup(topRow + 35*(1+scaling), 32*(1+scaling) + lfoDist*2, 2, modulator3.t);
    panel4.drawLFOGroup(topRow + 35*(1+scaling), 32*(1+scaling) + lfoDist*3, 3, modulator4.t);
    
    panel1.drawLFOtops();
    panel2.drawLFOtops();
    panel3.drawLFOtops();
    panel4.drawLFOtops();
  );
  
  function vButton(x, y, w, h, text, active)
  local()
  global(BUTTON_FONT, mouse_cap, mouse_x, mouse_y)
  instance()
  (
    active ? (
      gfx_set(.5,.5,1,1);
    ) : (
      gfx_set(.05,.2,.5,1);
    );
    
    gfx_rect(x, y, w, h, 0);
    drawVertLabel(x + .15*w, y, text, h, BUTTON_FONT, 4);
    
    (mouse_cap & 1) && (mouse_x > x) && (mouse_x < (x+w)) && (mouse_y > y) && (mouse_y < (y+h))
  );
  
  modVisible ? (
    envX = 32*(1+scaling) + lfoDist*4 + offs;
    envY = topRow + 35*(1+scaling);
    envW = 6.4*groupWidth - offs;
    envH = miniknobWidth*8+miniknobPadY*4;
    owidth = 15*(1+scaling); 
    offs = 10*(1+scaling) + owidth;
    dist = envH*.05;
    
    ( viewDynamics == 0 ) ? (          
      // ENVELOPES
      str = 20; str2 = 21;
      
      vButton(envX-offs, envY + .5*dist + 1+scaling, owidth, envH*.5 - dist, "ENVELOPE", 1);
      vButton(envX-offs, envY+envH*.5 + .5*dist + 1+scaling, owidth, envH*.5 - dist, "DYNAMICS", 0) ? ( viewDynamics = 1 );
      
      envWindow1.initEnvelope(envX, envY, envW, envH*.45, 6, "MODULATOR 5", env_bg_r, env_bg_g, env_bg_b, env_bg_a );
      envWindow1.drawEnvelopeWindow();
      envWindow1.processMouseEnvelope();
    
      envWindow2.initEnvelope(envX, envY+.555*envH, envW, envH*.45, 6, "MODULATOR 6", env_bg_r, env_bg_g, env_bg_b, env_bg_a );
      envWindow2.drawEnvelopeWindow();
      envWindow2.processMouseEnvelope();      
    ) : (
      // DYNAMICS
      vButton(envX-offs, envY + .5*dist + 1+scaling, owidth, envH*.5 - dist, "ENVELOPE", 0) ? ( viewDynamics = 0 );
      vButton(envX-offs, envY+envH*.5 + .5*dist + 1+scaling, owidth, envH*.5 - dist, "DYNAMICS", 1);      
      
      gfx_set(.5,.5,1,.2);
      inBuf.draw_buffer(envX, envY, envW, envH*.45, 0, 1);
      gfx_set(mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a);
      dynBuf1.draw_buffer(envX, envY, envW, envH*.45, 0, 0);
      f1Thresholded ? ( gfx_line(envX, envY + envH*.45*(1-f1Threshold), envX + envW, envY + envH*.45*(1-f1Threshold)) );
      
      gfx_set(mod2_color_r, mod2_color_g, mod2_color_b, mod2_color_a);
      dynBuf2.draw_buffer(envX, envY, envW, envH*.45, 0, 0);
      f2Thresholded ? ( gfx_line(envX, envY + envH*.45*(1-f2Threshold), envX + envW, envY + envH*.45*(1-f2Threshold)) );
      
      ( dynWindowCap == 1 ) ? (
        ( mouse_cap & 1 == 0 ) ? (
          dynWindowCap = 0;
        ) : (
          envInputGain = clamp(envInputGain - 0.01 * ( mouse_y - dynWindowY ), -1, 1);
          
          dynWindowY = mouse_y;
        );
      ) : (
        ( ( lastCap == 0 ) && ( mouse_cap & 1 ) ) ? (
          ( ( mouse_x > envX ) && (mouse_y > envY) && ( mouse_x < ( envX+envW ) ) && ( mouse_y < ( envY + envH*.45 ) ) ) ? (
            dynWindowCap = 1;
            dynWindowY = mouse_y;
          );
        );
      );
      
      dynCtrlY = envY + 6.5*miniKnobWidth + miniKnobPadY;
      tinyKnobWidth = .85*miniKnobWidth;
      bStart = envX + 2*tinyKnobWidth + miniknobPadX;
      
      drawGroupRect(envX, envY+.5*envH + .25*tinyKnobWidth, 13*tinyKnobWidth, 5*tinyKnobWidth, group_r, group_g, group_b, group_a);
      gfx_x = envX+3; gfx_y = envY+.5*envH + .25*tinyKnobWidth;
      gfx_set(widget_r, widget_g, widget_b, widget_a);
      gfx_setfont(BAND_FONT);
      gfx_printf("7");
      
      kAttack1.active = 1;
      kAttack1.value = ( f1Attack - attackMin ) * iAttackRange;
      kAttack1.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Attack", "Set attack");
      kAttack1.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( f1Attack = kAttack1.value * attackRange + attackMin );
      bStart += 4*tinyKnobWidth;
      
      kDecay1.active = 1;
      kDecay1.value = ( f1Decay - releaseMin ) * iReleaseRange;
      kDecay1.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Decay", "Set decay");
      kDecay1.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( f1Decay = kDecay1.value * releaseRange + releaseMin );
      bStart += 4*tinyKnobWidth;
      
      miniButtonSize = .65*buttonSize;
      kThreshToggle1.drawToggle(bStart - 1.6*tinyKnobWidth, dynCtrlY - 1.6*tinyKnobWidth, miniButtonSize, miniButtonSize, f1Thresholded, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use threshold.");
      f1Thresholded = kThreshToggle1.processMouseToggle(mouse_x, mouse_y, mouse_cap);
      
      kThresh1.active = f1Thresholded;
      kThresh1.value = f1Threshold;
      kThresh1.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Thresh", "Set threshold");
      kThresh1.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( f1Threshold = kThresh1.value );
      bStart += 6*tinyKnobWidth;
      
      drawGroupRect(envX + 14*tinyKnobWidth, envY+.5*envH + .25*tinyKnobWidth, 13*tinyKnobWidth, 5*tinyKnobWidth, group_r, group_g, group_b, group_a);
      gfx_x = envX + 14*tinyKnobWidth+3; gfx_y = envY+.5*envH + .25*tinyKnobWidth;
      gfx_set(widget_r, widget_g, widget_b, widget_a);
      gfx_setfont(BAND_FONT);
      gfx_printf("8");
      
      kAttack2.active = 1;
      kAttack2.value = ( f2Attack - attackMin ) * iAttackRange;
      kAttack2.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Attack", "Set attack");
      kAttack2.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( f2Attack = kAttack2.value * attackRange + attackMin );
      bStart += 4*tinyKnobWidth;
      
      kDecay2.active = 1;
      kDecay2.value = ( f2Decay - releaseMin ) * iReleaseRange;
      kDecay2.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Decay", "Set decay");
      kDecay2.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( f2Decay = kDecay2.value * releaseRange + releaseMin );
      bStart += 4*tinyKnobWidth;
      
      miniButtonSize = .65*buttonSize;
      kThreshToggle2.drawToggle(bStart - 1.6*tinyKnobWidth, dynCtrlY - 1.6*tinyKnobWidth, miniButtonSize, miniButtonSize, f2Thresholded, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use threshold.");
      f2Thresholded = kThreshToggle2.processMouseToggle(mouse_x, mouse_y, mouse_cap);
      
      kThresh2.active = f2Thresholded;
      kThresh2.value = f2Threshold;
      kThresh2.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Thresh", "Set threshold");
      kThresh2.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( f2Threshold = kThresh2.value );
      bStart += 5*tinyKnobWidth;
      
      kEnvInputGain.active = 1;
      kEnvInputGain.value = envInputGain*.5+.5;
      kEnvInputGain.drawKnob(bStart, dynCtrlY, tinyKnobWidth, "Gain", "Envelope input gain");
      kEnvInputGain.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? ( envInputGain =  ( kEnvInputGain.value - .5 ) * 2 );
      bStart += 4*tinyKnobWidth;
    );
  );
  
  /////////////////////
  /* Global controls */
  /////////////////////

  /* Global gain control */
  drawGroupRect(masterLoc, groupTop, groupWidth, miniknobWidth*8+miniknobPadY*4, group_r, group_g, group_b, group_a);
  masterGain.active = 1;
  masterGain.value = ( masterGainSlider - gainMin ) * iGainRange;
  masterGain.drawKnob(masterLoc + 2*miniknobWidth + miniknobPadX, groupTop + 2*miniKnobWidth + miniKnobPadY, miniknobWidth, "Master", "Set master volume");
  masterGain.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ?  slider_automate( masterGainSlider = masterGain.value * gainRange + gainMin );

  dcToggle.drawToggle(masterLoc + 3.5*miniknobWidth + miniknobPadX, groupTop + buttonPad, buttonSize, buttonSize, fixDC, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Fix DC");
  fixDC = dcToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

  agcToggle.drawToggle(masterLoc + 1.3 * miniknobPadX, groupTop + buttonPad, buttonSize, buttonSize, agc, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Automatic Gain Compensation (BETA)\n\nLMB toggles AGC.\nRMB stores and fixes AGC gain\nreduction (indicated by yellow light).\n\nNote: Re-enabling after fixing loses the fixed setting.");
  agc = agcToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  (agc == 1) ? ( agc_gain_reduction = 0; );
  
  agcToggle.right_clicked ? (
    (agc > 0) ? (
      agc_gain_reduction = correction;
      agc = 0;
    );
  );
  ((agc_gain_reduction > 0) && (agc == 0)) ? (
    dummy.drawToggle(masterLoc + 1.3 * miniknobPadX, groupTop + buttonPad, buttonSize, buttonSize, 1, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_r, toggle_b, toggle_a, "Automatic Gain Compensation (BETA)\n\nLMB activates it.\nLMB deactivates and loses setting.\nRMB stores and fixes AGC gain reduction.");
  );

  /* Oversampling control */
  oversamplingKnob.active = 1;
  ( mouse_cap & 1 == 0 ) ? oversamplingKnob.value = (Oversampling - overSamplingMin) * iOverSamplingRange;
  oversamplingKnob.drawKnob(masterLoc + 2*miniknobWidth + miniknobPadX, groupTop + 6*miniKnobWidth + 2*miniKnobPadY, miniknobWidth, "Over", "Set oversampling factor.\nNote that high levels\nof oversampling will\nresult in high CPU usage.");
  oversamplingKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ?  slider_automate( overSampling = floor( oversamplingKnob.value * overSamplingRange + oversamplingMin + .5 ) );
  osString = 100;
  oversamplingKnob.label = sprintf( osString, "%d", overSampling );

  legacy_pan.drawToggle(masterLoc + 3.5*miniknobWidth + miniknobPadX, groupTop + buttonPad + 4 * miniKnobWidth + 1 * miniKnobPadY, buttonSize, buttonSize, legacy_pan, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use legacy panning\n\nLegacy panning would pan the signal left or right\nbefore the waveshaper.\n\nInstead of mixing in the unprocessed signal after\nthe waveshaper, the legacy mode would\nsimply end up with just a panned signal.");
  legacy_pan = legacy_pan.processMouseToggle(mouse_x, mouse_y, mouse_cap);

  /* Band indicator */
  sprintf(16,"Band %d", selectedBand+1);
  vLabel.drawVertLabel(5, bottomRow, 16, gfx_h-bottomRow, BAND_FONT, 3);
  
  /* Draw shaper curve */
  shaperWnd.drawBackface();
  drawMode ? shaperWnd.drawShaper(5, 1) : (
    shaperWnd.drawShaper(5, 0);
    shaperWnd.drawVolumes(filterBank.getBandPre(selectedBand), filterBank.getBandPost(selectedBand));  
  );
  
  /* Draw tops */
  driveModulator2.combobox_draw_top();
  driveModulator1.combobox_draw_top();
  shaperSelect.combobox_draw_top();
  shaperModulator2.combobox_draw_top();
  shaperModulator1.combobox_draw_top();
  
  gfx_x = gfx_y = 30;
  gfx_setfont(1,"ARIAL",30);
  gfx_set(0,0,0,.1+0.2*abs(sin(time_precise())));
  gfx_printf("S Q U A S H M A N  v  0 . 8 5 [Beta]");
  
  gfx_x = gfx_w-130*(1+scaling);
  gfx_y = bottomRow + 30*(1+scaling);
  gfx_set(1,1,1,.9);
  gfx_mode = 4;
  
  !loaded || (modVisible != lastModVisible) ? (
    ( modVisible == 0 ) ? (
      loaded = gfx_loadimg(5, "./Squashman_Dependencies/squashman2.png");
    ) : (
      loaded = gfx_loadimg(5, "./Squashman_Dependencies/squashman3.png");
    );
    lastModVisible = modVisible;
  );
  
  gfx_blit(5, 3.2*(1+scaling), 0);
  
  modPanelButton.drawButton(gfx_w-130*(1+scaling), spectrumH-25*(1+scaling), 120*(1+scaling), 25*(1+scaling), "Modulation", BAND_FONT, 14);
  modPanelButton.button_processMouse(mouse_x, mouse_y, mouse_cap) ? modVisible = 1 - modVisible;
  
  lastChar = gfx_getchar();
  lastCap = mouse_cap;
  filterBank.resetMeters();
  hinter.drawHint_draw();

