desc:Squashman (NOT READY FOR USE)
tags: multiband saturation plugin (WORK IN PROGRESS)
version: 0.19
author: Joep Vanlier
changelog: 
+ Fix issue with solo not working appropriately anymore.
+ Fix issue with band removal being broken.
license: MIT

Uses technique from: Parker et al, "REDUCING THE ALIASING OF NONLINEAR WAVESHAPING USING CONTINUOUS-TIME CONVOLUTION",
Proceedings of the 19th International Conference on Digital Audio Effects (DAFx-16), Brno, Czech Republic, September 5â€“9, 2016
I have only implemented the rect version, since the linear one depends on Li2 and LUTs aren't so fast in JSFX.

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:Cuts=1<0,4,1>-Cuts
slider2:Freq1=0.5<0,1,.0001>-Frequency 1
slider3:Freq2=0.5<0,1,.0001>-Frequency 2
slider4:Freq3=0.5<0,1,.0001>-Frequency 3
slider5:Freq4=0.5<0,1,.0001>-Frequency 4
slider6:Test=-1<-1,-1,-1>-Test
slider7:Drive1=0<-40,60,.1>-Drive 1 (dB)
slider8:Drive2=0<-40,60,.1>-Drive 2 (dB)
slider9:Drive3=0<-40,60,.1>-Drive 3 (dB)
slider10:Drive4=0<-40,60,.1>-Drive 4 (dB)
slider11:Drive5=0<-40,60,.1>-Drive 5 (dB)
slider12:Test=-1<-1,-1,-1>-Test
slider13:Gain1=0<-26,26,.1>-Gain 1 (dB)
slider14:Gain2=0<-26,26,.1>-Gain 2 (dB)
slider15:Gain3=0<-26,26,.1>-Gain 3 (dB)
slider16:Gain4=0<-26,26,.1>-Gain 4 (dB)
slider17:Gain5=0<-26,26,.1>-Gain 5 (dB)
slider12:Test=-1<-1,-1,-1>-Test
slider19:Mode1=0<0,17,1>-Mode 1
slider20:Mode2=0<0,17,1>-Mode 2
slider21:Mode3=0<0,17,1>-Mode 3
slider22:Mode4=0<0,17,1>-Mode 4
slider23:Mode5=0<0,17,1>-Mode 5
slider24:Test=-1<-1,-1,-1>-Test
slider25:Modifier1=0<0,1,.001>-Modifier1
slider26:Modifier2=0<0,1,.001>-Modifier2
slider27:Modifier3=0<0,1,.001>-Modifier3
slider28:Modifier4=0<0,1,.001>-Modifier4
slider29:Modifier5=0<0,1,.001>-Modifier5
slider30:Test=-1<-1,-1,-1>-Test
slider31:Delay1=0<0,1,.001>-Delay1
slider32:Delay2=0<0,1,.001>-Delay2
slider33:Delay3=0<0,1,.001>-Delay3
slider34:Delay4=0<0,1,.001>-Delay4
slider35:Delay5=0<0,1,.001>-Delay5
slider36:Feedback1=0<0,.99,.001>-Feedback1
slider37:Feedback2=0<0,.99,.001>-Feedback2
slider38:Feedback3=0<0,.99,.001>-Feedback3
slider39:Feedback4=0<0,.99,.001>-Feedback4
slider40:Feedback5=0<0,.99,.001>-Feedback5
slider41:DryWet1=1<0,1,.001>-Dry/Wet 1
slider42:DryWet2=1<0,1,.001>-Dry/Wet 2
slider43:DryWet3=1<0,1,.001>-Dry/Wet 3
slider44:DryWet4=1<0,1,.001>-Dry/Wet 4
slider45:DryWet5=1<0,1,.001>-Dry/Wet 5

slider62:masterGainSlider=0<-26,26,.1>-Master Gain
slider63:2<0,1,1>-Oversampling
slider64:0<0,1,1>-Fix DC?

@init
  function initBands()
  local()
  global()
  instance(lg1, lg2, lg3, lg4, lg5)
  (
    lg1 = lg2 = lg3 = lg4 = lg5 = -1000000;
  );

maxCuts = 4;
driveMax = 60;
driveMin = -40;
driveRange = driveMax - driveMin;
gainMin = -26;
gainMax = 26;

filterBank.initBands();

// Precompute some things
gainRange = ( gainMax - gainMin );
iGainRange = 1.0 / gainRange;

/* Keep these updated with the slider locations */
frequencyLocation = 2;
driveLocation     = 7;
modeLocation      = 19;
modifierLocation  = 25;
delayLocation     = 31;
feedbackLocation  = 36;
gainLocation      = 13;
drywetLocation    = 41;

/* Shift slider data right (for different bands) */
function shiftRight(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx-1);
      midx = midx - 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeft(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx+1);
      midx = midx + 1;
    );
  );

/* Make room for a new band in the slider data */
function addBand(idx)
  local(midx)
  instance()
  (
    shiftRight( driveLocation,     idx, maxCuts );
    shiftRight( modeLocation,      idx, maxCuts );
    shiftRight( modifierLocation,  idx, maxCuts );
    shiftRight( delayLocation,     idx, maxCuts );
    shiftRight( feedbackLocation,  idx, maxCuts );
    shiftRight( gainLocation,      idx, maxCuts );
    shiftRight( drywetLocation,    idx, maxCuts );
    shiftRight( frequencyLocation, idx, maxCuts-1 );
    cuts = cuts + 1;
  );
  
/* Remove a band and move other slider data accordingly */  
function remBand(idx)
  local(midx)
  instance()
  (
    shiftLeft( driveLocation,     idx, maxCuts );
    shiftLeft( modeLocation,      idx, maxCuts );
    shiftLeft( modifierLocation,  idx, maxCuts );
    shiftLeft( delayLocation,     idx, maxCuts );
    shiftLeft( feedbackLocation,  idx, maxCuts );
    shiftLeft( gainLocation,      idx, maxCuts );
    shiftLeft( drywetLocation,    idx, maxCuts );
    shiftLeft( frequencyLocation, idx, maxCuts-1 );
    cuts = cuts - 1;
  );  
  
nShapers = 18;  
  
/* Strings for the comboboxes */
function comboStrings(stridx, curitem)
  local(str)
  global()
  instance()
  (
    str = "";
    (stridx == 1) ?
    (
      ( curitem == 0 ) ? ( "Tanh" )
      : ( curitem == 1 ) ? ( "Tanh-like" )
      : ( curitem == 2 ) ? ( "Smooth" )
      : ( curitem == 3 ) ? ( "Asymmetric  (M)" )
      : ( curitem == 4 ) ? ( "Rapid Saturation" )
      : ( curitem == 5 ) ? ( "Chunky Clean" )
      : ( curitem == 6 ) ? ( "Crossover (M)" )
      : ( curitem == 7 ) ? ( "Dist. Crossover (M)" )
      : ( curitem == 8 ) ? ( "Dmgd Crossover (M)" )
      : ( curitem == 9 ) ? ( "Sine (M)" )
      : ( curitem == 10 ) ? ( "Octaver (M)" )
      : ( curitem == 11 ) ? ( "Wavefolder (M)" )
      : ( curitem == 12 ) ? ( "Serge Folder (M)" )
      : ( curitem == 13 ) ? ( "Chunker (M)" )
      : ( curitem == 14 ) ? ( "Nuker (M)" )
      : ( curitem == 15 ) ? ( "Bitcrusher (M)" )
      : ( curitem == 16 ) ? ( "Bitmorpher (M)" )
      : ( curitem == 17 ) ? ( "Bad connection (M)" )
    )
  );

function comboMapping(stridx, idx_in)
  local()
  global()
  instance()
  (
    idx_in;
  );

function inverseComboMapping(stridx, idx_in)
  local()
  global()
  instance()
  (
    idx_in;
  );

function hasShapeMod(curitem)
  local()
  global()
  instance()
  (
    ( curitem == 0 ) ? ( 0 )
    : ( curitem == 1 ) ? ( 0 )
    : ( curitem == 2 ) ? ( 0 )
    : ( curitem == 3 ) ? ( 1 )
    : ( curitem == 4 ) ? ( 0 )
    : ( curitem == 5 ) ? ( 0 )
    : ( curitem == 6 ) ? ( 1 )
    : ( curitem == 7 ) ? ( 1 )
    : ( curitem == 8 ) ? ( 1 )
    : ( curitem == 9 ) ? ( 1 )
    : ( curitem == 10 ) ? ( 1 )
    : ( curitem == 11 ) ? ( 1 )
    : ( curitem == 12 ) ? ( 1 )
    : ( curitem == 13 ) ? ( 1 )
    : ( curitem == 14 ) ? ( 1 )
    : ( curitem == 15 ) ? ( 1 )
    : ( curitem == 16 ) ? ( 1 )
    : ( curitem == 17 ) ? ( 1 )
  );

function updateHintTime(hint, hoverType)
  global(gfx_x, gfx_y, mouse_x, mouse_y, hintTime, currentHint, delta_time, lx, ly, hover)
  local()
  global()
  (
    ( (lx - mouse_x) || ( ly - mouse_y ) ) > 0 ? hintTime = 0;
    
    hint != 0 ? (
      currentHint = hint;
      hintTime = hintTime + 1 * delta_time;
      hover = hoverType;
      hintTime = min(1, hintTime)
    ) : (
      0
    )
  );

/* Feed sample to FFT */
function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );

/* Initialize FFT windowing function */
function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 

/* Calculate current spectrum */
function calcFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, slope, yshift)
  local(buf1, buf2, buf3, yOut, i, prec, ty)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

/* Set location of a window */
function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

// Draws the basic box for the FFT
function drawBackface()
  instance(x, y, w, h)
  global(backface_color_r, backface_color_g, backface_color_b, backface_color_a,
         grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local()
  (
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
  );

function drawEq(_x, _y, _w, _h, _bands)
  global( grid_color_r, grid_color_g, grid_color_b, grid_color_a
          group_r, group_g, group_b, group_a, gfx_x )
  instance(x, y, w, h, bands, dband)
  local()
  (
    x       = _x;
    y       = _y;
    w       = _w;
    h       = _h;
    bands   = _bands;
    
    gfx_set( 0, 0, 0, grid_color_a );
    gfx_rect( x, y, w, h );
    
    gfx_set( group_r, group_g, group_b, group_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y+h+1, x+w, y+h+1);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+w+1, y, x+w+1, y+h);
    gfx_line(x,y+.5*h,x+w,y+.5*h);
     
    dband = (w / bands);
    
    gfx_x = x;
    loop(bands,
      gfx_line(gfx_x, y, gfx_x, y+h);
      gfx_x += dband;  
    );
  );

// Draws the FFT Grid, frequency axis and dB axis
function drawGrid()  
  global(   fftSize, srate, gfx_x, gfx_y,
             )
  instance(x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset,
           grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local(xx, i, wsc, N, xl)
  (    
    this.drawBackface();
    
    i = 0;
    wsc = w/log(1+fftSize*0.5-hzoffset);
    xl = x;
    gfx_y = y+h+2;
    
    gfx_setfont(1, "Arial", 14);
    loop(16,
      xx = x + log(1+i*fftSize/srate-hzoffset)*wsc;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(xx, y, xx, y+h);
      
      ( (xx - xl) > 30 ) ? (
        gfx_set( 1, 1, 1, 1 );
        gfx_x = xx+2;
        gfx_line(xx, y+h, xx, y+h+7);
        (i>999) ? (
          gfx_printf("%dk", .001*i);
        ) : (
          gfx_printf("%d", i);
        );
        xl = xx;
      );
      
      ( i < 100 ) ? (i += 20) :
      ( i < 1000 ) ? (i += 200) :
      ( i < 10000 ) ? (i += 2000) :
      ( i < 100000 ) ? (i += 20000);
    );
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    N = 8;
    xx = y;
    i = 0;
    gfx_measurestr("8", wsc, xl);
    loop(N,
      gfx_set( 1, 1, 1, 1 );
      gfx_x = x+w-20;
      gfx_y = xx-.5*xl;
      i > 0 ? gfx_printf("-%d", 4.41*i*floorLevel/N);
      
      xx += h/N;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(x, xx, x+w, xx);
      i += 1;
    );
  );
  
function drawLine(x1, y1, x2, y2)
  local(dx, dy, x, smooth)
  global(gfx_x, gfx_y)
  instance()
  (
    smooth = 1;
    x1 = floor(x1);
    x2 = floor(x2);
    gfx_x=x1;
    gfx_y=y1;
    x2 = floor(x2);
    y2 = floor(y2);
    
    smooth ? (
      (x2 - x1) > 4 ? (
        dx = 1.0/(x2-x1);
        dy = (y2 - y1)*6*dx;
        x = 0;
        loop(x2-x1,
          x2 = x1 + 1;
          y2 = y1 + dy * ( x - x*x );
          
          gfx_line(x1, y1-1, x2, y2-1, 1);
          gfx_lineto(x2,y2,1);
          x1 = x2;
          y1 = y2;
          x = x + dx;
        );
      ) : (
        gfx_line(x1, y1-1, x2, y2-1, 1);
        gfx_lineto(x2,y2,1);
      );
    ) : (
      gfx_line(x1, y1-1, x2, y2-1, 1);
      gfx_lineto(x2,y2,1); 
    );
  );

bandClickRange = 10;
overRange = 10;

function isOver(mx, my)
  instance(x, y, w, h)
  global(overRange)
  local()
  (
    ( ( mx >= (x-overRange) ) && ( mx <= (x+w+overRange) ) && ( my >= (y-overRange) ) && ( my <= (y+h+overRange) ) ) ? 1 : 0;
  );

function clamp(value, mini, maxi)
  local()
  global()
  (
    max(min(value,maxi),mini)
  );

function overRect(x, y, w, h, mx, my)
  local()
  global()
  (
    ( (mx > x) && (mx < (x+w) ) && (my > y) && (my < (y+h) ) )
  );

function pixelToWindowRatio(x_loc)
  instance(x, y, w, h, hzoffset)
  global(fftSize)
  local(lmin, wsc, hfft)
  (
    hfft  = 0.5*fftSize;
    lmin  = log(20/22050);
    wsc   = w/log(1+fftSize*0.5-hzoffset);
    
    1-log( (exp((x_loc)/wsc) + hzoffset)/hfft )/lmin
  );

function fftWindow_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, lx, ly, lcap, cap, thisUI, htime, hint,
           x_over, dragging, lastLeftClick
           x1, x2, x3, x4, x5,
           v1, v2, v3, v4, v5,
           h1, h2, h3, h4, h5, 
           c1, c2, c3, c4, c5 )
  global(dnoisefloor_freq, dsteps_fft, mouse_wheel, lastUI, fftSize,
         bandClickRange, cuts,
         Freq1, Freq2, Freq3, Freq4,
         Drive1, Drive2, Drive3, Drive4, Drive5,
         mute1, mute2, mute3, mute4, mute5,
         solo1, solo2, solo3, solo4, solo5,
         driveMin, driveMax, maxCuts,
         selectedBand, gfx_x, gfx_y )
  local(dx, dy, over,
        F1, F2, F3, F4,
        leftClick, rightClick, doubleClick,
        cTime, mpos)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    leftClick   = ( mouse_cap & 1 == 1 && lcap & 1 == 0 );
    rightClick  = ( mouse_cap & 2 == 2 && lcap & 2 == 0 );
    doubleClick = 0;
    
    leftClick ? (
       time_precise(cTime);
       ( ( cTime - lastLeftClick ) < .25 ) ? (
          leftClick = 0;
          doubleClick = 1;
       );
       lastLeftClick = cTime;
    );
    
    x_over = -1;
    
    /*gfx_x = 0;
    gfx_y = 0;
    gfx_set(1,1,1,1);
    gfx_printf("%g", this.pixelToWindowRatio(mouse_x));*/
    
    ( cap == 3 && mouse_cap & 1 == 1 ) ? (
      dy = mouse_y - ly;
      
      dragging == 1 ? ( Drive1 -= 100*dy/h; Drive1 = clamp(Drive1, driveMin, driveMax); );
      dragging == 2 ? ( Drive2 -= 100*dy/h; Drive2 = clamp(Drive2, driveMin, driveMax); );
      dragging == 3 ? ( Drive3 -= 100*dy/h; Drive3 = clamp(Drive3, driveMin, driveMax); );
      dragging == 4 ? ( Drive4 -= 100*dy/h; Drive4 = clamp(Drive4, driveMin, driveMax); );
      dragging == 5 ? ( Drive5 -= 100*dy/h; Drive5 = clamp(Drive5, driveMin, driveMax); );
      
    ) : ( cap == 2 && mouse_cap & 1 == 1 ) ? (
      // Dragging a band frequency
      dx = mouse_x - lx;
      
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
      
      dragging == 1 ? ( 
        F1 = this.pixelToWindowRatio(x1 - x + dx);
        slider_automate( Freq1 = clamp( F1, 0, 1 ) );
        slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-F1), 0, 1 ) );
      );
      dragging == 2 ? ( 
        F2 = this.pixelToWindowRatio(x2 - x + dx);
        slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-Freq1), 0, 1 ) );
        F2 = Freq1  + Freq2 * (1 - Freq1);
        slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1) );
      );
      dragging == 3 ? ( 
        F3 = this.pixelToWindowRatio(x3 - x + dx);
        slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1 ) );
        F3 = F2     + Freq3 * (1 - F2);
        slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
      );
      dragging == 4 ? ( 
        F4 = this.pixelToWindowRatio(x4 - x + dx);
        slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
      );

    ) : ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dnoisefloor_freq -= .5*(mouse_y-ly);
      dnoisefloor_freq > 35 ? dnoisefloor_freq = 35;
      dnoisefloor_freq < -15 ? dnoisefloor_freq = -15;
    ) : ( 
      // Not already capped
      cap = 0;
      
      /* Toggle mute/solo */
      ( c1.isOver(mouse_x, mouse_y) == 1 ) ? (
        c1.over = 1;
        leftClick ? ( mute1 = 1-mute1; solo1 ? (mute1 = 1; solo1 = 0; selectedBand = 0; ) );
        rightClick ? ( solo1 = 1-solo1; selectedBand = 0; );
      ) : ( c2.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        c2.over = 1;
        leftClick ? ( mute2 = 1-mute2; solo2 ? (mute2 = 1; solo2 = 0; selectedBand = 1;) );
        rightClick ? ( solo2 = 1-solo2; selectedBand = 1; );
      ) : ( c3.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 1 ) ? (
        c3.over = 1;
        leftClick ? ( mute3 = 1-mute3; solo3 ? (mute3 = 1; solo3 = 0; selectedBand = 2; ) );
        rightClick ? ( solo3 = 1-solo3; selectedBand = 2; );
      ) : ( c4.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 2 ) ? (
        c4.over = 1;
        leftClick ? ( mute4 = 1-mute4; solo4 ? (mute4 = 1; solo4 = 0; selectedBand = 3; ) );
        rightClick ? ( solo4 = 1-solo4; selectedBand = 3; );
      ) : ( c5.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 3 ) ? (
        c5.over = 1;
        leftClick ? ( mute5 = 1-mute5; solo5 ? (mute5 = 1; solo5 = 0; selectedBand = 4; ) );
        rightClick ? ( solo5 = 1-solo5; selectedBand = 4; );
        
      /* Drag frequency */
      ) : ( v1.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        v1.over = 1;
        leftClick ? ( cap = 2; dragging = 1; );
        rightClick ? ( 
          Freq2 = ( Freq2 * ( 1 - Freq1 ) + ( Freq1 - 0 ) ) / ( 1 - 0 );
          remBand(0);
        );
      ) : ( v2.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        v2.over = 1;
        leftClick ? ( cap = 2; dragging = 2; );
        rightClick ? ( 
          Freq3 = ( Freq3 * ( 1 - Freq2 ) + ( Freq2 - 0 ) ) / ( 1 - 0 );
          remBand(1);
        );
      ) : ( v3.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        v3.over = 1;
        leftClick ? ( cap = 2; dragging = 3; );
        rightClick ? ( 
          Freq4 = ( Freq4 * ( 1 - Freq3 ) + ( Freq3 - 0 ) ) / ( 1 - 0 );
          remBand(2);
        );
      ) : ( v4.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        v4.over = 1;
        leftClick ? ( cap = 2; dragging = 4; );
        rightClick ? ( remBand(3); );
      ) : ( v5.isOver(mouse_x, mouse_y) ) && ( cuts > 4 ) ? (
        v5.over = 1;
        leftClick ? ( cap = 2; dragging = 5; );
        rightClick ? ( remBand(4); );
      
      /* Drag drive */
      ) : ( h1.isOver(mouse_x, mouse_y) ) ? (
        h1.over = 1;
        leftClick ? ( cap = 3; dragging = 1; selectedBand = 0; );
        doubleClick ? ( drive1 = 0; selectedBand = 0; );
      ) : ( h2.isOver(mouse_x, mouse_y) ) && ( cuts > 0 ) ? (
        h2.over = 1;
        leftClick ? ( cap = 3; dragging = 2; selectedBand = 1; );
        doubleClick ? ( drive2 = 0; selectedBand = 1;);
      ) : ( h3.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        h3.over = 1;
        leftClick ? ( cap = 3; dragging = 3; selectedBand = 2; );
        doubleClick ? ( drive3 = 0; selectedBand = 2; );
      ) : ( h4.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        h4.over = 1;
        leftClick ? ( cap = 3; dragging = 4; selectedBand = 3; );
        doubleClick ? ( drive4 = 0; selectedBand = 3; );
      ) : ( h5.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        h5.over = 1;
        leftClick ? ( cap = 3; dragging = 5; selectedBand = 4; );
        doubleClick ? ( drive5 = 0; selectedBand = 4; );
        
      /* Handle clicks within the bands (creating a new band or selecting a band) */
      ) : ( overRect( h1.x, y, h1.w, h, mouse_x, mouse_y ) ) ? (
        leftClick ? selectedBand = 0;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(0);
          mpos = this.pixelToWindowRatio(mouse_x);
          Freq2 = ( Freq2 * (1-0) + 0 - mpos ) / ( 1 - mpos );
          Freq1 = mpos;
        );
      ) : ( overRect( h2.x, y, h2.w, h, mouse_x, mouse_y ) && ( cuts > 0 )  ) ? (
        leftClick ? selectedBand = 1;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(1);
          mpos = this.pixelToWindowRatio(mouse_x);
          Freq3 = ( Freq3 * (1-Freq1) + Freq1 - mpos ) / ( 1 - mpos );
          Freq2 = ( mpos - Freq1 ) / ( 1 - Freq1 );
        );
      ) : ( overRect( h3.x, y, h3.w, h, mouse_x, mouse_y ) && ( cuts > 1 ) ) ? (
        leftClick ? selectedBand = 2;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(2);
          mpos = this.pixelToWindowRatio(mouse_x);
          F2 = Freq1  + Freq2 * (1 - Freq1);
          Freq4 = ( Freq4 * (1-F2) + F2 - mpos ) / ( 1 - mpos );
          Freq3 = ( mpos - F2 ) / ( 1 - F2 );
        );
      ) : ( overRect( h4.x, y, h4.w, h, mouse_x, mouse_y ) && ( cuts > 2 ) ) ? (
        leftClick ? selectedBand = 3;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(3);
          mpos = this.pixelToWindowRatio(mouse_x);
          F2 = Freq1  + Freq2 * (1 - Freq1);
          F3 = F2     + Freq3 * (1 - F2);
          Freq4 = ( mpos - F3 ) / ( 1 - F3 );
        );
      ) : ( overRect( h5.x, y, h5.w, h, mouse_x, mouse_y ) && ( cuts > 3 ) ) ? (
        leftClick ? selectedBand = 4;
      ) : (
        cap = 0;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
          cap = 1;
        );
      );
    );
    
    mouse_wheel > 0 && over ? lastUI = thisUI;
    
    abs(floor(mouse_wheel/240)) > 0 && over ?
    (
      dsteps_fft += floor(mouse_wheel/240);
      dsteps_fft > 8 ? dsteps_fft = 8;
      dsteps_fft < -4 ? dsteps_fft = -4;
      mouse_wheel = 0;
    );
    
    lx = mouse_x;
    ly = mouse_y;
    lcap = mouse_cap;
    
    over
  );

function drawFFT(fill, oversamplingFactor, r, g, b, a)
  global(scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate, gfx_mode, dsteps_fft )
  instance(hstep, x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset)
  local(copyval, stepsize, buf, i, ixsc, txl, tx, ty, wsc, fill, tx0, lx0, lx, ly, ty2, ly2, fill_slast, fill_slmin, cum, cumelem)
  (
    this.calcFFT();
 
    cum = -10000000;
    cumelem = 0;
    i = 0;
    ixsc = 0;
    wsc = w/log(1+fftsize*0.5-hzoffset);
    fill_slmin = y;

    buf = fftLoc + fftsize*0.5 - 2;
    stepsize = floor((4+dsteps_fft)*(1+scaling));
    copyval = buf[];
    loop( stepsize*200,
      (buf+=1)[] = copyval;
    );
     
    gfx_r = r;
    gfx_g = g;
    gfx_b = b;
    gfx_a = a;
 
    hstep = .5 * stepsize;
    buf = fftLoc;
    txl = x;
    lx = x;
    ly = y - max(buf[], -floorLevel)*h / floorLevel;
    buf += 1;
    loop(fftsize*0.5+stepsize*200,
      tx = floor(x + log(1.0+ixsc-hzoffset)*wsc);
      cum = max(cum, buf[]);
      cumelem += 1;
      
      ( (tx != txl) && (tx-txl > stepsize) && tx > x && i && ( tx < (x+w+stepsize) ) ) ? // 
      ( 
        ty = y - max(cum, -floorLevel)*h / floorLevel;
        //ty = y - log(cum)+100;
        txl = floor(tx);
        
        tx = min(tx, x+w);
        (fill) ? 
        (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0 ? 
          (
            gfx_triangle(lx0-hstep,max(y+h,ly),lx0-hstep,ly,tx0-1-hstep,ty,tx0-1-hstep,max(y+h,ty));
          ) : (
            tx0 > fill_slast ? 
            (
              fill_slast < h ? gfx_line(fill_slast,h,fill_slast,fill_slmin);
              fill_slmin=h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          
          fill_slast=tx0;        
        );
        
        (fill==0) ? (
          drawLine(lx-hstep, ly, tx-hstep, ty);
        );
        
        lx=tx; ly=ty; ly2=ty2; cum = -1000000; cumelem = 0;
      );
      
      buf+=1; i+=1; ixsc+=oversamplingFactor;
    );
  );
  
function drawLineFFT(peakLocation)
  global(fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate)
  instance(x, y, w, h, hzoffset)
  local(wsc, tx, base, i)
  (
    wsc = w/log(1+fftSize*0.5-hzoffset);
    base = fftSize*peakLocation;
    tx = floor(x + log(1.0+base-hzoffset)*wsc);
    drawLine(tx, y, tx, y+h);
  );
  
function f_trafo(freq)
  local()
  global()
  instance()
  (
    exp( (1-freq) * log(20/22050) )
  );  
  
function updateBands()
  global(Freq1,   Freq2,  Freq3,  Freq4,
         Ceil1,   Ceil2,  Ceil3,  Ceil4,
         Drive1,  Drive2, Drive3, Drive4, Drive5
         fftSize, driveRange, driveMax)
  instance(x, y, w, h, hzoffset,
           x1, x2, x3, x4, x5, /* Frequencies */
           y1, y2, y3, y4, y5  /* Drives      */
           )
  local(F1, F2, F3, F4, F5, wsc, hfft, lmin, irange, dmax)
  (
    F1 = Freq1;
    F2 = Freq1  + Freq2 * (1 - Freq1);
    F3 = F2     + Freq3 * (1 - F2);
    F4 = F3     + Freq4 * (1 - F3);
    
    hfft = 0.5*fftSize;
    lmin = log(20/22050);
    
    wsc = w/log(1+fftSize*0.5-hzoffset);
    x1 = ( x + log( hfft * exp( (1-F1) * lmin ) - hzoffset ) * wsc );
    x2 = ( x + log( hfft * exp( (1-F2) * lmin ) - hzoffset ) * wsc );
    x3 = ( x + log( hfft * exp( (1-F3) * lmin ) - hzoffset ) * wsc );
    x4 = ( x + log( hfft * exp( (1-F4) * lmin ) - hzoffset ) * wsc );
    x5 = ( x + log( hfft * exp( lmin ) - hzoffset ) * wsc );
       
    iRange = 1/driveRange;
    dmax = iRange * driveMax;
    
    y1 = y+h*(dmax-iRange*Drive1);
    y2 = y+h*(dmax-iRange*Drive2);
    y3 = y+h*(dmax-iRange*Drive3);
    y4 = y+h*(dmax-iRange*Drive4);
    y5 = y+h*(dmax-iRange*Drive5);
  );

function fancyCircle(x1, y1, rin, mute, solo)
  local(dx)
  global()
  instance(x, y, r, over)
  (
    x = x1;
    y = y1;
    rin == 0 ? r = 10 : r = rin;
    
    over ? (
      gfx_set(1, 1, 1, .2);
      gfx_circle(x, y, 1.1*r, 1, 1);
      gfx_set(1, 1, 1, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);
      gfx_set(1, 1, 1, .2);
      gfx_circle(x, y, 1.3*r, 1, 1);
    );
    
    gfx_set(.2, .2, .2, 1);
    gfx_circle(x, y, r, 1, 1);
    
    gfx_set(.7, .7, .7, .7);
    gfx_circle(x, y, .92*r, 1, 1);
    
    gfx_set(.2, .2, .2, .7);
    gfx_circle(x, y, .8*r, 1, 1);
    
    gfx_set(.2, .2, .2, .7);
    gfx_circle(x, y, .7*r, 1, 1);
    
    ( solo == 1 ) ? (
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, .8*r, 1, 1);
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, .9*r, 1, 1);
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, r, 1, 1);
      gfx_set(.2, 1, .2, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);
    ) : ( mute == 1 ) ? (
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, .8*r, 1, 1);
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, .9*r, 1, 1);
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, r, 1, 1);
      gfx_set(1, .2, .2, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);
    );    
    
    over = 0;
  );
  
function drawGroupRect(x, y, w, h, r, g, b, a)  
  local()
  instance()
  global()
  (
    gfx_set(r, g, b, a);
    gfx_line(x, y, x+w, y);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y+h, x+w, y+h);
    
    gfx_set(r, g, b, a*.5);
    gfx_line(x, y+h+1, x+w, y+h+1);
    gfx_line(x+w+1, y, x+w+1, y+h);
  );
 
function processMouseToggle(mx, my, mousecap)
  instance(x, y, w, h, on, lastleft)
  local(left, slack)
  global()
  (
    slack = 5;
    left = mousecap & 1;
    
    ( (left == 1) && (lastleft == 0) ) ?  (
      ( (mx >= (x-slack)) && ( mx <= (x+w+slack) ) && ( my >= (y-slack) ) && ( my <= (y+h+slack) ) ) ? (
        on = 1 - on;
      );
    );
    
    lastleft = left;
    
    on
  );
 
function drawToggle(_x, _y, _w, _h, _on, wr, wg, wb, wa, r, g, b, a)
  local()
  instance(x, y, w, h, on)
  global(gfx_a, gfx_mode)
  (
    x = _x;
    y = _y;
    w = _w;
    h = _h;
    on = _on;

    gfx_set(0, 0, 0, 0);
    gfx_rect(x, y, w, h);
    
    gfx_set(r, g, b, a*.2);
    gfx_rect(x, y, w, h);
    
    gfx_set(wr, wg, wb, wa);
    gfx_line(x, y, x+w, y);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y+h, x+w, y+h);
    
    on ? (
      gfx_set(r, g, b, a);
      gfx_rect(x, y, w, h);
      gfx_a *= .6;
      gfx_rect(x-1, y-1, w+2, h+2);
      gfx_a *= .6;
      gfx_rect(x-2, y-2, w+4, h+4);
      gfx_a *= .6;
      gfx_rect(x-3, y-3, w+6, h+6);
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 2*max(w,h), 2*max(w,h));
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 3*max(w,h), 3*max(w,h));
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 4*max(w,h), 4*max(w,h));
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 5*max(w,h), 5*max(w,h));
    );
  );
 
function drawKnob(_x, _y, _r, text)
  local(ang, dang, r0, r1, r2, r3, rk, tw, th)
  instance(x, y, r, value, active)
  global(gfx_x, gfx_y)
  (
    x = _x;
    y = _y;
    r = _r;
    
    r0 = .5*r;
    r1 = 1.2*r;
    r2 = 1.4*r;
    r3 = 1.7*r;
    rk = .1*r;
    
    gfx_set(.2, .3, .7, 1);
    gfx_circle(x, y, r, 1, 1);
    gfx_set(0, 0, 0, 1);
    gfx_circle(x, y, .9*r, 1, 1);
    gfx_set(.2, .3, .6, 1);
    gfx_circle(x, y, .8*r, 1, 1);
    gfx_set(1, 1, 1, .04);
    gfx_circle(x, y, .7*r, 1, 1);

    !active ? (
      gfx_set(0, 0, 0, .5);
      gfx_circle(x, y, r, 1, 1);
    );
  
    gfx_set(0, 0, 0, .2);
    gfx_circle(x, y, .78*r, 0, 1);
    gfx_circle(x, y, .76*r, 0, 1);
    gfx_set(.3, .4, .8, 1);
    
    ang = .75*$pi;
    dang = 1.5*$pi/30;
    
    // 31 segments
    loop(6,
      gfx_line(x + r1 * cos(ang), y + r1 * sin(ang), x + r3 * cos(ang), y + r3 * sin(ang) );
      ang += dang;
      loop(4,
        gfx_line(x + r1 * cos(ang), y + r1 * sin(ang), x + r2 * cos(ang), y + r2 * sin(ang) );
        ang += dang;
      );
    );
    gfx_line(x + r1 * cos(ang), y + r1 * sin(ang), x + r3 * cos(ang), y + r3 * sin(ang) );
    
    ang = .75*$pi + 1.5*$pi*value;
    active ? (
      gfx_set(0, 0, 0, .9);
      gfx_circle( x + r0 * cos(ang), y + r0 * sin(ang), rk, 1, 1 );
    );
    
    gfx_set(.4, .6, .9, 1);

    gfx_setfont(2, "Arial", 13);
    gfx_measurestr(text, tw, th);
    gfx_x = x - .5*tw;
    gfx_y = y + r + .25*th;
    gfx_printf(text);
  );
  
function processMouse(mx, my, mousecap, default)
  local(left, dx, dy, change, mul)
  instance(value, x, y, r, cap, lleft, lx, ly, active, lastLeftClick, doubleClick, cTime)
  global()
  (
    change = 0;
    mul = 1;
    
    (mousecap&4) ? mul = mul * 0.1666666666667; /* CTRL */
    (mousecap&8) ? mul = mul * 0.125; /* SHIFT */
    active ? (
      left = mousecap & 1;
      
      doubleClick = 0;
      (left && !lleft) ? (
         time_precise(cTime);
         ( ( cTime - lastLeftClick ) < .25 ) ? (
            doubleClick = 1;
         ) : lastLeftClick = cTime;
      );
      
      ( left && cap == 1 ) ? (
        value = value - .01*mul*(my - ly);
        value = clamp(value, 0, 1);
        change = 1;
      ) : ( cap = 0; );
      
      ( left && !lleft ) ? 
      (
        dx = (mx-x);
        dy = (my-y);
        ( (dx*dx + dy*dy) < (r*r) ) ?
        (
          doubleClick ? (
            lastLeftClick = -100;
            change = 1;
            value = default;
          ) : ( 
            cap = 1;
          );
        );
      );
      
      lleft = left;
      lx = mx;
      ly = my;
    );
    
    change
  );

function combobox(x_in, y_in, w_in, h_in, r_in, g_in, b_in, a_in, nitems_in, stridx_in, goup_in, cols_in, hint_in )
  local()
  global(newUI)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, hasfocus, goup, cols, thisUI, htime, hint)
  (
      !thisUI ?     thisUI = newUI += 1;
      x             = x_in;
      y             = y_in+1;
      w             = w_in;
      h             = ceil(h_in-2);
      r             = r_in;
      g             = g_in;
      b             = b_in;
      a             = a_in;
      nitems        = nitems_in;
      stridx        = stridx_in;
      goup          = goup_in;
      cols          = cols_in;
      hint          = hint_in;
      //cap           = 0;
      //curitem       = 0;
      //open          = 0;
      //lastleft      = 0;
      //hasfocus      = 0;
      //htime         = 0;
      //hover         = 8;
  );
  
function combobox_setcuritem( item )
  local(i, xtxt)
  global(gfx_x, gfx_y)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, lastset)
  (
    curitem = inverseComboMapping(stridx, item);
  );  
  
function combobox_draw()
  local(i, xtxt, x1, x2, x3, y1, y2, y3, pad, wi)
  global(gfx_x, gfx_y, lastUI, scaling, 
         highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a,
         font_color_r, font_color_g, font_color_b, font_color_a,
         disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a )
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup, cols, thisUI, htime, disabled)
  (
    gfx_set( min(1,r + .15*htime), min(1,g + .15*htime), min(1,b + .25*htime), .1 );
    gfx_rect( x, y, w, h );
    
    disabled == 1 ? gfx_set( disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a ) :
    ( 
      lastUI == thisUI ? gfx_set( highlight_color_r, highlight_color_g, highlight_color_b, highlight_color_a ) : gfx_set( r, g, b, a );
    );
    
    gfx_line(x, y, x, y+h);
    gfx_line(x+1, y, x+w-1, y);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x+1, y+h, x+w-1, y+h);
    
    pad = .3*h;
    wi = .5 * (h-pad);
    x1 = x+w-wi-pad;
    x2 = x+w-pad;
    x3 = x+w-.5*wi-pad;
    
    y1 = y+pad;
    y2 = y+pad;
    y3 = y+h-pad;
    
    gfx_line(x1, y1, x2, y2);
    gfx_line(x2, y2, x3, y3);
    gfx_line(x3, y3, x1, y1);
  
    xtxt = x+3*(1+scaling);
    gfx_x = xtxt;
    gfx_y = y+4*(1+scaling);
    
    disabled == 0 ? gfx_set( font_color_r, font_color_g, font_color_b, font_color_a ) : gfx_set( disabled_color_r, disabled_color_g, disabled_color_b, disabled_color_a );
    gfx_printf(comboStrings(stridx, comboMapping(stridx, curitem)));
  );
  
function combobox_getCurItem()
  instance(stridx, curitem)
  global()
  local()
  (
    comboMapping(stridx, curitem)
  );
  
function combobox_draw_top()
  local(i, i_internal, j, xtxt, x1, x2, x3, y1, y2, y3, pad, wi, delta, ny, hasMarked)
  global(gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, font_color_r, font_color_g, font_color_b, font_color_a )
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, hasfocus, goup, cols, dangerousElements)
  (    
    xtxt = x+3;
    delta = goup ? (nitems/cols+1)*h : 0;
    gfx_x = xtxt;
    gfx_y = y + 4 - delta;
    ny = ceil(nitems/cols);
    
    hasMarked = dangerousElements > 0;
    open ?
    (
      gfx_set( r*.3, g*.3, b*.3, 1 );
      gfx_rect( x - (cols-1)*w, y-delta+h-1, cols*w+2, h * ny + 2 );
          
      gfx_set( r*.1, g*.1, b*.1, 1 );
      gfx_rect( x - (cols-1)*w+1, y-delta+h, cols*w, h * ny );
      i = 0; j = 0;
      gfx_set( r, g, b, a, 0.95 );
      loop( cols, 
        loop( ny,
          gfx_x = xtxt - (cols-1-j)*w + 1;
          gfx_y += h;
          hover == i ? (
            gfx_rect( gfx_x-3, gfx_y - 3, w, h );
            gfx_set( 0, 0, 0, a, 0.95 );
          ) : gfx_set( font_color_r, font_color_g, font_color_b, font_color_a );

          i_internal = comboMapping(stridx, i);
          ( hasMarked && dangerousElements[i_internal] ) ? (
            gfx_set( gfx_r+.3, gfx_g-.5, gfx_b-.5, .75*gfx_a );
            gfx_printf("[%s]", comboStrings(stridx, i_internal));
            gfx_set( gfx_r-.3, gfx_g+.5, gfx_b+.5, gfx_a/.75 );
          ) : gfx_printf(comboStrings(stridx, i_internal));
          i += 1;
        );
        gfx_y = y + 4 - delta;
        j += 1;
      );
      gfx_set( 1, 1, 1, .1 );
    )
  );

function combobox_processMouse(xx, yy, mc)
  local(over, left, right, change, delta, xmin, xmax, ymin, ymax, xl, yl, ny, hasMarked, olditem)
  global(gfx_x, gfx_y, lastUI, lastChar, mouse_wheel)
  instance(x, y, w, h, r, g, b, a, open, curitem, nitems, cap, hover, stridx, lastleft, lastright, hasfocus, goup, cols, thisUI, htime, hint, disabled, dangerousElements)  
  (
    disabled == 0 ? (
      delta   = goup ? (nitems/cols+1)*h : 0;
      change  = 0;
      left    = mc & 1;
      right   = mc & 2;
      
      olditem = curitem;
      xmin    = x - (cols-1)*w;
      ymin    = y + h - delta;
      xmax    = x + w;
      ny      = ceil(nitems/cols);
      ymax    = ymin + ny*h;
      
      hasMarked = dangerousElements > 0;
      over = xx > x && xx < ( x+w ) && yy > y && yy < ( y + h );
      
      ( lastUI == thisUI ) ?
      (
        ( lastChar == 1685026670 ) ? 
        ( 
          curitem = curitem + 1;
          curitem > nitems - 1 ? curitem = 0;
          while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
          (
            curitem = curitem + 1;
            curitem > nitems - 1 ? curitem = 0;
          );
          
          change = 1;
          mouse_wheel = 0;
        ) : (
          ( lastChar == 30064 ) ? 
          (
            curitem = curitem - 1;
            curitem < 0 ? curitem = nitems-1;
            while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
            (
              curitem = curitem - 1;
              curitem < 0 ? curitem = nitems-1;
            );
            
            change = 1;
            mouse_wheel = 0;
          );
        );
      );
      
      ( over ) ?
      (
        ( mouse_wheel < 0 ) ? 
        ( 
          curitem = curitem + 1;
          curitem > nitems - 1 ? curitem = 0;
          
          while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
          (
            curitem = curitem + 1;
            curitem > nitems - 1 ? curitem = 0;
          );
          
          change = 1;
          mouse_wheel = 0;
        ) : 
        (
          ( mouse_wheel > 0 ) ? 
          (
            curitem = curitem - 1;
            curitem < 0 ? curitem = nitems-1;
            
            while( hasMarked && (dangerousElements[comboMapping(stridx, curitem)]==1) && (curitem != olditem) )
            (
              curitem = curitem - 1;
              curitem < 0 ? curitem = nitems-1;
            );
            
            change = 1;
            mouse_wheel = 0;
          );
        );
      );
      
      over ? (
        htime = updateHintTime(hint, 0);
      ) : htime = updateHintTime(0, 0);
      
      open ? 
      (
        xl = min( max( 0, floor((xx - xmin)/w)), cols-1 );
        yl = floor((yy-ymin)/h);
         
        hover = min( nitems-1, max( 0, xl * ny + max(0, min(ny-1, yl)) ) );
        
        ( !lastleft && left ) ? (
          open = 0;
          ( xx > xmin && xx < xmax && yy > (y+h-delta) && yy < ( ymax ) ) ? ( curitem = hover; change = 1 );
        ) : ( !lastright && right ) ? (
          hover > 0 ? dangerousElements[comboMapping(stridx, hover)] = 1 - dangerousElements[comboMapping(stridx, hover)];
        )
      ) : (
        ( lastleft == 0 && left && over ) ? (
          open = 1; hasfocus = 1; lastUI = thisUI;
        )
      );
      
      ( !left && !open ) ? hasfocus = 0;
      
      lastleft = left;
      lastright = right;
      
      change
    );
  );

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
  
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    c2 * (1.0-frac) + c1 * frac
  );
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );  
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    memset( scopebuffer, 0, MAXBUFFERSIZE );
    scopeptr = scopebuffer;
  );  
  
function fancyLineV(x1, y1, x2, y2)
  local(dx)
  global()
  instance(x, y, w, h, over)
  (
    dx = 5; 
    
    x = x1 - .5*dx;
    y = y1;
    w = dx;
    h = y2-y1;
  
    gfx_set(.2, .2, .2, 1);
    gfx_rect(x, y, w, h);
    gfx_set(.5, .5, .5, 1);    
    dx = 3; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(.7, .7, .7, 1);
    dx = 2; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    
    over ? ( 
      gfx_set(1,1,1,.7);
      gfx_rect(x, y, w, h);
    );
    
    over = 0;
  );

function fancyLineH(x1, y1, x2, y2)
  local(dy)
  global()
  instance(x, y, w, h, over)
  (
    dy = 5;
    
    x = x1;
    y = y1 - .5*dy;
    w = x2-x1;
    h = dy;
  
    gfx_set(.2, .2, .2, 1);
    gfx_rect(x, y, w, h);
    gfx_set(.5, .5, .5, 1);    
    dy = 3; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(.7, .7, .7, 1);
    dy = 2; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    
    over ? ( 
      gfx_set(1,1,1,.7);
      gfx_rect(x, y, w, h);
    );
    
    over = 0;    
  );
  
function drawBands()
  global(Cuts, 
           mute1, mute2, mute3, mute4, mute5,
           solo1, solo2, solo3, solo4, solo5,
           selectedBand )
  instance(xc, dx, x, y, w, h, 
           x1, x2, x3, x4, x5, // Band frequency screen positions
           y1, y2, y3, y4, y5, // Band drive positions
           v1, v2, v3, v4, v5, // Frequency handles
           h1, h2, h3, h4, h5, // Drive handles
           c1, c2, c3, c4, c5, // Circle handles
           x_over)
  local()
  (
    xc = x;
    dx = 5;
    while(xc<x+w) (
      gfx_set(0,0,0,1);
      gfx_line(xc, y+.6*h+1, xc+dx, y+.6*h+1);
      gfx_line(xc, y+.6*h-1, xc+dx, y+.6*h-1);
      gfx_set(0.6,0.6,0.6,1);
      gfx_line(xc, y+.6*h, xc+dx, y+.6*h);
      xc = xc + 2*dx;
    );
    
    gfx_set(1,1,1,1);
    (Cuts > 0) ? (
      v1.fancyLineV(x1, y, x1, y+h);
    );
    (Cuts > 1) ? (
      v2.fancyLineV(x2, y, x2, y+h);
    );
    (Cuts > 2) ? (
      v3.fancyLineV(x3, y, x3, y+h);
    );
    (Cuts > 3) ? (
      v4.fancyLineV(x4, y, x4, y+h);
    );
    (Cuts > 4) ? (
      v5.fancyLineV(x5, y, x5, y+h);
    );
    
    gfx_rect(x_over-3, y, 5, h);
    
    ( Cuts == 0 ) ? (
       h1.fancyLineH(x, y1, x+w-2, y1);
       c1.fancyCircle(x + .5*w, y1, 0, mute1, solo1);
    ) : ( Cuts == 1 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1);
       h2.fancyLineH(x1, y2, x+w-2, y2);
       c2.fancyCircle(x1 + .5*(w-x1), y2, 0, mute2, solo2);
    ) : ( Cuts == 2 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2);
       h3.fancyLineH(x2, y3, x+w-2, y3);
       c3.fancyCircle(x2 + .5*(w-x2), y3, 0, mute3, solo3);
    ) : ( Cuts == 3 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3);
       h4.fancyLineH(x3, y4, x+w-2, y4);
       c4.fancyCircle(x3 + .5*(x4-x3), y4, 0, mute4, solo4);
    ) : ( Cuts == 4 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3);
       h4.fancyLineH(x3, y4, x4-2, y4);
       c4.fancyCircle(x3 + .5*(x4-x3), y4, 0, mute4, solo4);
       h5.fancyLineH(x4, y5, x+w-2, y5);
       c5.fancyCircle(x4 + .5*(w-x4), y5, 0, mute5, solo5);
    );
    
    selectedBand == 0 ? gfx_muladdrect( h1.x, y, h1.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 1 ? gfx_muladdrect( h2.x, y, h2.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 2 ? gfx_muladdrect( h3.x, y, h3.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 3 ? gfx_muladdrect( h4.x, y, h4.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 4 ? gfx_muladdrect( h5.x, y, h5.w, h, 1, 1, 1, .6, .05, .05, .105 );
    
    //this.drawLineFFT(.5*f_trafo(F1));
    //this.drawLineFFT(.5*f_trafo(F2));
    //this.drawLineFFT(.5*f_trafo(F3));
    //this.drawLineFFT(.5*f_trafo(F4));
    
  );  
  
function initSpectrum(memoryOffset, fftSize, srate)
  global(newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 20*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );
  
  
  function F0(x, em2x)
  local()
  global()
  instance()
  (
    x - log(2/(1 + em2x))
  );
  
  function tanh_prec(x, em2x)
  local() 
  global()
  instance()
  (
    (2/(1+em2x))-1
  );
  
  function tanh(x)
  local()
  global()
  instance()
  (
    (2/(1+exp(-2*x)))-1
  );
  
  function antialiased_tanh_rect(x)
  local(eps, em2x, F0_xn)
  global(slider4)
  instance(antialias, F0_xnm1, xnm1,diff)
  (
    354 < abs(x) ? (
      antialias = sign(x);
      x         = antialias * 354;
      F0_xn     = 354 - log(2);
    ) : (
      em2x      = exp(-2*x);
      F0_xn     = F0(x, em2x);
      diff      = ( x - xnm1 );
      eps       = 0.0000000001;
      antialias = (abs(diff) > eps) ? ( F0_xn - F0_xnm1 ) / diff : tanh(.5*(x+xnm1));
    );
    
    F0_xnm1   = F0_xn;
    xnm1      = x;

    antialias
  );
  
  // Approximation to W(exp(x))
  function lambertExpApprox(x)  
    local(ex, approx, v, c, p, t, f)
    global()
    instance()
    (
      ex = exp(x);
      
      approx = sqrt(2*$e*ex + 2) - 1;
      v = log(ex + 1);
      v = v - log(v);
      c = abs(ex + 1/$e);
      c = (c > 1.45);
      approx = (1 - c)*approx + c*v;
      loop(2,
        p = exp(approx);
        t = approx*p - ex;
        t = t/(p*(approx + 1) - 0.5*(approx + 2.0)*t/(approx + 1));
        approx = approx - t;
      );
      
      approx
    );
    
  function folder_init(cutoff, reso)
    local(R, RL, Vt, iVt)
    instance(dc_scum, alpha, beta, delta)
    global()
    (
      R       = 15000;
      RL      = (8000+49000*cutoff);
      iVt     = 1/.025864;
      dc_scum = .1 * reso;
      
      alpha   = 2 * RL / R;
      beta    = (alpha + 1) * iVt;
      delta   = log( RL * .00000000000000001 * iVt );
    );      
    
  function folder_eval(sample)
    local(lambda)
    instance(alpha, beta, delta)
    global()
    (
      lambda = sign(sample);
      .025864 * lambda * lambertExpApprox( lambda * beta * sample + delta ) - alpha * sample
    );    
  
  function resetBandMeter()
  local()
  global()
  instance(in, pre, post)
  (
    in = pre = post = 0;
  );
  
  /* TO DO: Merge crossovers with control */
  function processBand(drive, play, mode, modifier, fbl, fbr)
  global(antialiased_tanh_rect)
  instance(l, r, inL, inR, in, pre, post)
  local(preamp, inv_ceiling, t, factor, depth, idepth, tl, tr)
  (
    play ? (
      preamp = 10^(0.05*drive);
      
      in = max(in, abs(inL+inR));
      
      l = inL * preamp;
      r = inR * preamp;
      
      l += fbl;
      r += fbr;
      
      pre = max(pre, abs(l+r));
      
      //l = this.ch0.antialiased_tanh_rect(l);
      //r = this.ch1.antialiased_tanh_rect(r);
      ( mode == 0 ) ? (
        /* Tanh */
        l = tanh(l);
        r = tanh(r);
      ) : ( mode == 1 ) ? (
        /* Tanh-like */
        l = .5*l;
        r = .5*r;
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      ) : ( mode == 2 ) ? (
        /* Smooth */
        l = 1.399 * l;
        r = 1.399 * r;
        l = sign(l)*(1-exp(-abs(l)));
        r = sign(r)*(1-exp(-abs(r)));
      ) : ( mode == 3 ) ? (
        /* Asymmetric */
        l = l - modifier;
        r = r - modifier;
        
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        t = l*l;
        l = l - 0.17 * t - 0.17 * t*l;
        t = r*r;
        r = r - 0.17 * t - 0.17 * t*r;
      ) : ( mode == 4 ) ? (
        /* Rapid saturation */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        t = l*l;
        l = 1.23950091*l/(1+0.89322598*abs(l)-2.07339946*t+1.43974791*abs(l)*t);
        t = r*r;
        r = 1.23950091*r/(1+0.89322598*abs(r)-2.07339946*t+1.43974791*abs(r)*t);
      ) : ( mode == 5 ) ? (
        /* Almost linear */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        t = l*l;
        l = 0.55054001*l/(1-1.27438856*abs(l)+0.84846189*t);
        t = r*r;
        r = 0.55054001*r/(1-1.27438856*abs(r)+0.84846189*t);
      ) : ( mode == 6 ) ? (
        /* Crossover distortion */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        // Amount of plateau
        factor = -15.09587456 + 11*modifier;
        
        t = l*l;
        l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-exp(factor*t));
        t = r*r;
        r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-exp(factor*t));
      ) : ( mode == 7 ) ? (
        /* Heavy crossover distortion */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        factor = -15.09587456 + 11*modifier;
        t = l*l;
        l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-sin(15*t)*exp(factor*t));
        t = r*r;
        r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-sin(15*t)*exp(factor*t));
      ) : ( mode == 8 ) ? (
        /* Very heavy crossover distortion */
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 );
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 );
        
        factor = -15.09587456 + 11*modifier;
        t = l*l;
        l = (0.78779516*l/(1+abs(l)-3.39263197*t+2.20506682*abs(l)*t)) * (1-sin(45*t*t)*sin(5*l)*exp(factor*t));
        t = r*r;
        r = (0.78779516*r/(1+abs(r)-3.39263197*t+2.20506682*abs(r)*t)) * (1-sin(45*t*t)*sin(5*r)*exp(factor*t));
      ) : ( mode == 9 ) ? (
        /* Sine */
        l = sin(1.5*l*(1+2*modifier));
        r = sin(1.5*r*(1+2*modifier));
      ) : ( mode == 10 ) ? (
        /* Octaver up */
        l = 2*abs(l)-1+modifier;
        r = 2*abs(r)-1+modifier;
        l = 1.399 * l;
        r = 1.399 * r;
        l = sign(l)*(1-exp(-abs(l)));
        r = sign(r)*(1-exp(-abs(r)));
      ) : ( mode == 11 ) ? (
        /* Wavefolder */
        this.ch0.folder_init(0, 1);
        this.ch1.folder_init(0, 1);
        l = -this.ch0.folder_eval(l+modifier);
        t = l*l;
        l = l / (1+t*t);
        r = -this.ch1.folder_eval(r+modifier);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 12 ) ? (
        /* Serge wavefolder */
        l = .5*l;
        r = .5*r;
        this.ch0.folder_init(modifier, 1);
        this.ch1.folder_init(modifier, 1);
        l = -this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        t = l*l;
        l = l / (1+t*t);
        r = -this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 14 ) ? (
        /* Wavenuker */
        l = .5*l/(1+l);
        r = .5*r/(1+r);
        this.ch0.folder_init(modifier, 1);
        this.ch1.folder_init(modifier, 1);
        l = -this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        l = this.ch0.folder_eval(l);
        t = l*l;
        l = l / (1+t*t);
        r = -this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        r = this.ch1.folder_eval(r);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 13 ) ? (
        /* Asymmetric Chunker */
        l = .5*l;
        r = .5*r;
        this.ch0.folder_init(modifier, 0);
        this.ch1.folder_init(modifier, 0);
        l = l-this.ch0.folder_eval(l);
        l = l+this.ch0.folder_eval(l*l);
        t = l*l;
        l = l / (1+t*t);
        r = r-this.ch0.folder_eval(r);
        r = r+this.ch0.folder_eval(r*r);
        t = r*r;
        r = r / (1+t*t);
      ) : ( mode == 15 ) ? (
        /* Bitcrusher */
        depth   = 16 - pow(modifier, .25)*15.5;
        idepth  = 1/depth;
        l = floor( l * depth + 0.5 ) * idepth;
        r = floor( r * depth + 0.5 ) * idepth;
        
        l = .5*l;
        r = .5*r;
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      ) : ( mode == 16 ) ? (
        /* Bitcrusher */
        depth   = 2;
        idepth  = 1/depth;
        l = sin(5*(.3+modifier)*l);
        r = sin(5*(.3+modifier)*r);
        l = floor( l * depth + 1.5*modifier - .5 ) * idepth;
        r = floor( r * depth + 1.5*modifier - .5 ) * idepth;
        
        l = .5*l;
        r = .5*r;
        ( l > 1 ) ? ( l = 1 ) : ( l < -1 ) ? ( l = -1 ) : l = sign(l)*(2*abs(l)-l*l);
        ( r > 1 ) ? ( r = 1 ) : ( r < -1 ) ? ( r = -1 ) : r = sign(r)*(2*abs(r)-r*r);
      ) : ( mode == 17 ) ? (
        tl = tanh(1.5*l);
        tr = tanh(1.5*r);
        l = (abs(l*20^(1-modifier))>.5) * tl*tl*tr;
        r = (abs(r*20^(1-modifier))>.5) * tr*tr*tr;
      ) : (
        l = 0;
        r = 0;
      );
      
      post = max(post, abs(l+r));
    ) : (
      l = 0;
      r = 0;
    );
  ); 
  
  function processBands()
  local(BW2)
  global( Drive1,    Drive2,    Drive3,     Drive4,     Drive5, 
          Gain1,     Gain2,     Gain3,      Gain4,      Gain5,
          DryWet1,   DryWet2,   DryWet3,    DryWet4,    DryWet5,
          play1,     play2,     play3,      play4,      play5,
          Mode1,     Mode2,     Mode3,      Mode4,      Mode5,
          Feedback1, Feedback2, Feedback3,  Feedback4,  Feedback5,
          Modifier1, Modifier2, Modifier3,  Modifier4,  Modifier5,
          fbToggle1, fbToggle2, fbToggle3,  fbToggle4,  fbToggle5 )
  instance(b1, b2, b3, b4, b5, F1, F2, F3, F4, F5, 
           bufferL1, bufferL2, bufferL3, bufferL4, bufferL5, 
           bufferR1, bufferR2, bufferR3, bufferR4, bufferR5,
           fbL1,     fbL2,     fbL3,     fbL4,     fbL5
           fbR1,     fbR2,     fbR3,     fbR4,     fbR5,
           g1,       g2,       g3,       g4,       g5,
           lg1,      lg2,      lg3,      lg4,      lg5 )
  (
    fbToggle1 ? ( fbL1 = Feedback1 * bufferL1.readBuffer();
                  fbR1 = Feedback1 * bufferR1.readBuffer(); ) : ( fbL1 = fbR1 = 0; );
    fbToggle2 ? ( fbL2 = Feedback2 * bufferL2.readBuffer();
                  fbR2 = Feedback2 * bufferR2.readBuffer(); ) : ( fbL2 = fbR2 = 0; );
    fbToggle3 ? ( fbL3 = Feedback3 * bufferL3.readBuffer();
                  fbR3 = Feedback3 * bufferR3.readBuffer(); ) : ( fbL3 = fbR3 = 0; );
    fbToggle4 ? ( fbL4 = Feedback4 * bufferL4.readBuffer();
                  fbR4 = Feedback4 * bufferR4.readBuffer(); ) : ( fbL4 = fbR4 = 0; );
    fbToggle5 ? ( fbL5 = Feedback5 * bufferL5.readBuffer();
                  fbR5 = Feedback5 * bufferR5.readBuffer(); ) : ( fbL5 = fbR5 = 0; );
    
    b1.processBand(Drive1, play1, Mode1, Modifier1, fbL1, fbR1);
    b2.processBand(Drive2, play2, Mode2, Modifier2, fbL2, fbR2);
    b3.processBand(Drive3, play3, Mode3, Modifier3, fbL3, fbR3);
    b4.processBand(Drive4, play4, Mode4, Modifier4, fbL4, fbR4);
    b5.processBand(Drive5, play5, Mode5, Modifier5, fbL5, fbR5);
    
    fbToggle1 ? ( bufferL1.updateBuffer(b1.l);
                  bufferR1.updateBuffer(b1.r); );
    fbToggle2 ? ( bufferL2.updateBuffer(b2.l);
                  bufferR2.updateBuffer(b2.r); );
    fbToggle3 ? ( bufferL3.updateBuffer(b3.l);
                  bufferR3.updateBuffer(b3.r); );
    fbToggle4 ? ( bufferL4.updateBuffer(b4.l);
                  bufferR4.updateBuffer(b4.r); );
    fbToggle5 ? ( bufferL5.updateBuffer(b5.l);
                  bufferR5.updateBuffer(b5.r); );

    ( lg1 != Gain1 ) ? ( g1 = (10^(0.05*Gain1)); lg1 = Gain1; );
    ( lg2 != Gain2 ) ? ( g2 = (10^(0.05*Gain2)); lg2 = Gain2; );
    ( lg3 != Gain3 ) ? ( g3 = (10^(0.05*Gain3)); lg3 = Gain3; );
    ( lg4 != Gain4 ) ? ( g4 = (10^(0.05*Gain4)); lg4 = Gain4; );
    ( lg5 != Gain5 ) ? ( g5 = (10^(0.05*Gain5)); lg5 = Gain5; );

    play1 ? (
      b1.l = g1*(b1.l*DryWet1+b1.inL*(1-DryWet1));
      b1.r = g1*(b1.r*DryWet1+b1.inR*(1-DryWet1));
    );
    play2 ? (
      b2.l = g2*(b2.l*DryWet2+b2.inL*(1-DryWet2));
      b2.r = g2*(b2.r*DryWet2+b2.inR*(1-DryWet2));
    );
    play3 ? (
      b3.l = g3*(b3.l*DryWet3+b3.inL*(1-DryWet3));
      b3.r = g3*(b3.r*DryWet3+b3.inR*(1-DryWet3));
    );
    play4 ? (
      b4.l = g4*(b4.l*DryWet4+b4.inL*(1-DryWet4));
      b4.r = g4*(b4.r*DryWet4+b4.inR*(1-DryWet4));
    );
    play5 ? (
      b5.l = g5*(b5.l*DryWet5+b5.inL*(1-DryWet5));
      b5.r = g5*(b5.r*DryWet5+b5.inR*(1-DryWet5));
    );
  );
  
  function resetMeters()
  local()
  global()
  instance(b1, b2, b3, b4, b5)
  (
    b1.resetBandMeter();
    b2.resetBandMeter();
    b3.resetBandMeter();
    b4.resetBandMeter();
    b5.resetBandMeter();                
  );
  
  function getBandPre(bandIdx)
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    ( bandIdx == 0 ) ? ( .5*b1.pre )
    : ( bandIdx == 1 ) ? ( .5*b2.pre )
    : ( bandIdx == 2 ) ? ( .5*b3.pre )
    : ( bandIdx == 3 ) ? ( .5*b4.pre )
    : ( bandIdx == 4 ) ? ( .5*b5.pre )
  );
  
  function getBandPost(bandIdx)
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    ( bandIdx == 0 ) ? ( .5*b1.post )
    : ( bandIdx == 1 ) ? ( .5*b2.post )
    : ( bandIdx == 2 ) ? ( .5*b3.post )
    : ( bandIdx == 3 ) ? ( .5*b4.post )
    : ( bandIdx == 4 ) ? ( .5*b5.post )
  );
  
  function getBandIn(bandIdx)
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    ( bandIdx == 0 ) ? ( .5*b1.in )
    : ( bandIdx == 1 ) ? ( .5*b2.in )
    : ( bandIdx == 2 ) ? ( .5*b3.in )
    : ( bandIdx == 3 ) ? ( .5*b4.in )
    : ( bandIdx == 4 ) ? ( .5*b5.in )
  );
  
function drawShaper(drive)
  global( Drive1,       Drive2,     Drive3,     Drive4,     Drive5, 
          play1,        play2,      play3,      play4,      play5,
          Mode1,        Mode2,      Mode3,      Mode4,      Mode5,
          Modifier1,    Modifier2,  Modifier3,  Modifier4,  Modifier5,
          selectedBand
          fft_out_r, fft_out_g, fft_out_b, fft_out_a )
  instance(x, y, w, h, hm, calc, displayDrive)
  local(steps, cx, dx, ds, s, ll, lr, mode, ol, or, modifier)
  (
    steps = 25;
    s = -1;
    dx = w / steps;
    ds = 2 / steps;
    hm = h - 2;
    displayDrive = drive;
    
    ll = 0;
    lr = 0;
    cx = x;
    gfx_set(fft_out_r, fft_out_g, fft_out_b, fft_out_a);
    
    ( selectedBand == 0 ) ? (
      mode = Mode1;
      modifier = Modifier1;
    ) : ( selectedBand == 1 ) ? (
      mode = Mode2;
      modifier = Modifier2;
    ) : ( selectedBand == 2 ) ? (
      mode = Mode3;
      modifier = Modifier3;
    ) : ( selectedBand == 3 ) ? (
      mode = Mode4;
      modifier = Modifier4;
    ) : ( selectedBand == 4 ) ? (    
      mode = Mode5;
      modifier = Modifier5;
    );
    
    calc.inL = s;
    calc.inR = s;
    calc.processBand(displayDrive, 1, mode, modifier, 0, 0);
    ll = calc.l*.5 + .5;
    lr = calc.r*.5 + .5;
    loop( steps,
      s += ds;
      calc.inL = s;
      calc.inR = s;
      
      calc.processBand(displayDrive, 1, mode, modifier, 0, 0);
      ol = calc.l*.5 + .5;
      or = calc.r*.5 + .5;
      gfx_line(cx, y+h-ll*hm, cx+dx, y+h-ol*hm);
      gfx_line(cx, y+h-lr*hm, cx+dx, y+h-or*hm);
      gfx_line(cx, y+h-ll*hm-1, cx+dx, y+h-ol*hm-1);
      gfx_line(cx, y+h-lr*hm-1, cx+dx, y+h-or*hm-1);
      
      ll = ol;
      lr = or;
      cx += dx;
    );
  );  

function drawVolumes(pre, post)
  local(thc, iDisplayDrive)
  instance(x, y, w, h, displayDrive, hot1, hot2, xv, yv, xv2, yv2, xs, ys)
  global()
  (
    iDisplayDrive = 10^(-displayDrive/20);
    
    thc = 3;
    
    xv = min(1,pre * iDisplayDrive);
    yv = min(1,post);
    
    xv2 = max(xv2*.97, xv);
    yv2 = max(yv2*.97, yv);
    
    hot1 = .8*hot1 + .2*2*xv*xv*(xv-0.5);
    gfx_set(1, 1-hot1, 1-3*hot1, .5);
    gfx_rect(floor(x+.5*w*(1-xv))-1, y+h+1, floor(w*xv)+2, thc+2);
    gfx_set(1, 1-hot1, 1-3*hot1, 1);
    gfx_rect(floor(x+.5*w*(1-xv)), y+h+2, floor(w*xv)+1, thc);
    
    hot2 = .8*hot2 + .2*2*yv*yv*(yv-0.5);
    gfx_set(1, 1-hot2, 1-3*hot2, .5);
    gfx_rect(x-thc-2, floor(y+.5*h*(1-yv))+1, thc+2, floor(h*yv)+2);
    gfx_set(1, 1-hot2, 1-3*hot2, 1);
    gfx_rect(x-thc-1, floor(y+.5*h*(1-yv))+2, thc, floor(h*yv));
    
    gfx_set(1, 1, 1, .1);
    gfx_rect(floor(x+.5*w*(1-xv2))-1, y+h+1, floor(w*xv2)+2, thc+2);
    
    gfx_set(1, 1, 1, .1);
    gfx_rect(x-thc-2, floor(y+.5*h*(1-yv2))-1, thc+2, floor(h*yv2)+2);
    
    gfx_set(1,1,1,.15);
    gfx_rect(floor(x+.5*w*(1-xv)), y, 1, h);
    gfx_rect(floor(x+.5*w*(1+xv)), y, 1, h);
  );

function initDelays()
  local()
  global(delayBuf1, delayBuf2, delayBuf3, delayBuf4, delayBuf5, 
         delayBuf6, delayBuf7, delayBuf8, delayBuf9, delayBuf10,
         bufferDist)
  instance(bufferL1, bufferL2, bufferL3, bufferL4, bufferL5,
           bufferR1, bufferR2, bufferR3, bufferR4, bufferR5)
  (
    bufferL1.initBuffer(delayBuf1, delayBuf1+bufferDist-1);
    bufferL2.initBuffer(delayBuf2, delayBuf2+bufferDist-1);
    bufferL3.initBuffer(delayBuf3, delayBuf3+bufferDist-1);
    bufferL4.initBuffer(delayBuf4, delayBuf4+bufferDist-1);
    bufferL5.initBuffer(delayBuf5, delayBuf5+bufferDist-1);
    bufferR1.initBuffer(delayBuf6, delayBuf6+bufferDist-1);
    bufferR2.initBuffer(delayBuf7, delayBuf7+bufferDist-1);
    bufferR3.initBuffer(delayBuf8, delayBuf8+bufferDist-1);
    bufferR4.initBuffer(delayBuf9, delayBuf9+bufferDist-1);
    bufferR5.initBuffer(delayBuf10, delayBuf10+bufferDist-1);
  );

//bpos=0;

// MEMORY LAYOUT
fftSize     = 2*8192;
bufferDist  = 65536;
audioBufIn  = 0;
audioBufOut = bufferDist;

delayBuf1   = 2*bufferDist;
delayBuf2   = 3*bufferDist;
delayBuf3   = 4*bufferDist;
delayBuf4   = 5*bufferDist;
delayBuf5   = 6*bufferDist;
delayBuf6   = 7*bufferDist;
delayBuf7   = 8*bufferDist;
delayBuf8   = 9*bufferDist;
delayBuf9   = 10*bufferDist;
delayBuf10  = 11*bufferDist;

filterBank.initDelays();

// INITIALIZATION
spectrumIn.initSpectrum(audioBufIn, fftSize, srate);
spectrumOut.initSpectrum(audioBufOut, fftSize, srate);

@serialize
file_var(0,dnoisefloor_freq);
file_var(0,dsteps_fft);

file_var(0,solo1);
file_var(0,solo2);
file_var(0,solo3);
file_var(0,solo4);
file_var(0,solo5);
file_var(0,placeholder);
file_var(0,placeholder);

file_var(0,mute1);
file_var(0,mute2);
file_var(0,mute3);
file_var(0,mute4);
file_var(0,mute5);
file_var(0,placeholder);
file_var(0,placeholder);

file_var(0,fb1Toggle);
file_var(0,fb2Toggle);
file_var(0,fb3Toggle);
file_var(0,fb4Toggle);
file_var(0,fb5Toggle);

@slider

@block
!mute1 ? play1 = 1 : play1 = 0;
!mute2 ? play2 = 1 : play2 = 0;
!mute3 ? play3 = 1 : play3 = 0;
!mute4 ? play4 = 1 : play4 = 0;
!mute5 ? play5 = 1 : play5 = 0;

( solo1 || solo2 || solo3 || solo4 || solo5 ) ? ( play1 = play2 = play3 = play4 = play5 = 0; );
solo1 ? play1 = 1;
solo2 ? play2 = 1;
solo3 ? play3 = 1;
solo4 ? play4 = 1;
solo5 ? play5 = 1;

@sample
  // Generate windowed sinc filter at memory location FIR
  // Inputs are:
  //    fir   - Memory location to store windowed sinc
  //    nt    - Number of taps
  //    bw    - Fractional bandwidth
  //     g    - Gain
  function sinc(fir, nt, bw, g)
    local(a, ys, yg, yw, i, pibw2, pifc2, pidnt2, hnt)
    global()
    (
      pibw2   = 2.0*$pi*bw;
      pidnt2  = 2.0*$pi/nt;
      hnt     = 0.5*nt;
      i       = 1;
          
      loop(nt-1,
        // Sinc width
        a  = (i - hnt) * pibw2;
          
        // Sinc
        ys = (a != 0) ? sin(a)/a : 1.0;
   
        // Window gain
        yg = g * (4.0 * bw);
          
        // Hamming window (could be replaced with Kaiser in the future)
        yw = 0.54 - 0.46 * cos(i * pidnt2);
           
        // Calc FIR coeffs
        fir[i-1] = yw * yg * ys;
        
        i += 1;
      );
    );
  
  // Generate sinc filters for a specific upsampling ratio
  //
  // Upsampling leads to a sample followed by N-1 zeroes. Hence 
  // to compute each subsample, we only need 1/Nth of the taps.
  // This is why we set up a specific filter for each subsample.
  // i.e. for N=4, you get something like f1*Zn + f5*Zn-1 + ...
  //
  // Inputs:
  //    N_in            - oversampling factor
  //    tapsPerFilter   - Taps per subfilter (should be 8 in this implementation)
  //    targetmem       - Location to store the coefficients
  //    tmp             - Working memory
  function updateSincFilter(N_in, tapsPerFilter, targetmem, tmp)
    local(nHist, iFilt, nTaps)
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N, delta)
    global()
    (
      N       = N_in;
      nHist   = tapsPerFilter;
      loc     = 0;
      coeffs  = targetmem;
      nTaps   = N*nHist;
      
      // Memory being set is conservatively large.
      memset(coeffs,0,10000);
      memset(tmp,0,10000);
      
      sinc(tmp, nTaps, .5/N, .5*N);
      
      // Divide sinc over the different filters
      iFilt = 0; // Filter idx for which subsample this filter is
      delta = 0; // Sample idx
      loop(nTaps,
        coeffs[delta + iFilt*100] = tmp[];
        iFilt += 1;
        iFilt == N ? ( iFilt = 0; delta += 1 );
        tmp += 1;
      );
    );
  
  // Generate downsample filter
  // Here, the full N*nHist tap filter has to be evaluated for every sample, 
  // but only every Nth sample has to be evaluated.
  function updateSincDownsampleFilter(N_in, nTaps_in, histmem, coeffmem)
    global()
    instance(hist, hend, hptr, coeffs, loc, N, delta, nTaps)
    local()
    (
      N       = N_in;
      hist    = histmem;
      coeffs  = coeffmem;
      nTaps   = nTaps_in;
      hptr    = hist;
      hend    = hist + nTaps;
      
      memset(coeffs,0,10000);
      sinc(coeffs, nTaps, .5/N, .5);
    );
    
  function advanceHist(sample)
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, nTaps)
    (
      hptr += 1;
      ( hptr == hend ) ? hptr = hist;
      hptr[] = sample;
    );
  
  function sincDownSample()
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, hm1, hptr2, out, cfptr)
    (
      hm1   = hist-1;
      hptr2 = hptr;
      cfptr = coeffs;
      out   = 0;
      
      loop(nTaps,
        out = out + hptr2[] * cfptr[];
        
        cfptr += 1;
        hptr2 -= 1;
        ( hptr2 == hm1 ) ? hptr2 = hend-1;
      );
      
      out
    );
  
  function resetSincDown()
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, hm1, hptr2)
    (
      hm1   = hist-1;
      hptr2 = hptr;
      
      loop(nTaps,
        hptr2[] = 0;
        
        hptr2 -= 1;
        ( hptr2 == hm1 ) ? hptr2 = hend-1;
      );
    );
  
  // Maintain input sample history. Hardcoded for speed.
  // Note h7 is omitted because for integer upsampling it is always zero!
  function advanceSinc(sample)
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt)
    (
      h6 = h5;
      h5 = h4;
      h4 = h3;
      h3 = h2;
      h2 = h1;
      h1 = h0;
      h0 = sample;
      loc = 0;
    );
  
  function resetSincUp()
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt)
    (
      h0 = h1 = h2 = h3 = h4 = h5 = h6 = 0;
    );
  
  // Note h7 is omitted because for integer upsampling it is always zero!
  function getSubSample()
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt, out)
    (
      filt = coeffs + loc;
  
      out =  filt[] * h0 + filt[1] * h1 + filt[2] * h2 + filt[3] * h3 + filt[4] * h4 + filt[5] * h5 + filt[6] * h6;
  
      loc += 100;
      out
    ); 

  function fix_dc(x)
  local()
  global()
  instance(DC_fixed, prev)
  (
    DC_fixed=0.999*DC_fixed + x - prev;
    prev=x;
    DC_fixed
  );

  function init_LR(freq)
    global(srate, slider54)
    local(g, res)
    instance(k, a1, a2, a3)
    (
      g = tan( .5 * $pi * exp( (1-freq) * log(20/22050) ) );
      k = 2;
      
      a1 = 1/(1+g*(g+k));
      a2 = g*a1;
      a3 = g*a2;
    ); 

  function init_LR2(freq)
    global(srate, slider54)
    local(g, res)
    instance(k, a1, a2, a3)
    (
      g = tan( .5 * $pi * exp( (1-freq) * log(20/22050) ) );
      k = sqrt(2); /* Note the different peak resonance because we're combining 2 SVFs into the Linkwitz-Riley structure */

      a1 = 1/(1+g*(g+k));
      a2 = g*a1;
      a3 = g*a2;
    ); 
  
  function reset_LR()
    global()
    local()
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq, k, a1, a2, a3)
    (
      ic1eq = ic2eq = 0;  
    );  

  function eval_LRLP(v0)
    global()
    local(v1, v2, v3)
    instance(ic3eq, ic4eq, k, a1, a2, a3)
    (
      v3 = v0 - ic4eq;
      v1 = a1 * ic3eq + a2 * v3;
      v2 = ic4eq + a2 * ic3eq + a3 * v3;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      
      v2
    ); 
 
  function eval_LRAP(v0)
    global()
    local(v1, v2, v3)
    instance(ic5eq, ic6eq, k, a1, a2, a3)
    (
      v3 = v0 - ic6eq;
      v1 = a1 * ic5eq + a2 * v3;
      v2 = ic6eq + a2 * ic5eq + a3 * v3;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;    
      
      v0 - 2*k*v1
    );    

  function eval_LR2(v0)
    global()
    local(v1, v2, v3, all)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;    
      
      all = v0 - 2 * k * v1;
 
      lp = this.eval_LRLP(v2); 
      hp = all - lp;
    );    

  function updateCoeffs()
  local()
  global(Cuts, Freq1, Freq2, Freq3, Freq4)
  instance( F1, F2, F3, F4
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            lcuts)
  (
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
  
      (cuts==1) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
      ) : (cuts==2) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
        LF2.init_LR2(F2);
        RF2.k  = LF2.k;
        RF2.a1 = LF2.a1;
        RF2.a2 = LF2.a2;
        RF2.a3 = LF2.a3;
        
        LA_F2.init_LR(F2);
        RA_F2.k  = LA_F2.k;
        RA_F2.a1 = LA_F2.a1;
        RA_F2.a2 = LA_F2.a2;
        RA_F2.a3 = LA_F2.a3;
      ) : (cuts == 3) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
        LF2.init_LR2(F2);
        RF2.k  = LF2.k;
        RF2.a1 = LF2.a1;
        RF2.a2 = LF2.a2;
        RF2.a3 = LF2.a3;
        LF3.init_LR2(F3);
        RF3.k  = LF3.k;
        RF3.a1 = LF3.a1;
        RF3.a2 = LF3.a2;
        RF3.a3 = LF3.a3;
        
        // All-passes for maintaining the phase relation between the bands
        LA_F2.init_LR(F2);
        LA_F3.init_LR(F3);
        
        RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
        RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
        RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
        RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
  
        RA_F2.k  = LA_F2.k;
        RA_F2.a1 = LA_F2.a1;
        RA_F2.a2 = LA_F2.a2;
        RA_F2.a3 = LA_F2.a3;
      ) : (cuts == 4) ? (
        LF1.init_LR2(Freq1);
        RF1.k  = LF1.k;
        RF1.a1 = LF1.a1;
        RF1.a2 = LF1.a2;
        RF1.a3 = LF1.a3;
        LF2.init_LR2(F2);
        RF2.k  = LF2.k;
        RF2.a1 = LF2.a1;
        RF2.a2 = LF2.a2;
        RF2.a3 = LF2.a3;
        LF3.init_LR2(F3);
        RF3.k  = LF3.k;
        RF3.a1 = LF3.a1;
        RF3.a2 = LF3.a2;
        RF3.a3 = LF3.a3;
        LF4.init_LR2(F4);
        RF4.k  = LF4.k;
        RF4.a1 = LF4.a1;
        RF4.a2 = LF4.a2;
        RF4.a3 = LF4.a3;
        
        // All-passes for maintaining the phase relation between the bands
        LA_F2.init_LR(F2);
        LA_F3.init_LR(F3);
        LA_F4.init_LR(F4);
        
        RA_F4.k  = RA_F4_2.k  = RA_F4_3.k  = LA_F4_2.k  = LA_F4_3.k  = LA_F4.k;
        RA_F4.a1 = RA_F4_2.a1 = RA_F4_3.a1 = LA_F4_2.a1 = LA_F4_3.a1 = LA_F4.a1;
        RA_F4.a2 = RA_F4_2.a2 = RA_F4_3.a2 = LA_F4_2.a2 = LA_F4_3.a2 = LA_F4.a2;
        RA_F4.a3 = RA_F4_2.a3 = RA_F4_3.a3 = LA_F4_2.a3 = LA_F4_3.a3 = LA_F4.a3;
        
        RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
        RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
        RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
        RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
  
        RA_F2.k  = LA_F2.k;
        RA_F2.a1 = LA_F2.a1;
        RA_F2.a2 = LA_F2.a2;
        RA_F2.a3 = LA_F2.a3;
      );
  );  
  
  function updateDelays()
  local(d1, d2, d3, d4, d5, scale)
  global(Delay1, Delay2, Delay3, Delay4, Delay5,
         fbToggle1, fbToggle2,  fbToggle3,  fbToggle4,  fbToggle5, srate)
  instance(bufferL1,  bufferL2,   bufferL3,   bufferL4,   bufferL5,
           bufferR1,  bufferR2,   bufferR3,   bufferR4,   bufferR5 )
  (
    scale = 0.04*srate;
    d1 = scale * (exp(Delay1)-1);
    d2 = scale * (exp(Delay2)-1);
    d3 = scale * (exp(Delay3)-1);
    d4 = scale * (exp(Delay4)-1);
    d5 = scale * (exp(Delay5)-1);
  
    fbToggle1 ? ( bufferL1.setOffset(d1+2);
                  bufferR1.setOffset(d1+2) );
    fbToggle2 ? ( bufferL2.setOffset(d2+2);
                  bufferR2.setOffset(d2+2) );
    fbToggle3 ? ( bufferL3.setOffset(d3+2);
                  bufferR3.setOffset(d3+2) );
    fbToggle4 ? ( bufferL4.setOffset(d4+2);
                  bufferR4.setOffset(d4+2) );
    fbToggle5 ? ( bufferL5.setOffset(d5+2);
                  bufferR5.setOffset(d5+2) );
  );
  
  function resetBands()
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    b1.r = b1.l = b2.r = b2.l = b3.r = b3.l = b4.r = b4.l = b5.l = 0;
  );  
  
  // Make sure the delay is the same on all bands (identical number of filters)
  function splitBands(sl, sr)
  local()
  global(Cuts)
  instance( LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            b1, b2, b3, b4, b5, lcuts )
  (
    ( lcuts != cuts ) ? (
      lcuts = cuts;
      this.resetBands();
    );
  
    (cuts==0) ? (
      b1.inL = sl;
      b1.inR = sr;
    ) : (cuts==1) ? (
      LF1.eval_LR2(sl);
      b1.inL = LF1.lp;
      b2.inL = LF1.hp;
      
      RF1.eval_LR2(sr);
      b1.inR = RF1.lp;
      b2.inR = RF1.hp;
    ) : (cuts==2) ? (
      LF1.eval_LR2(sl);
      b1.inL   = LA_F2.eval_LRAP(LF1.lp);
      
      LF2.eval_LR2(LF1.hp);
      b2.inL   = LF2.lp;
      b3.inL   = LF2.hp;
      
      RF1.eval_LR2(sr);
      b1.inR   = RA_F2.eval_LRAP(RF1.lp);
      
      RF2.eval_LR2(RF1.hp);
      b2.inR   = RF2.lp;
      b3.inR   = RF2.hp;
    ) : (cuts == 3) ? (
      LF1.eval_LR2(sl);
      b1.inL   = LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp));
      
      LF2.eval_LR2(LF1.hp);
      b2.inL   = LA_F3_2.eval_LRAP(LF2.lp);
      
      LF3.eval_LR2(LF2.hp);
      b3.inL   = LF3.lp;
      b4.inL   = LF3.hp;
      
      RF1.eval_LR2(sr);
      b1.inR   = RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp));
      
      RF2.eval_LR2(RF1.hp);
      b2.inR   = RA_F3_2.eval_LRAP(RF2.lp);
      
      RF3.eval_LR2(RF2.hp);
      b3.inR   = RF3.lp;
      b4.inR   = RF3.hp;
    ) : (cuts == 4) ? (
      LF1.eval_LR2(sl);
      b1.inL   = LA_F4.eval_LRAP(LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp)));
      
      LF2.eval_LR2(LF1.hp);
      b2.inL   = LA_F4_2.eval_LRAP(LA_F3_2.eval_LRAP(LF2.lp));
      
      LF3.eval_LR2(LF2.hp);
      b3.inL   = LA_F4_3.eval_LRAP(LF3.lp);
      
      LF4.eval_LR2(LF3.hp);
      b4.inL   = LF4.lp;
      b5.inL   = LF4.hp;
      
      RF1.eval_LR2(sr);
      b1.inR   = RA_F4.eval_LRAP(RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp)));
      
      RF2.eval_LR2(RF1.hp);
      b2.inR   = RA_F4_2.eval_LRAP(RA_F3_2.eval_LRAP(RF2.lp));
      
      RF3.eval_LR2(RF2.hp);
      b3.inR   = RA_F4_3.eval_LRAP(RF3.lp);
      
      RF4.eval_LR2(RF3.hp);
      b4.inR   = RF4.lp;
      b5.inR   = RF4.hp;
    );
  );  
  
  spectrumIn.feedSample(.5*(spl0+spl1));

  // Split signal into bands
  filterBank.updateCoeffs();
  filterBank.splitBands(spl0, spl1);
  filterBank.processBands();
  filterBank.updateDelays();
  
  spl0 = filterBank.b1.l + filterBank.b2.l + filterBank.b3.l + filterBank.b4.l + filterBank.b5.l;
  spl1 = filterBank.b1.r + filterBank.b2.r + filterBank.b3.r + filterBank.b4.r + filterBank.b5.r;
  
  gBoost = (10^(0.05*masterGainSlider));
  spl0 *= gBoost;
  spl1 *= gBoost;
  
  //spl0=spl1=filterBank.b2.l;
  //spl0 = spl1 = filterBank.b1.l;
  
  slider64 ? (
    spl0 = dc0.fix_dc(spl0);
    spl1 = dc1.fix_dc(spl1);
  );
  
  spectrumOut.feedSample(.5*(spl0+spl1));
    
@gfx 1080 800
  function createGUI(stripStart)
  (
    scaling   = gfx_ext_retina;
    spectrumX = 0;
    spectrumY = 0;
    spectrumW = gfx_w;
    spectrumH = gfx_h - 175 * (1+scaling);
    spectrumIn.setWindowLocation(spectrumX,  spectrumY, spectrumW, spectrumH);
    spectrumOut.setWindowLocation(spectrumX, spectrumY, spectrumW, spectrumH);
    shaperWnd.setWindowLocation(stripStart*(1+scaling), spectrumH + 25*(1+scaling), 125*(1+scaling), 125*(1+scaling));
  );

  /* Gradients are buffered to save rendering perf */
  function drawGradients(w, h, spectrumH, gradient_bg)
  instance(lw, lh)
  global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
         gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
  local( oldDest, oldMode)
  (
    oldMode = gfx_mode;
    gfx_mode = 0;
    gfx_set(1,1,1,1);
    ( ( lw != w ) || ( lh != h ) ) ? (
      /* Only draw gradients when size changes */
      gfx_x = gfx_y = 0;
      lw = w;
      lh = h;
      oldDest = gfx_dest;
      gfx_setimgdim(gradient_bg, w, h);
      gfx_dest = gradient_bg;
      gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);
      gfx_rectto(w,spectrumH);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, gfx_a, .0001, .001, .0001, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, .3, .0001, .001, .0006, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, 0, 0, 0, 0, 0, -.001, -.0006, .0001, -.0001, -.0001, .01, -.00008);
      gfx_gradrect(0, spectrumH, w, h-spectrumH, 0, 0, .0, 1.0, .0001, .0001, .0002, 0, 0, 0, .0005, 0);
      gfx_dest = oldDest;
    );
    
    gfx_x = gfx_y = 0;
    gfx_blit(gradient_bg, 1, 0);
    gfx_mode = oldMode;
  );

  /* Draw a vertical label */
  function drawVertLabel(x, y, stridx, labelW, fontSize, labelBuffer)
  local(oldDest, oldMode, strw, strh)
  global(gfx_dest, gfx_mode, gfx_x, gfx_y,
         font_color_r, font_color_g, font_color_b, font_color_a)
  instance()
  (
    labelBuffer = 3;
    fontSize = 20;
    oldDest = gfx_dest;
    oldMode = gfx_mode;
    gfx_setimgdim(labelBuffer, labelW, labelW);
    gfx_dest = labelBuffer;
    gfx_setfont(2, "ARIAL", fontSize);
    gfx_measurestr(stridx, strw, strh);
    gfx_set(0,0,0,1);
    gfx_rect(0,0, labelW, strh);
    gfx_set(font_color_r,font_color_g,font_color_b,font_color_a);
    gfx_x = .5 * labelW - .5 * strw; gfx_y = 0;
    gfx_drawstr(stridx);
    gfx_dest = oldDest;
    
    gfx_x = x;
    gfx_y = y;
    gfx_mode = 1;
    gfx_blit(labelBuffer, 1, 1.5*$pi);
    gfx_mode = oldMode;
  );
  
  function getFbToggle(band)
  global(fbToggle1, fbToggle2, fbToggle3, fbToggle4, fbToggle5)
  local()
  instance()
  (
    ( band == 0 ) ? ( fbToggle1 )
    : ( band == 1 ) ? ( fbToggle2 )
    : ( band == 2 ) ? ( fbToggle3 )
    : ( band == 3 ) ? ( fbToggle4 )
    : ( band == 4 ) ? ( fbToggle5 )
  );
  
  function setFbToggle(band, value)
  global(fbToggle1, fbToggle2, fbToggle3, fbToggle4, fbToggle5)
  local()
  instance()
  (
    ( band == 0 ) ? ( fbToggle1 = value )
    : ( band == 1 ) ? ( fbToggle2 = value )
    : ( band == 2 ) ? ( fbToggle3 = value )
    : ( band == 3 ) ? ( fbToggle4 = value )
    : ( band == 4 ) ? ( fbToggle5 = value )
  );

  bg_color_r = 47/255;
  bg_color_g = 65/255;
  bg_color_b = 75/255;
  bg_color_a = 1;
  fft_out_r = .8;
  fft_out_g = .8;
  fft_out_b = .8;
  fft_out_a = 1.0;
  fft_in_r = .13;
  fft_in_g = .13;
  fft_in_b = .23;
  fft_in_a = .6;
  grid_color_r = .73;
  grid_color_g = .73;
  grid_color_b = .76;
  grid_color_a = .2;
  backface_color_r = .2;
  backface_color_g = .2;
  backface_color_b = .3;
  backface_color_a = .1;
  font_color_r = .8;
  font_color_g = .8;
  font_color_b = .8;
  font_color_a = .8;
  highlight_color_r = .9;
  highlight_color_g = .7;
  highlight_color_b = .7;
  highlight_color_a = .7;
  disabled_color_r = .4;
  disabled_color_g = .4;
  disabled_color_b = .4;
  disabled_color_a = .8;
  widget_r = .3;
  widget_g = .3;
  widget_b = .3;
  widget_a = 1.0;
  toggle_r = 1.0;
  toggle_g = .3;
  toggle_b = .3;
  toggle_a = 1.0;
  group_r = .2;
  group_g = .3;
  group_b = .4;
  group_a = 1.0;
  
  stripStart = 35;
  createGUI(stripStart);
  gradient.drawGradients(gfx_w, gfx_h, spectrumH, 2);
  
  //getBandPre  
  //getBandPost  
  //getBandIn
  
  gfx_r = 1;
  spectrumIn.drawGrid();
  spectrumIn.floorLevel = 25 + dnoisefloor_freq;
  spectrumOut.floorLevel = 25 + dnoisefloor_freq;
  spectrumIn.drawFFT(1, 1, fft_in_r, fft_in_g, fft_in_b, fft_in_a);
  spectrumOut.drawFFT(0, 1, fft_out_r, fft_out_g, fft_out_b, fft_out_a);
  spectrumIn.updateBands();
  spectrumIn.drawBands();  
  
  !shaperSelect.open ? spectrumIn.fftWindow_processMouse(mouse_x, mouse_y, mouse_cap);
  
  /* Knob which controls shaper modifier */
  modKnob = (210+stripStart)*(1+scaling);
  modifierKnob.active = hasShapeMod(slider(modeLocation+selectedBand));
  modifierKnob.value = slider(modifierLocation+selectedBand);
  modifierKnob.drawKnob(modKnob, spectrumH + 75*(1+scaling), 30*(1+scaling), "Shape Mod");
  modifierKnob.processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(modifierLocation+selectedBand) = modifierKnob.value );
  
  /* Combobox to select shaper */
  shaperSelect.combobox(modKnob-60*(1+scaling), spectrumH + 150*(1+scaling)-20, 120*(1+scaling), 20, .2, .2, .6, 1, nShapers, 1, 1, 1, "Waveshaper selection." );
  shaperSelect.combobox_setcuritem(slider(modeLocation+selectedBand));
  shaperSelect.combobox_draw();  
  shaperSelect.combobox_draw_top();
  shaperSelect.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? ( 
    slider_automate( slider(modeLocation+selectedBand)=shaperSelect.curitem; ); 
  );
    
  groupTop       = spectrumH + 25*(1+scaling);
  postShaperKnob = modKnob*(1+scaling);
  
  groupDistance = 85*(1+scaling);
  miniknobWidth = 14*(1+scaling);
  miniknobPad   = 5*(1+scaling);
  buttonPad     = 6*(1+scaling);
  buttonSize    = 6*(1+scaling); 
  
  /* Gain dry/wet section */
  drawGroupRect(postShaperKnob + groupDistance, groupTop, miniknobWidth*4+miniknobPad*2, miniknobWidth*8+miniknobPad*4, group_r, group_g, group_b, group_a);
  gainKnob.active = 1;
   
  gainKnob.value = ( slider(gainLocation+selectedBand) - gainMin ) * iGainRange;
  gainKnob.drawKnob(postShaperKnob + groupDistance + 2*miniknobWidth + miniknobPad, groupTop + 2*miniKnobWidth + miniKnobPad, miniknobWidth, "Gain");
  gainKnob.processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? slider_automate( slider(gainLocation+selectedBand) = gainKnob.value * gainRange + gainMin );
  drywetKnob.active = 1;
  drywetKnob.value = slider(drywetLocation+selectedBand);
  drywetKnob.drawKnob(postShaperKnob + groupDistance + 2*miniknobWidth + miniknobPad, groupTop + 6*miniKnobWidth + 2*miniKnobPad, miniknobWidth, "Dry/Wet");
  drywetKnob.processMouse(mouse_x, mouse_y, mouse_cap, 1) ? slider_automate( slider(drywetLocation+selectedBand) = drywetKnob.value );

  /* Delay Section */
  delayKnob.active = 1;
  delayKnob.value = slider(delayLocation+selectedBand);
  drawGroupRect(postShaperKnob + 2*groupDistance, groupTop, miniknobWidth*4+miniknobPad*2, miniknobWidth*8+miniknobPad*4, group_r, group_g, group_b, group_a);
  delayKnob.drawKnob(postShaperKnob + 2*groupDistance + 2*miniknobWidth + miniknobPad, groupTop + 2*miniKnobWidth + miniKnobPad, miniknobWidth, "Delay");
  delayKnob.processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(delayLocation+selectedBand) = delayKnob.value );

  feedbackKnob.active = 1;
  feedbackKnob.value = slider(feedbackLocation+selectedBand);
  feedbackKnob.drawKnob(postShaperKnob + 2*groupDistance + 2*miniknobWidth + miniknobPad, groupTop + 6*miniKnobWidth + 2*miniKnobPad, miniknobWidth, "Feedback");
  feedbackKnob.processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( slider(feedbackLocation+selectedBand) = feedbackKnob.value );

  delayToggle.drawToggle(postShaperKnob + 2*groupDistance + buttonPad, groupTop + buttonPad, buttonSize, buttonSize, getFbToggle(selectedBand), widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a);
  setFbToggle(selectedBand, delayToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap));

  /* Global gain control */
  masterGain = (210+stripStart)*(1+scaling);
  masterGain.active = 1;
  masterGain.value = ( masterGainSlider - gainMin ) * iGainRange;
  masterGain.drawKnob(gfx_w - 200, spectrumH + 75*(1+scaling), 30*(1+scaling), "Master Gain");
  masterGain.processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ?  slider_automate( masterGainSlider = masterGain.value * gainRange + gainMin );

  /* Draw tiny EQ for gain control */
  //outputGains.drawEq(gfx_w - 300, groupTop, 120*(1+scaling), miniknobWidth*8+miniknobPad*4, cuts+1);

  /* Band indicator */
  sprintf(16,"Band %d", selectedBand+1);
  vLabel.drawVertLabel(5, spectrumH, 16, gfx_h-spectrumH, 20, 3);
  
  /* Draw shaper curve */
  shaperWnd.drawBackface();
  shaperWnd.drawShaper(5);
  shaperWnd.drawVolumes(filterBank.getBandPre(selectedBand), filterBank.getBandPost(selectedBand));  
  
  gfx_x = gfx_y = 30;
  gfx_setfont(1,"ARIAL",30);
  gfx_set(1,0,0,1);
  gfx_printf("THIS PLUGIN IS *NOT* READY FOR USE. CHECK BACK LATER...");
  gfx_x = 30;
  gfx_y = 60;
  gfx_printf("ALL SLIDER MAPPINGS *WILL* CHANGE.");
  
  gfx_x = gfx_w-130;
  gfx_y = spectrumH + 30;
  gfx_mode = 4;
  !loaded ? loaded = gfx_loadimg(5, "./squashman2.png");
  
  gfx_blit(5, 3.2, 0);
  
  filterBank.resetMeters();
