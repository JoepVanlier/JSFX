desc:Saike 4-pole BandSplitter
tags: bandsplitter
version: 0.17
author: Joep Vanlier
changelog: Expose absolute cuts in the UI.
provides:
  BandJoiner.jsfx
  BandSplitter_phasematcher.jsfx
about:
  # 4-pole Band Splitter
  4-pole band splitter that preserves phase between the bands. It has a UI and uses much steeper crossover filters (24 dB/oct) than the default that ships with Reaper thereby providing sharper band transitions.
  It also has an option for linear phase FIR crossovers instead of the default IIR filters. IIRs cost less CPU and introduce no preringing or latency. The linear phase FIRs however prevent phase distortion (which can be important in some mixing settings), but introduce latency compensation. Note that when using the linear phase filters, it is not recommended to modulate the crossover frequencies as this introduces crackles.
  [Screenshot](https://i.imgur.com/nOhiaJB.png)
  ### Demos
  You can find a tutorial of the plugin [here](https://www.youtube.com/watch?v=JU_7gIr5RTI).
  
license: MIT

in_pin:left input
in_pin:right input
out_pin:left output 1
out_pin:right output 1
out_pin:left output 2
out_pin:right output 2
out_pin:left output 3
out_pin:right output 3
out_pin:left output 4
out_pin:right output 4
out_pin:left output 5
out_pin:right output 5

slider1:Cuts=1<0,4,1>-Cuts
slider2:Freq1=0.2<0,1,.0001>-Frequency 1
slider3:Freq2=0.5<0,1,.0001>-Frequency 2
slider4:Freq3=0.5<0,1,.0001>-Frequency 3
slider5:Freq4=0.5<0,1,.0001>-Frequency 4

slider6:Drive1=0<-40,60,.1>-Drive 1 (dB)
slider7:Drive2=0<-40,60,.1>-Drive 2 (dB)
slider8:Drive3=0<-40,60,.1>-Drive 3 (dB)
slider9:Drive4=0<-40,60,.1>-Drive 4 (dB)
slider10:Drive5=0<-40,60,.1>-Drive 5 (dB)

slider59:abs_placement=0<0,1,1>-Absolute placement
slider60:FIR_quality=0<0,2,{Normal,High,Ultra}>-FIR Quality
slider61:FIR=0<0,1,1>-FIR mode

slider62:masterGainSlider=0<-26,26,.1>-Master Gain
slider63:band_mode=0<0,1,1{4p,2p}>-Band mode

@init
/*function fft_real(x, x)
(
  1
);*/

/*-----------*/
/* HINTS     */  
/*-----------*/ 
function updateHintTime(hint)
  global(gfx_x, gfx_y)
  local()
  instance(hintTime, currentHint, delta_time)
  (
    (hint != 0) ? (
      currentHint = hint;
      hintTime = hintTime + delta_time;
      hintTime = min(1, hintTime);
    ) : (
      0
    );
  );   
  
function drawHint_draw()
  global(scaling, gfx_x, gfx_y, gfx_w, gfx_h, mouse_x, mouse_y, fontface, HINT_FONT)
  local(w, h, globalTime)
  instance(hintTime, currentHint, lastGlobalTime, delta_time, lx, ly)
  (
    globalTime = time_precise();
    delta_time = globalTime - lastGlobalTime;
    lastGlobalTime = globalTime;
  
    ( ( abs( lx - mouse_x ) + abs( ly - mouse_y ) ) > 0 ) ? (
      hintTime = 0;
    );
  
    ( hintTime > .99 ) ? (
      gfx_setfont(HINT_FONT);
      gfx_measurestr(currentHint,w,h);
      
      gfx_x = mouse_x+15;
      gfx_y = mouse_y+15;
      ( gfx_x > 0.5*gfx_w ) ? gfx_x = mouse_x - w - 8;
      ( gfx_y > 0.5*gfx_h ) ? gfx_y = mouse_y - h - 8;

      gfx_set( 0.05, 0.05, 0.1, .8 );
      gfx_rect(gfx_x-2, gfx_y-2, w+4, h+4);
      gfx_set( .7, .7, .7, 1 );      
      gfx_printf(currentHint);
    );
    
    lx = mouse_x;
    ly = mouse_y;
  );    

/*-----------*/
/* CIRCLE    */  
/*-----------*/
function fancyCircle(x1, y1, rin, mute, solo, bypass)
  local(dx)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(hl, x, y, r, over, gfx_mode)
  (
    x = x1;
    y = y1;
    rin == 0 ? r = 10 : r = rin;
    
    over ? (
      hl = abs(sin(2*globalTime));
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .1*hl);
      gfx_circle(x, y, 1.2*r, 1, 1);
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .1*hl);
      gfx_circle(x, y, 1.5*r, 1, 1);
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .05*hl);
      gfx_circle(x, y, 1.9*r, 1, 1);
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .03*hl);
      gfx_circle(x, y, 4*r, 1, 1);
    ); 
    
    gfx_set(.2*lineR, .2*lineG, .2*lineB, 1);
    gfx_circle(x, y, r, 1, 1);
    
    gfx_set(lineR, lineG, lineB, lineA);    
    gfx_circle(x, y, .92*r, 1, 1);
    
    gfx_set(.8*lineR, .8*lineG, .8*lineB, lineA);
    gfx_circle(x, y, .8*r, 1, 1);
    
    gfx_set(.6*lineR, .6*lineG, .6*lineB, lineA);
    gfx_circle(x, y, .75*r, 1, 1);
    
    gfx_set(.4*lineR, .4*lineG, .4*lineB, lineA);
    gfx_circle(x, y, .7*r, 1, 1);
    
    ( solo == 1 ) ? (
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, .8*r, 1, 1);
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, .9*r, 1, 1);
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, r, 1, 1);
      gfx_set(.2, 1, .2, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);    
      
      gfx_set(.7, 1, .7, .3);
      gfx_circle(x, y, .7*r, 1, 1);
      
      gfx_set(.2, 1, .5, .08);
      gfx_circle(x, y, 1.1*r, 1, 0);
      gfx_set(.2, 1, .5, .08);
      gfx_circle(x, y, 1.2*r, 1, 0);
      gfx_set(.2, 1, .5, .08);
      gfx_circle(x, y, 1.4*r, 1, 0);
     ) : ( mute == 1 ) ? (
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, .8*r, 1, 1);
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, .9*r, 1, 1);
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, r, 1, 1);
      gfx_set(1, .2, .2, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);
      
      gfx_set(1, .55, .55, 1);
      gfx_circle(x, y, 1*r, 0, 1);
      
      gfx_set(1, .7, .7, .1);
      gfx_circle(x, y, .7*r, 1, 1);
      
      gfx_set(1, .5, .5, .1);
      gfx_circle(x, y, 1.1*r, 1, 0);
      gfx_set(1, .5, .5, .1);
      gfx_circle(x, y, 1.2*r, 1, 0);
      gfx_set(1, .5, .5, .1);
      gfx_circle(x, y, 1.4*r, 1, 0);
    );    
    
    ( bypass == 1 ) ? (
      gfx_set(1-mute, .2, .2, 1);
      dx = .5*r;
      gfx_line(x-dx, y-dx-1, x+dx, y+dx-1);
      gfx_line(x-dx, y-dx+1, x+dx, y+dx+1);
      gfx_line(x+dx, y-dx-1, x-dx, y+dx-1);
      gfx_line(x+dx, y-dx+1, x-dx, y+dx+1);    
      gfx_line(x+dx, y-dx,   x-dx, y+dx);
      gfx_line(x-dx, y-dx,   x+dx, y+dx);
    );
    
    over ? ( 
      gfx_set(1,1,1,.4*hl);
      gfx_circle(x, y, .6*r, 1, 1);
      gfx_circle(x, y, 1.4*r, 0, 1);
      gfx_circle(x, y, 1.5*r, 0, 1);
    );
    
    over = 0;
  );

/*-----------*/
/* TOGGLE    */  
/*-----------*/ 
function processMouseToggle(mx, my, mousecap)
  instance(x, y, w, h, on, lastleft, str)
  local(left, slack, over)
  global(hinter.updateHintTime, comboboxOpen)
  (
    !comboboxOpen ? (
      slack = 5;
      left = mousecap & 1;
      
      over = ( (mx >= (x-slack)) && ( mx <= (x+w+slack) ) && ( my >= (y-slack) ) && ( my <= (y+h+slack) ) );
      
      over ? (
        ( (left == 1) && (lastleft == 0) ) ?  (
          on = 1 - on;
        );
        hinter.updateHintTime(str);
      );
      
      lastleft = left;
    );
    
    on
  );
 
function drawToggle(_x, _y, _w, _h, _on, wr, wg, wb, wa, r, g, b, a, _str)
  local(ww, hh)
  instance(x, y, w, h, str, on, invert, label)
  global(gfx_x, gfx_y, gfx_a, gfx_mode, 
         TOGGLE_FONT, knob_font_color_r, knob_font_color_g, knob_font_color_b, knob_font_color_a)
  (
    x = _x;
    y = _y;
    w = _w;
    h = _h;
    on = _on;
    str = _str;

    gfx_set(0, 0, 0, 0);
    gfx_rect(x, y, w, h);
    
    gfx_set(r, g, b, a*.2);
    gfx_rect(x, y, w, h);
    
    gfx_set(wr, wg, wb, wa);
    gfx_line(x, y, x+w, y);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y+h, x+w, y+h);

    ( label ) ? (
      gfx_set(knob_font_color_r, knob_font_color_g, knob_font_color_b, knob_font_color_a);
      gfx_setfont(TOGGLE_FONT);
      gfx_measurestr(label, ww, hh);
      gfx_x = floor(x+1.5*w);
      gfx_y = floor(y-.5*hh+.5*h);
      gfx_printf(label);
    );
    
    ( (on && !invert) || (!on && invert) ) ? (
      gfx_set(r, g, b, a);
      gfx_rect(x, y, w, h);
      gfx_a *= .6;
      gfx_rect(x-1, y-1, w+2, h+2);
      gfx_a *= .6;
      gfx_rect(x-2, y-2, w+4, h+4);
      gfx_a *= .6;
      gfx_rect(x-3, y-3, w+6, h+6);
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 2*max(w,h), 2*max(w,h));
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 3*max(w,h), 3*max(w,h));
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 4*max(w,h), 4*max(w,h));
      gfx_a *= .4;
      gfx_circle(x+.5*w-1, y+.5*h-1, 5*max(w,h), 5*max(w,h));
    );
  );


  GRID_FONT     = 15;
  HINT_FONT     = 14;
  TOGGLE_FONT   = 15;
  gfx_ext_retina = 1;

  function f_trafo(freq)
  local()
  global(srate, freq_max, norm_freq_min)
  instance()
  (
    freq_max * exp( (1-freq) * log(norm_freq_min) )
  );

  function initBands()
  local()
  global()
  instance(lg1, lg2, lg3, lg4, lg5, b1, b2, b3, b4, b5)
  (
    lg1 = lg2 = lg3 = lg4 = lg5 = -1000000;
    b1.ldrive = b2.ldrive = b3.ldrive = b4.ldrive = b5.ldrive = -1000000;
    b1.initialized = b2.initialized = b3.initialized = b4.initialized = b5.initialized = 0;
  );

maxCuts = 4;
driveMax = 60;
driveMin = -40;
driveRange = driveMax - driveMin;

filterBank.initBands();

// Precompute some things
gainRange = ( gainMax - gainMin );
iGainRange = 1.0 / gainRange;
iDriveRange = 1.0 / driveRange;

///////////////////
/* SLIDER LAYOUT */
///////////////////
/* Keep these updated with the slider locations */
frequencyLocation = 2;
driveLocation     = 6;

/* Shift slider data right (for different bands) */
function shiftRight(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx-1);
      midx = midx - 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeft(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx+1);
      midx = midx + 1;
    );
  );
  
/* Shift slider data right (for different bands) */
function shiftRightMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      midx[] = midx[-1];
      midx -= 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeftMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      midx[] = midx[1];
      midx += 1;
    );
  );  

/* Make room for a new band in the slider data */
function addBand(idx)
  local(midx)
  instance()
  (
    shiftRight( driveLocation,     idx, maxCuts );
    shiftRight( frequencyLocation, idx, maxCuts-1 );
    
    cuts = cuts + 1;
  );
  
/* Remove a band and move other slider data accordingly */  
function remBand(idx)
  local(midx)
  instance()
  (
    shiftLeft( driveLocation,     idx, maxCuts );
    shiftLeft( frequencyLocation, idx, maxCuts-1 );
    
    cuts = cuts - 1;
  );  

/* Feed sample to FFT */
function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );

/* Initialize FFT windowing function */
function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 

/* Calculate current spectrum */
function calcFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, slope, yshift)
  local(buf1, buf2, buf3, yOut, i, prec, ty)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

/* Set location of a window */
function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

// Draws the basic box for the FFT
function drawBackface()
  instance(x, y, w, h)
  global(backface_color_r, backface_color_g, backface_color_b, backface_color_a,
         grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local()
  (
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
  );

// Draws the FFT Grid, frequency axis and dB axis
function drawGrid()
  global(fftSize, srate, gfx_x, gfx_y, grid_alpha, scaling, GRID_FONT, norm_freq_max)
  instance(x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset,
           grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local(xx, i, wsc, N, xl)
  (    
    this.drawBackface();
    
    i = 0;
    wsc = w/log(1+fftSize*0.5-hzoffset);
    xl = x;
    gfx_y = y+h+2;
    
    gfx_setfont(GRID_FONT);
    loop(16,
      xx = x + log(i*fftSize/(2 * srate * norm_freq_max)-hzoffset)*wsc;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(xx, y, xx, y+h);
      
      ( (xx - xl) > 30 * (1 + scaling) ) ? (
        gfx_set( 1, 1, 1, 1 );
        gfx_x = xx+2;
        gfx_line(xx, y+h, xx, y+h+7);
        (i>999) ? (
          gfx_printf("%dk", .001*i);
        ) : (
          gfx_printf("%d", i);
        );
        xl = xx;
      );
      
      gfx_set( .2, .2, .2, grid_alpha );
      gfx_line(xx, y, xx, y+h);
      
      ( i < 100 ) ? (i += 20) :
      ( i < 1000 ) ? (i += 200) :
      ( i < 10000 ) ? (i += 2000) :
      ( i < 100000 ) ? (i += 20000);
    );
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    N = 8;
    xx = y;
    i = 0;
    gfx_measurestr("8", wsc, xl);
    loop(N,
      gfx_set( 1, 1, 1, 1 );
      gfx_x = x+w-20;
      gfx_y = xx-.5*xl;
      i > 0 ? gfx_printf("-%d", 4.41*i*floorLevel/N);
      
      gfx_set( .2, .2, .2, grid_alpha );
      gfx_line(x, xx+1, x+w, xx+1);
      
      xx += h/N;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(x, xx, x+w, xx);
      i += 1;
    );
  );
  
function drawLine(x1, y1, x2, y2)
  local(dx, dy, x, smooth)
  global(gfx_x, gfx_y)
  instance()
  (
    smooth = 1;
    x1 = floor(x1);
    x2 = floor(x2);
    gfx_x=x1;
    gfx_y=y1;
    x2 = floor(x2);
    y2 = floor(y2);
    
    smooth ? (
      (x2 - x1) > 4 ? (
        dx = 1.0/(x2-x1);
        dy = (y2 - y1)*6*dx;
        x = 0;
        loop(x2-x1,
          x2 = x1 + 1;
          y2 = y1 + dy * ( x - x*x );

          gfx_line(x1-1, y1-1, x2-1, y2-1, 1);          
          gfx_line(x1, y1-1, x2, y2-1, 1);
          gfx_lineto(x2,y2,1);
          x1 = x2;
          y1 = y2;
          x = x + dx;
        );
      ) : (
        gfx_line(x1, y1-1, x2, y2-1, 1);
        gfx_lineto(x2,y2,1);
      );
    ) : (
      gfx_line(x1, y1-1, x2, y2-1, 1);
      gfx_lineto(x2,y2,1); 
    );
  );

bandClickRange = 10;
overRange = 10;

function isOver(mx, my)
  instance(x, y, w, h)
  global(overRange)
  local()
  (
    ( ( mx >= (x-overRange) ) && ( mx <= (x+w+overRange) ) && ( my >= (y-overRange) ) && ( my <= (y+h+overRange) ) ) ? 1 : 0;
  );

function clamp(value, mini, maxi)
  local()
  global()
  (
    max(min(value,maxi),mini)
  );

function overRect(x, y, w, h, mx, my)
  local()
  global()
  (
    ( (mx > x) && (mx < (x+w) ) && (my > y) && (my < (y+h) ) )
  );

function pixelToWindowRatio(x_loc)
  instance(x, y, w, h, hzoffset)
  global(fftSize, norm_freq_min)
  local(lmin, wsc, hfft)
  (
    hfft  = 0.5*fftSize;
    lmin  = log(norm_freq_min);
    wsc   = w/log(1+fftSize*0.5-hzoffset);
    
    1-log( (exp((x_loc)/wsc) + hzoffset)/hfft )/lmin
  );

function fftWindow_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, lx, ly, lcap, cap, thisUI, htime, hint,
           x_over, dragging, lastLeftClick
           x1, x2, x3, x4, x5,
           v1, v2, v3, v4, v5,
           h1, h2, h3, h4, h5, 
           c1, c2, c3, c4, c5,
           F1hz, F2hz, F3hz, F4hz )
  global(dnoisefloor_freq, dsteps_fft, mouse_wheel, lastUI, fftSize,
         bandClickRange, cuts,
         Freq1, Freq2, Freq3, Freq4,
         bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5,
         Drive1, Drive2, Drive3, Drive4, Drive5,
         mute1, mute2, mute3, mute4, mute5,
         solo1, solo2, solo3, solo4, solo5,
         driveMin, driveMax, maxCuts,
         hinter.updateHintTime,
         selectedBand, gfx_x, gfx_y, srate, abs_placement )
  local(dx, dy, over, dys,
        F1, F2, F3, F4,
        leftClick, rightClick, doubleClick,
        cTime, mpos, shift, ctrl, lb)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    leftClick   = ( mouse_cap & 1 == 1 && lcap & 1 == 0 );
    rightClick  = ( mouse_cap & 2 == 2 && lcap & 2 == 0 );
    doubleClick = 0;
    shift       = ( mouse_cap & 8 );
    ctrl        = ( mouse_cap & 4 );
    
    leftClick ? (
       time_precise(cTime);
       ( ( cTime - lastLeftClick ) < .25 ) ? (
          leftClick = 0;
          doubleClick = 1;
       );
       lastLeftClick = cTime;
    );
    
    x_over = -1;
    
    abs_placement ? (
      F1 = clamp(Freq1, 0, 1);
      F2 = clamp(Freq2, F1, cuts > 2 ? F3 : 1);
      F3 = clamp(Freq3, F2, cuts > 3 ? F4 : 1);
      F4 = clamp(Freq4, F3, 1.0);
    ) : (
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
    );

    F1hz = f_trafo(F1);
    F2hz = f_trafo(F2);
    F3hz = f_trafo(F3);
    F4hz = f_trafo(F4);
        
    ( cap == 3 && mouse_cap & 1 == 1 ) ? (
      dy = mouse_y - ly;
      
      dys = 100*dy/h;
      dragging == 1 ? ( Drive1 -= dys; Drive1 = clamp(Drive1, driveMin, driveMax); );
      dragging == 2 ? ( Drive2 -= dys; Drive2 = clamp(Drive2, driveMin, driveMax); );
      dragging == 3 ? ( Drive3 -= dys; Drive3 = clamp(Drive3, driveMin, driveMax); );
      dragging == 4 ? ( Drive4 -= dys; Drive4 = clamp(Drive4, driveMin, driveMax); );
      dragging == 5 ? ( Drive5 -= dys; Drive5 = clamp(Drive5, driveMin, driveMax); );
      
    ) : ( cap == 2 && mouse_cap & 1 == 1 ) ? (
      // Dragging a band frequency
      dx = mouse_x - lx;
      
      shift ? dx *= .5;
      ctrl ? dx *= .01;
      
      lb = .02;
      dragging == 1 ? ( 
        F1 = this.pixelToWindowRatio(x1 - x + dx);
        abs_placement ? (
          slider_automate( Freq1 = clamp( F1, lb, 1 ) );
        ) : (
          slider_automate( Freq1 = clamp( F1, lb, 1 ) );
          slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-F1), 0, 1 ) );
        );
      );
      dragging == 2 ? ( 
        F2 = this.pixelToWindowRatio(x2 - x + dx);
        abs_placement ? (
          slider_automate( Freq2 = clamp(F2, F1, cuts > 2 ? F3 : 1));
        ) : (
          slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-Freq1), 0, 1 ) );
          F2 = Freq1  + Freq2 * (1 - Freq1);
          slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1) );
        );
      );
      dragging == 3 ? ( 
        F3 = this.pixelToWindowRatio(x3 - x + dx);
        abs_placement ? (
          slider_automate( Freq3 = clamp( F3, F2, cuts > 3 ? F4 : 1 ) );          
        ) : (
          slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1 ) );
          F3 = F2     + Freq3 * (1 - F2);
          slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
        );
      );
      dragging == 4 ? ( 
        F4 = this.pixelToWindowRatio(x4 - x + dx);
        abs_placement ? (
          slider_automate( Freq4 = clamp( F4, F3, 1.0 ) );
        ) : (
          slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
        );
      );
    ) : ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dnoisefloor_freq -= .5*(mouse_y-ly);
      dnoisefloor_freq > 35 ? dnoisefloor_freq = 35;
      dnoisefloor_freq < -15 ? dnoisefloor_freq = -15;
    ) : ( 
      // Not already capped
      cap = 0;
      
      /* Toggle mute/solo */
      ( c1.isOver(mouse_x, mouse_y) == 1 ) ? (
        c1.over = 1;
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        leftClick  ? ( ctrl ? ( bypassBand1 = 1 - bypassBand1) : (
                       mute1 = 1-mute1; solo1 ? (mute1 = 1; solo1 = 0; selectedBand = 0; ); ); );
        rightClick ? ( solo1 = 1-solo1; selectedBand = 0; 
                       ((solo1 == 1) && (shift==0)) ? (solo2=solo3=solo4=solo5=0;); );
      ) : ( c2.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c2.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand2 = 1 - bypassBand2) : (
                       mute2 = 1-mute2; solo2 ? (mute2 = 1; solo2 = 0; selectedBand = 1;); ); );
        rightClick ? ( solo2 = 1-solo2; selectedBand = 1;
                       ((solo2 == 1) && (shift==0)) ? (solo1=solo3=solo4=solo5=0;); );
      ) : ( c3.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c3.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand3 = 1 - bypassBand3) : (
                       mute3 = 1-mute3; solo3 ? (mute3 = 1; solo3 = 0; selectedBand = 2; ); ); );
        rightClick ? ( solo3 = 1-solo3; selectedBand = 2;
                       ((solo3 == 1) && (shift==0)) ? (solo1=solo2=solo4=solo5=0;); );
      ) : ( c4.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c4.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand4 = 1 - bypassBand4) : (
                        mute4 = 1-mute4; solo4 ? (mute4 = 1; solo4 = 0; selectedBand = 3; ); ); );
        rightClick ? ( solo4 = 1-solo4; selectedBand = 3;
                       ((solo4 == 1) && (shift==0)) ? (solo1=solo2=solo3=solo5=0;); );
      ) : ( c5.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c5.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand5 = 1 - bypassBand5) : (
                       mute5 = 1-mute5; solo5 ? (mute5 = 1; solo5 = 0; selectedBand = 4; ); ); );
        rightClick ? ( solo5 = 1-solo5; selectedBand = 4;
                       ((solo5 == 1) && (shift==0)) ? (solo1=solo2=solo3=solo4=0;); );
        
      /* Drag frequency */
      ) : ( v1.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v1.over = 1;
        leftClick ? ( cap = 2; dragging = 1; );
        rightClick ? (
          !abs_placement ? ( Freq2 = ( Freq2 * ( 1 - Freq1 ) + ( Freq1 - 0 ) ) / ( 1 - 0 ); );
          remBand(0);
        );
      ) : ( v2.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v2.over = 1;
        leftClick ? ( cap = 2; dragging = 2; );
        rightClick ? ( 
          !abs_placement ? ( Freq3 = ( Freq3 * ( 1 - Freq2 ) + ( Freq2 - 0 ) ) / ( 1 - 0 ) );
          remBand(1);
        );
      ) : ( v3.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");    
        v3.over = 1;
        leftClick ? ( cap = 2; dragging = 3; );
        rightClick ? ( 
          !abs_placement ? ( Freq4 = ( Freq4 * ( 1 - Freq3 ) + ( Freq3 - 0 ) ) / ( 1 - 0 ) );
          remBand(2);
        );
      ) : ( v4.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v4.over = 1;
        leftClick ? ( cap = 2; dragging = 4; );
        rightClick ? ( remBand(3); );
      ) : ( v5.isOver(mouse_x, mouse_y) ) && ( cuts > 4 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");     
        v5.over = 1;
        leftClick ? ( cap = 2; dragging = 5; );
        rightClick ? ( remBand(4); );
      
      /* Drag drive */
      ) : ( h1.isOver(mouse_x, mouse_y) ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h1.over = 1;
        leftClick ? ( cap = 3; dragging = 1; selectedBand = 0; );
        doubleClick ? ( Drive1 = 0; selectedBand = 0; );
      ) : ( h2.isOver(mouse_x, mouse_y) ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");
        h2.over = 1;
        leftClick ? ( cap = 3; dragging = 2; selectedBand = 1; );
        doubleClick ? ( Drive2 = 0; selectedBand = 1; );
      ) : ( h3.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");
        h3.over = 1;
        leftClick ? ( cap = 3; dragging = 3; selectedBand = 2; );
        doubleClick ? ( Drive3 = 0; selectedBand = 2; );
      ) : ( h4.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h4.over = 1;
        leftClick ? ( cap = 3; dragging = 4; selectedBand = 3; );
        doubleClick ? ( Drive4 = 0; selectedBand = 3; );
      ) : ( h5.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");            
        h5.over = 1;
        leftClick ? ( cap = 3; dragging = 5; selectedBand = 4; );
        doubleClick ? ( Drive5 = 0; selectedBand = 4; );    
        
      /* Handle clicks within the bands (creating a new band or selecting a band) */
      ) : ( overRect( h1.x, y, h1.w, h, mouse_x, mouse_y ) ) ? (
        leftClick ? selectedBand = 0;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(0);
          mpos = this.pixelToWindowRatio(mouse_x);
          !abs_placement ? ( Freq2 = ( Freq2 * (1-0) + 0 - mpos ) / ( 1 - mpos ); );
          Freq1 = mpos;
        );
      ) : ( overRect( h2.x, y, h2.w, h, mouse_x, mouse_y ) && ( cuts > 0 )  ) ? (
        leftClick ? selectedBand = 1;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(1);
          mpos = this.pixelToWindowRatio(mouse_x);
          !abs_placement ? (
            Freq3 = ( Freq3 * (1-Freq1) + Freq1 - mpos ) / ( 1 - mpos );
            Freq2 = ( mpos - Freq1 ) / ( 1 - Freq1 );
          ) : (
            Freq2 = mpos;
          );
        );
      ) : ( overRect( h3.x, y, h3.w, h, mouse_x, mouse_y ) && ( cuts > 1 ) ) ? (
        leftClick ? selectedBand = 2;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(2);
          mpos = this.pixelToWindowRatio(mouse_x);
          !abs_placement ? (
            F2 = Freq1  + Freq2 * (1 - Freq1);
            Freq4 = ( Freq4 * (1-F2) + F2 - mpos ) / ( 1 - mpos );
            Freq3 = ( mpos - F2 ) / ( 1 - F2 );
          ) : (
            Freq3 = mpos;
          );
        );
      ) : ( overRect( h4.x, y, h4.w, h, mouse_x, mouse_y ) && ( cuts > 2 ) ) ? (
        leftClick ? selectedBand = 3;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(3);
          mpos = this.pixelToWindowRatio(mouse_x);
          !abs_placement ? (
            F2 = Freq1  + Freq2 * (1 - Freq1);
            F3 = F2     + Freq3 * (1 - F2);
            Freq4 = ( mpos - F3 ) / ( 1 - F3 );
          ) : (
            Freq4 = mpos;
          );
        );
      ) : ( overRect( h5.x, y, h5.w, h, mouse_x, mouse_y ) && ( cuts > 3 ) ) ? (
        leftClick ? selectedBand = 4;
      ) : (
        cap = 0;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
          cap = 1;
        );
      );
    );
    
    mouse_wheel > 0 && over ? lastUI = thisUI;
    
    abs(floor(mouse_wheel/240)) > 0 && over ?
    (
      dsteps_fft += floor(mouse_wheel/240);
      dsteps_fft > 8 ? dsteps_fft = 8;
      dsteps_fft < -4 ? dsteps_fft = -4;
      mouse_wheel = 0;
    );
    
    lx = mouse_x;
    ly = mouse_y;
    lcap = mouse_cap;
    
    over
  );

function drawFFT(fill, r, g, b, a)
  global(scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate, gfx_mode, dsteps_fft, FIR1, norm_freq_max)
  instance(hstep, x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset)
  local(step, copyval, stepsize, buf, i, ixsc, txl, tx, ty, wsc, fill, tx0, lx0, lx, ly, ty2, ly2, fill_slast, fill_slmin, cum, cumelem)
  (
    this.calcFFT();
 
    cum = -10000000;
    cumelem = 0;
    i = 0;
    ixsc = 0;
    wsc = w/log(fftsize*0.5-hzoffset);
    fill_slmin = y;

    buf = fftLoc + fftsize*0.5;
    stepsize = floor((4+dsteps_fft)*(1+scaling));
    copyval = buf[];
    loop( stepsize*200,
      (buf+=1)[] = copyval;
    );
     
    gfx_r = r;
    gfx_g = g;
    gfx_b = b;
    gfx_a = a;
 
    hstep = 0.5 * stepsize;
    buf = fftLoc;
    txl = x;
    lx = x;
    ly = y - max(buf[2], -floorLevel)*h / floorLevel;
    step = 1.0 / (2*norm_freq_max);
    
    loop(fftsize*0.5+stepsize*200,
      tx = floor(x + log(ixsc - hzoffset)*wsc);
      cum = max(cum, tx > 0 ? buf[] : -10000);
      cumelem += 1;
      
      ( (tx != txl) && (tx-txl > stepsize) && tx > x && i && ( tx < (x+w+stepsize) ) ) ?
      ( 
        ty = y - max(cum, -floorLevel)*h / floorLevel;
        txl = floor(tx);
        
        tx = min(tx, x+w);
        (fill) ? 
        (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0 ? 
          (
            gfx_triangle(lx0-hstep,max(y+h,ly),lx0-hstep,ly,tx0-1-hstep,ty,tx0-1-hstep,max(y+h,ty));
          ) : (
            tx0 > fill_slast ? 
            (
              fill_slast < h ? gfx_line(fill_slast,h,fill_slast,fill_slmin);
              fill_slmin=h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          
          fill_slast=tx0;        
        );
        
        (fill==0) ? (
          drawLine(lx-hstep, ly, tx-hstep, ty);
        );
        
        lx=tx; ly=ty; ly2=ty2; cum = -1000000; cumelem = 0;
      );
      
      buf+=1; i+=1; ixsc+=step;
    );
  );
  
function drawLineFFT(peakLocation)
  global(fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate)
  instance(x, y, w, h, hzoffset)
  local(wsc, tx, base, i)
  (
    wsc = w/log(1+fftSize*0.5-hzoffset);
    base = fftSize*peakLocation;
    tx = floor(x + log(1.0+base-hzoffset)*wsc);
    drawLine(tx, y, tx, y+h);
  );  
  
function updateBands()
  global(Freq1,   Freq2,   Freq3,   Freq4,
         Ceil1,   Ceil2,   Ceil3,   Ceil4,
         Drive1,  Drive2,  Drive3,  Drive4,  Drive5,
         fftSize, driveRange, driveMax, abs_placement, cuts,
         norm_freq_min)
  instance(x, y, w, h, hzoffset,
           x1,  x2,  x3,  x4,  x5,  /* Frequencies          */
           y1,  y2,  y3,  y4,  y5,  /* Drives               */
           )
  local(F1, F2, F3, F4, F5, wsc, hfft, lmin, irange, dmax)
  (
    abs_placement ? (
      F1 = clamp(Freq1, 0, 1);
      F2 = clamp(Freq2, F1, cuts > 2 ? F3 : 1);
      F3 = clamp(Freq3, F2, cuts > 3 ? F4 : 1);
      F4 = clamp(Freq4, F3, 1.0);
    ) : (
      F1 = Freq1;
      F2 = Freq1  + Freq2 * (1 - Freq1);
      F3 = F2     + Freq3 * (1 - F2);
      F4 = F3     + Freq4 * (1 - F3);
    );
    
    hfft = 0.5*fftSize;
    lmin = log(norm_freq_min);
    
    wsc = w/log(1+fftSize*0.5-hzoffset);
    x1 = ( x + log( hfft * exp( (1-F1) * lmin ) - hzoffset ) * wsc );
    x2 = ( x + log( hfft * exp( (1-F2) * lmin ) - hzoffset ) * wsc );
    x3 = ( x + log( hfft * exp( (1-F3) * lmin ) - hzoffset ) * wsc );
    x4 = ( x + log( hfft * exp( (1-F4) * lmin ) - hzoffset ) * wsc );
    x5 = ( x + log( hfft * exp( lmin ) - hzoffset ) * wsc );
       
    iRange = 1/driveRange;
    dmax = iRange * driveMax;
    
    y1 = y+h*(dmax-iRange*Drive1);
    y2 = y+h*(dmax-iRange*Drive2);
    y3 = y+h*(dmax-iRange*Drive3);
    y4 = y+h*(dmax-iRange*Drive4);
    y5 = y+h*(dmax-iRange*Drive5);
  );

lineR = 1;
lineG = .9;
lineB = 1.0;
lineA = .95;
lineHighlightR = 0;
lineHighlightG = .7;
lineHighlightB = .5;
  
function drawGroupRect(x, y, w, h, r, g, b, a)  
  local()
  instance()
  global()
  (
    gfx_set(r, g, b, a);
    gfx_line(x, y, x+w, y);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y+h, x+w, y+h);
    
    gfx_set(r, g, b, a*.5);
    gfx_line(x, y+h+1, x+w, y+h+1);
    gfx_line(x+w+1, y, x+w+1, y+h);
  );  
  
function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
  
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    c2 * (1.0-frac) + c1 * frac
  );
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );  
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    memset( scopebuffer, 0, MAXBUFFERSIZE );
    scopeptr = scopebuffer;
  );   
  
function fancyLineV(x1, y1, x2, y2)
  local(dx)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dx = 5;
    
    x = x1 - .5*dx;
    y = y1;
    w = dx;
    h = y2-y1;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x-2, y, w+5, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x-4, y, w+9, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x-7, y, w+15, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x-10, y, w+20, h);
    );
  
    gfx_set(.2*lineR, .2*lineG, .2*lineB, lineA);
    gfx_rect(x, y, w, h);
    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dx = 3; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dx = 2; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(lineR, lineG, lineB, lineA);
    dx = 1; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    
    over ? ( 
      gfx_set(1,1,1,.4*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;
  );

function fancyLineH(x1, y1, x2, y2)
  local(dy)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dy = 5;    
    
    x = x1;
    y = y1 - .5*dy;
    w = x2-x1;
    h = dy;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-2, w, h+5);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-4, w, h+9);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x, y-7, w, h+15);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x, y-10, w, h+20);
    );  
  
    gfx_set(.2*lineR, .2*lineG, .2*lineB, lineA);
    gfx_rect(x, y, w, h);
    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dy = 3; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dy = 2; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(lineR, lineG, lineB, lineA);
    dy = 1; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    
    over ? ( 
      gfx_set(1,1,1,.7*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;    
  ); 

function hzLabel(dy, label)
  local(lww, lhh, cy, dy2)
  global(gfx_x, gfx_y, hzLabelW, hzLabelH, lineR, lineG, lineB, lineA)
  instance(x, y, w, h, over)
  (
    cy = y + dy*h;
    
    gfx_measurestr("888888", hzLabelW, hzLabelH);

    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dy2 = 3; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dy2 = 2; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);
    gfx_set(lineR, lineG, lineB, lineA);
    dy2 = 1; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);

    gfx_set( 1, 1, 1, .8 );
    gfx_rect(x-.5*hzLabelW-1, cy-1, hzLabelW+2, hzLabelH+2);
    
    gfx_set( 0, 0, 0, 1 );
    gfx_rect(x-.5*hzLabelW, cy, hzLabelW, hzLabelH);

    sprintf(19, "%d", label);
    gfx_measurestr(19, lww, lhh);
    gfx_set( 1, 1, 1, 1 );    
    gfx_x = x - .5 *lww;
    gfx_y = y + dy*h;
    gfx_printf(19, label);
  );
  
function drawBands()
  global(Cuts, stest,
           mute1, mute2, mute3, mute4, mute5,
           solo1, solo2, solo3, solo4, solo5,
           bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5,
           selectedBand )
  instance(xc, dx, x, y, w, h, 
           x1, x2, x3, x4, x5, // Band frequency screen positions
           y1, y2, y3, y4, y5, // Band drive positions
           v1, v2, v3, v4, v5, // Frequency handles
           h1, h2, h3, h4, h5, // Drive handles
           c1, c2, c3, c4, c5, // Circle handles
           F1hz, F2hz, F3hz, F4hz, F5hz, // Frequencies
           x_over)
  local()
  (
    xc = x;
    dx = 5;
    while(xc<x+w) (
      gfx_set(0,0,0,1);
      gfx_line(xc, y+.6*h+1, xc+dx, y+.6*h+1);
      gfx_line(xc, y+.6*h-1, xc+dx, y+.6*h-1);
      gfx_set(0.6,0.6,0.6,1);
      gfx_line(xc, y+.6*h, xc+dx, y+.6*h);
      xc = xc + 2*dx;
    );
    
    xc = x;
    dx = 5;
    gfx_set(0,0,0,.3);
    gfx_line(x, y+.3*h, x+w, y+.3*h);
    gfx_line(x, y+.3*h+2, x+w, y+.3*h+2);
 
    (Cuts > 0) ? (
      gfx_set(1,1,1,1); v1.fancyLineV(x1, y, x1, y+h);
      v1.hzLabel(.8, F1hz);
    );
    (Cuts > 1) ? (
      gfx_set(1,1,1,1); v2.fancyLineV(x2, y, x2, y+h);
      v2.hzLabel(.8, F2hz);
    );
    (Cuts > 2) ? (
      gfx_set(1,1,1,1); v3.fancyLineV(x3, y, x3, y+h);
      v3.hzLabel(.8, F3hz);
    );
    (Cuts > 3) ? (
      gfx_set(1,1,1,1); v4.fancyLineV(x4, y, x4, y+h);
      v4.hzLabel(.8, F4hz);
    );
    (Cuts > 4) ? (
      gfx_set(1,1,1,1); v5.fancyLineV(x5, y, x5, y+h);
      v5.hzLabel(.8, F5hz);
    );
    
    gfx_rect(x_over-3, y, 5, h);
    ( Cuts == 0 ) ? (
       h1.fancyLineH(x, y1, x+w-2, y1);
       c1.fancyCircle(x + .5*w, y1, 0, mute1, solo1, bypassBand1);
    ) : ( Cuts == 1 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x+w-2, y2);
       c2.fancyCircle(x1 + .5*(w-x1), y2, 0, mute2, solo2, bypassBand2);
    ) : ( Cuts == 2 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       h3.fancyLineH(x2, y3, x+w-2, y3);
       c3.fancyCircle(x2 + .5*(w-x2), y3, 0, mute3, solo3, bypassBand3);
    ) : ( Cuts == 3 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3, bypassBand3);
       h4.fancyLineH(x3, y4, x+w-2, y4);
       c4.fancyCircle(x3 + .5*(w-x3), y4, 0, mute4, solo4, bypassBand4);
    ) : ( Cuts == 4 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3, bypassBand3);
       h4.fancyLineH(x3, y4, x4-2, y4);      
       c4.fancyCircle(x3 + .5*(x4-x3), y4, 0, mute4, solo4, bypassBand4);
       h5.fancyLineH(x4, y5, x+w-2, y5);
       c5.fancyCircle(x4 + .5*(w-x4), y5, 0, mute5, solo5, bypassBand5);
    );
    
    selectedBand == 0 ? gfx_muladdrect( h1.x, y, h1.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 1 ? gfx_muladdrect( h2.x, y, h2.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 2 ? gfx_muladdrect( h3.x, y, h3.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 3 ? gfx_muladdrect( h4.x, y, h4.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 4 ? gfx_muladdrect( h5.x, y, h5.w, h, 1, 1, 1, .6, .05, .05, .105 );

  );  
  
function initSpectrum(memoryOffset, fftSize, srate)
  global(newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 10*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );
  
  function resetBandMeter()
  local()
  global()
  instance(in, pre, post)
  (
    in = pre = post = 0;
  );
  
  function processBands()
  local(BW2)
  global( Drive1,    Drive2,    Drive3,     Drive4,     Drive5
          play1,     play2,     play3,      play4,      play5 )
  instance(b1, b2, b3, b4, b5, F1, F2, F3, F4, F5,
           g1,       g2,       g3,       g4,       g5,
           lg1,      lg2,      lg3,      lg4,      lg5 )
  (
    ( lg1 != Drive1 ) ? ( g1 = (10^(0.05*Drive1)); lg1 = Drive1; );
    ( lg2 != Drive2 ) ? ( g2 = (10^(0.05*Drive2)); lg2 = Drive2; );
    ( lg3 != Drive3 ) ? ( g3 = (10^(0.05*Drive3)); lg3 = Drive3; );
    ( lg4 != Drive4 ) ? ( g4 = (10^(0.05*Drive4)); lg4 = Drive4; );
    ( lg5 != Drive5 ) ? ( g5 = (10^(0.05*Drive5)); lg5 = Drive5; );

    b1.l = b2.l = b3.l = b4.l = b5.l = 0;
    b1.r = b2.r = b3.r = b4.r = b5.r = 0;
    play1 ? (
      b1.l = g1*b1.inL;
      b1.r = g1*b1.inR;
    );
    play2 ? (
      b2.l = g2*b2.inL;
      b2.r = g2*b2.inR;
    );
    play3 ? (
      b3.l = g3*b3.inL;
      b3.r = g3*b3.inR;
    );
    play4 ? (
      b4.l = g4*b4.inL;
      b4.r = g4*b4.inR;
    );
    play5 ? (
      b5.l = g5*b5.inL;
      b5.r = g5*b5.inR;
    );
  ); 
  
// MEMORY LAYOUT
fftSize     = 2*8192;
bufferDist  = 65536;
audioBufIn  = 0;
audioBufOut = bufferDist;

FIR1        = 2*bufferDist;
FIR2        = 3*bufferDist;
FIR3        = 4*bufferDist;
FIR4        = 5*bufferDist;
FIR5        = 6*bufferDist;

F1Block1    = 7*bufferDist;
F1Block2    = 8*bufferDist;
F2Block1    = 9*bufferDist;
F2Block2    = 10*bufferDist;
F3Block1    = 11*bufferDist;
F3Block2    = 12*bufferDist;
F4Block1    = 13*bufferDist;
F4Block2    = 14*bufferDist;
F5Block1    = 15*bufferDist;
F5Block2    = 16*bufferDist;

specBufferLoc = 17*bufferDist;

specBuffer.initBuffer(specBufferLoc, specBufferLoc+bufferDist-4);

// INITIALIZATION
spectrumIn.initSpectrum(audioBufIn, fftSize, srate);
spectrumOut.initSpectrum(audioBufOut, fftSize, srate);

@serialize
file_var(0, mute1);
file_var(0, mute2);
file_var(0, mute3);
file_var(0, mute4);
file_var(0, mute5);

file_var(0, solo1);
file_var(0, solo2);
file_var(0, solo3);
file_var(0, solo4);
file_var(0, solo5);

file_var(0, FIR);

@slider

@block
absolute_frequencies ? (
  freq_max = 24000;
  norm_freq_min = 20.0 / freq_max;
  norm_freq_max = freq_max / srate;
) : (
  freq_max = 0.5 * srate;
  norm_freq_min = 20.0 / 22050;
  norm_freq_max = 0.5;
);

!mute1 ? play1 = 1 : play1 = 0;
!mute2 ? play2 = 1 : play2 = 0;
!mute3 ? play3 = 1 : play3 = 0;
!mute4 ? play4 = 1 : play4 = 0;
!mute5 ? play5 = 1 : play5 = 0;

( solo1 || solo2 || solo3 || solo4 || solo5 ) ? ( play1 = play2 = play3 = play4 = play5 = 0; );
solo1 ? play1 = 1;
solo2 ? play2 = 1;
solo3 ? play3 = 1;
solo4 ? play4 = 1;
solo5 ? play5 = 1;

(FIR) ? (
  chunkSize = (fftCalcSize - firSize - 1);
  newPDC = chunkSize + 0.5*firSize;
) : (
  newPDC = 0;
);

(pdc_delay != newPDC) ? (
  pdc_top_ch = 10;
  pdc_bot_ch = 0;
  pdc_delay = newPDC;
);

@sample
  function init_LR2(freq)
    global(srate, norm_freq_max, norm_freq_min, band_mode)
    local(f0, ct, st, div)
    instance(k, a1, a2, a3)
    (
      f0 = norm_freq_max * $pi * exp( (1.0 - freq) * log(norm_freq_min) );
      k = band_mode == 0 ? sqrt(2) : 2; /* Note the different peak resonance because we're combining 2 SVFs into the Linkwitz-Riley structure */

      ct = cos(f0);
      st = sin(f0);
      div = 1.0 / (1.0 + k * st * ct);
      a1 = ct * ct * div;
      a2 = st * ct * div;
      a3 = st * st * div;
    );
  
  function reset_LR()
    global()
    local()
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq, k, a1, a2, a3)
    (
      ic1eq = ic2eq = 0;  
    );  

  function eval_LRLP(v0)
    global()
    local(v1, v2, v3)
    instance(ic3eq, ic4eq, a1, a2, a3)
    (
      v3 = v0 - ic4eq;
      v1 = a1 * ic3eq + a2 * v3;
      v2 = ic4eq + a2 * ic3eq + a3 * v3;
      ic3eq = 2*v1 - ic3eq;
      ic4eq = 2*v2 - ic4eq;
      
      v2
    );  
 
  function eval_LRAP(v0)
    global()
    local(v1, v2, v3)
    instance(ic5eq, ic6eq, k, a1, a2, a3)
    (
      v3 = v0 - ic6eq;
      v1 = a1 * ic5eq + a2 * v3;
      v2 = ic6eq + a2 * ic5eq + a3 * v3;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;    
      
      v0 - 2*k*v1
    );
    
  function eval_LR2(v0)
    global()
    local(v1, v2, v3, all)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;
      
      all = v0 - 2 * k * v1;
 
      lp = this.eval_LRLP(v2); 
      hp = all - lp;
    );
    
  function eval_LR1(v0)
    global()
    local(v1, v2, v3)
    instance(ic1eq, ic2eq, k, a1, a2, a3, hp, lp)
    (
      v3 = v0 - ic2eq;
      v1 = a1 * ic1eq + a2 * v3;
      v2 = ic2eq + a2 * ic1eq + a3 * v3;
      ic1eq = 2*v1 - ic1eq;
      ic2eq = 2*v2 - ic2eq;
 
      lp = v2;
      hp = v0 - k * v1 - lp;
    );
    
  function init_AP1(freq)
    global(srate, norm_freq_min, norm_freq_max)
    instance(k)
    local(f0, st)
    (
      f0 = norm_freq_max * $pi * exp((1 - freq) * log(norm_freq_min));
      st = sin(f0);
      k = st / (st + cos(f0));
    );
    
  function eval_AP1(v0)
    global()
    instance(k, state)
    local(v, y)
    (
      v = (v0 - state) * k;
      y = v + state;
      state = y + v;
      y - (v0 - y)
    );
  
  function resetBands()
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    b1.r = b1.l = b2.r = b2.l = b3.r = b3.l = b4.r = b4.l = b5.l = 0;
  );
  
  function resetFilters()
  global()
  local()
  instance(
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */  
  )
  (
    // LR2  => ic1eq, ic2eq, ic3eq, ic4eq
    // LPLP => ic3eq, ic4eq
    // LRAP => ic5eq, ic6eq
    
    LF1.ic1eq = LF1.ic2eq = LF1.ic3eq = LF1.ic4eq = 0;
    LF2.ic1eq = LF2.ic2eq = LF2.ic3eq = LF2.ic4eq = 0;
    LF3.ic1eq = LF3.ic2eq = LF3.ic3eq = LF3.ic4eq = 0;
    LF4.ic1eq = LF4.ic2eq = LF4.ic3eq = LF4.ic4eq = 0;

    RF1.ic1eq = RF1.ic2eq = RF1.ic3eq = RF1.ic4eq = 0;
    RF2.ic1eq = RF2.ic2eq = RF2.ic3eq = RF2.ic4eq = 0;
    RF3.ic1eq = RF3.ic2eq = RF3.ic3eq = RF3.ic4eq = 0;
    RF4.ic1eq = RF4.ic2eq = RF4.ic3eq = RF4.ic4eq = 0;
    
    LA_F4.ic5eq = LA_F4.ic6eq = LA_F3.ic5eq = LA_F3.ic6eq = LA_F2.ic5eq = LA_F2.ic6eq = 0;
    RA_F4.ic5eq = RA_F4.ic6eq = RA_F3.ic5eq = RA_F3.ic6eq = RA_F2.ic5eq = RA_F2.ic6eq = 0;

    LA_F4_2.ic5eq = LA_F4_2.ic6eq = LA_F3_2.ic5eq = LA_F3_2.ic6eq = LA_F4_3.ic5eq = LA_F4_3.ic6eq = 0;
    RA_F4_2.ic5eq = RA_F4_2.ic6eq = RA_F3_2.ic5eq = RA_F3_2.ic6eq = RA_F4_3.ic5eq = RA_F4_3.ic6eq = 0;
  );
  
  // Make sure the delay is the same on all bands (identical number of filters)
  function splitBands(sl, sr)
  local()
  global(Cuts, FIR, band_mode, lband_mode)
  instance( LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            b1, b2, b3, b4, b5, lcuts )
  (
    ( lcuts != cuts ) ? (
      lcuts = cuts;
      this.resetBands();
    );
    
    band_mode == 0 ? (
      // 4p filters
      (cuts==0) ? (
        b1.inL = sl;
        b1.inR = sr;
      ) : (cuts==1) ? (
        LF1.eval_LR2(sl);
        b1.inL = LF1.lp;
        b2.inL = LF1.hp;
          
        RF1.eval_LR2(sr);
        b1.inR = RF1.lp;
        b2.inR = RF1.hp;
      ) : (cuts==2) ? (
        LF1.eval_LR2(sl);
        b1.inL   = LA_F2.eval_LRAP(LF1.lp);
          
        LF2.eval_LR2(LF1.hp);
        b2.inL   = LF2.lp;
        b3.inL   = LF2.hp;
          
        RF1.eval_LR2(sr);
        b1.inR   = RA_F2.eval_LRAP(RF1.lp);
          
        RF2.eval_LR2(RF1.hp);
        b2.inR   = RF2.lp;
        b3.inR   = RF2.hp;
      ) : (cuts == 3) ? (
        LF1.eval_LR2(sl);
        b1.inL   = LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp));
          
        LF2.eval_LR2(LF1.hp);
        b2.inL   = LA_F3_2.eval_LRAP(LF2.lp);
          
        LF3.eval_LR2(LF2.hp);
        b3.inL   = LF3.lp;
        b4.inL   = LF3.hp;
          
        RF1.eval_LR2(sr);
        b1.inR   = RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp));
        
        RF2.eval_LR2(RF1.hp);
        b2.inR   = RA_F3_2.eval_LRAP(RF2.lp);
        
        RF3.eval_LR2(RF2.hp);
        b3.inR   = RF3.lp;
        b4.inR   = RF3.hp;
      ) : (cuts == 4) ? (
        LF1.eval_LR2(sl);
        b1.inL   = LA_F4.eval_LRAP(LA_F3.eval_LRAP(LA_F2.eval_LRAP(LF1.lp)));
        
        LF2.eval_LR2(LF1.hp);
        b2.inL   = LA_F4_2.eval_LRAP(LA_F3_2.eval_LRAP(LF2.lp));
          
        LF3.eval_LR2(LF2.hp);
        b3.inL   = LA_F4_3.eval_LRAP(LF3.lp);
          
        LF4.eval_LR2(LF3.hp);
        b4.inL   = LF4.lp;
        b5.inL   = LF4.hp;
          
        RF1.eval_LR2(sr);
        b1.inR   = RA_F4.eval_LRAP(RA_F3.eval_LRAP(RA_F2.eval_LRAP(RF1.lp)));
          
        RF2.eval_LR2(RF1.hp);
        b2.inR   = RA_F4_2.eval_LRAP(RA_F3_2.eval_LRAP(RF2.lp));
          
        RF3.eval_LR2(RF2.hp);
        b3.inR   = RA_F4_3.eval_LRAP(RF3.lp);
          
        RF4.eval_LR2(RF3.hp);
        b4.inR   = RF4.lp;
        b5.inR   = RF4.hp;
      );
    ) : (
      // 2p filters
      (cuts==0) ? (
        b1.inL = sl;
        b1.inR = sr;
      ) : (cuts==1) ? (
        LF1.eval_LR1(sl);
        b1.inL = LF1.lp;
        b2.inL = - LF1.hp;
          
        RF1.eval_LR1(sr);
        b1.inR = RF1.lp;
        b2.inR = - RF1.hp;
      ) : (cuts==2) ? (
        LF1.eval_LR1(sl);
        b1.inL   = LA_F2.eval_AP1(LF1.lp);
          
        LF2.eval_LR1(LF1.hp);
        b2.inL   = -LF2.lp;
        b3.inL   = LF2.hp;
            
        RF1.eval_LR1(sr);
        b1.inR   = RA_F2.eval_AP1(RF1.lp);
            
        RF2.eval_LR1(RF1.hp);
        b2.inR   = -RF2.lp;
        b3.inR   = RF2.hp;
      ) : (cuts == 3) ? (
        LF1.eval_LR1(sl);
        b1.inL   = LA_F3.eval_AP1(LA_F2.eval_AP1(LF1.lp));
          
        LF2.eval_LR1(LF1.hp);
        b2.inL   = - LA_F3_2.eval_AP1(LF2.lp);
        
        LF3.eval_LR1(LF2.hp);
        b3.inL   = LF3.lp;
        b4.inL   = - LF3.hp;
          
        RF1.eval_LR1(sr);
        b1.inR   = RA_F3.eval_AP1(RA_F2.eval_AP1(RF1.lp));
        
        RF2.eval_LR1(RF1.hp);
        b2.inR   = - RA_F3_2.eval_AP1(RF2.lp);
        
        RF3.eval_LR1(RF2.hp);
        b3.inR   = RF3.lp;
        b4.inR   = - RF3.hp;
      ) : (cuts == 4) ? (
        LF1.eval_LR1(sl);
        b1.inL   = LA_F4.eval_AP1(LA_F3.eval_AP1(LA_F2.eval_AP1(LF1.lp)));
        
        LF2.eval_LR1(LF1.hp);
        b2.inL   = - LA_F4_2.eval_AP1(LA_F3_2.eval_AP1(LF2.lp));
          
        LF3.eval_LR1(LF2.hp);
        b3.inL   = LA_F4_3.eval_AP1(LF3.lp);
          
        LF4.eval_LR1(- LF3.hp);
        b4.inL   = LF4.lp;
        b5.inL   = - LF4.hp;
          
        RF1.eval_LR1(sr);
        b1.inR   = RA_F4.eval_AP1(RA_F3.eval_AP1(RA_F2.eval_AP1(RF1.lp)));
          
        RF2.eval_LR1(RF1.hp);
        b2.inR   = - RA_F4_2.eval_AP1(RA_F3_2.eval_AP1(RF2.lp));
          
        RF3.eval_LR1(RF2.hp);
        b3.inR   = RA_F4_3.eval_AP1(RF3.lp);
          
        RF4.eval_LR1(- RF3.hp);
        b4.inR   = RF4.lp;
        b5.inR   = - RF4.hp;
      );
    );
  );  
  
  // Convert to linear phase
  function linearPhase(fft_mem, fftCalcSize)
  local(fwd, r1, i1, mag1, flip, i, w)
  global()
  instance()
  (
    fwd = fft_mem;
    
    /* Making the filter linear phase involves both removing
       the phase; but then also shifting the impulse response
       to overlap with our chunk. If we just remove the phase, 
       we'd get an impulse response like this:
       \____/
       The goal is to shift it to the middle of the FIR section.
       Considering that the FIR section is at .25 of the spectrum,
       we have to shift it further than we normally would (a step of
       1.5 * pi rather than pi. */
    
    flip = 1;
    i = 0;
    loop(fftCalcSize,
      r1  = fwd[];
      i1  = fwd[1];
      
      mag1      = sqrt(sqr(r1) + sqr(i1));
            
      fwd[]     = mag1 * cos($pi*i);
      fwd[1]    = mag1 * sin($pi*i);

      i += 1.5;
      fwd += 2;
    );
    
    /*i = 0;
    loop(1,
      fft_mem[2*i] = 0;
      fft_mem[2*fftCalcSize-2*i] = 0;
      i = i + 1;
    );*/
    
  );
  
  function updateCoeffs()
  local(fptr1, fptr2, fptr3, fptr4, fptr5, middle, i, M)
  global(Cuts, Freq1, Freq2, Freq3, Freq4, FIR, FIR_quality,
         FIR1, FIR2, FIR3, FIR4, FIR5, bufferDist,
         firSize, fftCalcSize, band_mode, lband_mode, abs_placement)
  instance( F1,  F2,  F3,  F4
            LF1, LF2, LF3, LF4            /* Lowpass left */
            LA_F2,                        /* Allpass frequency 2 left */
            LA_F3, LA_F3_2,               /* Allpass frequency 3 left */
            LA_F4, LA_F4_2, LA_F4_3,      /* Allpass frequency 4 left */
            RF1, RF2, RF3, RF4            /* Lowpass right */
            RA_F2,                        /* Allpass frequency 2 right */
            RA_F3, RA_F3_2,               /* Allpass frequency 3 right */
            RA_F4, RA_F4_2, RA_F4_3,      /* Allpass frequency 4 right */
            lcuts, lFIR, lFIR_quality,
            lF1, lF2, lF3, lF4,
            labs_placement,
            updateRequired
            )
  (
      updateRequired = 0;
      updateRequired = (
        ( labs_placement != abs_placement ) ||
        ( lF1 != Freq1 ) ||
        ( lF2 != Freq2 ) ||
        ( lF3 != Freq3 ) ||
        ( lF4 != Freq4 ) ||
        ( cuts != lcuts ) ||
        ( FIR != lFIR ) ||
        ( FIR_quality != lFIR_quality ) ||
        ( band_mode != lband_mode ));

      updateRequired ? (
        M = 4;
        (FIR_quality > 0) ? M *= 2;
        (FIR_quality > 1) ? M *= 2;
        firSize = 512*M;
        fftCalcSize = 1024*M;
        lband_mode = band_mode;
        labs_placement = abs_placement;
      
        lF1 = Freq1;
        lF2 = Freq2;
        lF3 = Freq3;
        lF4 = Freq4;
        lFIR = FIR;
        lFIR_quality = FIR_quality;
        lcuts = cuts;
      
        abs_placement ? (
          F1 = clamp(Freq1, 0, 1);
          F2 = clamp(Freq2, F1, cuts > 2 ? F3 : 1);
          F3 = clamp(Freq3, F2, cuts > 3 ? F4 : 1);
          F4 = clamp(Freq4, F3, 1.0);
        ) : (
          F1 = Freq1;
          F2 = Freq1  + Freq2 * (1 - Freq1);
          F3 = F2     + Freq3 * (1 - F2);
          F4 = F3     + Freq4 * (1 - F3);
        );
          
        (cuts==1) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
        ) : (cuts==2) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          
          (band_mode == 0) ? (
            LA_F2.init_LR2(F2);
          ) : (
            LA_F2.init_AP1(F2);
          );
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 3) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          LF3.init_LR2(F3);
          RF3.k  = LF3.k;
          RF3.a1 = LF3.a1;
          RF3.a2 = LF3.a2;
          RF3.a3 = LF3.a3;
          
          // All-passes for maintaining the phase relation between the bands
          (band_mode == 0) ? (
            LA_F2.init_LR2(F2);
            LA_F3.init_LR2(F3);
          ) : (
            LA_F2.init_AP1(F2);
            LA_F3.init_AP1(F3);
          );
          
          RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
          RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
          RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
          RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
    
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 4) ? (
          LF1.init_LR2(Freq1);
          RF1.k  = LF1.k;
          RF1.a1 = LF1.a1;
          RF1.a2 = LF1.a2;
          RF1.a3 = LF1.a3;
          LF2.init_LR2(F2);
          RF2.k  = LF2.k;
          RF2.a1 = LF2.a1;
          RF2.a2 = LF2.a2;
          RF2.a3 = LF2.a3;
          LF3.init_LR2(F3);
          RF3.k  = LF3.k;
          RF3.a1 = LF3.a1;
          RF3.a2 = LF3.a2;
          RF3.a3 = LF3.a3;
          LF4.init_LR2(F4);
          RF4.k  = LF4.k;
          RF4.a1 = LF4.a1;
          RF4.a2 = LF4.a2;
          RF4.a3 = LF4.a3;
          
          // All-passes for maintaining the phase relation between the bands
          (band_mode == 0) ? (
            LA_F2.init_LR2(F2);
            LA_F3.init_LR2(F3);
            LA_F4.init_LR2(F4);
          ) : (
            LA_F2.init_AP1(F2);
            LA_F3.init_AP1(F3);
            LA_F4.init_AP1(F4);
          );
          
          RA_F4.k  = RA_F4_2.k  = RA_F4_3.k  = LA_F4_2.k  = LA_F4_3.k  = LA_F4.k;
          RA_F4.a1 = RA_F4_2.a1 = RA_F4_3.a1 = LA_F4_2.a1 = LA_F4_3.a1 = LA_F4.a1;
          RA_F4.a2 = RA_F4_2.a2 = RA_F4_3.a2 = LA_F4_2.a2 = LA_F4_3.a2 = LA_F4.a2;
          RA_F4.a3 = RA_F4_2.a3 = RA_F4_3.a3 = LA_F4_2.a3 = LA_F4_3.a3 = LA_F4.a3;
          
          RA_F3.k   = RA_F3_2.k  = LA_F3_2.k  = LA_F3.k;
          RA_F3.a1  = RA_F3_2.a1 = LA_F3_2.a1 = LA_F3.a1;
          RA_F3.a2  = RA_F3_2.a2 = LA_F3_2.a2 = LA_F3.a2;
          RA_F3.a3  = RA_F3_2.a3 = LA_F3_2.a3 = LA_F3.a3;
    
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        );
        
        /* Are we dealing with a FIR filter? */
        FIR ? (
          // CalcFIR
          memset(FIR1, 0, bufferDist);
          memset(FIR2, 0, bufferDist);
          memset(FIR3, 0, bufferDist);
          memset(FIR4, 0, bufferDist);
          memset(FIR5, 0, bufferDist);
          
          this.resetFilters();
        
          /* Fetch impulse response */
          fptr1 = FIR1;
          fptr2 = FIR2;
          fptr3 = FIR3;
          fptr4 = FIR4;
          fptr5 = FIR5;

          this.splitBands(1.0/fftCalcSize, 1.0/fftCalcSize);
               
          loop(firSize,
            fptr1[] = this.b1.inL; fptr1 += 2;
            fptr2[] = this.b2.inL; fptr2 += 2;
            fptr3[] = this.b3.inL; fptr3 += 2;
            fptr4[] = this.b4.inL; fptr4 += 2;
            fptr5[] = this.b5.inL; fptr5 += 2;
          
            this.splitBands(0, 0);
          );
          
          //FIR1[0]=1/fftCalcSize;
                    
          /* Transform impulse responses */
          fft(FIR1, fftCalcSize);
          fft(FIR2, fftCalcSize);
          fft(FIR3, fftCalcSize);
          fft(FIR4, fftCalcSize);
          fft(FIR5, fftCalcSize);
          
          fft_permute(FIR1, fftCalcSize);
          fft_permute(FIR2, fftCalcSize);
          fft_permute(FIR3, fftCalcSize);
          fft_permute(FIR4, fftCalcSize);
          fft_permute(FIR5, fftCalcSize);
          
          /* Remove phase information (converts to linear phase) */
          linearPhase(FIR1, fftCalcSize);
          linearPhase(FIR2, fftCalcSize);
          linearPhase(FIR3, fftCalcSize);
          linearPhase(FIR4, fftCalcSize);
          linearPhase(FIR5, fftCalcSize);
          
          fft_ipermute(FIR1, fftCalcSize);
          fft_ipermute(FIR2, fftCalcSize);
          fft_ipermute(FIR3, fftCalcSize);
          fft_ipermute(FIR4, fftCalcSize);
          fft_ipermute(FIR5, fftCalcSize);
        );
      );
    
    updateRequired
  );
  
  function doFIR(l, r, block1, block2, fftCalcSize, filterSize, filterLoc, cPos)
  instance(curBlock, lastBlock, initialized, chunkSize, chunksizeT2)
  local(tmp, cPosT2)
  global(bufferdist)
  (
    !initialized ? (
      curBlock  = block1;
      lastBlock = block2;
      
      memset(curBlock, 0, bufferdist);
      memset(lastBlock, 0, bufferdist);
      initialized = 1;
      
      chunkSize   = (fftCalcSize - filterSize - 1);
      chunkSizeT2 = chunkSize * 2;
    );
  
    cPos >= chunkSize ? 
    (
      tmp       = lastBlock;
      lastBlock = curBlock;
      curBlock  = tmp;
     
      /* Empty out the data beyond chunkSize of the block that has 
         just been filled. This used to be the carried over overlap-add
         tail of the previous one */
      memset( curBlock + chunkSizeT2, 0, (fftCalcSize-chunkSize)*2 );
    
      /* Calculate FFT of current chunk */
      fft(curBlock, fftCalcSize);
      //fft_permute(curBlock, fftCalcSize);
      
      /* Convolve with the FIR filter (already FFT'd) */
      convolve_c(curBlock, filterLoc, fftCalcSize);
      //fft_ipermute(curBlock, fftCalcSize);
      ifft(curBlock, fftCalcSize);
      
      cPos = 0;
    );
      
    /* Save sample */
    cPosT2 = cPos * 2;
    lastBlock[cPosT2]   = l;
    lastBlock[cPosT2+1] = r;
    
    this.inL = curBlock[cPosT2];
    this.inR = curBlock[cPosT2+1];
    
    /* Overlap add the previous tail */
    ( cPos < (fftCalcSize-chunkSize) ) ? 
    (
      this.inL += lastBlock[chunkSizeT2+cPosT2];
      this.inR += lastBlock[chunkSizeT2+cPosT2+1];
      1
    );
 
    cPos + 1
  );
  
  function processSample()
  (  
    FIR ? (
      filterBank.resetBands();   
      cPosNew = filterBank.b1.doFIR(inL, inR, F1Block1, F1Block2, fftCalcSize, firSize, FIR1, cPos);
      ( cuts > 0 ) ? ( filterBank.b2.doFIR(inL, inR, F2Block1, F2Block2, fftCalcSize, firSize, FIR2, cPos); );
      ( cuts > 1 ) ? ( filterBank.b3.doFIR(inL, inR, F3Block1, F3Block2, fftCalcSize, firSize, FIR3, cPos); );
      ( cuts > 2 ) ? ( filterBank.b4.doFIR(inL, inR, F4Block1, F4Block2, fftCalcSize, firSize, FIR4, cPos); );
      ( cuts > 3 ) ? ( filterBank.b5.doFIR(inL, inR, F5Block1, F5Block2, fftCalcSize, firSize, FIR5, cPos); );
      cPos = cPosNew;
    ) : (
      filterBank.splitBands(inL, inR);
    );
    
    filterBank.processBands();
  );
    
  FIR ? (
    specBuffer.updateBuffer(.5*(spl0+spl1));
    specBuffer.setOffset(newPDC+2);
    cSpec = specBuffer.readBuffer();
    spectrumIn.feedSample(cSpec);
  ) : (
    spectrumIn.feedSample(.5*(spl0+spl1));
  );

  // Split signal into bands
  filterBank.updateCoeffs();
  
  inL = spl0;
  inR = spl1;
  
  processSample();
  
  spl0 = filterBank.b1.l;
  spl1 = filterBank.b1.r;
  out = spl0 + spl1;
  ( cuts > 0 ) ? (
    spl2 = filterBank.b2.l;
    spl3 = filterBank.b2.r;
    out += spl2 + spl3;
    ( cuts > 1 ) ? (
      spl4 = filterBank.b3.l;
      spl5 = filterBank.b3.r;
      out += spl4 + spl5;
      ( cuts > 2 ) ? (
        spl6 = filterBank.b4.l;
        spl7 = filterBank.b4.r;
        out += spl6 + spl7;
        ( cuts > 3 ) ? (
          spl8 = filterBank.b5.l;
          spl9 = filterBank.b5.r;
          out += spl8 + spl9;
        );
      );
    );
  );
  
  spectrumOut.feedSample(.5*out);
  
  /* Uncomment for testing flatness
  spl0 += spl2 + spl4 + spl6 + spl8;
  spl1 += spl3 + spl5 + spl7 + spl9;*/
  
  curSample += 1;
  
@gfx 1080 400
  function createGUI(stripStart)
  (
    scaling   = gfx_ext_retina-1;
    spectrumX = 0;
    spectrumY = 0;
    spectrumW = gfx_w - 200*0;
    spectrumH = gfx_h - 25 * ( 1 + modVisible ) * (1+scaling);
    
    fontface = "Arial";
    gfx_setfont(GRID_FONT,      fontface, 14*(1+scaling));
    gfx_setfont(HINT_FONT,      fontface, 14*(1+scaling));
    
    spectrumIn.setWindowLocation(spectrumX,  spectrumY, spectrumW, spectrumH);
    spectrumOut.setWindowLocation(spectrumX, spectrumY, spectrumW, spectrumH);
  );

  /* Gradients are buffered to save rendering perf */
  function drawGradients(w, h, spectrumH, gradient_bg)
  instance(lw, lh, lSpectrumH)
  global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
         gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
  local( oldDest, oldMode)
  (
    oldMode = gfx_mode;
    gfx_mode = 0;
    gfx_set(1,1,1,1);
    ( ( lw != w ) || ( lh != h ) || (spectrumH != lSpectrumH) ) ? (
      /* Only draw gradients when size changes */
      gfx_x = gfx_y = 0;
      lw = w;
      lh = h;
      lSpectrumH = spectrumH;
      oldDest = gfx_dest;
      gfx_setimgdim(gradient_bg, w, h);
      gfx_dest = gradient_bg;
      gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);
      gfx_rectto(w,spectrumH);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, gfx_a, .0001, .001, .0001, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, .3, .0001, .001, .0006, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, 0, 0, 0, 0, 0, -.001, -.0006, .0001, -.0001, -.0001, .01, -.00008);
      gfx_gradrect(0, spectrumH, w, h-spectrumH, 0, 0, .0, 1.0, .0001, .0001, .0002, 0, 0, 0, .0005, 0);
      gfx_dest = oldDest;
    );
    
    gfx_x = gfx_y = 0;
    gfx_blit(gradient_bg, 1, 0);
    gfx_mode = oldMode;
  );
  
  bg_color_r = 47/255;
  bg_color_g = 65/255;
  bg_color_b = 75/255;
  bg_color_a = 1;
  fft_out_r = .8;
  fft_out_g = .8;
  fft_out_b = .8;
  fft_out_a = 1.0;
  fft_in_r = .13;
  fft_in_g = .13;
  fft_in_b = .23;
  fft_in_a = .6;
  grid_color_r = .73;
  grid_color_g = .73;
  grid_color_b = .76;
  grid_color_a = .2;
  grid_alpha = .1 * (1+.5*abs(sin(2*time_precise())));
  backface_color_r = .2;
  backface_color_g = .2;
  backface_color_b = .3;
  backface_color_a = .1;
  font_color_r = .8;
  font_color_g = .8;
  font_color_b = .8;
  font_color_a = .8;
  knob_font_color_r = .5;
  knob_font_color_g = .7;
  knob_font_color_b = 1;
  knob_font_color_a = 1;
  highlight_color_r = .5;
  highlight_color_g = .7+.2*abs(sin(2*time_precise()));
  highlight_color_b = .9;
  highlight_color_a = .6+.4*abs(sin(2*time_precise()));
  disabled_color_r = .4;
  disabled_color_g = .4;
  disabled_color_b = .4;
  disabled_color_a = .8;
  
  stripStart = 35; 
  createGUI(stripStart);
  gradient.drawGradients(gfx_w, gfx_h, spectrumH, 2);
  
  globalTime = time_precise();
  delta_time = globalTime - lastGlobalTime;
  lastGlobalTime = globalTime;
  
  gfx_r = 1;
  spectrumIn.drawGrid();
  spectrumIn.floorLevel = 25 + dnoisefloor_freq;
  spectrumOut.floorLevel = 25 + dnoisefloor_freq;
  spectrumIn.drawFFT(1, fft_in_r, fft_in_g, fft_in_b, fft_in_a);
  spectrumOut.drawFFT(0, fft_out_r, fft_out_g, fft_out_b, fft_out_a);
  spectrumIn.updateBands();
  spectrumIn.drawBands();    
  spectrumIn.fftWindow_processMouse(mouse_x, mouse_y, mouse_cap);  

  tFIR.label = "FIR";  
  tFIR.drawToggle(20, 20, 10, 10, FIR, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "Linear phase FIR mode.\n\nLinear phase filters preserve the phase relations between this\nand other tracks but introduce a higher CPU cost and latency.\nEnable only when needed for its linear phase properties.\n\nNote: Modulation of the frequency when in FIR mode can cause crackles.");
  FIR = tFIR.processMouseToggle(mouse_x, mouse_y, mouse_cap);

  FIR ? (
    FIR_NQ.drawToggle(60, 20, 10, 10, FIR_quality == 0, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "Normal quality mode.\n\nHigher quality modes can be useful when using splits\nat very low frequencies. Note that high quality modes\ninduce more latency and require restarting transport\n(press stop and play).");
    FIR_NQ.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? FIR_quality = 0;  
    FIR_HQ.drawToggle(75, 20, 10, 10, FIR_quality == 1, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "High quality mode.\n\nHigher quality modes can be useful when using splits\nat very low frequencies. Note that high quality modes\ninduce more latency and require restarting transport\n(press stop and play).");
    FIR_HQ.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? FIR_quality = 1;
    FIR_UQ.label =
      FIR_quality == 0 ? "Normal"
      : FIR_quality == 1 ? "High"
      : FIR_quality == 2 ? "Ultra";
    FIR_UQ.drawToggle(90, 20, 10, 10, FIR_quality == 2, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "Ultra quality mode.\n\nHigher quality modes can be useful when using splits\nat very low frequencies. Note that high quality modes\ninduce more latency and require restarting transport\n(press stop and play).");
    FIR_UQ.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? FIR_quality = 2;
  );

  fourpole.drawToggle(20, 40, 10, 10, band_mode == 0, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "Use 4 pole 24 dB/oct filters");
  fourpole.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? band_mode = 0;
  fourpole.label = "4p";
  twopole.drawToggle(60, 40, 10, 10, band_mode == 1, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "Use 2 pole 12 dB/oct filters");
  twopole.processMouseToggle(mouse_x, mouse_y, mouse_cap) ? band_mode = 1;
  twopole.label = "2p";
  
  absChoice.label = "Abs position";  
  absChoice.drawToggle(20, 60, 10, 10, abs_placement, 1, 0.2, 0.2, 0.8, 1.0, 0.2, 0.2, 0.8, "Absolute positioning.\n\nIn this mode the slider mapping is absolute.");
  abs_placement = absChoice.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  gfx_x = gfx_y = 30;
  gfx_setfont(1,"ARIAL",30);
  gfx_set(1,0,0,1);
  gfx_x = 30;
  gfx_y = 60;
  
  gfx_x = gfx_w-130*(1+scaling);
  gfx_y = bottomRow + 30*(1+scaling);
  gfx_mode = 4;
  
  hinter.drawHint_draw();
