desc:Saike 4-pole phase matcher for IIR BandSplitter
tags: phasematcher for bandsplitter
version: 0.03
author: Joep Vanlier
changelog: Workaround for SSE branch tan(pi/2) issue.
provides:
license: MIT

in_pin:left input
in_pin:right input
out_pin:left output 1
out_pin:right output 1
out_pin:left output 2
out_pin:right output 2
out_pin:left output 3
out_pin:right output 3
out_pin:left output 4
out_pin:right output 4
out_pin:left output 5
out_pin:right output 5

slider1:Cuts=4<0,4,1>-Cuts
slider2:Freq1=0.2<0,1,.0001>-Frequency 1
slider3:Freq2=0.5<0,1,.0001>-Frequency 2
slider4:Freq3=0.5<0,1,.0001>-Frequency 3
slider5:Freq4=0.5<0,1,.0001>-Frequency 4

slider6:Drive1=0<-40,60,.1>-Drive 1 (dB)
slider7:Drive2=0<-40,60,.1>-Drive 2 (dB)
slider8:Drive3=0<-40,60,.1>-Drive 3 (dB)
slider9:Drive4=0<-40,60,.1>-Drive 4 (dB)
slider10:Drive5=0<-40,60,.1>-Drive 5 (dB)

slider62:masterGainSlider=0<-26,26,.1>-Master Gain

@init
/*function fft_real(x,x)
(
  1
);*/

/*-----------*/
/* HINTS     */  
/*-----------*/ 
function updateHintTime(hint)
  global(gfx_x, gfx_y)
  local()
  instance(hintTime, currentHint, delta_time)
  (
    (hint != 0) ? (
      currentHint = hint;
      hintTime = hintTime + delta_time;
      hintTime = min(1, hintTime);
    ) : (
      0
    );
  );   
  
function drawHint_draw()
  global(scaling, gfx_x, gfx_y, gfx_w, gfx_h, mouse_x, mouse_y, fontface, HINT_FONT)
  local(w, h, globalTime)
  instance(hintTime, currentHint, lastGlobalTime, delta_time, lx, ly)
  (
    globalTime = time_precise();
    delta_time = globalTime - lastGlobalTime;
    lastGlobalTime = globalTime;
  
    ( ( abs( lx - mouse_x ) + abs( ly - mouse_y ) ) > 0 ) ? (
      hintTime = 0;
    );
  
    ( hintTime > .99 ) ? (
      gfx_setfont(HINT_FONT);
      gfx_measurestr(currentHint,w,h);
      
      gfx_x = mouse_x+15;
      gfx_y = mouse_y+15;
      ( gfx_x > 0.5*gfx_w ) ? gfx_x = mouse_x - w - 8;
      ( gfx_y > 0.5*gfx_h ) ? gfx_y = mouse_y - h - 8;

      gfx_set( 0.05, 0.05, 0.1, .8 );
      gfx_rect(gfx_x-2, gfx_y-2, w+4, h+4);
      gfx_set( .7, .7, .7, 1 );      
      gfx_printf(currentHint);
    );
    
    lx = mouse_x;
    ly = mouse_y;
  );    

/*-----------*/
/* CIRCLE    */  
/*-----------*/
function fancyCircle(x1, y1, rin, mute, solo, bypass)
  local(dx)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(hl, x, y, r, over, gfx_mode)
  (
    x = x1;
    y = y1;
    rin == 0 ? r = 10 : r = rin;
    
    over ? (
      hl = abs(sin(2*globalTime));
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .1*hl);
      gfx_circle(x, y, 1.2*r, 1, 1);
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .1*hl);
      gfx_circle(x, y, 1.5*r, 1, 1);
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .05*hl);
      gfx_circle(x, y, 1.9*r, 1, 1);
      gfx_set(lineHighlightR, lineHighlightG, lineHighlightB, .03*hl);
      gfx_circle(x, y, 4*r, 1, 1);
    ); 
    
    gfx_set(.2*lineR, .2*lineG, .2*lineB, 1);
    gfx_circle(x, y, r, 1, 1);
    
    gfx_set(lineR, lineG, lineB, lineA);    
    gfx_circle(x, y, .92*r, 1, 1);
    
    gfx_set(.8*lineR, .8*lineG, .8*lineB, lineA);
    gfx_circle(x, y, .8*r, 1, 1);
    
    gfx_set(.6*lineR, .6*lineG, .6*lineB, lineA);
    gfx_circle(x, y, .75*r, 1, 1);
    
    gfx_set(.4*lineR, .4*lineG, .4*lineB, lineA);
    gfx_circle(x, y, .7*r, 1, 1);
    
    ( solo == 1 ) ? (
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, .8*r, 1, 1);
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, .9*r, 1, 1);
      gfx_set(.2, 1, .2, .5);
      gfx_circle(x, y, r, 1, 1);
      gfx_set(.2, 1, .2, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);    
      
      gfx_set(.7, 1, .7, .3);
      gfx_circle(x, y, .7*r, 1, 1);
      
      gfx_set(.2, 1, .5, .08);
      gfx_circle(x, y, 1.1*r, 1, 0);
      gfx_set(.2, 1, .5, .08);
      gfx_circle(x, y, 1.2*r, 1, 0);
      gfx_set(.2, 1, .5, .08);
      gfx_circle(x, y, 1.4*r, 1, 0);
     ) : ( mute == 1 ) ? (
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, .8*r, 1, 1);
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, .9*r, 1, 1);
      gfx_set(1, .2, .2, .5);
      gfx_circle(x, y, r, 1, 1);
      gfx_set(1, .2, .2, .2);
      gfx_circle(x, y, 1.2*r, 1, 1);
      
      gfx_set(1, .55, .55, 1);
      gfx_circle(x, y, 1*r, 0, 1);
      
      gfx_set(1, .7, .7, .1);
      gfx_circle(x, y, .7*r, 1, 1);
      
      gfx_set(1, .5, .5, .1);
      gfx_circle(x, y, 1.1*r, 1, 0);
      gfx_set(1, .5, .5, .1);
      gfx_circle(x, y, 1.2*r, 1, 0);
      gfx_set(1, .5, .5, .1);
      gfx_circle(x, y, 1.4*r, 1, 0);
    );    
    
    ( bypass == 1 ) ? (
      gfx_set(1-mute, .2, .2, 1);
      dx = .5*r;
      gfx_line(x-dx, y-dx-1, x+dx, y+dx-1);
      gfx_line(x-dx, y-dx+1, x+dx, y+dx+1);
      gfx_line(x+dx, y-dx-1, x-dx, y+dx-1);
      gfx_line(x+dx, y-dx+1, x-dx, y+dx+1);    
      gfx_line(x+dx, y-dx,   x-dx, y+dx);
      gfx_line(x-dx, y-dx,   x+dx, y+dx);
    );
    
    over ? ( 
      gfx_set(1,1,1,.4*hl);
      gfx_circle(x, y, .6*r, 1, 1);
      gfx_circle(x, y, 1.4*r, 0, 1);
      gfx_circle(x, y, 1.5*r, 0, 1);
    );
    
    over = 0;
  );

  GRID_FONT     = 15;
  HINT_FONT     = 14;
  TOGGLE_FONT   = 15;
  gfx_ext_retina = 1;

  function f_trafo(freq)
  local()
  global()
  instance()
  (
    exp( (1-freq) * log(20/22050) )
  );  

  function initBands()
  local()
  global()
  instance(lg1, lg2, lg3, lg4, lg5, b1, b2, b3, b4, b5)
  (
    lg1 = lg2 = lg3 = lg4 = lg5 = -1000000;
    b1.ldrive = b2.ldrive = b3.ldrive = b4.ldrive = b5.ldrive = -1000000;
    b1.initialized = b2.initialized = b3.initialized = b4.initialized = b5.initialized = 0;
  );

maxCuts = 4;
driveMax = 60;
driveMin = -40;
driveRange = driveMax - driveMin;

filterBank.initBands();
M = 4;
fftCalcSize = 1024*M;

// Precompute some things
gainRange = ( gainMax - gainMin );
iGainRange = 1.0 / gainRange;
iDriveRange = 1.0 / driveRange;

///////////////////
/* SLIDER LAYOUT */
///////////////////
/* Keep these updated with the slider locations */
frequencyLocation = 2;
driveLocation     = 6;

/* Shift slider data right (for different bands) */
function shiftRight(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx-1);
      midx = midx - 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeft(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      slider(midx) = slider(midx+1);
      midx = midx + 1;
    );
  );
  
/* Shift slider data right (for different bands) */
function shiftRightMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc + numElements;
    loop(numElements-fromIdx,
      midx[] = midx[-1];
      midx -= 1;
    );
  );

/* Shift slider data left  (for different bands) */
function shiftLeftMem(loc, fromIdx, numElements)
  local(midx)
  global()
  (
    midx = loc+fromIdx;
    loop(numElements-fromIdx,
      midx[] = midx[1];
      midx += 1;
    );
  );  

/* Make room for a new band in the slider data */
function addBand(idx)
  local(midx)
  instance()
  (
    shiftRight( driveLocation,     idx, maxCuts );
    shiftRight( frequencyLocation, idx, maxCuts-1 );
    
    cuts = cuts + 1;
  );
  
/* Remove a band and move other slider data accordingly */  
function remBand(idx)
  local(midx)
  instance()
  (
    shiftLeft( driveLocation,     idx, maxCuts );
    shiftLeft( frequencyLocation, idx, maxCuts-1 );
    
    cuts = cuts - 1;
  );  

/* Feed sample to FFT */
function feedSample(sample)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local()
  (
    recPtr[] = sample;
    recPtr = (recPtr+1) >= rEnd ? rStart : recPtr + 1;
  );

/* Initialize FFT windowing function */
function initWindow(windowtype)
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc)
  local(i, pwr, dwindowpos, windowpos)
  (
    windowpos = 0;
    dwindowpos = $pi*2/fftSize;
    i = 0; pwr = 0;
    loop(fftSize*.5+1,
       pwr += (window[i] = (
         windowtype==1 ? ( 0.53836 - cos(windowpos)*0.46164 ) :
         windowtype==2 ? ( 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) ) :
         windowtype==3 ? ( 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) ) :
         windowtype==4 ? ( 1.0 ) :
         ( .21557895 - 0.41663158 * cos(windowpos) + 0.277263158 * cos(2*windowpos) - 0.083578947 * cos(3*windowpos) + 0.006947368 * cos(4*windowpos) )
         ) );
       i+=1;
       windowpos+=dwindowpos;
    );
    pwr=.5/(pwr*2-window[i-1]);
    loop(fftsize*.5+1,window[i-=1]*=pwr);
 );
  
function setToFFTLoc()
 global(fftSize)
 instance(recPtr, rStart)
 local()
 ( 
    recPtr = rStart + fftSize;
 ); 

/* Calculate current spectrum */
function calcFFT()
  global(fftSize)
  instance(recPtr, window, rStart, rEnd, fftLoc, slope, yshift)
  local(buf1, buf2, buf3, yOut, i, prec, ty)
  (
    buf1=recPtr-fftSize;
    buf1<rStart ? buf1+=(rEnd-rStart);
    buf2=window;
    buf3=fftLoc;
    loop(fftSize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
    
      buf2+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    buf2-=1;
    loop(fftSize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= rEnd ? buf1 -= (rEnd-rStart);
    );
    
    fft_real(fftLoc,fftSize);
    fft_permute(fftLoc,fftSize/2);
    
    buf3    = fftLoc;
    yOut    = fftLoc;  
    i       = 0;
    slope   = .5*log(2)*slope;
    yshift  = slope*log(1.0+.5*fftSize);
    prec    = (10^(-500/20*2));
    loop(fftSize*0.5,   
      ty      = sqr(buf3[0])+sqr(buf3[1]);
      ty      = log(max(ty,prec));
      
      ty      = ty + slope*log(1.0+i) - yshift;
      yOut[]  = ty;
      yOut    += 1;
      buf3    += 2;    
      
      i += 1;
    );
  );  

/* Set location of a window */
function setWindowLocation(_x, _y, _w, _h)
  global()
  instance(x, y, w, h, cap)
  local()
  ( 
    x = _x;
    y = _y;
    w = _w;
    h = _h;
  );

// Draws the basic box for the FFT
function drawBackface()
  instance(x, y, w, h)
  global(backface_color_r, backface_color_g, backface_color_b, backface_color_a,
         grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local()
  (
    gfx_set( backface_color_r, backface_color_g, backface_color_b, backface_color_a );
    gfx_rect(x, y, w, h);
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
  );

// Draws the FFT Grid, frequency axis and dB axis
function drawGrid()
  global( fftSize, srate, gfx_x, gfx_y, grid_alpha, scaling, GRID_FONT,
             )
  instance(x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset,
           grid_color_r, grid_color_g, grid_color_b, grid_color_a )
  local(xx, i, wsc, N, xl)
  (    
    this.drawBackface();
    
    i = 0;
    wsc = w/log(1+fftSize*0.5-hzoffset);
    xl = x;
    gfx_y = y+h+2;
    
    gfx_setfont(GRID_FONT);
    loop(16,
      xx = x + log(i*fftSize/srate-hzoffset)*wsc;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(xx, y, xx, y+h);
      
      ( (xx - xl) > 30 ) ? (
        gfx_set( 1, 1, 1, 1 );
        gfx_x = xx+2;
        gfx_line(xx, y+h, xx, y+h+7);
        (i>999) ? (
          gfx_printf("%dk", .001*i);
        ) : (
          gfx_printf("%d", i);
        );
        xl = xx;
      );
      
      gfx_set( .2, .2, .2, grid_alpha );
      gfx_line(xx, y, xx, y+h);
      
      ( i < 100 ) ? (i += 20) :
      ( i < 1000 ) ? (i += 200) :
      ( i < 10000 ) ? (i += 2000) :
      ( i < 100000 ) ? (i += 20000);
    );
    
    gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
    N = 8;
    xx = y;
    i = 0;
    gfx_measurestr("8", wsc, xl);
    loop(N,
      gfx_set( 1, 1, 1, 1 );
      gfx_x = x+w-20;
      gfx_y = xx-.5*xl;
      i > 0 ? gfx_printf("-%d", 4.41*i*floorLevel/N);
      
      gfx_set( .2, .2, .2, grid_alpha );
      gfx_line(x, xx+1, x+w, xx+1);
      
      xx += h/N;
      gfx_set( grid_color_r, grid_color_g, grid_color_b, grid_color_a );
      gfx_line(x, xx, x+w, xx);
      i += 1;
    );
  );
  
function drawLine(x1, y1, x2, y2)
  local(dx, dy, x, smooth)
  global(gfx_x, gfx_y)
  instance()
  (
    smooth = 1;
    x1 = floor(x1);
    x2 = floor(x2);
    gfx_x=x1;
    gfx_y=y1;
    x2 = floor(x2);
    y2 = floor(y2);
    
    smooth ? (
      (x2 - x1) > 4 ? (
        dx = 1.0/(x2-x1);
        dy = (y2 - y1)*6*dx;
        x = 0;
        loop(x2-x1,
          x2 = x1 + 1;
          y2 = y1 + dy * ( x - x*x );

          gfx_line(x1-1, y1-1, x2-1, y2-1, 1);          
          gfx_line(x1, y1-1, x2, y2-1, 1);
          gfx_lineto(x2,y2,1);
          x1 = x2;
          y1 = y2;
          x = x + dx;
        );
      ) : (
        gfx_line(x1, y1-1, x2, y2-1, 1);
        gfx_lineto(x2,y2,1);
      );
    ) : (
      gfx_line(x1, y1-1, x2, y2-1, 1);
      gfx_lineto(x2,y2,1); 
    );
  );

bandClickRange = 10;
overRange = 10;

function isOver(mx, my)
  instance(x, y, w, h)
  global(overRange)
  local()
  (
    ( ( mx >= (x-overRange) ) && ( mx <= (x+w+overRange) ) && ( my >= (y-overRange) ) && ( my <= (y+h+overRange) ) ) ? 1 : 0;
  );

function clamp(value, mini, maxi)
  local()
  global()
  (
    max(min(value,maxi),mini)
  );

function overRect(x, y, w, h, mx, my)
  local()
  global()
  (
    ( (mx > x) && (mx < (x+w) ) && (my > y) && (my < (y+h) ) )
  );

function pixelToWindowRatio(x_loc)
  instance(x, y, w, h, hzoffset)
  global(fftSize)
  local(lmin, wsc, hfft)
  (
    hfft  = 0.5*fftSize;
    lmin  = log(20/22050);
    wsc   = w/log(1+fftSize*0.5-hzoffset);
    
    1-log( (exp((x_loc)/wsc) + hzoffset)/hfft )/lmin
  );

function fftWindow_processMouse(mouse_x, mouse_y, mouse_cap)
  instance(x, y, w, h, lx, ly, lcap, cap, thisUI, htime, hint,
           x_over, dragging, lastLeftClick
           x1, x2, x3, x4, x5,
           v1, v2, v3, v4, v5,
           h1, h2, h3, h4, h5, 
           c1, c2, c3, c4, c5,
           F1hz, F2hz, F3hz, F4hz )
  global(dnoisefloor_freq, dsteps_fft, mouse_wheel, lastUI, fftSize,
         bandClickRange, cuts,
         Freq1, Freq2, Freq3, Freq4,
         bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5,
         Drive1, Drive2, Drive3, Drive4, Drive5,
         mute1, mute2, mute3, mute4, mute5,
         solo1, solo2, solo3, solo4, solo5,
         driveMin, driveMax, maxCuts,
         hinter.updateHintTime,
         selectedBand, gfx_x, gfx_y, srate, HI )
  local(dx, dy, over, dys,
        F1, F2, F3, F4,
        leftClick, rightClick, doubleClick,
        cTime, mpos, shift, ctrl, lb)
  (
    over = mouse_x > x && mouse_y > y && mouse_x < (x+w) && mouse_y < (y+h);
    leftClick   = ( mouse_cap & 1 == 1 && lcap & 1 == 0 );
    rightClick  = ( mouse_cap & 2 == 2 && lcap & 2 == 0 );
    doubleClick = 0;
    shift       = ( mouse_cap & 8 );
    ctrl        = ( mouse_cap & 4 );
    
    leftClick ? (
       time_precise(cTime);
       ( ( cTime - lastLeftClick ) < .25 ) ? (
          leftClick = 0;
          doubleClick = 1;
       );
       lastLeftClick = cTime;
    );
    
    x_over = -1;
    
    F1 = Freq1;
    F2 = Freq1  + Freq2 * (1 - Freq1);
    F3 = F2     + Freq3 * (1 - F2);
    F4 = F3     + Freq4 * (1 - F3);

    F1hz = .5*f_trafo(F1)*srate;
    F2hz = .5*f_trafo(F2)*srate;
    F3hz = .5*f_trafo(F3)*srate;
    F4hz = .5*f_trafo(F4)*srate;
        
    ( cap == 3 && mouse_cap & 1 == 1 ) ? (
      dy = mouse_y - ly;
      
      dys = 100*dy/h;
      dragging == 1 ? ( Drive1 -= dys; Drive1 = clamp(Drive1, driveMin, driveMax); );
      dragging == 2 ? ( Drive2 -= dys; Drive2 = clamp(Drive2, driveMin, driveMax); );
      dragging == 3 ? ( Drive3 -= dys; Drive3 = clamp(Drive3, driveMin, driveMax); );
      dragging == 4 ? ( Drive4 -= dys; Drive4 = clamp(Drive4, driveMin, driveMax); );
      dragging == 5 ? ( Drive5 -= dys; Drive5 = clamp(Drive5, driveMin, driveMax); );
      
    ) : ( cap == 2 && mouse_cap & 1 == 1 ) ? (
      // Dragging a band frequency
      dx = mouse_x - lx;
      
      shift ? dx *= .5;
      ctrl ? dx *= .01;
      
      lb = .02;
      dragging == 1 ? ( 
        F1 = this.pixelToWindowRatio(x1 - x + dx);
        slider_automate( Freq1 = clamp( F1, lb, 1 ) );
        slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-F1), 0, 1 ) );
      );
      dragging == 2 ? ( 
        F2 = this.pixelToWindowRatio(x2 - x + dx);
        slider_automate( Freq2 = clamp( (F2 - Freq1) / (1-Freq1), 0, 1 ) );
        F2 = Freq1  + Freq2 * (1 - Freq1);
        slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1) );
      );
      dragging == 3 ? ( 
        F3 = this.pixelToWindowRatio(x3 - x + dx);
        slider_automate( Freq3 = clamp( (F3 - F2) / (1-F2), 0, 1 ) );
        F3 = F2     + Freq3 * (1 - F2);
        slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
      );
      dragging == 4 ? ( 
        F4 = this.pixelToWindowRatio(x4 - x + dx);
        slider_automate( Freq4 = clamp( (F4 - F3) / (1-F3), 0, 1 ) );
      );

    ) : ( cap == 1 && mouse_cap & 1 == 1 ) ? (
      dnoisefloor_freq -= .5*(mouse_y-ly);
      dnoisefloor_freq > 35 ? dnoisefloor_freq = 35;
      dnoisefloor_freq < -15 ? dnoisefloor_freq = -15;
    ) : ( 
      // Not already capped
      cap = 0;
      
      /* Toggle mute/solo */
      ( c1.isOver(mouse_x, mouse_y) == 1 ) ? (
        c1.over = 1;
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        leftClick  ? ( ctrl ? ( bypassBand1 = 1 - bypassBand1) : (
                       mute1 = 1-mute1; solo1 ? (mute1 = 1; solo1 = 0; selectedBand = 0; ); ); );
        rightClick ? ( solo1 = 1-solo1; selectedBand = 0; 
                       ((solo1 == 1) && (shift==0)) ? (solo2=solo3=solo4=solo5=0;); );
      ) : ( c2.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c2.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand2 = 1 - bypassBand2) : (
                       mute2 = 1-mute2; solo2 ? (mute2 = 1; solo2 = 0; selectedBand = 1;); ); );
        rightClick ? ( solo2 = 1-solo2; selectedBand = 1;
                       ((solo2 == 1) && (shift==0)) ? (solo1=solo3=solo4=solo5=0;); );
      ) : ( c3.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c3.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand3 = 1 - bypassBand3) : (
                       mute3 = 1-mute3; solo3 ? (mute3 = 1; solo3 = 0; selectedBand = 2; ); ); );
        rightClick ? ( solo3 = 1-solo3; selectedBand = 2;
                       ((solo3 == 1) && (shift==0)) ? (solo1=solo2=solo4=solo5=0;); );
      ) : ( c4.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c4.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand4 = 1 - bypassBand4) : (
                        mute4 = 1-mute4; solo4 ? (mute4 = 1; solo4 = 0; selectedBand = 3; ); ); );
        rightClick ? ( solo4 = 1-solo4; selectedBand = 3;
                       ((solo4 == 1) && (shift==0)) ? (solo1=solo2=solo3=solo5=0;); );
      ) : ( c5.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB - Toggle mute\nRMB - Toggle solo\nShift + RMB - Select multiple solo bands\nCTRL + LMB - Toggle bypass waveshaper");
        c5.over = 1;
        leftClick  ? ( ctrl ? ( bypassBand5 = 1 - bypassBand5) : (
                       mute5 = 1-mute5; solo5 ? (mute5 = 1; solo5 = 0; selectedBand = 4; ); ); );
        rightClick ? ( solo5 = 1-solo5; selectedBand = 4;
                       ((solo5 == 1) && (shift==0)) ? (solo1=solo2=solo3=solo4=0;); );
        
      /* Drag frequency */
      ) : ( v1.isOver(mouse_x, mouse_y) == 1 ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v1.over = 1;
        leftClick ? ( cap = 2; dragging = 1; );
        rightClick ? ( 
          Freq2 = ( Freq2 * ( 1 - Freq1 ) + ( Freq1 - 0 ) ) / ( 1 - 0 );
          remBand(0);
        );
      ) : ( v2.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v2.over = 1;
        leftClick ? ( cap = 2; dragging = 2; );
        rightClick ? ( 
          Freq3 = ( Freq3 * ( 1 - Freq2 ) + ( Freq2 - 0 ) ) / ( 1 - 0 );
          remBand(1);
        );
      ) : ( v3.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");    
        v3.over = 1;
        leftClick ? ( cap = 2; dragging = 3; );
        rightClick ? ( 
          Freq4 = ( Freq4 * ( 1 - Freq3 ) + ( Freq3 - 0 ) ) / ( 1 - 0 );
          remBand(2);
        );
      ) : ( v4.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");
        v4.over = 1;
        leftClick ? ( cap = 2; dragging = 4; );
        rightClick ? ( remBand(3); );
      ) : ( v5.isOver(mouse_x, mouse_y) ) && ( cuts > 4 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify crossover frequency\nRMB - Remove frequency cut\nRMB anywhere else - Add frequency cut");     
        v5.over = 1;
        leftClick ? ( cap = 2; dragging = 5; );
        rightClick ? ( remBand(4); );
      
      /* Drag drive */
      ) : ( h1.isOver(mouse_x, mouse_y) ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h1.over = 1;
        leftClick ? ( cap = 3; dragging = 1; selectedBand = 0; );
        doubleClick ? ( Drive1 = 0; selectedBand = 0; );
      ) : ( h2.isOver(mouse_x, mouse_y) ) && ( cuts > 0 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");
        h2.over = 1;
        leftClick ? ( cap = 3; dragging = 2; selectedBand = 1; );
        doubleClick ? ( Drive2 = 0; selectedBand = 1; );
      ) : ( h3.isOver(mouse_x, mouse_y) ) && ( cuts > 1 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");
        h3.over = 1;
        leftClick ? ( cap = 3; dragging = 3; selectedBand = 2; );
        doubleClick ? ( Drive3 = 0; selectedBand = 2; );
      ) : ( h4.isOver(mouse_x, mouse_y) ) && ( cuts > 2 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");      
        h4.over = 1;
        leftClick ? ( cap = 3; dragging = 4; selectedBand = 3; );
        doubleClick ? ( Drive4 = 0; selectedBand = 3; );
      ) : ( h5.isOver(mouse_x, mouse_y) ) && ( cuts > 3 ) ? (
        hinter.updateHintTime("LMB + Drag - Modify drive\nDouble LMB - Reset drive to zero\nShift + LMB + Drag - Modify drive while reducing gain");            
        h5.over = 1;
        leftClick ? ( cap = 3; dragging = 5; selectedBand = 4; );
        doubleClick ? ( Drive5 = 0; selectedBand = 4; );    
        
      /* Handle clicks within the bands (creating a new band or selecting a band) */
      ) : ( overRect( h1.x, y, h1.w, h, mouse_x, mouse_y ) ) ? (
        leftClick ? selectedBand = 0;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(0);
          mpos = this.pixelToWindowRatio(mouse_x);
          Freq2 = ( Freq2 * (1-0) + 0 - mpos ) / ( 1 - mpos );
          Freq1 = mpos;
        );
      ) : ( overRect( h2.x, y, h2.w, h, mouse_x, mouse_y ) && ( cuts > 0 )  ) ? (
        leftClick ? selectedBand = 1;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(1);
          mpos = this.pixelToWindowRatio(mouse_x);
          Freq3 = ( Freq3 * (1-Freq1) + Freq1 - mpos ) / ( 1 - mpos );
          Freq2 = ( mpos - Freq1 ) / ( 1 - Freq1 );
        );
      ) : ( overRect( h3.x, y, h3.w, h, mouse_x, mouse_y ) && ( cuts > 1 ) ) ? (
        leftClick ? selectedBand = 2;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(2);
          mpos = this.pixelToWindowRatio(mouse_x);
          F2 = Freq1  + Freq2 * (1 - Freq1);
          Freq4 = ( Freq4 * (1-F2) + F2 - mpos ) / ( 1 - mpos );
          Freq3 = ( mpos - F2 ) / ( 1 - F2 );
        );
      ) : ( overRect( h4.x, y, h4.w, h, mouse_x, mouse_y ) && ( cuts > 2 ) ) ? (
        leftClick ? selectedBand = 3;
        rightClick && (cuts < maxCuts) ? ( 
          addBand(3);
          mpos = this.pixelToWindowRatio(mouse_x);
          F2 = Freq1  + Freq2 * (1 - Freq1);
          F3 = F2     + Freq3 * (1 - F2);
          Freq4 = ( mpos - F3 ) / ( 1 - F3 );
        );
      ) : ( overRect( h5.x, y, h5.w, h, mouse_x, mouse_y ) && ( cuts > 3 ) ) ? (
        leftClick ? selectedBand = 4;
      ) : (
        cap = 0;
        ( mouse_cap & 1 == 1 && lcap & 1 == 0 && over ) ? (
          cap = 1;
        );
      );
    );
    
    mouse_wheel > 0 && over ? lastUI = thisUI;
    
    abs(floor(mouse_wheel/240)) > 0 && over ?
    (
      dsteps_fft += floor(mouse_wheel/240);
      dsteps_fft > 8 ? dsteps_fft = 8;
      dsteps_fft < -4 ? dsteps_fft = -4;
      mouse_wheel = 0;
    );
    
    lx = mouse_x;
    ly = mouse_y;
    lcap = mouse_cap;
    
    over
  );

function drawFFT(fill, r, g, b, a)
  global(scaling, fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate, gfx_mode, dsteps_fft )
  instance(hstep, x, y, w, h, recPtr, window, rStart, rEnd, fftLoc, floorLevel, hzoffset)
  local(copyval, stepsize, buf, i, ixsc, txl, tx, ty, wsc, fill, tx0, lx0, lx, ly, ty2, ly2, fill_slast, fill_slmin, cum, cumelem)
  (
    this.calcFFT();
 
    cum = -10000000;
    cumelem = 0;
    i = 0;
    ixsc = 0;
    wsc = w/log(1+fftsize*0.5-hzoffset);
    fill_slmin = y;

    buf = fftLoc + fftsize*0.5 - 2;
    stepsize = floor((4+dsteps_fft)*(1+scaling));
    copyval = buf[];
    loop( stepsize*200,
      (buf+=1)[] = copyval;
    );
     
    gfx_r = r;
    gfx_g = g;
    gfx_b = b;
    gfx_a = a;
 
    hstep = .5 * stepsize;
    buf = fftLoc+2;
    txl = x;
    lx = x;
    ly = y - max(buf[], -floorLevel)*h / floorLevel;
    buf += 1;
    loop(fftsize*0.5+stepsize*200,
      tx = floor(x + log(1.0+ixsc-hzoffset)*wsc);
      cum = max(cum, buf[]);
      cumelem += 1;
      
      ( (tx != txl) && (tx-txl > stepsize) && tx > x && i && ( tx < (x+w+stepsize) ) ) ? // 
      ( 
        ty = y - max(cum, -floorLevel)*h / floorLevel;
        //ty = y - log(cum)+100;
        txl = floor(tx);
        
        tx = min(tx, x+w);
        (fill) ? 
        (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0 ? 
          (
            gfx_triangle(lx0-hstep,max(y+h,ly),lx0-hstep,ly,tx0-1-hstep,ty,tx0-1-hstep,max(y+h,ty));
          ) : (
            tx0 > fill_slast ? 
            (
              fill_slast < h ? gfx_line(fill_slast,h,fill_slast,fill_slmin);
              fill_slmin=h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          
          fill_slast=tx0;        
        );
        
        (fill==0) ? (
          drawLine(lx-hstep, ly, tx-hstep, ty);
        );
        
        lx=tx; ly=ty; ly2=ty2; cum = -1000000; cumelem = 0;
      );
      
      buf+=1; i+=1; ixsc+=1;
    );
  );
  
function drawLineFFT(peakLocation)
  global(fftSize, gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, srate)
  instance(x, y, w, h, hzoffset)
  local(wsc, tx, base, i)
  (
    wsc = w/log(1+fftSize*0.5-hzoffset);
    base = fftSize*peakLocation;
    tx = floor(x + log(1.0+base-hzoffset)*wsc);
    drawLine(tx, y, tx, y+h);
  );  
  
function updateBands()
  global(Freq1,   Freq2,   Freq3,   Freq4,
         Ceil1,   Ceil2,   Ceil3,   Ceil4,
         Drive1,  Drive2,  Drive3,  Drive4,  Drive5,
         fftSize, driveRange, driveMax)
  instance(x, y, w, h, hzoffset,
           x1,  x2,  x3,  x4,  x5,  /* Frequencies          */
           y1,  y2,  y3,  y4,  y5,  /* Drives               */
           )
  local(F1, F2, F3, F4, F5, wsc, hfft, lmin, irange, dmax)
  (
    F1 = Freq1;
    F2 = Freq1  + Freq2 * (1 - Freq1);
    F3 = F2     + Freq3 * (1 - F2);
    F4 = F3     + Freq4 * (1 - F3);
    
    hfft = 0.5*fftSize;
    lmin = log(20/22050);
    
    wsc = w/log(1+fftSize*0.5-hzoffset);
    x1 = ( x + log( hfft * exp( (1-F1) * lmin ) - hzoffset ) * wsc );
    x2 = ( x + log( hfft * exp( (1-F2) * lmin ) - hzoffset ) * wsc );
    x3 = ( x + log( hfft * exp( (1-F3) * lmin ) - hzoffset ) * wsc );
    x4 = ( x + log( hfft * exp( (1-F4) * lmin ) - hzoffset ) * wsc );
    x5 = ( x + log( hfft * exp( lmin ) - hzoffset ) * wsc );
       
    iRange = 1/driveRange;
    dmax = iRange * driveMax;
    
    y1 = y+h*(dmax-iRange*Drive1);
    y2 = y+h*(dmax-iRange*Drive2);
    y3 = y+h*(dmax-iRange*Drive3);
    y4 = y+h*(dmax-iRange*Drive4);
    y5 = y+h*(dmax-iRange*Drive5);
  );

lineR = 1;
lineG = .9;
lineB = 1.0;
lineA = .95;
lineHighlightR = 0;
lineHighlightG = .7;
lineHighlightB = .5;
  
function drawGroupRect(x, y, w, h, r, g, b, a)  
  local()
  instance()
  global()
  (
    gfx_set(r, g, b, a);
    gfx_line(x, y, x+w, y);
    gfx_line(x, y, x, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y+h, x+w, y+h);
    
    gfx_set(r, g, b, a*.5);
    gfx_line(x, y+h+1, x+w, y+h+1);
    gfx_line(x+w+1, y, x+w+1, y+h);
  );  
  
function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    scopebuffermax  = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function setOffset(offset)
  local()
  global()
  instance(scopeptr, readptr, scopebuffermax, scopebuffer, frac)
  (
    readptr   = scopeptr;
    frac      = offset - floor(offset);
    readptr  -= floor(offset);
    readptr < scopebuffer ? readptr += (scopebuffermax-scopebuffer+1);
  );
  
function readBuffer()
  local(c1, c2)
  global()
  instance(readptr, scopebuffermax, scopebuffer, frac)
  (
    c1 = readptr[];
    readptr += 1;
    readptr > scopebuffermax ? readptr = scopebuffer;
    
    c2 = readptr[];
    c2 * (1.0-frac) + c1 * frac
  );
  
function updateBuffer(M)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = M;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
    
    M
  );  
  
function clearBuffer()
  local()
  global(MAXBUFFERSIZE)
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    memset( scopebuffer, 0, MAXBUFFERSIZE );
    scopeptr = scopebuffer;
  );   
  
function fancyLineV(x1, y1, x2, y2)
  local(dx)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dx = 5;
    
    x = x1 - .5*dx;
    y = y1;
    w = dx;
    h = y2-y1;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x-2, y, w+5, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x-4, y, w+9, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x-7, y, w+15, h);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x-10, y, w+20, h);
    );
  
    gfx_set(.2*lineR, .2*lineG, .2*lineB, lineA);
    gfx_rect(x, y, w, h);
    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dx = 3; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dx = 2; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    gfx_set(lineR, lineG, lineB, lineA);
    dx = 1; gfx_rect(x1 - .5*dx, y1, dx, y2-y1);
    
    over ? ( 
      gfx_set(1,1,1,.4*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;
  );

function fancyLineH(x1, y1, x2, y2)
  local(dy)
  global(globalTime, lineR, lineG, lineB, lineA, lineHighlightR, lineHighlightG, lineHighlightB)
  instance(x, y, w, h, over)
  (
    dy = 5;    
    
    x = x1;
    y = y1 - .5*dy;
    w = x2-x1;
    h = dy;
  
    over ? ( 
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-2, w, h+5);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.1);
      gfx_rect(x, y-4, w, h+9);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.05);
      gfx_rect(x, y-7, w, h+15);
      gfx_set(lineHighlightR,lineHighlightG,lineHighlightB,.03);
      gfx_rect(x, y-10, w, h+20);
    );  
  
    gfx_set(.2*lineR, .2*lineG, .2*lineB, lineA);
    gfx_rect(x, y, w, h);
    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dy = 3; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dy = 2; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    gfx_set(lineR, lineG, lineB, lineA);
    dy = 1; gfx_rect(x1, y1 - .5*dy, x2-x1, dy );
    
    over ? ( 
      gfx_set(1,1,1,.7*abs(sin(2*globalTime)));
      gfx_rect(x, y, w, h);
    );
    
    over = 0;    
  ); 

function hzLabel(dy, label)
  local(lww, lhh, cy, dy2)
  global(gfx_x, gfx_y, hzLabelW, hzLabelH, lineR, lineG, lineB, lineA)
  instance(x, y, w, h, over)
  (
    cy = y + dy*h;
    
    gfx_measurestr("888888", hzLabelW, hzLabelH);

    gfx_set(.5*lineR, .5*lineG, .5*lineB, lineA);    
    dy2 = 3; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);
    gfx_set(.7*lineR, .7*lineG, .7*lineB, lineA);
    dy2 = 2; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);
    gfx_set(lineR, lineG, lineB, lineA);
    dy2 = 1; gfx_rect(x-.5*hzLabelW-.5*dy2, cy-.5*dy2, hzLabelW+dy2, hzLabelH+dy2);

    gfx_set( 1, 1, 1, .8 );
    gfx_rect(x-.5*hzLabelW-1, cy-1, hzLabelW+2, hzLabelH+2);
    
    gfx_set( 0, 0, 0, 1 );
    gfx_rect(x-.5*hzLabelW, cy, hzLabelW, hzLabelH);

    sprintf(19, "%d", label);
    gfx_measurestr(19, lww, lhh);
    gfx_set( 1, 1, 1, 1 );    
    gfx_x = x - .5 *lww;
    gfx_y = y + dy*h;
    gfx_printf(19, label);
  );
  
function drawBands()
  global(Cuts, stest,
           mute1, mute2, mute3, mute4, mute5,
           solo1, solo2, solo3, solo4, solo5,
           bypassBand1, bypassBand2, bypassBand3, bypassBand4, bypassBand5,
           selectedBand )
  instance(xc, dx, x, y, w, h, 
           x1, x2, x3, x4, x5, // Band frequency screen positions
           y1, y2, y3, y4, y5, // Band drive positions
           v1, v2, v3, v4, v5, // Frequency handles
           h1, h2, h3, h4, h5, // Drive handles
           c1, c2, c3, c4, c5, // Circle handles
           F1hz, F2hz, F3hz, F4hz, F5hz, // Frequencies
           x_over)
  local()
  (
    xc = x;
    dx = 5;
    while(xc<x+w) (
      gfx_set(0,0,0,1);
      gfx_line(xc, y+.6*h+1, xc+dx, y+.6*h+1);
      gfx_line(xc, y+.6*h-1, xc+dx, y+.6*h-1);
      gfx_set(0.6,0.6,0.6,1);
      gfx_line(xc, y+.6*h, xc+dx, y+.6*h);
      xc = xc + 2*dx;
    );
    
    xc = x;
    dx = 5;
    gfx_set(0,0,0,.3);
    gfx_line(x, y+.3*h, x+w, y+.3*h);
    gfx_line(x, y+.3*h+2, x+w, y+.3*h+2);
 
    (Cuts > 0) ? (
      gfx_set(1,1,1,1); v1.fancyLineV(x1, y, x1, y+h);
      v1.hzLabel(.8, F1hz);
    );
    (Cuts > 1) ? (
      gfx_set(1,1,1,1); v2.fancyLineV(x2, y, x2, y+h);
      v2.hzLabel(.8, F2hz);
    );
    (Cuts > 2) ? (
      gfx_set(1,1,1,1); v3.fancyLineV(x3, y, x3, y+h);
      v3.hzLabel(.8, F3hz);
    );
    (Cuts > 3) ? (
      gfx_set(1,1,1,1); v4.fancyLineV(x4, y, x4, y+h);
      v4.hzLabel(.8, F4hz);
    );
    (Cuts > 4) ? (
      gfx_set(1,1,1,1); v5.fancyLineV(x5, y, x5, y+h);
      v5.hzLabel(.8, F5hz);
    );
    
    gfx_rect(x_over-3, y, 5, h);
    ( Cuts == 0 ) ? (
       h1.fancyLineH(x, y1, x+w-2, y1);
       c1.fancyCircle(x + .5*w, y1, 0, mute1, solo1, bypassBand1);
    ) : ( Cuts == 1 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x+w-2, y2);
       c2.fancyCircle(x1 + .5*(w-x1), y2, 0, mute2, solo2, bypassBand2);
    ) : ( Cuts == 2 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       h3.fancyLineH(x2, y3, x+w-2, y3);
       c3.fancyCircle(x2 + .5*(w-x2), y3, 0, mute3, solo3, bypassBand3);
    ) : ( Cuts == 3 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3, bypassBand3);
       h4.fancyLineH(x3, y4, x+w-2, y4);
       c4.fancyCircle(x3 + .5*(w-x3), y4, 0, mute4, solo4, bypassBand4);
    ) : ( Cuts == 4 ) ? (
       h1.fancyLineH(x,  y1, x1-2, y1);
       c1.fancyCircle(.5*x + .5*x1, y1, 0, mute1, solo1, bypassBand1);
       h2.fancyLineH(x1, y2, x2-2, y2);
       c2.fancyCircle(x1 + .5*(x2-x1), y2, 0, mute2, solo2, bypassBand2);
       h3.fancyLineH(x2, y3, x3-2, y3);
       c3.fancyCircle(x2 + .5*(x3-x2), y3, 0, mute3, solo3, bypassBand3);
       h4.fancyLineH(x3, y4, x4-2, y4);      
       c4.fancyCircle(x3 + .5*(x4-x3), y4, 0, mute4, solo4, bypassBand4);
       h5.fancyLineH(x4, y5, x+w-2, y5);
       c5.fancyCircle(x4 + .5*(w-x4), y5, 0, mute5, solo5, bypassBand5);
    );
    
    selectedBand == 0 ? gfx_muladdrect( h1.x, y, h1.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 1 ? gfx_muladdrect( h2.x, y, h2.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 2 ? gfx_muladdrect( h3.x, y, h3.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 3 ? gfx_muladdrect( h4.x, y, h4.w, h, 1, 1, 1, .6, .05, .05, .105 );
    selectedBand == 4 ? gfx_muladdrect( h5.x, y, h5.w, h, 1, 1, 1, .6, .05, .05, .105 );

  );  
  
function initSpectrum(memoryOffset, fftSize, srate)
  global(newUI)
  instance(recPtr, window, rStart, rEnd, fftLoc, hzoffset, thisUI, slope)
  local()
  (
    slope     = 3;
  
    hzoffset  = 20*fftSize/srate;
    window    = memoryOffset + fftSize + (fftSize*0.5 - 1);
  
    // Start and end of the buffer
    rStart    = memoryOffset;                              // rpos
    rEnd      = window;                                      // hsize
    
    fftLoc    = window + (fftSize*0.5 + 1); // fftw
    
    recPtr    = rStart;
    thisUI    = newUI+=1;
    
    this.initWindow(3)
  );
  
  function resetBandMeter()
  local()
  global()
  instance(in, pre, post)
  (
    in = pre = post = 0;
  );
  
  function processBands()
  local(BW2)
  global( Drive1,    Drive2,    Drive3,     Drive4,     Drive5
          play1,     play2,     play3,      play4,      play5 )
  instance(b1, b2, b3, b4, b5, F1, F2, F3, F4, F5,
           g1,       g2,       g3,       g4,       g5,
           lg1,      lg2,      lg3,      lg4,      lg5 )
  (
    ( lg1 != Drive1 ) ? ( g1 = (10^(0.05*Drive1)); lg1 = Drive1; );
    ( lg2 != Drive2 ) ? ( g2 = (10^(0.05*Drive2)); lg2 = Drive2; );
    ( lg3 != Drive3 ) ? ( g3 = (10^(0.05*Drive3)); lg3 = Drive3; );
    ( lg4 != Drive4 ) ? ( g4 = (10^(0.05*Drive4)); lg4 = Drive4; );
    ( lg5 != Drive5 ) ? ( g5 = (10^(0.05*Drive5)); lg5 = Drive5; );

    b1.l = b2.l = b3.l = b4.l = b5.l = 0;
    b1.r = b2.r = b3.r = b4.r = b5.r = 0;
    play1 ? (
      b1.l = g1*b1.inL;
      b1.r = g1*b1.inR;
    );
    play2 ? (
      b2.l = g2*b2.inL;
      b2.r = g2*b2.inR;
    );
    play3 ? (
      b3.l = g3*b3.inL;
      b3.r = g3*b3.inR;
    );
    play4 ? (
      b4.l = g4*b4.inL;
      b4.r = g4*b4.inR;
    );
    play5 ? (
      b5.l = g5*b5.inL;
      b5.r = g5*b5.inR;
    );
  ); 
  
// MEMORY LAYOUT
fftSize     = 2*8192;
bufferDist  = 65536;
audioBufIn  = 0;
audioBufOut = bufferDist;

F1Block1    = 7*bufferDist;
F1Block2    = 8*bufferDist;
F2Block1    = 9*bufferDist;
F2Block2    = 10*bufferDist;
F3Block1    = 11*bufferDist;
F3Block2    = 12*bufferDist;
F4Block1    = 13*bufferDist;
F4Block2    = 14*bufferDist;
F5Block1    = 15*bufferDist;
F5Block2    = 16*bufferDist;

specBufferLoc = 17*bufferDist;

specBuffer.initBuffer(specBufferLoc, specBufferLoc+bufferDist-4);

// INITIALIZATION
spectrumIn.initSpectrum(audioBufIn, fftSize, srate);
spectrumOut.initSpectrum(audioBufOut, fftSize, srate);

@serialize
file_var(0, mute1);
file_var(0, mute2);
file_var(0, mute3);
file_var(0, mute4);
file_var(0, mute5);

file_var(0, solo1);
file_var(0, solo2);
file_var(0, solo3);
file_var(0, solo4);
file_var(0, solo5);

@slider

@block
!mute1 ? play1 = 1 : play1 = 0;
!mute2 ? play2 = 1 : play2 = 0;
!mute3 ? play3 = 1 : play3 = 0;
!mute4 ? play4 = 1 : play4 = 0;
!mute5 ? play5 = 1 : play5 = 0;

( solo1 || solo2 || solo3 || solo4 || solo5 ) ? ( play1 = play2 = play3 = play4 = play5 = 0; );
solo1 ? play1 = 1;
solo2 ? play2 = 1;
solo3 ? play3 = 1;
solo4 ? play4 = 1;
solo5 ? play5 = 1;

@sample
  function init_LR2(freq)
    global(srate)
    local(f0, ct, st, div)
    instance(k, a1, a2, a3)
    (
      f0 = .5 * $pi * exp( (1-freq) * log(20/22050) );
      k = sqrt(2); /* Note the different peak resonance because we're combining 2 SVFs into the Linkwitz-Riley structure */

      ct = cos(f0);
      st = sin(f0);
      div = 1.0 / (1.0 + k * st * ct);
      a1 = ct * ct * div;
      a2 = st * ct * div;
      a3 = st * st * div;
    ); 
  
  function reset_LR()
    global()
    local()
    instance(ic1eq, ic2eq, ic3eq, ic4eq, ic5eq, ic6eq, k, a1, a2, a3)
    (
      ic1eq = ic2eq = 0;  
    );  
 
  function eval_LRAP(v0)
    global()
    local(v1, v2, v3)
    instance(ic5eq, ic6eq, k, a1, a2, a3)
    (
      v3 = v0 - ic6eq;
      v1 = a1 * ic5eq + a2 * v3;
      v2 = ic6eq + a2 * ic5eq + a3 * v3;
      ic5eq = 2*v1 - ic5eq;
      ic6eq = 2*v2 - ic6eq;    
      
      v0 - 2*k*v1
    );    
 
  function resetBands()
  local()
  global()
  instance( b1, b2, b3, b4, b5 )
  (
    b1.r = b1.l = b2.r = b2.l = b3.r = b3.l = b4.r = b4.l = b5.l = 0;
  );
  
  function resetFilters()
  global()
  local()
  instance(
            LA_F1, LA_F2, LA_F3, LA_F4    /* Allpasses left */
            RA_F1, RA_F2, RA_F3, RA_F4    /* Allpasses right */
  )
  (
    // LR2  => ic1eq, ic2eq, ic3eq, ic4eq
    // LPLP => ic3eq, ic4eq
    // LRAP => ic5eq, ic6eq
    
    LA_F1.ic5eq = LA_F1.ic6eq = 0;
    LA_F2.ic5eq = LA_F2.ic6eq = 0;
    LA_F3.ic5eq = LA_F3.ic6eq = 0;
    LA_F4.ic5eq = LA_F4.ic6eq = 0;
    
    RA_F1.ic5eq = RA_F1.ic6eq = 0;
    RA_F2.ic5eq = RA_F2.ic6eq = 0;
    RA_F3.ic5eq = RA_F3.ic6eq = 0;
    RA_F4.ic5eq = RA_F4.ic6eq = 0;
  );
  
  // Make sure the delay is the same on all bands (identical number of filters)
  function splitBands(sl, sr)
  local()
  global(Cuts)
  instance( LA_F1, LA_F2, LA_F3, LA_F4    /* Allpasses left */
            RA_F1, RA_F2, RA_F3, RA_F4    /* Allpasses right */
            lcuts )
  (
    ( lcuts != cuts ) ? (
      lcuts = cuts;
      this.resetBands();
    );
    
    (cuts==0) ? (
      this.outL = sl;
      this.outR = sr;
    ) : (cuts==1) ? (
      this.outL = LA_F1.eval_LRAP(sl);
      this.outR = RA_F1.eval_LRAP(sr);
    ) : (cuts==2) ? (
      this.outL = LA_F2.eval_LRAP(LA_F1.eval_LRAP(sl));
      this.outR = RA_F2.eval_LRAP(RA_F1.eval_LRAP(sr));
    ) : (cuts==3) ? (
      this.outL = LA_F3.eval_LRAP(LA_F2.eval_LRAP(LA_F1.eval_LRAP(sl)));
      this.outR = RA_F3.eval_LRAP(RA_F2.eval_LRAP(RA_F1.eval_LRAP(sr)));
    ) : (cuts==4) ? (
      this.outL = LA_F4.eval_LRAP(LA_F3.eval_LRAP(LA_F2.eval_LRAP(LA_F1.eval_LRAP(sl))));
      this.outR = RA_F4.eval_LRAP(RA_F3.eval_LRAP(RA_F2.eval_LRAP(RA_F1.eval_LRAP(sr))));
    );
  );  
  
  function updateCoeffs()
  local(fptr1, fptr2, fptr3, fptr4, fptr5, middle, i)
  global(Cuts, Freq1, Freq2, Freq3, Freq4, bufferDist, fftCalcSize )
  instance( F1,  F2,  F3,  F4
            LA_F1, LA_F2, LA_F3, LA_F4    /* Allpasses left */
            RA_F1, RA_F2, RA_F3, RA_F4    /* Allpasses right */
            lcuts, 
            lF1, lF2, lF3, lF4,
            updateRequired )
  (
      updateRequired = 0;
      updateRequired = ( 
        ( lF1 != Freq1 ) ||
        ( lF2 != Freq2 ) ||
        ( lF3 != Freq3 ) ||
        ( lF4 != Freq4 ) ||
        ( cuts != lcuts ) );

      updateRequired ? (        
        lF1 = Freq1;
        lF2 = Freq2;
        lF3 = Freq3;
        lF4 = Freq4;
        lcuts = cuts;
      
        F1 = Freq1;
        F2 = Freq1  + Freq2 * (1 - Freq1);
        F3 = F2     + Freq3 * (1 - F2);
        F4 = F3     + Freq4 * (1 - F3);
          
        (cuts==1) ? (
          // All-passes for maintaining the phase relation between the bands
          LA_F1.init_LR2(F1);
          RA_F1.k  = LA_F1.k;
          RA_F1.a1 = LA_F1.a1;
          RA_F1.a2 = LA_F1.a2;
          RA_F1.a3 = LA_F1.a3;
        ) : (cuts==2) ? (
          // All-passes for maintaining the phase relation between the bands
          LA_F1.init_LR2(F1);
          RA_F1.k  = LA_F1.k;
          RA_F1.a1 = LA_F1.a1;
          RA_F1.a2 = LA_F1.a2;
          RA_F1.a3 = LA_F1.a3;
          
          LA_F2.init_LR2(F2);
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
        ) : (cuts == 3) ? (
          // All-passes for maintaining the phase relation between the bands
          LA_F1.init_LR2(F1);
          RA_F1.k  = LA_F1.k;
          RA_F1.a1 = LA_F1.a1;
          RA_F1.a2 = LA_F1.a2;
          RA_F1.a3 = LA_F1.a3;          
          
          LA_F2.init_LR2(F2);
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
          
          LA_F3.init_LR2(F3);
          RA_F3.k  = LA_F3.k;
          RA_F3.a1 = LA_F3.a1;
          RA_F3.a2 = LA_F3.a2;
          RA_F3.a3 = LA_F3.a3;
        ) : (cuts == 4) ? (
          // All-passes for maintaining the phase relation between the bands
          LA_F1.init_LR2(F1);
          RA_F1.k  = LA_F1.k;
          RA_F1.a1 = LA_F1.a1;
          RA_F1.a2 = LA_F1.a2;
          RA_F1.a3 = LA_F1.a3;
          
          LA_F2.init_LR2(F2);
          RA_F2.k  = LA_F2.k;
          RA_F2.a1 = LA_F2.a1;
          RA_F2.a2 = LA_F2.a2;
          RA_F2.a3 = LA_F2.a3;
          
          LA_F3.init_LR2(F3);
          RA_F3.k  = LA_F3.k;
          RA_F3.a1 = LA_F3.a1;
          RA_F3.a2 = LA_F3.a2;
          RA_F3.a3 = LA_F3.a3;
          
          LA_F4.init_LR2(F4);
          RA_F4.k  = LA_F4.k;
          RA_F4.a1 = LA_F4.a1;
          RA_F4.a2 = LA_F4.a2;
          RA_F4.a3 = LA_F4.a3;
        );
      );
    updateRequired
  );
  
  spectrumIn.feedSample(.5*(spl0+spl1));

  // Split signal into bands
  filterBank.updateCoeffs();
  
  inL = spl0;
  inR = spl1;
  
  filterBank.splitBands(inL, inR);
  
  spl0 = filterBank.outL;
  spl1 = filterBank.outR;
  out = spl0 + spl1;

  spectrumOut.feedSample(.5*out);
    
  curSample += 1;
  
@gfx 1080 400
  function createGUI(stripStart)
  (
    scaling   = gfx_ext_retina-1;
    spectrumX = 0;
    spectrumY = 0;
    spectrumW = gfx_w - 200*0;
    spectrumH = gfx_h - 25 * ( 1 + modVisible ) * (1+scaling);
    
    fontface = "Arial";
    gfx_setfont(GRID_FONT,      fontface, 14*(1+scaling));
    gfx_setfont(HINT_FONT,      fontface, 14*(1+scaling));
    
    spectrumIn.setWindowLocation(spectrumX,  spectrumY, spectrumW, spectrumH);
    spectrumOut.setWindowLocation(spectrumX, spectrumY, spectrumW, spectrumH);
  );

  /* Gradients are buffered to save rendering perf */
  function drawGradients(w, h, spectrumH, gradient_bg)
  instance(lw, lh, lSpectrumH)
  global(gfx_mode, gfx_dest, bg_color_r, bg_color_g, bg_color_b, bg_color_a,
         gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a )
  local( oldDest, oldMode)
  (
    oldMode = gfx_mode;
    gfx_mode = 0;
    gfx_set(1,1,1,1);
    ( ( lw != w ) || ( lh != h ) || (spectrumH != lSpectrumH) ) ? (
      /* Only draw gradients when size changes */
      gfx_x = gfx_y = 0;
      lw = w;
      lh = h;
      lSpectrumH = spectrumH;
      oldDest = gfx_dest;
      gfx_setimgdim(gradient_bg, w, h);
      gfx_dest = gradient_bg;
      gfx_set(bg_color_r, bg_color_g, bg_color_b, bg_color_a);
      gfx_rectto(w,spectrumH);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, gfx_a, .0001, .001, .0001, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, gfx_r, gfx_g, gfx_b, .3, .0001, .001, .0006, .0001, -.0001, -.0001, .0001, .0001);
      gfx_gradrect(0, 0, w, spectrumH, 0, 0, 0, 0, 0, -.001, -.0006, .0001, -.0001, -.0001, .01, -.00008);
      gfx_gradrect(0, spectrumH, w, h-spectrumH, 0, 0, .0, 1.0, .0001, .0001, .0002, 0, 0, 0, .0005, 0);
      gfx_dest = oldDest;
    );
    
    gfx_x = gfx_y = 0;
    gfx_blit(gradient_bg, 1, 0);
    gfx_mode = oldMode;
  );
  
  bg_color_r = 47/255;
  bg_color_g = 65/255;
  bg_color_b = 75/255;
  bg_color_a = 1;
  fft_out_r = .8;
  fft_out_g = .8;
  fft_out_b = .8;
  fft_out_a = 1.0;
  fft_in_r = .13;
  fft_in_g = .13;
  fft_in_b = .23;
  fft_in_a = .6;
  grid_color_r = .73;
  grid_color_g = .73;
  grid_color_b = .76;
  grid_color_a = .2;
  grid_alpha = .1 * (1+.5*abs(sin(2*time_precise())));
  backface_color_r = .2;
  backface_color_g = .2;
  backface_color_b = .3;
  backface_color_a = .1;
  font_color_r = .8;
  font_color_g = .8;
  font_color_b = .8;
  font_color_a = .8;
  knob_font_color_r = .5;
  knob_font_color_g = .7;
  knob_font_color_b = 1;
  knob_font_color_a = 1;
  highlight_color_r = .5;
  highlight_color_g = .7+.2*abs(sin(2*time_precise()));
  highlight_color_b = .9;
  highlight_color_a = .6+.4*abs(sin(2*time_precise()));
  disabled_color_r = .4;
  disabled_color_g = .4;
  disabled_color_b = .4;
  disabled_color_a = .8;
  
  stripStart = 35; 
  createGUI(stripStart);
  gradient.drawGradients(gfx_w, gfx_h, spectrumH, 2);
  
  globalTime = time_precise();
  delta_time = globalTime - lastGlobalTime;
  lastGlobalTime = globalTime;
  
  gfx_r = 1;
  spectrumIn.drawGrid();
  spectrumIn.floorLevel = 25 + dnoisefloor_freq;
  spectrumOut.floorLevel = 25 + dnoisefloor_freq;
  spectrumIn.drawFFT(1, fft_in_r, fft_in_g, fft_in_b, fft_in_a);
  spectrumOut.drawFFT(0, fft_out_r, fft_out_g, fft_out_b, fft_out_a);
  spectrumIn.updateBands();
  spectrumIn.drawBands();    
  spectrumIn.fftWindow_processMouse(mouse_x, mouse_y, mouse_cap);  

  gfx_x = gfx_y = 30;
  gfx_setfont(1,"ARIAL",30);
  gfx_set(1,0,0,1);
  gfx_x = 30;
  gfx_y = 60;
  
  gfx_x = gfx_w-130*(1+scaling);
  gfx_y = bottomRow + 30*(1+scaling);
  gfx_mode = 4;
  
  hinter.drawHint_draw();

