desc:Amaranth (ALPHA - DO NOT USE, SLIDER MAPPING WILL CHANGE!)
tags: amaranth granular synth graintable grains
version: 0.08
author: Joep Vanlier
changelog: Added pre and post filter gain modulators. Added a bunch of new filters.
provides: Amaranth_Dependencies/*
license: MIT

slider1:LoopStart=0<0,1,.0000001>-Start point
slider2:LoopEnd=1<0,1,.0000001>-End point
slider3:Position=0<0,1,.0000001>-Position
slider4:grainSize=70<40,300,1>-Grain size [ms]
slider5:grainVariance=80<0,1000,1>-Position Variance [%]
slider6:grainOverlap=90<0,93,1>-Overlap (%)
slider7:panSpread=1<0,1,.00001>-Pan Spread
slider8:Speed=1<.125,2,.0001>-Speed
slider9:spdSpread=.001<0,1,.000001>-Speed Spread
slider10:PitchFollow=1<0,1,1>-Follow MIDI pitch
slider11:RefNote=0<-48,48,1>-Reference semitone
slider12:pitchMode=0<0,1,1{Normal,RandomPitch}>
slider13:octaveMin=0<-4,4,1>-Octave Min
slider14:octaveMax=0<-4,4,1>-Octave Max
slider15:reverseProb=0<0,1,1>-Reverse Probability
slider16:feedbackLevel=0<0,1,1>-Feedback
slider17:pitchTimeInvariance=0<0,1,1>-Invariance
slider18:F1_type=0<0,1,6>-F1 Type
slider19:F1_freq=0<0,1,.0000000000000001>-F1 Freq
slider20:F1_res=0<0,1,.0000000000000001>-F1 Resonance
slider21:F2_type=0<0,1,6>-F2 Type
slider22:F2_freq=0<0,1,.0000000000000001>-F2 Freq
slider23:F2_res=0<0,1,.0000000000000001>-F2 Resonance
slider62:storeSample=0<0,1,0>-Store sample in preset
slider63:updateBuffer=1<0,1,1>-Update Buffer
slider61:preGain=1<0,4,.00001>-preGain
slider64:postGain=1<0,4,.00001>-postGain

import Amaranth_widgets.jsfx-inc
import Amaranth_envelopes.jsfx-inc
import Amaranth_grainlib.jsfx-inc
import Amaranth_filters.jsfx-inc

// Filters
// 0 - OFF
// 1 - Linear LPF
// 2 - Linear HPF
// 3 - Linear BPF
// 4 - Non-linear LPF
// 5 - Non-linear HPF
// 6 - Non-linear BPF
// 7 - 303 LP
// 8 - Vowel
// 9 - Voodoo
// 10 - Vowel
// 11 - Monstro

@init
nModulators = 4;
nFilters = 12;

function updateFilter( idx, cutoff, reso )
  local()
  instance(fidx, lastCutoff, lastReso, lFilter, rFilter)
  global()
  (
    fidx = idx;
    ( fidx == 0 ) ? (
      1
    ) : ( fidx < 4 ) ? (
      lFilter.init_linearSVF(cutoff, .99*reso);
      rFilter.init_linearSVF(cutoff, .99*reso);
    ) : ( fidx < 7 ) ? (
      lFilter.init_MS20(cutoff, .99*reso);
      rFilter.init_MS20(cutoff, .99*reso);
    ) : ( fidx == 7 ) ? (
      lFilter.init303(cutoff, .99*reso);
      rFilter.init303(cutoff, .99*reso);
    ) : ( fidx == 8 ) ? (
      lFilter.init_voodoo(cutoff, .99*reso);
      rFilter.init_voodoo(cutoff, .99*reso);
    ) : ( fidx == 9 ) ? (
      lFilter.init_modulatrix(cutoff, .99*reso);
      rFilter.init_modulatrix(cutoff, .99*reso);
    ) : ( fidx == 10 ) ? (
      lFilter.init_vowelSVF(cutoff, reso);
      rFilter.init_vowelSVF(cutoff, reso);
    ) : ( fidx == 11 ) ? (
      lFilter.init_vowelSVF(cutoff, reso);
      rFilter.init_vowelSVF(cutoff, reso);
    );
  );
  
function evalSample( l, r )
  local()
  instance(fidx, lFilter, rFilter, outL, outR)
  global()
  (
    ( fidx == 0 ) ? (
      outL = l;
      outR = r;
    ) : ( fidx == 1 ) ? (
      outL = lFilter.eval_linearSVF_LP( l );
      outR = rFilter.eval_linearSVF_LP( r );
    ) : ( fidx == 2 ) ? (
      outL = lFilter.eval_linearSVF_BP( l );
      outR = rFilter.eval_linearSVF_BP( r );
    ) : ( fidx == 3 ) ? (
      outL = lFilter.eval_linearSVF_HP( l );
      outR = rFilter.eval_linearSVF_HP( r );
    ) : ( fidx == 4 ) ? (
      outL = lFilter.eval_MS20_lp( l );
      outR = rFilter.eval_MS20_lp( r );
    ) : ( fidx == 5 ) ? (
      outL = lFilter.eval_MS20_bp( l );
      outR = rFilter.eval_MS20_bp( r );
    ) : ( fidx == 6 ) ? (
      outL = lFilter.eval_MS20_hp( l );
      outR = rFilter.eval_MS20_hp( r );
    ) : ( fidx == 7 ) ? (
      outL = lFilter.eval303( l );
      outR = rFilter.eval303( r );
    ) : ( fidx == 8 ) ? (
      outL = lFilter.eval_voodoo( l );
      outR = rFilter.eval_voodoo( r );
    ) : ( fidx == 9 ) ? (
      outL = lFilter.eval_modulatrix( l );
      outR = rFilter.eval_modulatrix( r );
    ) : ( fidx == 10 ) ? (
      outL = lFilter.eval_vowelsvf( l );
      outR = rFilter.eval_vowelsvf( r );
    ) : ( fidx == 11 ) ? (
      outL = lFilter.eval_monstro( l );
      outR = rFilter.eval_monstro( r );
    );
  );

function initSettings()
(
  MINSPEED = .125;
  MAXSPEED = 2;
  SPEEDRANGE = MAXSPEED - MINSPEED;
  
  GRAINMIN = 40;
  GRAINMAX = 300;
  GRAINRANGE = GRAINMAX - GRAINMIN;
  
  OVERLAPMAX = 93;
  GRAINDISTMIN = log(1);
  GRAINDISTMAX = log(500);
  
  VARIANCEMIN = log(.1);
  VARIANCEMAX = log(500);
);
initSettings();

function updatePitch()
  local()
  global(lastNote, refNote, noteFollowFactor)
  instance()
  (
    noteFollowFactor = 2^((lastNote-(floor(RefNote)+60))/12);
  );

function openRect(x, y, w, h)
  local()
  global()
  instance()
  (
    gfx_line(x, y, x+w, y);
    gfx_line(x, y+h, x+w, y+h);
    gfx_line(x+w, y, x+w, y+h);
    gfx_line(x, y, x, y+h);
  );

function initRect(_x, _y, _w, _h)
  instance(x, y, w, h)
  local()
  global()
  (
    x = _x; y = _y; w = _w; h = _h;
  );
  
function vertBar(width, _xpos, mx, my, mcap)
  instance(x, y, w, h, xpos, cap, lmx, lmy, lastleft, left)
  local(xScreen, change, over)
  global(gfx_w, gfx_a)
  (
    xpos = _xpos;
    left = mcap & 1;
    xScreen = x + xpos*w - .5*width;    
    
    over = ( mx > xScreen ) && ( mx < ( xScreen + width ) ) && ( my > y ) && ( my < (y + h) );
    
    gfx_rect(xScreen+2, y, width-4, h);
    
    over ? (
      gfx_a = .5*gfx_a;
      gfx_rect(xScreen, y, width, h);
      gfx_a = .5*gfx_a;
      gfx_rect(xScreen-2, y, width+4, h);
    );
    
    change = 0;
    ( left == 1 ) ? (
      ( cap == 1 ) ? (
        xpos += (mx - lmx) / w;
        xpos = max(min(xpos, 1), 0);
        change = 1;
      ) : ( lastleft == 0 ) ? (
        over ? (
          cap = 1;
        );
      );
    ) : ( cap = 0; );
  
    lmx = mx;
    lmy = my;
    lastleft = left;
    
    change
  );

function initBuffer(scopebuffer_in, scopebuffermax_in)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopebuffer     = scopebuffer_in;
    !scopebuffermax ? scopebuffermax = scopebuffermax_in;
    
    scopeptr < scopebuffer ? (
      scopeptr = scopebuffer 
    ) : ( scopeptr > scopebuffermax ) ? scopeptr = scopebuffer    
  );
  
function resetBuffer()
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    memset(scopebuffer, 0, scopebuffermax - scopebuffer + 1);
  );
  
function setBufferSize( len )
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    scopebuffermax = scopebuffer + len;
  );

function getBufferSize( len )
  local()
  global()
  instance(scopebuffermax, scopebuffer)
  (
    scopebuffermax - scopebuffer
  );

function updateBuffer(L, R)
  local()
  global()
  instance(scopeptr, scopebuffermax, scopebuffer)
  (
    scopeptr[] = L;
    scopeptr += 1;
    scopeptr[] = R;
    scopeptr += 1;
    scopeptr > scopebuffermax ? scopeptr = scopebuffer;
  );
  
function serializeBuffer(reading)
  local(bufSize)
  global()
  instance(scopebuffermax, scopebuffer, scopeptr)
  (  
    bufSize = scopebuffermax - scopebuffer;
    file_var(0, bufSize);
    file_var(0, scopeptr);
    file_mem(0, scopebuffer, bufSize);
    
    reading ? scopebuffermax = scopebuffer + bufSize;
  );

function drawBuffer(x, y, w, h, fill)
  local(yScale, lymax, lymin, xx, ymax, ymin, yCenter, lptr, blockIdx, yb, lvl, blen, xLast)
  global(gfx_x, gfx_y, gfx_a, graphicsIntensity, xAdvance, blockSize, nDraw)
  instance(scopebuffer, scopebuffermax, scopeptr)
  (
    blen = scopebuffermax - scopebuffer;
    blockSize = floor(blen / w);
    blockSize = max(blockSize, 16);
    nDraw = blen / blockSize;
    xAdvance = w / nDraw;
    yScale = h/4;
    yCenter = y+.5*h;
    
    xLast       = x;
    xx          = x + xAdvance;
    gfx_x       = xx;
    gfx_y       = yCenter;
    blockIdx    = 0;
    ymax        = 0;
    ymin        = 0;
    lymax       = yCenter;
    lymin       = yCenter;
    yb          = 5;
    lvl         = (1-.2*graphicsIntensity);
    
    lptr        = floor(scopePtr/blockSize)*blockSize;
    loop(scopebuffermax-scopeptr,
      (blockIdx == blockSize) ? (
        ymax = yCenter + yScale*min(max(-2,ymax),2);
        ymin = yCenter + yScale*min(max(-2,ymin),2);
      
        fill ? (
          gfx_a = fill * lvl;
          gfx_triangle( xLast,  lymin,
                        xLast,  lymax,
                        xx,     ymin,
                        xx,     ymax);
                        
          gfx_a = .3*fill;
          gfx_triangle( xLast,  lymin-yb,
                        xLast,  lymax+yb,
                        xx,     ymin-yb,
                        xx,     ymax+yb);                        
          );
          gfx_a = lvl;
          gfx_lineto(xx, ymax);
          gfx_line(xLast, lymin, xx, ymin);          
            
          lymin = ymin;
          lymax = ymax;
          ymax = 0;
          ymin = 0;
          xLast = xx + 1;
          xx += xAdvance;
          blockIdx = 0;
          
          xx > (x+w) ? xx = x+w;
       );
      
       ymax = max(lptr[], ymax);
       ymin = min(lptr[], ymin);
       
       blockIdx += 1;
       lptr += 1;
     );
     
     blockIdx = 0;
     lptr = scopebuffer;
     loop(scopeptr-scopebuffer,
       ( blockIdx == blockSize ) ? (
         ymax = yCenter + yScale*min(max(-2,ymax),2);
         ymin = yCenter + yScale*min(max(-2,ymin),2);
       
         fill ? (
           gfx_a = fill * lvl;
           gfx_triangle( xLast, lymin,
                         xLast, lymax,
                            xx, ymin,
                            xx, ymax);
           
           gfx_a = .3*fill;
           gfx_triangle( xLast, lymin-yb,
                         xLast, lymax+yb,
                            xx, ymin-yb,
                            xx, ymax+yb);                   
        );
               
        gfx_a = lvl;
        gfx_lineto(xx, ymax);
        gfx_line(xLast, lymin, xx, ymin);
          
        lymin = ymin;
        lymax = ymax;
        ymax = 0;
        ymin = 0;
        xLast = xx + 1;
        xx += xAdvance;
        xx > (x+w) ? xx = x+w;        
        
        blockIdx = 0;
      );
         
      ymax = max(lptr[], ymax);
      ymin = min(lptr[], ymin);
         
      blockIdx += 1;
      lptr += 1;
    );
  );

  // Current pitch change
  noteFollowFactor = 1;
  lastNote = 60;
  updatePitch();

  // MEMORY LAYOUT
  bufSize = 65536*8;
  
  // Vowel location
  vowel_A   = 1024;
  vowel_E   = 1048;
  vowel_I   = 1072;
  vowel_O   = 1096;
  vowel_U   = 1120;
  vowel_EE  = 1144;
  vowel_src = 1168;

  bootvowel();
  
  outBuffer.initBuffer(bufSize, 2*bufSize-4);
  grains.granulator_init();
  grains.normalize = 1;
  
  // Grains used for feedback when the timeline is frozen
  grainsFeedback.granulator_init();
  grainsFeedback.normalize = 1;
  
  env_buf = 4*bufSize;
  env_buf_shapes = env_buf + 8192;
  env_buf2 = env_buf_shapes + 8192;
  env_buf_shapes2 = env_buf2 + 8192;
  
  envWindow1.setEnvMemory(env_buf, env_buf_shapes);
  envWindow1.resetEnvelope(1, 1);
  envWindow2.setEnvMemory(env_buf2, env_buf_shapes2);
  envWindow2.resetEnvelope(1, 1);
  
  note_mem = 5*bufSize;
  
  // Temporary storage for cropping
  temporaryBuf = 6*bufSize;
  
  fbBuffer.initBuffer(10*bufSize, 10*bufSize + bufSize-4);
  
@serialize
  preset_ver = 1.03;
  reading = file_avail(0)>=0;
  
  file_var(0, preset_ver);
  file_var(0, Octaver);
  
  envWindow1.serializeEnvelope();
  envWindow2.serializeEnvelope();
  
  storedWas = envWindow1.triggering;
  
  /* Store the sample in memory */
  file_var(0, storeSample);
  
  storeSample ? (
    outBuffer.serializeBuffer(reading);
  );
  
  file_var(0, useAbsoluteDist);
  file_var(0, useAbsoluteVar);
  
  file_var(0, positionModulator);
  file_var(0, sizeModulator);
  file_var(0, speedModulator);
  file_var(0, positionModulatorAmount);
  file_var(0, sizeModulatorAmount);
  file_var(0, speedModulatorAmount);
  file_var(0, F1CutoffModulator);
  file_var(0, F1CutoffModulatorAmount);
  file_var(0, F1ResModulator);
  file_var(0, F1ResModulatorAmount);  
  file_var(0, F2CutoffModulator);
  file_var(0, F2CutoffModulatorAmount);
  file_var(0, F2ResModulator);
  file_var(0, F2ResModulatorAmount);

  fbBuffer.setBufferSize(outBuffer.getBufferSize());

  file_var(0, postGainModulator);
  file_var(0, postGainModulatorAmount);
  file_var(0, preGainModulator);
  file_var(0, preGainModulatorAmount);

@slider

@block
  envWindow1.updateEnvRate();
  envWindow2.updateEnvRate();
  
  israte = 1 / srate;
  
  /* Did the user drop a file? */
  /* Sadly, drops from anywhere don't work, so for now this is commented out */
  /*!fHandle ? (
    fHandle = file_open("25009__LS__soft_pad_3.wav");
    fHandle >= 0 ? (
    triedLoad = 2;
      file_riff(fHandle,nChannels,waveSampleRate);
      nChannels > 0 ? (
        triedLoad=file_avail(fHandle);
        amt = file_mem(fHandle, outBuffer.scopebuffer, file_avail(fHandle));
      );
      file_close(fHandle);
    );
  );
  fHandle = 1;*/
  
  notePtr = note_mem;
  while (midirecv(offset,msg1,msg2,msg3)) (
    noteOn = msg1>$x8F&&msg1<$xA0 && msg3!=0;
    noteOff = (msg1>$x7F&&msg1<$x90) || (msg1>$x89&&msg1<$xA0 && msg3==0);
    mwCC = (msg1>$xAF&&msg1<$xC0);
        
    noteOn ? (
    noteLOGGED = 1;
      notePtr[] = offset;
      notePtr += 1;
      notePtr[] = msg3;
      notePtr += 1;
      notePtr[] = msg2;
      notePtr += 1;
    ) : ( noteOff ) ? (
      notePtr[] = offset;
      notePtr += 1;
      notePtr[] = -1;
      notePtr += 1;
    ) : ( mwCC ) ? (
      ( slider45 > 9 && slider45 < 11 ) ? (
        notePtr[] = offset;
        notePtr += 1;
        notePtr[] = -2;
        notePtr += 1;
        notePtr[] = msg2;
        notePtr += 1;
        notePtr[] = msg3;
        notePtr += 1;
      );
    );
      
    midisend(offset,msg1,msg2,msg3); // passthrough MIDI events
  );
  notePtr[]       = -1337;    // Signal end of note buffer
  notePtr         = note_mem;
  curSample       = -1;        // Current sample in block
  notes_remain    = 1;        // End of the note buffer?
  note_next       = notePtr[];  

@sample
  curSample += 1;
  
  // Does this plugin respond to MIDI signals?
  // Take notes from the stack until we hit the end marker -1
  (notes_remain) ? (
    while( note_next == curSample ) (
    noteF = 1;
      notePtr += 1;
      (notePtr[] > 0) ? ( // note-on
        notesOn = notesOn + 1;
        lastVel_cur = notePtr[]/127;
        lastVel = ( (slider45 == 4) || (slider45 == 5) ) ? lastVel_cur : 1;
        (slider45 == 2 || slider45 == 4) ? ( tDynamic = 0; dynval = 0; );
        
        envWindow1.resetEnvelope(lastVel_cur, 0);
        envWindow2.resetEnvelope(lastVel_cur, 0);
        
        notePtr += 1;
        lastNote = notePtr[];
        
        updatePitch();
      ) : (notePtr[] == -1) ? ( // note-off
        notesOn = notesOn - 1;
        notesOn = max(0, notesOn);
      ) : (notePtr[] == -2) ? ( // CC
        notePtr += 1;
        // msg3
        cur_cc = notePtr[];
        
        notePtr += 1;
        // msg2
        cur_cc == 1 ? (
          cc_target = notePtr[]/128;
        )
      );
      notePtr += 1;
      
      // Avoid constantly dereferencing by picking up the next one
      note_next = notePtr[];
      notes_remain = note_next != -1337;
    );
  );

  env1    = envWindow1.evaluateEnvelope(notesOn);
  env2    = envWindow2.evaluateEnvelope(notesOn);
  
  function chooseEnv( choice )
  (
    ( choice == 1 ) ? env1
    : ( choice == 2 ) ? env2
  );
  
  cPosition   = position;
  cGrainSize  = grainSize;
  cSpeed      = speed;
  cCutoff1    = F1_freq;
  cReso1      = F1_res;
  cCutoff2    = F2_freq;
  cReso2      = F2_res;
  cPreGain    = preGain;
  cPostGain   = postGain;  
  
  /* Process modulators */
  ( positionModulator ) ? ( cPosition   = min( 1, max( 0, cPosition + positionModulatorAmount * chooseEnv(positionModulator) ) ) );
  ( sizeModulator )     ? ( cGrainSize  = min( GRAINMAX, max( GRAINMIN, cGrainSize + GRAINRANGE * sizeModulatorAmount * chooseEnv(sizeModulator) ) ) );
  ( speedModulator )    ? ( cSpeed      = min( MAXSPEED, max( MINSPEED, cSpeed + SPEEDRANGE * speedModulatorAmount * chooseEnv(speedModulator) ) ) );
  ( F1CutoffModulator ) ? ( cCutoff1    = min( 1, max( 0, cCutoff1 + F1CutoffModulatorAmount * chooseEnv(F1CutoffModulator) ) ) );
  ( F1ResModulator )    ? ( cReso1      = min( 1, max( 0, cReso1 + F1ResModulatorAmount * chooseEnv(F1ResModulator) ) ) );
  ( F2CutoffModulator ) ? ( cCutoff2    = min( 1, max( 0, cCutoff2 + F2CutoffModulatorAmount * chooseEnv(F2CutoffModulator) ) ) );
  ( F2ResModulator )    ? ( cReso2      = min( 1, max( 0, cReso2 + F2ResModulatorAmount * chooseEnv(F2ResModulator) ) ) );
  ( preGainModulator )  ? ( cPreGain    = min( 4, max( 0, cPreGain + 4 * preGainModulatorAmount * chooseEnv(preGainModulator) ) ) );  
  ( postGainModulator ) ? ( cPostGain   = min( 4, max( 0, cPostGain + 4 * postGainModulatorAmount * chooseEnv(postGainModulator) ) ) );  
  
  /* Actual grain parameters */
  curPos  = 1-cPosition;
  readBufMin = outBuffer.scopebuffer;
  readBufMax = outBuffer.scopebuffermax;
  readBufCur = (1-LoopStart) + (LoopStart-LoopEnd)*curPos;
  spd = cSpeed;
  
  inL = spl0;
  inR = spl1;
  
  Octaver ? ( spd = spd * 2^(floor(octaveMin) + floor((floor(octaveMax) - floor(octaveMin) + 1)*rand())); );
  pitchFollow ? (
    spd = spd * noteFollowFactor;
  ); 
  grains.granulator_update(cGrainSize, useAbsoluteVar, grainVariance, useAbsoluteDist, grainOverlap, spd, spdSpread, panSpread, reverseProb, play_state, readBufCur, readBufMin, readBufMax, outBuffer.scopeptr, curPos, pitchTimeInvariance, updateBuffer);
  
  updateBuffer ? ( 
    fbL *= feedbackLevel*.99999999;
    fbR *= feedbackLevel*.99999999;
    outBuffer.updateBuffer(inL + fbL, inR + fbR);
  ) : (
    feedbackLevel > 0 ? (
      fbL *= feedbackLevel*.99999999+0.0000000001;
      fbR *= feedbackLevel*.99999999+0.0000000001;
      
      fbBuffer.updateBuffer(fbL, fbR);
      readBufMin = fbBuffer.scopebuffer;
      readBufMax = fbBuffer.scopebuffermax;
      readBufCur = (1-LoopStart) + (LoopStart-LoopEnd)*curPos;
      grainsFeedback.granulator_update(cGrainSize, useAbsoluteVar, grainVariance, useAbsoluteDist, grainOverlap, spd, spdSpread, panSpread, reverseProb, play_state, readBufCur, readBufMin, readBufMax, fbBuffer.scopeptr, curPos, pitchTimeInvariance, 1);
      
      grains.L += grainsFeedback.L;
      grains.R += grainsFeedback.R;
    );
  );
  
  spLeft  = grains.L * cPreGain;
  spRight = grains.R * cPreGain;
  
  filter1.updateFilter( F1_type, cCutoff1, cReso1 );
  filter1.evalSample( spLeft, spRight );
  spLeft  = filter1.outL;
  spRight = filter1.outR;
  
  filter2.updateFilter( F2_type, cCutoff2, cReso2 );
  filter2.evalSample( spLeft, spRight );
  spLeft  = filter2.outL;
  spRight = filter2.outR;
  
  fbL = outL = spLeft;
  fbR = outR = spRight;

  spl0 = ( outL + grainsFeedback.L ) * cPostGain;
  spl1 = ( outR + grainsFeedback.R ) * cPostGain;

@gfx
  graphicsIntensity = abs(sin(time_precise())); 
  
  /* Visual settings */
  ENVELOPE_FONT = 6;
  BUTTON_FONT = 7;
  KNOB_FONT = 5;
  TOGGLE_FONT = 5;
  KNOB_FONT2 = 5;
  HINT_FONT = 14;
  COMBO_SMALL = 13;
  gfx_setfont(ENVELOPE_FONT, "Arial", 10);
  gfx_setfont(BUTTON_FONT, "Arial", 10);
  gfx_setfont(KNOB_FONT, "Arial", 10);
  gfx_setfont(HINT_FONT, "Arial", 14);
  gfx_setfont(KNOB_FONT2, "Arial", 12);
  gfx_setfont(COMBO_SMALL, "Arial", 10);
  baseR = .3;
  baseG = .6;
  baseB = 1;
  selectionbutton_color_r = baseR;
  selectionbutton_color_g = baseG;
  selectionbutton_color_b = baseB;
  selectionbutton_color_a = 1;
  widgetcolor_r = widgetcolor_g = widgetcolor_b = widgetcolor_a = 1;
  env1_widget_r = baseR;
  env1_widget_g = baseG;
  env1_widget_b = baseB;
  env1_widget_a = 1;
  grid_color_r = grid_color_g = grid_color_b = grid_color_a = 1;
  font_color_r = font_color_g = font_color_b = font_color_a = 1;
  knob_font_color_r = knob_font_color_g = knob_font_color_b = 0; knob_font_color_a = 1;
  highlight_r = highlight_g = highlight_b = highlight_a = 1;
  envelope_curve_r = envelope_curve_g = envelope_curve_b = envelope_curve_a = 1;
  knob_font_color2_r = .3;
  knob_font_color2_g = .6;
  knob_font_color2_b = 1;
  knob_font_color2_a = 1;
  knob_ring_r = 0;
  knob_ring_g = .5;
  knob_ring_b = 1;
  knob_r = .1;
  knob_g = .2;
  knob_b = .8;
  knob_segments_r = .4;
  knob_segments_g = .4;
  knob_segments_b = 1;
  
  mod1_color_r = 1.0;
  mod1_color_g = 0.0;
  mod1_color_b = 1.0;
  mod1_color_a = 1.0;
  
  mod2_color_r = 1.0;
  mod2_color_g = 0.0;
  mod2_color_b = 1.0;
  mod2_color_a = 1.0;
  
  widget_r = .1;
  widget_g = .2;
  widget_b = .8;
  widget_a = 1.0;
  toggle_r = 1;
  toggle_g = .1;
  toggle_b = .1;
  toggle_a = 1.0;
  
  /* Render GUI */
  gfx_set(0,0.05,0.1,1);
  gfx_rect(0, 0, gfx_w, gfx_h);
  
  gfx_set(.1,.1,.2,.15+.1*sin(time_precise()));
  i = 0; dx = 15+sin(.1*time_precise());
  xmax = .5*gfx_w;
  ymax = gfx_h;
  loop(2*gfx_w / dx,
    gfx_line(xmax - ( xmax - xmax + dx*i ), 0, 0, ymax - (ymax-dx*i));
    i += 1;
  );
  
  gfx_set(.1,.1,.2,.15+.1*sin(time_precise()));
  i = 0; dx = 15+sin(.1*time_precise());
  xmax = 1.5*gfx_w;
  ymax = gfx_h;
  loop(2*gfx_w / dx,
    gfx_line(xmax - xmax + dx*i, ymax, xmax, ymax-dx*i);
    i += 1;
  );
  
  /* Render the waveform */
  audioX = .12*gfx_w;
  audioY = .05*gfx_h;
  audioW = .85*gfx_w;
  audioH = .6*gfx_h;
  gfx_set(baseR, baseG, baseB,.2);
  openRect(audioX-1, audioY-1, audioW+2, audioH+2);
  gfx_set(baseR, baseG, baseB,.5);
  openRect(audioX-2, audioY-2, audioW+4, audioH+4);
  gfx_set(baseR, baseG, baseB,1);
  openRect(audioX, audioY, audioW, audioH);
  outBuffer.drawbuffer(audioX, audioY, audioW, audioH, .5);

  /* Draw the grain heads */
  gfx_a = 0.5;
  grains.grainDrawHeads(audioX, audioY, audioW, audioH, outBuffer.scopeptr);  

  /* Start / Stop loop indicators and controls */
  startBar.initRect(audioX, audioY, audioW, audioH);
  endBar.initRect(audioX, audioY, audioW, audioH);
  gfx_set(baseR+1, baseG+1, baseB,.8);
  startBar.vertBar(6, LoopStart, mouse_x, mouse_y, mouse_cap) ? ( 
    LoopStart = startBar.xpos;
    (LoopStart > LoopEnd) ? ( LoopEnd = LoopStart; );
  );
  gfx_set(baseR+1, baseG+1, baseB,.8);
  endBar.vertBar(6, LoopEnd, mouse_x, mouse_y, mouse_cap) ? (
    LoopEnd = endBar.xpos;
    (LoopEnd < LoopStart) ? ( LoopStart = LoopEnd; );
  );  
  
  posBar.initRect(audioX, audioY, audioW, audioH);
  LEnd = 1-LoopEnd;
  LStart = 1-LoopStart;
  
  gfx_set(.8, 0, .8,.8);
  posBar.vertBar(6, (1-Position)*(LStart-LEnd) + LoopStart, mouse_x, mouse_y, mouse_cap) ? (
    Position = 1 - (posBar.xpos - LoopStart) /(LStart-LEnd);
    Position > 1 ? Position = 1;
    Position < 0 ? Position = 0;
  );
  
  gfx_set(1,1,0,1);
  ( feedbackLevel > 0 ) && ( updateBuffer == 0 ) ? (
    fbBuffer.drawbuffer(audioX, audioY, audioW, audioH, .5);
  );
  
  /* Draw envelopes */
  envX = audioX;
  envW = .48*audioW;
  envH = .4*audioH;
  envY = .95*gfx_h - envH;
  envWindow1.initEnvelope(envX, envY, envW, envH, 6, "ENVELOPE 1", env1_widget_r, env1_widget_g, env1_widget_b, env1_widget_a );    
  envWindow1.drawEnvelopeWindow();
  envWindow1.processMouseEnvelope();
  
  envX = audioX + envW + .04*audioW;
  envW = .48*audioW;
  envH = .4*audioH;
  envY = .95*gfx_h - envH;
  envWindow2.initEnvelope(envX, envY, envW, envH, 6, "ENVELOPE 2", env1_widget_r, env1_widget_g, env1_widget_b, env1_widget_a );    
  envWindow2.drawEnvelopeWindow();
  envWindow2.processMouseEnvelope();
  
  col1 = 35*(1+scaling);
  col2 = 90*(1+scaling);
  buttonSize = 6*(1+scaling);
  knobSize = 20*(1+scaling);
  comboModulatorYSize = 11*(1+scaling);
  comboModulatorXSize = 9*(1+scaling);
  
  freeze.drawToggle(audioX+knobSize, audioY+knobSize, buttonSize, buttonSize, 1-updateBuffer, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Freeze sampler.");
  freeze.label = "Freeze";
  updateBuffer = 1-freeze.processMouseToggle(mouse_x, mouse_y, mouse_cap);

  storeToggle.drawToggle(audioX+knobSize, audioY+2*knobSize, buttonSize, buttonSize, storeSample, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Read/Write sample in preset. Note: this increases load/save time\nand size of a preset considerably)..");
  storeToggle.label = "Store sample in preset";  
  storeSample = storeToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  bw = 16.5 * (1+scaling);
  bh = 12 * (1+scaling);
  crop.selectionButton(audioX+audioW-2.5*bw, audioY+.5*bh, 2*bw, bh, "CROP", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Crop to loop");
  crop.selectionButton_draw();
  crop.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);

  function memCpySlow( target, src, cnt )
  local(srcPtr, targetPtr)
  instance()
  global()
  (
    srcPtr = src;
    targetPtr = target;
    loop( cnt,
      targetPtr[] = srcPtr[];
      srcPtr += 1;
      targetPtr += 1;
    );
  );
  
  function cropBuffer( temporaryStorage, LoopStart, LoopEnd )
  local()
  instance(scopePtr, scopebuffermax, scopebuffer)
  global(len, startPos, endPos, copyLen, chunk1,
  _sP, _eP, _tmp, _cpLen, _sPtr, _doo, _lastCase)
  (
    len       = 2 * floor( ( scopebuffermax - scopebuffer + 1 ) * .5 );
    startPos  = 2 * floor((scopePtr - LoopStart * len) * .5 );
    copyLen   = ceil((LoopStart-LoopEnd) * len);
    endPos    = startPos + copyLen;
    
    _sP = startPos;
    _eP = endPos;
    _tmp = scopebuffer;
    _cpLen = copyLen;
    _sPtr = scopePtr;
    
    ( startPos < scopebuffer ) && ( endPos < scopebuffer ) ? (
      startPos += len;
      endPos   += len;
      
      // Considering that memcpy has restrictions over 65536 item ranges we just loopcopy
      memCpySlow( temporaryStorage, startPos, copyLen );
      scopeptr = scopebuffer;
      scopebuffermax = scopebuffer + copyLen;
      memCpySlow( scopeptr, temporaryStorage, copyLen );
      _lastCase = 1;
    ) : ( ( startPos < scopebuffer ) && ( endPos >= scopebuffer ) ) ? (
      // Case 2 - Only start pointer is beyond the start of the buffer
      startPos += len;
      chunk1 = scopebuffermax-startPos;
      memCpySlow( temporaryStorage, startPos, chunk1 );
      memCpySlow( temporaryStorage + chunk1, startPos, copyLen - chunk1 );

      scopebuffermax = scopebuffer + copyLen;
      memCpySlow( scopeptr, temporaryStorage, copyLen );
      _lastCase = 2;
    ) : ( 
      // Case 3 - Entire thing fits without modification
      memCpySlow( temporaryStorage, startPos, copyLen );
      scopeptr = scopebuffer;
      scopebuffermax = scopebuffer + copyLen;
      memCpySlow( scopebuffer, temporaryStorage, copyLen );
      _lastCase = 3;
    );
    
    _doo += 1;
  );
  
  crop.active == 1 ? (
    // Block buffer updates right now
    updateOld = updateBuffer;
    updateBuffer = 0;
    crop.active = 0;
        
    outBuffer.cropBuffer( temporaryBuf, 1-LoopStart, 1-LoopEnd );
    loopStart = 0;
    loopEnd = 1;
    updateBuffer = updateOld;
  );
  
  reset.selectionButton(audioX+audioW-5*bw, audioY+.5*bh, 2*bw, bh, "RESET", selectionbutton_color_r, selectionbutton_color_g, selectionbutton_color_b, selectionbutton_color_a, "Crop to loop");
  reset.selectionButton_draw();
  reset.selectionButton_processMouse(mouse_x, mouse_y, mouse_cap);
  reset.active == 1 ? (
    reset.active = 0;
    outBuffer.setBufferSize(bufSize-4);
    outBuffer.resetBuffer();
    
    fbBuffer.setBufferSize(outBuffer.getBufferSize());
    fbBuffer.resetBuffer();
  );
  
  /* Knob which controls the position */
  xPos = col1;
  yDist = 70*(1+scaling);
  comboW = 5.4*knobSize;
  comboH = knobSize;
  yDistCombo = 1.4*comboH;
  yPos = 100*(1+scaling);
  
  /* Combobox to select envelope for shaper */
  positionModulator.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  positionModulator.combobox_setcuritem(positionModulator);
  positionModulator.value = positionModulatorAmount;
  positionModulator.combomodulator_draw();
  positionModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    positionModulator       = positionModulator.curItem;
    positionModulatorAmount = positionModulator.value;
  );
  positionModulator.combobox_draw_top();
  
  positionKnob.active = 1;
  positionKnob.value  = position;
  positionKnob.value2 = positionModulatorAmount;//positionModulator.value;
  positionKnob.noSegments = 1;
  positionKnob.drawKnob(xPos, yPos, knobSize, "Position", "Modify position.");
  positionKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( Position = positionKnob.value );
  
  /* Knob which controls the variance */
  xPos = col2;
  
  absoluteVarianceToggle.drawToggle(xPos + 1.1*knobSize, yPos - 1.1*knobSize, buttonSize, buttonSize, useAbsoluteVar, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use absolute variance (decoupled from grain size)\n");
  useAbsoluteVar = absoluteVarianceToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  grainVarianceKnob.active = 1;
  grainVarianceKnob.value  = grainVariance/1000;
  grainVarianceKnob.noSegments = 1;
  grainVarianceKnob.drawKnob(xPos, yPos, knobSize, "Variance", "Modify grain position variance.");
  grainVarianceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .08) ? slider_automate( grainVariance = 1000*grainVarianceKnob.value; );
  
  yPos += yDist;
  
  /* Knob which controls the grain size */
  xPos = col1;  
  grainSizeKnob.active = 1;
  grainSizeKnob.value  = (grainSize-GRAINMIN)/(GRAINMAX-GRAINMIN);
  grainSizeKnob.value2 = sizeModulatorAmount;
  grainSizeKnob.noSegments = 1;
  grainSizeKnob.drawKnob(xPos, yPos, knobSize, "Size [ms]", "Modify grain size.");
  grainSizeKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .116) ? slider_automate( grainSize = (GRAINMAX-GRAINMIN)*grainSizeKnob.value+GRAINMIN );
  
  fixedSizeToggle.drawToggle(xPos + 1.1*knobSize, yPos - 1.1*knobSize, buttonSize, buttonSize, pitchTimeInvariance, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Maintain grain size when pitching.\n");
  pitchTimeInvariance = fixedSizeToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  /* Combobox to select envelope for speed modulator */
  sizeModulator.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  sizeModulator.combobox_setcuritem(sizeModulator);
  sizeModulator.value = sizeModulatorAmount;
  sizeModulator.combomodulator_draw();
  sizeModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    sizeModulator       = sizeModulator.curItem;
    sizeModulatorAmount = sizeModulator.value;
  );
  sizeModulator.combobox_draw_top();
  
  /* Knob which controls the grain overlap */
  xPos = col2;
  overlapKnob.active = 1;  
  
  overlapToggle.drawToggle(xPos + 1.1*knobSize, yPos - 1.1*knobSize, buttonSize, buttonSize, useAbsoluteDist, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Use absolute distances (decoupled from grain size).\n\nNote: This may mean running out of grains.\n");
  useAbsoluteDist = overlapToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  overlapKnob.value  = grainOverlap/OVERLAPMAX;
  overlapKnob.noSegments = 1;
  useAbsoluteDist ? (
    overlapKnob.drawKnob(xPos, yPos, knobSize, "Distance", "Modify distance between grains.");
  ) : (
    overlapKnob.drawKnob(xPos, yPos, knobSize, "Overlap", "Modify grain overlap (higher leads to denser, more constant sounds).");
  );
  overlapKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .9) ? slider_automate( grainOverlap = OVERLAPMAX*overlapKnob.value );
  
  yPos += yDist;  
  
  /* Knob which controls the gain */
  xPos = col1;
  pregainKnob.active = 1;
  pregainKnob.value  = preGain*.25;
  pregainKnob.value2 = preGainModulatorAmount;
  pregainKnob.noSegments = 1;
  pregainKnob.drawKnob(xPos, yPos, knobSize, "Pre-Gain", "Modify pre-gain.");
  pregainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .25) ? slider_automate( preGain = pregainKnob.value*4 );
  
  /* Combobox to select envelope for gain modulator */
  preGainModulatorSelect.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  preGainModulatorSelect.combobox_setcuritem(preGainModulator);
  preGainModulatorSelect.value = preGainModulatorAmount;
  preGainModulatorSelect.combomodulator_draw();
  preGainModulatorSelect.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    preGainModulator       = preGainModulatorSelect.curItem;
    preGainModulatorAmount = preGainModulatorSelect.value;
  );
  preGainModulatorSelect.combobox_draw_top();
  
  /* Knob which controls the grain variance */
  xPos = col2;
  minl = -6;
  maxl = 0;
  postGainKnob.active = 1;
  postGainKnob.value  = postGain*.25;
  postGainKnob.value2 = postGainModulatorAmount;
  postGainKnob.noSegments = 1;
  postGainKnob.drawKnob(xPos, yPos, knobSize, "Post-Gain", "Modify output gain.");
  postGainKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? slider_automate( postGain = 4*postGainKnob.value );  
  
  /* Combobox to select envelope for gain modulator */
  postGainModulatorSelect.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  postGainModulatorSelect.combobox_setcuritem(postGainModulator);
  postGainModulatorSelect.value = postGainModulatorAmount;
  postGainModulatorSelect.combomodulator_draw();
  postGainModulatorSelect.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    postGainModulator       = postGainModulatorSelect.curItem;
    postGainModulatorAmount = postGainModulatorSelect.value;
  );
  postGainModulatorSelect.combobox_draw_top();  
  
  yPos += yDist;  
  
  /* Knob which controls the speed */
  xPos = col1;
  speedKnob.active = 1;
  speedKnob.value  = (Speed-MINSPEED)/(MAXSPEED-MINSPEED);
  speedKnob.value2 = speedModulatorAmount;
  speedKnob.noSegments = 1;
  speedKnob.drawKnob(xPos, yPos, knobSize, "Pitch", "Modify grain speed / pitch.");
  speedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, .466666666666666666) ? slider_automate( Speed = (MAXSPEED-MINSPEED)*speedKnob.value+MINSPEED );
  
  /* Combobox to select envelope for speed modulator */
  speedModulator.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  speedModulator.combobox_setcuritem(speedModulator);
  speedModulator.value = speedModulatorAmount;
  speedModulator.combomodulator_draw();
  speedModulator.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    speedModulator       = speedModulator.curItem;
    speedModulatorAmount = speedModulator.value;
  );
  speedModulator.combobox_draw_top();
  
  /* Knob which controls the grain variance */
  xPos = col2;
  minl = -6;
  maxl = 0;
  speedVarianceKnob.active = 1;
  speedVarianceKnob.value  = (log(spdSpread)-minl)/(maxl-minl);
  speedVarianceKnob.noSegments = 1;
  speedVarianceKnob.drawKnob(xPos, yPos, knobSize, "Detune", "Modify speed variance (perceived as detune).");
  speedVarianceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( spdSpread = exp(minl + (maxl-minl)*speedVarianceKnob.value) );
  
  yPos += yDist;
  
  /* Knob which controls the panning */
  xPos = col2;
  panVarianceKnob.active = 1;
  panVarianceKnob.value  = panSpread;
  panVarianceKnob.noSegments = 1;
  panVarianceKnob.drawKnob(xPos, yPos, knobSize, "Pan Spread", "Level of randomization of grain panning.");
  panVarianceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( panSpread = panVarianceKnob.value );  
  
  /* Reference pitch */
  xPos = col1;
  followToggle.drawToggle(xPos + 1.1*knobSize, yPos - 1.1*knobSize, buttonSize, buttonSize, PitchFollow, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable pitch following.\n\nEnabling this makes the pitch follow the last played MIDI note.");
  PitchFollow = followToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  refPitchKnob.active = PitchFollow;
  refPitchKnob.value  = (RefNote + 48)/96;
  refPitchKnob.noSegments = 1;
  refPitchKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? ( slider_automate( RefNote = refPitchKnob.value*96-48 ); updatePitch(); );
  sprintf( 5, "%d", floor(refPitchKnob.value*96-48) );
  refPitchKnob.label = 5;
  refPitchKnob.drawKnob(xPos, yPos, knobSize, "Ref Note", "Reference pitch for MIDI input.");
  yPos += 70*(1+scaling);  
  
  /* Knob which controls the minimum shift for the octaver */
  xPos = col1;
  octaverToggle.drawToggle(xPos + 1.1*knobSize, yPos - 1.1*knobSize, buttonSize, buttonSize, Octaver, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Enable pitch following.\n\nEnabling this makes the pitch follow the last played MIDI note.");
  Octaver = octaverToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);
  
  octaveMinKnob.active = 1;
  octaveMinKnob.value  = (octaveMin+4)/8;
  octaveMinKnob.noSegments = 1;
  octaveMinKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( octaveMin = 8*octaveMinKnob.value-4 );
  sprintf( 5, "%d", floor(octaveMinKnob.value*8-4) );
  octaveMinKnob.label = 5;
  octaveMinKnob.drawKnob(xPos, yPos, knobSize, "Min Octave", "Minimum octave to randomize over.");
  
  /* Knob which controls the max for the octaver */
  xPos = col2;
  octaveMaxKnob.active = 1;
  octaveMaxKnob.value  = (octaveMax+4)/8;
  octaveMaxKnob.noSegments = 1;
  octaveMaxKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( octaveMax = 8*octaveMaxKnob.value-4 );
  sprintf( 5, "%d", floor(octaveMaxKnob.value*8-4) );
  octaveMaxKnob.label = 5;
  octaveMaxKnob.drawKnob(xPos, yPos, knobSize, "Max Octave", "Maximum octave to randomize over.");
  
  yPos += yDist;
  
  /* Knob which controls the reverse probability */
  xPos = col1;
  reverseProbKnob.active = 1;
  reverseProbKnob.value  = reverseProb;
  reverseProbKnob.noSegments = 1;
  reverseProbKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( reverseProb = reverseProbKnob.value );
  reverseProbKnob.drawKnob(xPos, yPos, knobSize, "Reverse", "Reverse Probability.");
  
  /* Knob which controls the reverse probability */
  xPos = col2;
  fbKnob.active = 1;
  fbKnob.value  = feedbackLevel;
  fbKnob.noSegments = 1;
  fbKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( feedbackLevel = fbKnob.value );
  fbKnob.drawKnob(xPos, yPos, knobSize, "Feedback", "Feedback strength."); 
  
  yPos += yDist;
  
  /* Filter 1 */    
  xPos = col1;
  F1cutoffModulatorCtrl.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  F1cutoffModulatorCtrl.combobox_setcuritem(F1CutoffModulator);
  F1cutoffModulatorCtrl.value = F1CutoffModulatorAmount;
 F1cutoffModulatorCtrl.combomodulator_draw();
  F1cutoffModulatorCtrl.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    F1CutoffModulator       = F1cutoffModulatorCtrl.curItem;
    F1CutoffModulatorAmount = F1cutoffModulatorCtrl.value;
  );
  F1cutoffModulatorCtrl.combobox_draw_top();  
    
  F1freqKnob.active = 1;
  F1freqKnob.value  = F1_freq;
  F1freqKnob.value2 = F1CutoffModulatorAmount;
  F1freqKnob.noSegments = 1;
  F1freqKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( F1_freq = F1freqKnob.value );
  F1freqKnob.drawKnob(xPos, yPos, knobSize, "Cutoff", "Filter 1 Frequency");
  
  xPos = col2;
  F1resModulatorCtrl.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  F1resModulatorCtrl.combobox_setcuritem(F1ResModulator);
  F1resModulatorCtrl.value = F1ResModulatorAmount;
  F1resModulatorCtrl.combomodulator_draw();
  F1resModulatorCtrl.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    F1ResModulator       = F1resModulatorCtrl.curItem;
    F1ResModulatorAmount = F1resModulatorCtrl.value;
  );
  F1resModulatorCtrl.combobox_draw_top();
  
  F1resKnob.active = 1;
  F1resKnob.value  = F1_res;
  F1resKnob.value2 = F1ResModulatorAmount;
  F1resKnob.noSegments = 1;
  F1resKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( F1_res = F1resKnob.value );
  F1resKnob.drawKnob(xPos, yPos, knobSize, "Reso", "Filter 1 Resonance"); 
    
  yPos += yDist;
  
  xPos = col1;
  F1select.combobox(xPos-1.3*knobSize, yPos - 1.5*knobSize, comboW, comboH, widget_r, widget_g, widget_b, widget_a, nFilters, 2, 1, 1, COMBOFONT, "Filter selection" );
  F1select.combobox_setcuritem( F1_type );
  F1select.combobox_draw();
  F1select.combobox_draw_top();
  F1select.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? slider_automate( F1_type = F1select.curitem );
  
  yPos += yDistCombo;
  
  /* Filter 2 */
  xPos = col1;
  F2cutoffModulatorCtrl.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  F2cutoffModulatorCtrl.combobox_setcuritem(F2CutoffModulator);
  F2cutoffModulatorCtrl.value = F2CutoffModulatorAmount;
  F2cutoffModulatorCtrl.combomodulator_draw();
  F2cutoffModulatorCtrl.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    F2CutoffModulator       = F2cutoffModulatorCtrl.curItem;
    F2CutoffModulatorAmount = F2cutoffModulatorCtrl.value;
  );
  F2cutoffModulatorCtrl.combobox_draw_top();  
  
  F2freqKnob.active = 1;
  F2freqKnob.value  = F2_freq;
  F2freqKnob.value2 = F2CutoffModulatorAmount;
  F2freqKnob.noSegments = 1;
  F2freqKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( F2_freq = F2freqKnob.value );
  F2freqKnob.drawKnob(xPos, yPos, knobSize, "Cutoff", "Filter 2 Frequency");
  
  xPos = col2;
  F2resModulatorCtrl.combobox(xPos - 1.3*knobSize, yPos - 1.5*knobSize, comboModulatorXSize, comboModulatorYSize, .4, .4, .8, 1, nModulators, 1, 1, 1, COMBO_SMALL, "Select modulator." );
  F2resModulatorCtrl.combobox_setcuritem(F2ResModulator);
  F2resModulatorCtrl.value = F2ResModulatorAmount;
  F2resModulatorCtrl.combomodulator_draw();
  F2resModulatorCtrl.combomodulator_processMouse(mouse_x, mouse_y, mouse_cap) ? (
    F2ResModulator       = F2resModulatorCtrl.curItem;
    F2ResModulatorAmount = F2resModulatorCtrl.value;
  );
  F2resModulatorCtrl.combobox_draw_top();
  
  F2resKnob.active = 1;
  F2resKnob.value  = F2_res;
  F2resKnob.value2 = F2ResModulatorAmount;
  F2resKnob.noSegments = 1;
  F2resKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? slider_automate( F2_res = F2resKnob.value );
  F2resKnob.drawKnob(xPos, yPos, knobSize, "Reso", "Filter 2 Resonance");   
  
  yPos += yDist;
  
  xPos = col1;
  F2select.combobox(xPos-1.3*knobSize, yPos - 1.5*knobSize, comboW, comboH, widget_r, widget_g, widget_b, widget_a, nFilters, 2, 1, 1, COMBOFONT, "Filter selection" );
  F2select.combobox_setcuritem( F2_type );
  F2select.combobox_draw();
  F2select.combobox_draw_top();
  F2select.combobox_processMouse(mouse_x, mouse_y, mouse_cap) ? slider_automate( F2_type = F2select.curitem );
  
  yPos += yDistCombo;
  
  /* Draw logo */
  loaded = 0;
  !loaded || (modVisible != lastModVisible) ? (
    ( modVisible == 0 ) ? (
      loaded = gfx_loadimg(5, "./Amaranth_Dependencies/logo4.png");
    );
    lastModVisible = modVisible;
  );
  gfx_x = -111;
  gfx_y = -20;

  recSpeed = .3+.5*rand();
  lsMod = lsMod * (1-recSpeed) + lightState * recSpeed;
  gfx_a = .2 + .8*lsMod;
  rand() > lightProb ? (
    lightState = 1-lightState;
  );
  lightState ? (
    lightProb = lightProb + .1;
    lightProb > .99 ? lightProb = .99;
  ) : (
    lightProb = .5;
  );

  gfx_blit(5, .56*(1+scaling), 0);
  
  /*gfx_getdropfile(0, 14);
  gfx_x = 0;
  gfx_y = 50;
  gfx_printf(14);
  gfx_getdropfile(-1);*/
  
  hinter.drawHint_draw();
  
  gfx_x = 0;
  gfx_set(1,0,0,1);
  gfx_y = gfx_h-10;
  gfx_printf( "DO NOT USE !!! ALPHA !!! SLIDERS WILL CHANGE !!! DO NOT USE !!! ALPHA !!! SLIDERS WILL CHANGE !!! DO NOT USE !!! ALPHA !!! SLIDERS WILL CHANGE !!! DO NOT USE !!! ALPHA !!! SLIDERS WILL CHANGE !!! DO NOT USE !!! ALPHA !!! SLIDERS WILL CHANGE !!! " );
