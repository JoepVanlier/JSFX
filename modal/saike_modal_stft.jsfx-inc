@init
function fft_mem(freemem)
instance(prev_fft_size, fft_size
         overlap_factor,
         fft_interval,
         in_fft_mem, out_fft_mem, window_mem,
         input_mem, output_mem,
         fft_idx, output_idx,
         fft_scaling_factor,
         buffer_size)
global()
local(gain, i, r, a0, a1, a2, a3, a4)
(
  fft_size = 64;
  buffer_size = 65536;
  
  /* Make sure we start on a boundary */
  freemem = ceil(freemem / 65536) * 65536;
  freemem = (in_fft_mem = freemem) + 2 * fft_size;
  freemem = (out_fft_mem = freemem) + 2 * fft_size;
  freemem = (window_mem = freemem) + 2 * fft_size;
  freemem = (input_mem = freemem) + buffer_size;
  freemem = (output_mem = freemem) + buffer_size;
  
  // Hann
  a0 = 0.5;
  a1 = 0.5;
  a2 = a3 = a4 = 0;
  overlap_factor = fft_size / ceil(fft_size/4);
  gain = 5 / 0.375;//0.5 * 0.55;
  
  // Blackmann-Harris
  a0 = 0.35875;
  a1 = 0.48829;
  a2 = 0.14128;
  a3 = 0.01168;
  a4 = 0;
  overlap_factor = fft_size / ceil(fft_size/3); // Actually attained overlap with a target of 3
//  gain = 0.25 / 0.35875;
  gain = 5 / 0.25796335495;
  
  output_idx = 0;
  fft_idx = 0;
  fft_interval = fft_size / overlap_factor;
  fft_scaling_factor = gain / overlap_factor / overlap_factor / fft_size / fft_size;
  
  fft_size != prev_fft_size ? (
    prev_fft_size = fft_size;
    
    i = 0;
    loop(2 * fft_size,
      r = (i + 0.5) / (2 * fft_size);
      window_mem[i] = sqrt(fft_scaling_factor) * (a0 - a1 * cos(2 * $pi * r) + a2 * cos(4 * $pi * r) - a3 * cos(6 * $pi * r) + a4 * cos(8 * $pi * r));
      i += 1;
    );
  );
  freemem
);

function string_mem(freemem, _fft_size, _fft_interval, _in_fft_mem, _out_fft_mem)
instance(
  max_partial,
  bin_mem, coeff_mem, mix_mem, state_mem,
  fft_size, fft_interval,
  in_fft_mem, out_fft_mem,
)
local()
global()
(
  // Allocate memory for this string, note that in and out fft_mem have to be preallocated.
  
  max_partial = 1024;
  freemem = (bin_mem = freemem) + 2 * max_partial;
  freemem = (coeff_mem = freemem) + 2 * max_partial;
  freemem = (mix_mem = freemem) + 2 * max_partial;
  freemem = (state_mem = freemem) + 2 * max_partial;
  
  fft_size = _fft_size;
  fft_interval = _fft_interval;
  in_fft_mem = _in_fft_mem;
  out_fft_mem = _out_fft_mem;
  
  freemem
);

function set_pars_stft_basic(f_0)
global(inharm, base_damp, f_damp, relative_position, soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, max_bin)
instance(bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    k_inc = 1 + model;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      f_k = f_0 * k * sqrt(1 + inharm * (k-1) * (k-1));
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * fft_interval / srate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + f_damp * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * sin(k * $pi * relative_position) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += k_inc;
    );
    ticker = 0;
  );
);


function set_pars_stft_messy(f_0)
global(inharm, base_damp, f_damp, relative_position, soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, k_inc, offset, max_bin)
instance(bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    offset = 3;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      loop(2,
        offset = 3 - offset;
        f_k = f_0 * k * sqrt(1 + inharm * (k-1) * (k-1)) + offset * (1 + .05 * k * k) * (0.1 + relative_position);
        omega_k = 2.0 * $pi * f_k;
        advance = omega_k * fft_interval / srate;
        bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
        
        bin < max_bin ? (
          bin_mem[num_partials] = bin;
          damp = exp(- (base_damp + f_damp * omega_k * (1 + f_k / 1000)) * irate);
          
          coeff_mem[idx] = cos(advance) * damp;
          coeff_mem[idx + 1] = sin(advance) * damp;
            
          mix_mem[num_partials] = 0.5 * Adivfs * ((2 * floor(k / 2) != floor(k)) + 0.08) * 100 * (k * soundboard_factor) / f_k;
          num_partials += 1; idx += 2;
        );
      );
      k += 1;
    );
    ticker = 0;
  );
);

function set_pars_stft_beam(f_0, clamped)
global(inharm, base_damp, f_damp, relative_position, soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin)
instance(bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      clamped ? (
        (k == 1) ? (
          f_k = f_0 * 0.59686420;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 1.49417560;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 2.50024690;
        ) : ( k == 4 ) ? (
          f_k = f_0 * 3.49998930;
        ) : ( 
          f_k = f_0 * (k - 0.5);
        );
      ) : (
        (k == 1) ? (
          f_k = f_0 * 1.5056187;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 2.4997527;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 3.5000107;
        ) : ( 
          f_k = f_0 * (k + 0.5);
        );
      );
      f_k *= (1 + inharm * k);
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * fft_interval / srate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (f_damp / 1000) * omega_k * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * sin(k * $pi * relative_position) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);


function set_pars_stft_marimba(f_0)
global(inharm, base_damp, f_damp, relative_position, soundboard_factor, srate, Adivfs, model)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials, max_bin, camp)
instance(bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    max_bin = (2 * fft_size - 2);
    loop(partials,
      camp = 1;
      (k < 9) ? (
        (k == 1) ? (
          f_k = f_0;
        ) : ( k == 2 ) ? (
          f_k = f_0 * 1.911076; // Torsional
          camp = 0.04 + 0.2 * relative_position;
        ) : ( k == 3 ) ? (
          f_k = f_0 * 4;
        ) : ( k == 4 ) ? (
          f_k = f_0 * 10.25;
        ) : ( k == 5 ) ? (
          f_k = f_0 * 14.2511700468; // Torsional
          camp = 0.04 + 0.3 * relative_position;
        ) : ( k == 6 ) ? (
          f_k = f_0 * 17.745709828; // Torsional
          camp = 0.04 + 0.3 * relative_position;
        ) : ( k == 7 ) ? (
          f_k = f_0 * 19;
        ) : ( k == 8 ) ? (
          f_k = f_0 * 24.352574; // Torsional
          camp = 0.04 + 0.2 * relative_position;
        );
      ) : ( 
        f_k = f_0 * k * 2;
        camp = 0.09;
      );
      f_k *= sqrt((1 + inharm * k * k));
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * fft_interval / srate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < max_bin ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (20/k) + (f_damp / 1000) * omega_k * omega_k) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * camp * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);


function set_pars_stft_drum(f_0)
global(inharm, base_damp, f_damp, relative_position, soundboard_factor, srate, Adivfs, model, bessel_roots)
local(idx, k, f_k, omega_k, advance, bin, irate, damp, partials)
instance(bin_mem, coeff_mem, mix_mem, state_mem, fft_size, fft_interval, ticker, num_partials)
(
  ticker += 1;
  ticker > 256 ? (
    memset(coeff_mem, 0, 2 * fft_size);
    memset(mix_mem, 0, fft_size);
    
    partials = floor(0.5 * srate / f_0);
    irate = fft_interval / srate;
    
    k = 1;
    idx = 0;
    num_partials = 0;
    loop(198,
      f_k = f_0 * bessel_roots[k - 1] * (1 + inharm * k * k);
      omega_k = 2.0 * $pi * f_k;
      advance = omega_k * fft_interval / srate;
      bin = 2 * floor((f_k / srate) * (2 * fft_size) + 0.5);
      
      bin < (2 * fft_size - 2) ? (
        bin_mem[num_partials] = bin;
        damp = exp(- (base_damp + (10/k) + (f_damp / 1000) * (omega_k * omega_k)) * irate);
        
        coeff_mem[idx] = cos(advance) * damp;
        coeff_mem[idx + 1] = sin(advance) * damp;
          
        mix_mem[num_partials] = Adivfs * sin(k * $pi * relative_position) * 100 * (k * soundboard_factor) / f_k;
        num_partials += 1; idx += 2;
      );
      k += 1;
    );
    ticker = 0;
  );
);

function set_pars_stft(f_0)
local()
global(model)
instance()
(
  (model < 2) ? (
    this.set_pars_stft_basic(f_0);
  ) : (model == 2) ? (
    this.set_pars_stft_messy(f_0);
  ) : (model == 3) ? (
    this.set_pars_stft_beam(f_0, 0);
  ) : (model == 4) ? (
    this.set_pars_stft_beam(f_0, 1);
  ) : (model == 5) ? (
    this.set_pars_stft_drum(f_0);
  ) : (model == 6) ? (
    this.set_pars_stft_marimba(f_0);
  );
);

function process_block(in_fft_mem, out_fft_mem, active)
instance(fft_size, fft_interval, coeff_mem, mix_mem, state_mem, bin_mem, num_partials)
global(srate)
local(f_bin, ix, tix, tmp, bin, coeff_real, coeff_imag, state_real, state_imag)
(
  // Update the resonators
  convolve_c(state_mem, coeff_mem, num_partials + 1);
  
  ix = 0; tix = 0;  
  active ? (
    loop(num_partials,
      bin = bin_mem[ix];
      state_mem[tix] += mix_mem[ix] * in_fft_mem[bin];
      state_mem[tix + 1] += mix_mem[ix] * in_fft_mem[bin + 1];
      
      ix += 1; tix += 2;
    );
  );

  ix = 0; tix = 0;
  loop(num_partials,
    bin = bin_mem[ix];
    out_fft_mem[bin] += state_mem[tix];
    out_fft_mem[bin + 1] += state_mem[tix + 1];
    ix += 1; tix += 2;
  );
);


function read_block(input_mem, input_idx, fft_loc, window_ptr, len, buffer_size)
local(fft_ptr)
instance()
global()
(
  input_idx -= len;
  fft_ptr = fft_loc;
  input_idx < 0 ? input_idx += buffer_size;
  loop(len,
    input_idx == buffer_size ? input_idx = 0;
    fft_ptr[] = input_mem[input_idx] * window_ptr[];
    window_ptr += 1;
    input_idx += 1;
    fft_ptr += 1;
  );
  
  fft_real(fft_loc, len);
  fft_permute(fft_loc, len / 2);
);


function write_block(output_mem, output_idx, fft_ptr, window_ptr, len, buffer_size)
local()
instance()
global()
(
  fft_ptr[0] += fft_ptr[1];
  //fft_ptr[0] = sqrt(fft_ptr[0] * fft_ptr[0] + fft_ptr[1] * fft_ptr[1]);
  fft_ptr[1] = 0; // Kill Nyquist
  fft_ipermute(fft_ptr, len / 2);
  ifft_real(fft_ptr, len);

  loop(len,
    (output_idx == buffer_size) ? output_idx = 0;
    output_mem[output_idx] += fft_ptr[] * window_ptr[];
    fft_ptr += 1;
    window_ptr += 1;
    output_idx += 1;
  );
);


function read_stft(f_h)
local()
global()
instance(
  f_hn, f_b,
  fft_idx, fft_interval,
  input_mem, input_idx,
  in_fft_mem, out_fft_mem, window_mem,
  fft_size, buffer_size
)
(
  f_hn = f_b = 0;
  input_idx == buffer_size ? input_idx = 0;
  input_mem[input_idx] = f_h;
  
  (fft_idx == fft_interval) ? (
    read_block(input_mem, input_idx, in_fft_mem, window_mem, fft_size * 2, buffer_size);
    memset(out_fft_mem, 0, fft_size * 2);
  );
  
  input_idx += 1;
);


function write_stft()
local()
global()
instance(
  f_hn, f_b,
  fft_idx, fft_interval,
  output_mem, output_idx,
  out_fft_mem, window_mem,
  fft_size, buffer_size,
)
(
  (fft_idx == fft_interval) ? (
    write_block(output_mem, output_idx, out_fft_mem, window_mem, fft_size * 2, buffer_size);
    fft_idx = 0;
  );
  
  output_idx == buffer_size ? output_idx = 0;
  f_hn = f_b = output_mem[output_idx];
  output_mem[output_idx] = 0;
  
  fft_idx += 1;
  output_idx += 1;
);


function eval_string_stft(f_h, on)
instance(
  fft_idx,
  in_fft_mem, out_fft_mem,
  fft_interval
)
global()
local()
(
  (fft_idx == fft_interval) ? (    
    this.process_block(in_fft_mem, out_fft_mem, on);
    fft_idx = 0;
  );
  
  fft_idx += 1;
);

