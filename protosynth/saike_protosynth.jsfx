desc:Protosynth
options:maxmem=20000000
tags: instrument
version: 0.01
author: Joep Vanlier
changelog: WIP
license: MIT
provides:
  protosynth_dependencies/*

<?
  tuning_basic = 0.5;
  loop(i=0;8,
    par = i * 6 + 1;
    printf("slider%d:osc%d_gain=-9<-72,0,0.0001>-osc%d gain\n", par, i + 1, i + 1);
    printf("slider%d:osc%d_tune=%f<0.25,8,0.0001>-osc%d tune\n", par + 1, i + 1, tuning_basic, i + 1);
    printf("slider%d:osc%d_spacing=1<0.25,8,0.0001>-osc%d spacing\n", par + 2, i + 1, i + 1);
    printf("slider%d:osc%d_brightness=0.2<0.0,0.95,.0001>-osc%d brightness\n", par + 3, i + 1, i + 1);
    printf("slider%d:osc%d_spacing_offset=0<0,5000.0001>-osc%d spacing offset\n", par + 4, i + 1, i + 1);
    tuning_basic *= 1.5;
    
    i += 1
  );
?>

<?
  loop(i=0;6,
    par = i * 5 + 49;
    printf("slider%d:env%d_attack=3.0<3.0,3000.0,0.0001:log>-env%d attack\n", par, i + 1, i + 1);
    printf("slider%d:env%d_decay=30.0<30.0,3000.0.0001:log>-env%d decay\n", par + 1, i + 1, i + 1);
    printf("slider%d:env%d_sustain=0.7<0.0,1.0,0.0001>-env%d sustain\n", par + 2, i + 1, i + 1);
    printf("slider%d:env%d_release=300.0<30.0,3000.0,0.0001:log>-env%d release\n", par + 3, i + 1, i + 1);
    printf("slider%d:env%d_amount=1<0.0,1.0,0.0001>-env%d amount\n", par + 4, i + 1, i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;4,
    par = i * 5 + 90;
    printf("slider%d:mod%d_type=0<0,18,1>-mod%d_type\n", par, i + 1, i + 1);
    printf("slider%d:mod%d_freq=0.0<0.0,20.0.0001:log>-mod%d freq\n", par + 1, i + 1, i + 1);
    printf("slider%d:mod%d_phase=0<0.0,1.0,0.0001>-mod%d phase\n", par + 2, i + 1, i + 1);
    printf("slider%d:mod%d_lr=0.0<0.0,1.0,0.0001>-mod%d lr\n", par + 3, i + 1, i + 1);
    printf("slider%d:mod%d_amount=0.0<0.0,1.0,0.0001>-mod%d amount\n", par + 4, i + 1, i + 1);
    
    i += 1;
  );
?>

slider128:mix_mode1=0<0,2,1>-Mix mode 1
slider129:mix_mode2=0<0,2,1>-Mix mode 2
slider130:mix_mode3=0<0,2,1>-Mix mode 3
slider131:mix_mode4=0<0,2,1>-Mix mode 4
slider132:mix_mode21=0<0,2,1>-Mix mode 21
slider133:mix_mode22=0<0,2,1>-Mix mode 22
slider134:mix_mode31=0<0,2,1>-Mix mode 31

slider135:cutoff21=0<0,1,0.001>-Cutoff Mix 21
slider136:resonance21=0<0,1,0.001>-Resonance Mix 21
slider137:morph21=0<0,1,0.001>-Morph Mix 21

slider138:cutoff22=0<0,1,0.001>-Cutoff Mix 22
slider139:resonance22=0<0,1,0.001>-Resonance Mix 22
slider140:morph22=0<0,1,0.001>-Morph Mix 22

slider141:type31=0<0,16,1>-Filter Type
slider142:drive31=0<0,1,0.001>-Drive Mix
slider143:cutoff31=0<0,1,0.001>-Cutoff Mix
slider144:resonance31=0<0,1,0.001>-Resonance Mix
slider145:morph31=0<0,1,0.001>-Morph Mix

slider146:f1_cutoff=1<0,1,0.000001>-F1 Cutoff
slider147:f1_reso=0<0,1,0.000001>-F1 Resonance
slider148:f1_morph=0<0,1,0.000001>-F1 Morph

slider149:f2_cutoff=1<0,1,0.000001>-F2 Cutoff
slider150:f2_reso=0<0,1,0.000001>-F2 Resonance
slider151:f2_morph=0<0,1,0.000001>-F2 Morph

slider152:f3_cutoff=1<0,1,0.000001>-Output Filter Cutoff
slider153:f3_reso=0<0,1,0.000001>-Output Filter Resonance
slider154:f3_morph=0<0,1,0.000001>-Output Filter Morph

slider155:f3_type=0<0,16,1>Output Filter Type

slider255:chorus_amount=0<0,1,0.0001>Chorus amount
slider256:noise=0<0,1,0.0001:log>Noise

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import saike_proto_synth_oscillators.jsfx-inc
import saike_proto_synth_kp_midi.jsfx-inc
import saike_proto_synth_pixel_gfx.jsfx-inc
import saike_proto_stft_fx.jsfx-inc
import saike_proto_synth_filters.jsfx-inc
//import saike_proto_pitchlib.jsfx-inc
import saike_proto_synth_fx.jsfx-inc

@init
env_color = 0.5;
mod_color = 0.08;
SLOW_UPDATE_FACTOR = 16;
MAX_VOICES = 12;
<?
  N_OSCS = 8;
  N_MODULATORS = 6;
  N_ENVELOPES = 6;
  N_SELECTABLE_MODULATORS = 10;
?>
N_SELECTABLE_MODULATORS = 10;

<?MAX_VOICES = 12;?>
INV_SLOW_UPDATE_FACTOR = 1.0 / SLOW_UPDATE_FACTOR;

model = 5;

<?
  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.init_slider_ui(%d, -72, 0, 0);\n", i + 1, par);
    printf("tune_slider%d.init_slider_ui(%d, 0.25, 8.0, 0);\n", i + 1, par + 1);
    printf("spacing_slider%d.init_slider_ui(%d, 0.25, 8.0, 0);\n", i + 1, par + 2);
    printf("brightness_slider%d.init_slider_ui(%d, 0.0, 0.95, 0);\n", i + 1, par + 3);
    printf("spacing_offset_slider%d.init_slider_ui(%d, 0, 5000.0, 0);\n", i + 1, par + 4);
    
    printf("(gain_slider%d.gain_mod_target == 0) ? gain_slider%d.gain_mod_target = 1;\n cx += 10;", i + 1, i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;N_ENVELOPES,
    par = i * 5 + 49;
    printf("env_attack_slider%d.init_slider_ui(%d, 3.0, 3000.0, 1);\n", i + 1, par);
    printf("env_decay_slider%d.init_slider_ui(%d, 30.0, 3000.0, 1);\n", i + 1, par + 1);
    printf("env_sustain_slider%d.init_slider_ui(%d, 0, 1.0, 0);\n", i + 1, par + 2);
    printf("env_release_slider%d.init_slider_ui(%d, 30, 3000.0, 1);\n", i + 1, par + 3);
    
    printf("env_attack_slider%d.color=env_color;\n", i + 1);
    printf("env_decay_slider%d.color=env_color;\n", i + 1);
    printf("env_sustain_slider%d.color=env_color;\n", i + 1, par + 2);
    printf("env_release_slider%d.color=env_color;\n", i + 1, par + 3);
    
    i += 1;
  );
?>

<?
  loop(i=0;N_MODULATORS,
    par = i * 5 + 90;
    printf("mod_type_slider%d.init_slider_ui(%d, 0, 18, 0);\n", i + 1, par);
    printf("mod_freq_slider%d.init_slider_ui(%d, 0.0, 20.0, 0);\n", i + 1, par + 1);
    printf("mod_phase_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 2);
    printf("mod_lr_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 3);
    printf("mod_amount_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 4);
    
    printf("mod_type_slider%d.color=mod_color;\n", i + 1);
    printf("mod_freq_slider%d.color=mod_color;\n", i + 1);
    printf("mod_phase_slider%d.color=mod_color;\n", i + 1, par + 2);
    printf("mod_lr_slider%d.color=mod_color;\n", i + 1, par + 3);
    printf("mod_amount_slider%d.color=mod_color;\n", i + 1, par + 4);
    
    i += 1;
  );
?>

<?
  loop(i=0;3,
    par = i * 3 + 146;
    printf("f_cutoff_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par);
    printf("f_reso_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 1);
    printf("f_morph_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 2);
    i += 1;
  );
?>

function init_voice(freemem)
local()
global()
instance(
  osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, modulator_mem
)
(
  freemem = (modulator_mem = freemem) + 32;
  memset(modulator_mem, 0, 32);
  
  <?loop(i=1;8,
    printf("osc%d.init_dsf_osc();\n", i);
    printf("osc%d.init_ssaw();\n", i);
    i += 1;
  )?>
  
  freemem
);

function init_voice_mixers(freemem, shared_fft_buffer, window_buffer)
local()
global()
instance(mix1, mix2, mix3, mix4, mix21, mix22, mix31)
(
  freemem = mix1.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix2.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix3.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix4.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix21.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix22.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix31.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  
  freemem
);

twopi = 2 * $pi;

function lfo_modulator(shape, dt)
instance(state, lt, ct, y, t)
global(twopi)
local()
(
  shape = floor(shape);
  t += dt;
  y = ( shape == 0 ) ? .5 + .5 * sin(twopi*t)
  : ( shape==1 )  ? ( abs(cos($pi*t)) )
  : ( shape==2 )  ? ( abs(sin($pi*t)) )
  : ( shape==3 )  ? ( t-floor(t) )
  : ( shape==4 )  ? ( 1-t+floor(t) )
  : ( shape==5 )  ? ( exp(-4*(t-floor(t))) )
  : ( shape==6 )  ? ( min((15*(t-floor(t))),1)*exp(-4*(t-floor(t))) )
  : ( shape==7 )  ? ( 1-exp(-4*(t-floor(t))) )
  : ( shape==8 ) ? ( exp(-t) )    
  : ( shape==9 ) ? ( min((15*t),1)*exp(-t) )
  : ( shape==10 ) ? ( 1-2*abs(t-floor(t)-0.5) )
  : ( shape==11 ) ? ( sin(twopi*t)*.3+.5 + sin(2*twopi*t)*.2 )
  : ( shape==12 ) ? ( sin(twopi*t)*.2+.5 + sin(2*twopi*t)*.2 + sin(4*twopi*t)*.1 )
  : ( shape==13 ) ? ( (t-floor(t)) < .0625 )
  : ( shape==14 ) ? ( (t-floor(t)) < .125 )
  : ( shape==15 ) ? ( (t-floor(t)) < .25 )
  : ( shape==16 ) ? ( (t-floor(t)) < .5 )
  : ( shape==17 ) ? ( (t-floor(t)) < (lt-floor(lt)) ? ct = rand(); lt = t; ct )
  : ( shape==18 ) ? ( rand() );
  
  t == 0 ? state = y;
  state = .98 * state + .02 * y
);


function lfo_type(type)
(
  type = floor(type);
  (type == 0) ? "sine"
  : (type == 1) ? "abscos"
  : (type == 2) ? "abssin"
  : (type == 3) ? "rampup"
  : (type == 4) ? "rampdn"
  : (type == 5) ? "expdwn"
  : (type == 6) ? "exp"
  : (type == 7) ? "expup"
  : (type == 8) ? "1expdn"
  : (type == 9) ? "1exp"  // Exp up and down
  : (type == 10) ? "tri"
  : (type == 11) ? "harm2"
  : (type == 12) ? "harm3"
  : (type == 13) ? "16th"
  : (type == 14) ? "8th"
  : (type == 15) ? "4th"
  : (type == 16) ? "2th"
  : (type == 17) ? "S&H"
  : (type == 18) ? "noise"
);

function update_voice()
local(cur_freq, cur_spacing, cur_brightness, cfreq, noise_factor, atk, gain, f_cutoff, f_reso, f_morph, m1, m2, c_mod_freq)
global(
  INV_SLOW_UPDATE_FACTOR,
  slow_update_srate,
  midi.active_note_mem, midi.active_note_vel,
  rel_spacing, freq_atten, n_update,
  
  <?loop(i=1;8, printf("osc%d_enabled,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_gain,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_tune,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_brightness,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_spacing,", i); i += 1);?>,
  <?loop(i=1;8, printf("osc%d_spacing_offset,", i); i += 1);?>,
  noise,
  <?loop(i=1;N_ENVELOPES, printf("env%d_atk_samples,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_k_atk,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_k_decay,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_k_release,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_sustain,", i); i += 1);?>
  
  <?loop(i=1;8, printf("gain_slider%d.gain_mod_target,", i); i += 1);?>
  <?loop(i=1;8, printf("gain_slider%d.mod_target1,", i); i += 1);?>
  <?loop(i=1;8, printf("gain_slider%d.mod_amount1_clamped,", i); i += 1);?>
  
  <?loop(i=1;8, printf("tune_slider%d.mod_target1, tune_slider%d.mod_amount1_clamped, tune_slider%d.get_modulated_value1, tune_slider%d.sl, tune_slider%d.sl_max, tune_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;8, printf("spacing_slider%d.mod_target1, spacing_slider%d.mod_amount1_clamped, spacing_slider%d.get_modulated_value1, spacing_slider%d.sl, spacing_slider%d.sl_max, spacing_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;8, printf("brightness_slider%d.mod_target1, brightness_slider%d.mod_amount1_clamped, brightness_slider%d.get_modulated_value1, brightness_slider%d.sl, brightness_slider%d.sl_max, brightness_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  
  filter1_enabled, filter2_enabled, filter3_enabled,
  <?loop(i=1;3, printf("f_cutoff_slider%d.mod_target1, f_cutoff_slider%d.mod_amount1_clamped, f_cutoff_slider%d.mod_target2, f_cutoff_slider%d.mod_amount2_clamped, f_cutoff_slider%d.get_modulated_value1, f_cutoff_slider%d.sl, f_cutoff_slider%d.sl_max, f_cutoff_slider%d.sl_min,", i, i, i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;3, printf("f_reso_slider%d.mod_target1, f_reso_slider%d.mod_amount1_clamped, f_reso_slider%d.mod_target2, f_reso_slider%d.mod_amount2_clamped, f_reso_slider%d.get_modulated_value1, f_reso_slider%d.sl, f_reso_slider%d.sl_max, f_reso_slider%d.sl_min,", i, i, i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;3, printf("f_morph_slider%d.mod_target1, f_morph_slider%d.mod_amount1_clamped, f_morph_slider%d.mod_target2, f_morph_slider%d.mod_amount2_clamped, f_morph_slider%d.get_modulated_value1, f_morph_slider%d.sl, f_morph_slider%d.sl_max, f_morph_slider%d.sl_min,", i, i, i, i, i, i, i, i); i += 1);?>
  
  <?loop(i=1;N_MODULATORS, printf("mod_freq_slider%d.mod_target1, mod_freq_slider%d.mod_amount1_clamped, mod_freq_slider%d.sl, mod_freq_slider%d.sl_max, mod_freq_slider%d.sl_min,", i, i, i, i, i); i += 1);?>
  
  <?loop(i=1;N_MODULATORS, printf("mod%d_type, mod%d_freq, mod%d_phase, mod%d_lr, mod%d_amount,", i, i, i, i, i); i += 1; );?>
)
instance(
  midi_idx,
  freq, osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, rand_src,
  g1, g2, g3, g4, g5, g6, g7, g8,
  dg1, dg2, dg3, dg4, dg5, dg6, dg7, dg8,
  has_output,
  on,
  current_sample, pressed, has_played,
  modulator_mem,
  <?loop(i=1;N_MODULATORS, printf("mod%d_lfo,", i); i += 1; );?>
)
(
  // Modulator handling
  <?
    function get_modulated_value1_preproc(target, slider_name, idx)
    (
      printf("
        %s = %s%d.mod_target1 ? (
            max(min(slider(%s%d.sl) + %s%d.mod_amount1_clamped * modulator_mem[%s%d.mod_target1], %s%d.sl_max), %s%d.sl_min)
          ) : slider(%s%d.sl);
        ",
        target,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx
      )
    );
    
    function get_modulated_value1_preproc_ranged(target, slider_name, idx)
    (
      printf("
        %s = %s%d.mod_target1 ? (
            max(min(slider(%s%d.sl) + %s%d.mod_amount1_clamped * (%s%d.sl_max - %s%d.sl_min) * modulator_mem[%s%d.mod_target1], %s%d.sl_max), %s%d.sl_min)
          ) : slider(%s%d.sl);
        ",
        target,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx
      )
    );
    
    function get_modulated_value2_preproc(target, slider_name, idx)
    (
      printf("
        %s = (%s%d.mod_target1 || %s%d.mod_target2) ? (
            m1 = %s%d.mod_target1 ? %s%d.mod_amount1_clamped * modulator_mem[%s%d.mod_target1] : 0;
            m2 = %s%d.mod_target2 ? %s%d.mod_amount2_clamped * modulator_mem[%s%d.mod_target2] : 0;
            max(min(slider(%s%d.sl) + m1 + m2, %s%d.sl_max), %s%d.sl_min)
          ) : slider(%s%d.sl);
        ",
        target,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx
      )
    );
  ?>
  
  // Update envelopes and modulators
  <?loop(i=1;N_ENVELOPES, printf("atk = current_sample < env%d_atk_samples; modulator_mem[%d] += (atk ? env%d_k_atk : pressed ? env%d_k_decay : env%d_k_release) * (max(atk, env%d_sustain * pressed) - modulator_mem[%d]);\n", i, i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;N_MODULATORS, 
    get_modulated_value1_preproc_ranged("c_mod_freq", "mod_freq_slider", i);
    printf("modulator_mem[%d] = mod%d_lfo.lfo_modulator(mod%d_type, slow_update_srate * c_mod_freq);\n", i + N_ENVELOPES, i, i);
    i += 1);
  ?>
  
  has_output = max(max(max(max(max(max(max(max(g1, g2), g3), g4), g5), g6), g7), g8), pressed) > 0.0001;
  (!has_output) ? (
    on = 0;
    // Flag as available for new midi notes
    has_played ? (
      midi.active_note_mem[midi_idx] = 0;
      midi.active_note_vel[midi_idx] = 0;
      has_played = 0;
    );
  );
  
  rand_src = 0.9 * rand_src + 0.1 * rand();
  noise_factor = (1 - noise) + (noise + noise) * rand_src;
  cfreq = freq * noise_factor;
  
  // Update oscillators
  <?
    loop(i=1;8,
      printf("osc%d_enabled ? (", i);
        printf("gain = min(0, osc%d_gain + (gain_slider%d.mod_target1 ? 72 * gain_slider%d.mod_amount1_clamped * modulator_mem[gain_slider%d.mod_target1] : 0));", i, i, i, i);
        printf("dg%d = INV_SLOW_UPDATE_FACTOR * (10^(0.05 * gain) * modulator_mem[gain_slider%d.gain_mod_target] - g%d);", i, i, i);
      
        get_modulated_value1_preproc_ranged("cur_freq", "tune_slider", i);
        printf("cur_freq *= cfreq;");
        get_modulated_value1_preproc_ranged("cur_spacing", "spacing_slider", i);
        get_modulated_value1_preproc("cur_brightness", "brightness_slider", i);
      
        printf("osc%d.update_dsf_osc(cur_freq, cur_spacing * cur_freq + osc%d_spacing_offset, cur_brightness, 0);\n", i, i);
        //printf("osc%d.update_ssaw_osc(cur_freq, cur_spacing, cur_brightness, 0);\n", i);
      printf(") : (");
        printf("g%d = 0; dg%d = 0;", i, i);
      printf(");");

      i += 1
    );
  ?>
  
  // Only run the filter coefficient computation when there's a voice playing
  has_output ? (
    <?
    loop(i=1;3,
      printf("filter%d_enabled ? (\n", i);
      get_modulated_value2_preproc("f_cutoff", "f_cutoff_slider", i);
      get_modulated_value2_preproc("f_reso", "f_reso_slider", i);
      get_modulated_value2_preproc("f_morph", "f_morph_slider", i);
      
      // Basic SVF
      printf("this.filter%d.L.init_linearSVF_all(f_cutoff, f_reso, f_morph);", i);
      printf("this.filter%d.R.init_linearSVF_all(f_cutoff, f_reso, f_morph);", i);
      printf(");\n");
      
      //printf("this.filter%d.init_filter(0, f_cutoff, f_cutoff, f_morph, f_morph, f_reso);", i+1);
      i += 1;
    );
    ?>
  );
  
  current_sample += 1;
);

function initialize_envelopes()
local(to_samples, sample_rate, log001, log001tds)
global(
  srate,
  SLOW_UPDATE_FACTOR,
  <?loop(i=1;N_ENVELOPES, printf("env%d_attack,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_decay,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_sustain,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_release,", i); i += 1);?>
  
  <?loop(i=1;N_ENVELOPES, printf("env%d_atk_samples,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_k_atk,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_k_decay,", i); i += 1);?>
  <?loop(i=1;N_ENVELOPES, printf("env%d_k_release,", i); i += 1);?>
)
instance(current_sample, has_played)
(
  sample_rate = srate / SLOW_UPDATE_FACTOR;
  to_samples = 0.001 * sample_rate;  // Since times were specified in ms
  log001 = log(0.01);
  log001tds = log001 / to_samples;
  current_sample = 0;
  has_played = 1;
  
  <?
    loop(i=1;N_ENVELOPES,
      printf("env%d_atk_samples = env%d_attack * to_samples;\n", i, i);
      printf("env%d_k_atk = - log001 / env%d_atk_samples;\n", i, i);
      printf("env%d_k_decay = - log001tds / env%d_decay;\n", i, i);
      printf("env%d_k_release = - log001tds / env%d_release;\n", i, i);
      i += 1;
    );
  ?>
);

function play_voice()
local(
  o1, o2, o3, o4, o5, o6, o7, o8, t1, t2,
)
global(
  mix_mode1, mix_mode2, mix_mode3, mix_mode4,
  mix_mode21, mix_mode22,
  mix_mode31,
  filter1_enabled, filter2_enabled, filter3_enabled,
)
instance(
  mix1, mix2, mix3, mix4, mix21, mix22, mix31,
  osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, l, r
  g1, g2, g3, g4, g5, g6, g7, g8,
  dg1, dg2, dg3, dg4, dg5, dg6, dg7, dg8,
)
(
  <?
    function gen_mixer(mix_out, mix_id, o1, o2)
    (
      printf(
        "o%d = (mix_mode%d == 0) ? (o%d + o%d) 
        : (mix_mode%d == 1) ? (o%d * (1.0 + o%d)) 
        : (mix_mode%d == 2) ? (o%d * o%d) 
        : (mix_mode%d == 3) ? (min(max(o%d, o%d), min(o%d, o%d))) 
        : (mix_mode%d == 4) ? (t1 = o%d + o%d; t2 = o%d - o%d; min(max(t1, t2), -min(t1, t2))) 
        : (mix_mode%d == 5) ? (mix%d.process_stft_mixer(o%d, o%d); mix%d.out_left)
        : (mix_mode%d == 6) ? (this.ofs%d.freq_shift_audio_rate(o%d, 16 * this.freq * o%d));",
        mix_out, 
        mix_id, o1, o2, 
        mix_id, o1, o2, 
        mix_id, o1, o2, 
        mix_id, o1, o2, o1, o2, 
        mix_id, o1, o2, o1, o2,
        mix_id, mix_id, o1, o2, mix_id,
        mix_id, mix_id, o1, o2
      );
    );
  ?>
  
  o1 = g1 ? osc1.dsf_step() * g1;
  o2 = g2 ? osc2.dsf_step() * g2;
  <?gen_mixer(1, 1, 1, 2);?>
  
  o3 = g3 ? osc3.dsf_step() * g3;
  o4 = g4 ? osc4.dsf_step() * g4;
  <?gen_mixer(2, 2, 3, 4);?>

  o5 = g5 ? osc5.dsf_step() * g5;
  o6 = g6 ? osc6.dsf_step() * g6;
  <?gen_mixer(3, 3, 5, 6);?>
  
  o7 = g7 ? osc7.dsf_step() * g7;
  o8 = g8 ? osc8.dsf_step() * g8;
  <?gen_mixer(4, 4, 7, 8);?>
  
  <?gen_mixer(1, 21, 1, 2);?>
  o1 = filter1_enabled ? this.filter1.L.eval_linearSVF_all(o1) : o1;
  
  <?gen_mixer(2, 22, 3, 4);?>
  o2 = filter2_enabled ? this.filter2.L.eval_linearSVF_all(o2) : o2;
  
  <?gen_mixer(1, 31, 1, 2);?>
  l = filter3_enabled ? this.filter3.L.eval_linearSVF_all(o1) : o1;
  r = filter3_enabled ? this.filter3.R.eval_linearSVF_all(o1) : o1;
 
 // l = r = o1;
 
  <?loop(i=1;8, printf("g%d += dg%d;\n", i, i); i += 1);?>
);
  
function stop_voice()
local()
instance(on)
global()
(
  on = 0;
);


function pitch_to_freq(pitch)
local(scaling, frac, temp)
global(microtuned, tuning_memory, sample_time, ln)
instance()
(
  microtuned ? (
    temp = min(127, max(0, pitch + 69));
    frac = temp - floor(temp);
    ln = temp;
    (pow(tuning_memory[temp], (1.0 - frac)) * pow(tuning_memory[temp + 1], frac))
  ) : (
    440 * 2 ^ (pitch / 12)
  );
);

function process_midi(note_idx, active, vel, state, ref_pitch)
local()
global(initialize_envelopes, modulator_mem)
instance(on, freq, pressed, current_sample, midi_idx)
(
  midi_idx = note_idx;
  (state == 1) ? (
    // Note on
    on = 1;
    freq = pitch_to_freq(active + ref_pitch);
    pressed = 1;
    this.initialize_envelopes();
    this.update_voice();
  ) : (state == -1) ? (
    // Release
    pressed = 0;
    current_sample = 100000000000000000; // Make sure we are beyond the attack
  );
);


function update_notes()
instance(
  notes_on, active_note_mem, active_note_vel, active_note_state, note_history,
  last_count
)
global(
  midi.pitchbend, midi.last_vel,
  latest_note,
  pitchbend_range,
  pitch_shift,
  glide,
  v0.on, v1.on, v2.on, v3.on, 
  v4.on, v5.on, v6.on, v7.on, 
  v8.on, v9.on, v10.on, v11.on,
  v0.process_midi, v1.process_midi, v2.process_midi, v3.process_midi,
  v4.process_midi, v5.process_midi, v6.process_midi, v7.process_midi,
  v8.process_midi, v9.process_midi, v10.process_midi, v11.process_midi,
)
local(
  ref_pitch, remainder,
)
(
  ref_pitch = pitchbend_range * midi.pitchbend + pitch_shift - 69;
  
  latest_note = note_history[notes_on - 1];
  glide ? (
    v1.on = v2.on = v3.on = v4.on = v5.on = v6.on = v7.on = v8.on = v9.on = v10.on = v11.on = 0;
    
    (notes_on > 0) ? (
      v0.process_midi(latest_note, active_note_mem[latest_note], active_note_vel[latest_note], active_note_state[latest_note], ref_pitch);
    ) : (
      v0.process_midi(latest_note, active_note_mem[latest_note], active_note_vel[latest_note], -1, ref_pitch);
    );
  ) : (
    v0.process_midi(0, active_note_mem[0], active_note_vel[0], active_note_state[0], ref_pitch);
    v1.process_midi(1, active_note_mem[1], active_note_vel[1], active_note_state[1], ref_pitch);
    v2.process_midi(2, active_note_mem[2], active_note_vel[2], active_note_state[2], ref_pitch);
    v3.process_midi(3, active_note_mem[3], active_note_vel[3], active_note_state[3], ref_pitch);
    v4.process_midi(4, active_note_mem[4], active_note_vel[4], active_note_state[4], ref_pitch);
    v5.process_midi(5, active_note_mem[5], active_note_vel[5], active_note_state[5], ref_pitch);
    v6.process_midi(6, active_note_mem[6], active_note_vel[6], active_note_state[6], ref_pitch);
    v7.process_midi(7, active_note_mem[7], active_note_vel[7], active_note_state[7], ref_pitch);
    v8.process_midi(8, active_note_mem[8], active_note_vel[8], active_note_state[8], ref_pitch);
    v9.process_midi(9, active_note_mem[9], active_note_vel[9], active_note_state[9], ref_pitch);
    v10.process_midi(10, active_note_mem[10], active_note_vel[10], active_note_state[10], ref_pitch);
    v11.process_midi(11, active_note_mem[11], active_note_vel[11], active_note_state[11], ref_pitch);
    

    // Update note parameters
    /*note_on0 ? ( string1.set_pars(pitch_to_freq(note_on0 + ref_pitch), note_vel0, 0); string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0; );
    note_on1 ? ( string2.set_pars(pitch_to_freq(note_on1 + ref_pitch), note_vel1, 0); string2.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel1; );
    note_on2 ? ( string3.set_pars(pitch_to_freq(note_on2 + ref_pitch), note_vel2, 0); string3.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel2; );
    note_on3 ? ( string4.set_pars(pitch_to_freq(note_on3 + ref_pitch), note_vel3, 0); string4.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel3; );
    note_on4 ? ( string5.set_pars(pitch_to_freq(note_on4 + ref_pitch), note_vel4, 0); string5.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel4; );
    
    (note_state0 == -1) ? (string1.damp_string(); string1.update_freq(); );
    (note_state1 == -1) ? (string2.damp_string(); string2.update_freq(); );
    (note_state2 == -1) ? (string3.damp_string(); string3.update_freq(); );
    (note_state3 == -1) ? (string4.damp_string(); string4.update_freq(); );
    (note_state4 == -1) ? (string5.damp_string(); string5.update_freq(); );*/
  );
  
  memset(active_note_state, 0, 12);
  last_count = notes_on;
);

freemem = 0;
freemem = midi.init_midi(freemem);

MAX_FFT_SIZE = 32768;
freemem = (shared_window_buffer = freemem) + MAX_FFT_SIZE;
freemem = (shared_fft_buffer = freemem) + MAX_FFT_SIZE;

<?
/*  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.serialize(version);\n", i + 1);
    printf("tune_slider%d.serialize(version);\n", i + 1);
    printf("spacing_slider%d.serialize(version);\n", i + 1);
    printf("brightness_slider%d.serialize(version);\n", i + 1);
    printf("spacing_offset_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
*/
?>

<?
  loop(i=0;MAX_VOICES, printf("freemem = v%d.init_voice(freemem);\n", i); i += 1;);
  loop(i=0;MAX_VOICES, printf("freemem = v%d.init_voice_mixers(freemem, shared_fft_buffer, shared_window_buffer);\n", i); i += 1;);
?>

freemem = chorus.init_chorus(freemem, 340);


midi.reset_midi();

CURRENT_VERSION = 5;
version = CURRENT_VERSION;

@serialize
file_var(0, version);

<?
  loop(i=0;8,
    printf("gain_slider%d.serialize(version);\n", i + 1);
    printf("tune_slider%d.serialize(version);\n", i + 1);
    printf("spacing_slider%d.serialize(version);\n", i + 1);
    printf("brightness_slider%d.serialize(version);\n", i + 1);
    printf("spacing_offset_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
?>

version <= 3 ? (
  stored_envelopes = 8;
) : (
  stored_envelopes = 6;
);
<?
  loop(i=0;8,
    printf("(%d < stored_envelopes) ? (", i);
    printf("env_attack_slider%d.serialize(version);\n", i + 1);
    printf("env_decay_slider%d.serialize(version);\n", i + 1);
    printf("env_sustain_slider%d.serialize(version);\n", i + 1);
    printf("env_release_slider%d.serialize(version);\n", i + 1);
    printf(");", i);
    i += 1;
  );
?>

<?
  loop(i=1;3,
    printf("f_cutoff_slider%d.serialize(version);\n", i);
    printf("f_reso_slider%d.serialize(version);\n", i);
    printf("f_morph_slider%d.serialize(version);\n", i);
    i += 1;
  );
?>

(version > 2) ? (
  file_var(0, filter1_enabled);
  file_var(0, filter2_enabled);
  file_var(0, filter3_enabled);
) : (
  filter1_enabled = filter2_enabled = filter3_enabled = 0;
);

(version > 3) ? (
  <?
    loop(i=0;N_MODULATORS,
      printf("mod_type_slider%d.serialize(version);\n", i + 1);
      printf("mod_freq_slider%d.serialize(version);\n", i + 1);
      printf("mod_phase_slider%d.serialize(version);\n", i + 1);
      printf("mod_lr_slider%d.serialize(version);\n", i + 1);
      printf("mod_amount_slider%d.serialize(version);\n", i + 1);
      i += 1;
    );
  ?>
);

(version > 4) ? (
  <?
    loop(i=0;N_OSCS,
      printf("file_var(0, osc%d_enabled);", i + 1);
      i += 1;
    );
  ?>
) : (
  <?
    loop(i=0;N_OSCS,
      printf("osc%d_enabled = 0;", i + 1);
      i += 1;
    );
    printf("osc1_enabled = 1;");
  ?>
);

version = CURRENT_VERSION;

@slider

@block
slow_update_srate = SLOW_UPDATE_FACTOR / srate;

(last_srate != srate) ? (
  init_freq_shift_modulator();
  oversampling = 1;
  last_srate = srate;
  israte = 1.0 / srate;
  tpiT = 2.0 * $pi / srate;
  sampling_ratio = legacy_mode ? 1 : 44100 / srate;
  sampling_factor = oversampling / sampling_ratio;
  isampling_factor = 1 / sampling_factor;
);
//israte_radian = 2.0*$pi*israte;

pass_through = 1;
midi.midi_block(pass_through);

@sample
freq_shift_modulator_sample();

midi.curSample += 1;
midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi_input = 1;
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

big_tick = update_ticker == 0;
update_ticker += 1;
(update_ticker > 128) ? (
  update_ticker = 0;
);

big_tick ? (
  midi.update_notes();
);

((n_update % SLOW_UPDATE_FACTOR) == 0) ? (
  v0.update_voice();
  v1.update_voice();
  v2.update_voice();
  v3.update_voice();
  v4.update_voice();
  v5.update_voice();
  v6.update_voice();
  v7.update_voice();
  v8.update_voice();
  v9.update_voice();
  v10.update_voice();
  v11.update_voice();
);

v0.has_output ? v0.play_voice() : (v0.l = v0.r = 0);
v1.has_output ? v1.play_voice() : (v1.l = v1.r = 0);
v2.has_output ? v2.play_voice() : (v2.l = v2.r = 0);
v3.has_output ? v3.play_voice() : (v3.l = v3.r = 0);
v4.has_output ? v4.play_voice() : (v4.l = v4.r = 0);
v5.has_output ? v5.play_voice() : (v5.l = v5.r = 0);
v6.has_output ? v6.play_voice() : (v6.l = v6.r = 0);
v7.has_output ? v7.play_voice() : (v7.l = v7.r = 0);
v8.has_output ? v8.play_voice() : (v8.l = v8.r = 0);
v9.has_output ? v9.play_voice() : (v9.l = v9.r = 0);
v10.has_output ? v10.play_voice() : (v10.l = v10.r = 0);
v11.has_output ? v11.play_voice() : (v11.l = v11.r = 0);

spl0 += v0.l + v1.l + v2.l + v3.l + v4.l + v5.l + v6.l + v7.l + v8.l + v9.l + v10.l + v11.l;
spl1 += v0.r + v1.r + v2.r + v3.r + v4.r + v5.r + v6.r + v7.r + v8.r + v9.r + v10.r + v11.r;

chorus.apply_chorus(chorus_amount);

last_gain += d_gain;

n_update += 1;

@gfx
loaded = 0;
!loaded ? (
  loaded = gfx_loadimg(12, "./protosynth_dependencies/font.png");
  gfx_setimgdim(13, img_w, img_h);
);

function reset_color()
(
  gfx_r = gfx_g = gfx_b = 0.0; gfx_a = 1.0;
  gfx_mode = 1;
);

img_w = 320;
img_h = 245;

/* Background color */
gfx_dest = 13;
gfx_clear = 0;
gfx_set(0, 0, 0, 1);
gfx_rect(0, 0, img_w, img_h);
reset_color();

gfx_a = 0.1;
pad_width = 70;
pad_height = 70;
pad_spacing = 31;

side_pad = 8;
toggle_size = 6;

gfx_set(0.7, 0.5, 0.2, 0.3);
cx = side_pad;
cy = 0;
//osc1_enabled.choice_toggle(cx, cy, toggle_size, 0, 10, "Enable Oscillator 1", "Enable OSC1"); cx += toggle_size + 2;

<?
  function uuid()
  (
    next_uuid += 1
  );
  
  loop(i=0;8,
    printf("cx = side_pad;\n");
    printf("osc%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, osc%d_enabled, \"Enable Oscillator %d\", \"Enable OSC%d\") ? (osc%d_enabled = 1 - osc%d_enabled;);\ncx += toggle_size + 2;", i + 1, i + 1, i + 1, i + 1, i + 1, i + 1);
    printf("txt_blit(\"OSC%d\", cx, cy + 2); cx += 25;", i + 1);
    
    printf("gain_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Gain envelope to apply\", \"OSC Envelope\", 1, 6, 0);\n cx += 10;", i + 1, uuid());
    printf("gain_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", osc%d_gain), \"Gain\", \"Gain\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("gain_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Gain envelope to apply\", \"OSC Envelope\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    
    printf("tune_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_tune), \"Tuning\", \"Tuning\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("tune_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Tuning modulator to apply\", \"Tune Modulation\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    
    printf("spacing_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_spacing), \"Partial spacing\", \"Freq spacing\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("spacing_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Spacing modulator to apply\", \"Spacing Modulation\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    
    printf("brightness_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_brightness), \"Brightness\", \"Brightness\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("brightness_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Brightness modulator to apply\", \"Brightness Modulation\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    
    printf("cy += 8;");
    i += 1;
  );
?>
cy += 5;
cy_ref = cy;
<?
  loop(i=0;N_ENVELOPES,
    printf("cx = side_pad;\n");
    printf("env%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, 1, \"Enable Envelope %d\", \"Enable ENV%d\");\ncx += toggle_size + 2;", i + 1, i + 1, i + 1);
    printf("env%d_enabled.color=env_color;\n", i + 1);
    printf("txt_blit(\"ENV%d\", cx, cy + 2); cx += 25;", i + 1);
    printf("env_attack_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_attack), \"Attack\", \"Attack\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_decay_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_decay), \"Decay\", \"Decay\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_sustain_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%d\", 100 * env%d_sustain), \"Sustain\", \"Sustain\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_release_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_release), \"Release\", \"Release\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("cy += 8;");
    i += 1;
  );
?>

cy += 5;
<?
  loop(i=0;4,
    printf("cx = side_pad;\n");
    printf("mod%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, 1, \"Enable Modulator %d\", \"Enable MOD%d\");\ncx += toggle_size + 2;", i + 1, i + 1);
    printf("mod%d_enabled.color=mod_color;\n", i + 1);
    printf("txt_blit(\"MOD%d\", cx, cy + 2); cx += 25;", i + 1);
    
    printf("mod_type_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%s\", lfo_type(mod%d_type)), \"Type\", \"Type\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    
    printf("mod_freq_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\dHz\", mod%d_freq), \"Frequency\", \"Frequency\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_freq_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Envelope to apply\", \"Envelope\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    
    printf("mod_phase_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%d\", 100 * mod%d_phase), \"Phase\", \"Phase\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_phase_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Envelope to apply\", \"Envelope\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    
    printf("mod_lr_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", 100 * mod%d_lr), \"Spread\", \"Spread\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_amount_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", 100 * mod%d_amount), \"Amount\", \"Amount\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("cy += 8;");
    i += 1;
  );
?>

tune_slider1.active = 1;

//(x, y, w, select, slider_idx, hint, info)
cx = side_pad;
cy += 4;

function node(x, y, w, h, text, text_offset)
instance(_x, _y, _w, _h, x_from, x_to, y_from, y_to)
(
  gfx_set(0.2, 0.2, 0.3, 1.0);
  _x = x; _y = y; _w = w; _h = h;
  gfx_rect(x, y, w, h, 0);
  x_from = x + w;
  y_from = y + 0.5 * h;
  x_to = x;
  y_to = y + 0.5 * h;
  
  text ? (
    txt_blit(text, x + text_offset, y + 2);
  );
);

function mix_node(x, y, w, h, slider_idx)
instance()
local(value, text, mouse_nx, mouse_ny, over, ix)
global(gfx_a, gfx_x, gfx_y, mouse_x, mouse_y, x_offset, y_offset, blit_scale, cap_mode, last_cap, mouse_cap)
(
  value = slider(slider_idx);
  text = (value == 0) ? "ADD"
  : (value == 1) ? "AMP"
  : (value == 2) ? "MUL"
  : (value == 3) ? "XOR"
  : (value == 4) ? "XOD"
  : (value == 5) ? "CON"
  : (value == 6) ? "FrS";
  this.node(x, y, w, h, text, 2);

  mouse_nx = (mouse_x - x_offset) / blit_scale;
  mouse_ny = (mouse_y - y_offset) / blit_scale;
  over = ((mouse_nx > x) && (mouse_nx < (x + w)) && (mouse_ny > y) && (mouse_ny < (y + w)) && (cap_mode == 0));

  ((last_cap == 0) && over) ? (
    (mouse_cap == 2) ? (
      gfx_x = mouse_x;
      gfx_y = mouse_y;
      ix = gfx_showmenu("Additive mixing|Amplitude modulation|Ring modulation (multiply signals)|XOR|XOR on diff|Convolve|Freq Shift");
      (ix > 0) ? (
        slider(slider_idx) = ix - 1;
      );
    );
  );
);

function cline(x1, y1, x2, y2)
(
  gfx_line(floor(x1), floor(y1) - 0.5, floor(x2), floor(y2) - 0.5, 1);
  gfx_line(floor(x1), floor(y1), floor(x2), floor(y2), 0);
  gfx_line(floor(x1), floor(y1) + 0.5, floor(x2), floor(y2) + 0.5, 1);
);

block_size = 8;
spacing = 10;
left_side = 10;
start = cy;
cx = left_side;
cy = start;

//input_size = 
<?
  loop(i=0;8,
    printf("n1%d.node(cx, cy, block_size, block_size, 0, 0);", i);
    printf("cy += block_size + 2;");
    i += 1;
  );
?>

cx = left_side + block_size + spacing;
cy = start + 0.5 * (block_size + 2);

<?
  current_slider = 128; /* First mix slider */
  loop(i=0;4,
    printf("n2%d.mix_node(cx, cy, 2 * block_size + 2, block_size, %d);", i, current_slider);
    printf("cy += 2 * (block_size + 2);");
    i += 1;
    current_slider += 1;
  );
?>

cx = left_side + 3 * block_size + 2 * spacing;
cy = start + 0.5 * 3 * (block_size + 2);

<?
  loop(i=0;2,
    printf("n3%d.mix_node(cx, cy, 2 * block_size + 2, block_size, %d);", i, current_slider);
    printf("cy += 4 * (block_size + 2);");
    i += 1;
    current_slider += 1;
  );
?>

cx = left_side + 5 * block_size + 3 * spacing;
cy = start + 0.5 * 3 * (block_size + 2);

<?
  loop(i=0;2,
    printf("n4%d.node(cx, cy, 2 * block_size - 1, block_size, \"F%d\", 3);", i, i + 1);
    printf("!filter%d_enabled ? ( gfx_set(0, 0, 0, 0.7); gfx_rect(cx, cy, 2 * block_size - 1, block_size, 1); );", i + 1);
    printf("cy += 4 * (block_size + 2);");
    i += 1;
  );
?>

cx = left_side + 7 * block_size + 4 * spacing;
cy = start + 3.5 * (block_size + 2);
n5.mix_node(cx, cy, 2 * block_size + 2, block_size, 134);

cy += 4 * (block_size + 2);
cx += 2 * block_size + spacing;
cy = start + 3.5 * (block_size + 2);
n6.node(cx, cy, 2 * block_size - 1, block_size, "F3", 3);
!filter3_enabled ? ( gfx_set(0, 0, 0, 0.7); gfx_rect(cx, cy, 2 * block_size - 1, block_size, 1); );


gfx_a = 1.0;

gfx_set(0.2, 0.2, 0.3, 1.0);
cline(n10.x_from, n10.y_from, n20.x_to, n20.y_to);
cline(n11.x_from, n11.y_from, n20.x_to, n20.y_to);
cline(n12.x_from, n12.y_from, n21.x_to, n21.y_to);
cline(n13.x_from, n13.y_from, n21.x_to, n21.y_to);
cline(n14.x_from, n14.y_from, n22.x_to, n22.y_to);
cline(n15.x_from, n15.y_from, n22.x_to, n22.y_to);
cline(n16.x_from, n16.y_from, n23.x_to, n23.y_to);
cline(n17.x_from, n17.y_from, n23.x_to, n23.y_to);

cline(n20.x_from, n20.y_from, n30.x_to, n30.y_to);
cline(n21.x_from, n21.y_from, n30.x_to, n30.y_to);
cline(n22.x_from, n22.y_from, n31.x_to, n31.y_to);
cline(n23.x_from, n23.y_from, n31.x_to, n31.y_to);

cline(n30.x_from, n30.y_from, n40.x_to, n40.y_to);
cline(n31.x_from, n31.y_from, n41.x_to, n41.y_to);

cline(n40.x_from, n40.y_from, n5.x_to, n5.y_to);
cline(n41.x_from, n41.y_from, n5.x_to, n5.y_to);

cline(n5.x_from, n5.y_from, n6.x_to, n6.y_to);
//gfx_line(n50.x_from, n50.y_from, n60.x_to, n60.y_to);

// sprintf(9, \"%%\.1f\", f%d_morph)
function morph_level(morph)
(
  (morph < 0.2) ? (
    "LP"
  ) : ( morph < 0.4 ) ? (
    "BP"
  ) : ( morph < 0.6 ) ? (
    "HP"
  ) : ( morph < 0.8 ) ? (
    "BR"
  ) : (
    "LP"
  )
);

cx = 120;
cy = 208;
<?
  loop(i=0;3,
    printf("cx = 130;\n");//side_pad;\n");
    printf("filt%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, filter%d_enabled, \"Enable Filter %d\", \"Enable F%d\") ? (filter%d_enabled = 1 - filter%d_enabled);\ncx += toggle_size + 2;", i + 1, i + 1, i + 1, i+1, i + 1, i + 1, i + 1);
    printf("txt_blit(\"F%d\", cx, cy + 2); cx += 15;", i + 1);
    
    printf("center = 0.5 * sampling_ratio * srate * exp((1.0 - min(f_cutoff_slider%d.display_value, 0.99999)) * log(20/22050));\n", i + 1);
    printf("f_cutoff_slider%d.active = filter%d_enabled;\n", i + 1, i + 1);
    printf("f_cutoff_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, center < 1000 ? sprintf(1, \"%%dHz\", center) : sprintf(1, \"%%.1fk\", center/1000), \"Filter %d cutoff\", \"F%d Cutoff\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1, i + 1, i + 1, i + 1);
    printf("f_cutoff_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Cutoff envelope to apply\", \"F%d Cutoff Env\", 0, 10, 1);\n cx += 8;", i + 1, uuid(), i + 1);
    printf("f_cutoff_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Cutoff envelope to apply\", \"F%d Cutoff Env\", 0, 10, 2);\n cx += 10;", i + 1, uuid(), i + 1);

    printf("f_reso_slider%d.active = filter%d_enabled;\n", i + 1, i + 1);
    printf("f_reso_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\d\", 100 * f%d_reso), \"Filter %d resonance\", \"F%d Resonance\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1, i + 1, i + 1, i + 1);
    printf("f_reso_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Reso envelope to apply\", \"F%d Reso Env\", 0, 10, 1);\n cx += 8;", i + 1, uuid(), i + 1);
    printf("f_reso_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Reso envelope to apply\", \"F%d Reso Env\", 0, 10, 2);\n cx += 10;", i + 1, uuid(), i + 1);
    
    printf("f_morph_slider%d.active = filter%d_enabled;\n", i + 1, i + 1);
    printf("f_morph_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, morph_level(f%d_morph), \"Filter %d morph\\n\\nMorphs between LP, \\nBP, HP, BR and LP\\n\", \"F%d Morph\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1, i + 1, i + 1, i + 1);
    printf("f_morph_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Morph envelope to apply\", \"F%d Morph Env\", 10, 8, 1);\n cx += 8;", i + 1, uuid(), i + 1);
    printf("f_morph_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Morph envelope to apply\", \"F%d Morph Env\", 10, 8, 2);\n cx += 10;", i + 1, uuid(), i + 1);
    
    printf("cy += 8;");
    i += 1;
  );
?>

hinter.draw_hints();

i = 0;
str = sprintf(1, "");
loop(MAX_VOICES,
  str = strcat(str, (midi.active_note_mem[i] > 0) ? ("P") : (midi.active_note_mem[i] == 0) ? ("0") : ("R"));
  i += 1;
);

gfx_set(1, 1, 1, 0.3);
txt_blit(sprintf(2, "proto-synth %s", str), side_pad, img_h - 6);
(info_active > 0.001) ? (
  gfx_a = min(0.3, info_active);
  txt_blit(14, img_w - 66, img_h - 6);
  info_active *= 0.7;
) : (
  txt_blit("ALPHA VERSION", img_w - 66, img_h - 6);
);

gfx_dest = -1;
gfx_set(1, 1, 1, 1);

raw_blit_scale = min(gfx_h / img_h, gfx_w / img_w);
blit_scale = raw_blit_scale >= 1 ? floor(raw_blit_scale) : raw_blit_scale;
x_offset = (gfx_w - blit_scale * img_w) * 0.5;
y_offset = (gfx_h - blit_scale * img_h) * 0.5;
shake = equ + 2 * (equ > 1);
gfx_x = x_offset; gfx_y = y_offset;
gfx_x += 0.25 * rand() * shake * blit_scale;
gfx_y += 0.25 * rand() * shake * blit_scale;
shake > 0 ? shake -= 1;

/*!show_ui ? (
  gfx_set(10/255, 31/255, 49/255, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);
);*/

gfx_set(1, 1, 1, 1);
gfx_mode = 4;
gfx_blit(13, blit_scale, 0);

last_cap = mouse_cap;
last_mouse_x = mouse_x;
last_mouse_y = mouse_y;
mouse_nx = (mouse_x - x_offset) / blit_scale;
mouse_ny = (mouse_y - y_offset) / blit_scale;

/*
1 ? (
  gfx_x = 0;
  gfx_y = 30;
  gfx_set(1, 1, 1, 1);
  fff = midi.active_note_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
  
  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  fff = midi.note_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
);
*/

  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  fff = v0.modulator_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );

