desc:Protosynth
options:maxmem=20000000
tags: instrument
version: 0.01
author: Joep Vanlier
changelog: WIP
license: MIT
provides:
  protosynth_dependencies/*

<?
  tuning_basic = 0.5;
  loop(i=0;8,
    par = i * 6 + 1;
    printf("slider%d:osc%d_gain=-9<-72,0,0.0001>-osc%d gain\n", par, i + 1, i + 1);
    printf("slider%d:osc%d_tune=%f<0.25,8,0.0001>-osc%d tune\n", par + 1, i + 1, tuning_basic, i + 1);
    printf("slider%d:osc%d_spacing=1<0.25,8,0.0001>-osc%d spacing\n", par + 2, i + 1, i + 1);
    printf("slider%d:osc%d_brightness=0.2<0.0,0.95,.0001>-osc%d brightness\n", par + 3, i + 1, i + 1);
    printf("slider%d:osc%d_spacing_offset=0<0,5000.0001>-osc%d spacing offset\n", par + 4, i + 1, i + 1);
    tuning_basic *= 1.5;
    
    i += 1
  );
?>

<?
  loop(i=0;6,
    par = i * 5 + 49;
    printf("slider%d:env%d_attack=3.0<3.0,3000.0,0.0001:log>-env%d attack\n", par, i + 1, i + 1);
    printf("slider%d:env%d_decay=30.0<30.0,3000.0.0001:log>-env%d decay\n", par + 1, i + 1, i + 1);
    printf("slider%d:env%d_sustain=0.7<0.0,1.0,0.0001>-env%d sustain\n", par + 2, i + 1, i + 1);
    printf("slider%d:env%d_release=300.0<30.0,3000.0,0.0001:log>-env%d release\n", par + 3, i + 1, i + 1);
    printf("slider%d:env%d_amount=1<0.0,1.0,0.0001>-env%d amount\n", par + 4, i + 1, i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;4,
    par = i * 5 + 90;
    printf("slider%d:mod%d_type=0<0,18,1>-mod%d_type\n", par, i + 1, i + 1);
    printf("slider%d:mod%d_freq=0.0<0.0,20.0.0001:log>-mod%d freq\n", par + 1, i + 1, i + 1);
    printf("slider%d:mod%d_phase=0<0.0,1.0,0.0001>-mod%d phase\n", par + 2, i + 1, i + 1);
    printf("slider%d:mod%d_lr=0.0<0.0,1.0,0.0001>-mod%d lr\n", par + 3, i + 1, i + 1);
    printf("slider%d:mod%d_amount=0.0<0.0,1.0,0.0001>-mod%d amount\n", par + 4, i + 1, i + 1);
    
    i += 1;
  );
?>

slider128:mix_mode1=0<0,2,1>-Mix mode 1
slider129:mix_mode2=0<0,2,1>-Mix mode 2
slider130:mix_mode3=0<0,2,1>-Mix mode 3
slider131:mix_mode4=0<0,2,1>-Mix mode 4
slider132:mix_mode21=0<0,2,1>-Mix mode 21
slider133:mix_mode22=0<0,2,1>-Mix mode 22
slider134:mix_mode31=0<0,2,1>-Mix mode 31

slider135:cutoff21=0<0,1,0.001>-Cutoff Mix 21
slider136:resonance21=0<0,1,0.001>-Resonance Mix 21
slider137:morph21=0<0,1,0.001>-Morph Mix 21

slider138:cutoff22=0<0,1,0.001>-Cutoff Mix 22
slider139:resonance22=0<0,1,0.001>-Resonance Mix 22
slider140:morph22=0<0,1,0.001>-Morph Mix 22

slider141:type31=0<0,16,1>-Filter Type
slider142:drive31=0<0,1,0.001>-Drive Mix
slider143:cutoff31=0<0,1,0.001>-Cutoff Mix
slider144:resonance31=0<0,1,0.001>-Resonance Mix
slider145:morph31=0<0,1,0.001>-Morph Mix

slider146:f1_cutoff=1<0,1,0.000001>-F1 Cutoff
slider147:f1_reso=0<0,1,0.000001>-F1 Resonance
slider148:f1_morph=0<0,1,0.000001>-F1 Morph

slider149:f2_cutoff=1<0,1,0.000001>-F2 Cutoff
slider150:f2_reso=0<0,1,0.000001>-F2 Resonance
slider151:f2_morph=0<0,1,0.000001>-F2 Morph

slider152:f3_cutoff=1<0,1,0.000001>-F3 Filter Cutoff
slider153:f3_reso=0<0,1,0.000001>-F3 Filter Resonance
slider154:f3_morph=0<0,1,0.000001>-F3 Filter Morph
slider155:f3_type=0<0,1,5{LIN,MS,L2,L4,SHRK,PL>-F3 Type
slider156:f3_drive=0<-6,48,0.00001>-F3 Drive
slider157:keyfollow=0<0,1,0.00001>-Key follow

slider158:f4_cutoff=1<0,1,0.000001>-Output Filter Cutoff
slider159:f4_reso=0<0,1,0.000001>-Output Filter Resonance
slider160:f4_morph=0<0,1,0.000001>-Output Filter Morph
slider161:f4_type=0<0,5,1{LIN,MS,L2,L4,SHRK,PL>-Output Filter Type
slider162:f4_drive=0<-6,24,0.00001>-F4 Drive

slider254:output_gain=-12<-24,6,0,0.0001>-Output Gain
slider255:chorus_amount=0<0,1,0.0001>-Chorus amount
slider256:noise=0<0.0001,0.4,0.0001:log>-Noise

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import saike_proto_synth_filters.jsfx-inc
import saike_proto_synth_os_nl_filters.jsfx-inc
import saike_proto_synth_oscillators.jsfx-inc
import saike_proto_synth_kp_midi.jsfx-inc
import saike_proto_synth_pixel_gfx.jsfx-inc
import saike_proto_stft_fx.jsfx-inc
//import saike_proto_pitchlib.jsfx-inc
import saike_proto_synth_fx.jsfx-inc

@init
pitchbend_range = 2;
env_color = 0.5;
mod_color = 0.08;
SLOW_UPDATE_FACTOR = 16;
MAX_VOICES = 12;
<?
  N_OSCS = 8;
  N_MODULATORS = 6;
  N_VISIBLE_MODULATORS = 4;
  N_ENVELOPES = 6;
  N_FILTERS = 3;
  N_SELECTABLE_MODULATORS = 12;
  MAX_VOICES = 12;
?>
N_SELECTABLE_MODULATORS = 12;

<?MAX_VOICES = 12;?>
INV_SLOW_UPDATE_FACTOR = 1.0 / SLOW_UPDATE_FACTOR;

model = 5;


img_w = 350;
img_h = 245;
osc_downsample_factor = 16;
osc_skipfactor = 2;
osc_buffer = img_w * osc_downsample_factor;
function draw_oscilloscope(x, y, w, h)
global(
  gfx_x, gfx_y, gfx_r, gfx_g, gfx_b, gfx_a, gfx_mode, color_model,
  audio_buffer, x_step, osc_buffer, osc_downsample_factor, osc_skipfactor
)
local(ix, yc, hh, phh, y_top, y_bottom)
instance()
(
  gfx_x = x;
  ix = 0;
  colormodel(0.4);
  gfx_mode = 1;
  gfx_a = 0.4;
  hh = 0.5 * h;
  phh = 0.5 * h;
  yc = y + hh;
  y_top = y + h - 2;
  y_bottom = y + 2;
  x_step = w / (osc_buffer / osc_skipfactor);
  loop(osc_buffer / osc_skipfactor,
    gfx_y = yc + audio_buffer[ix] * phh;
    (gfx_y < y_top) && (gfx_y > y_bottom) ? (
      gfx_setpixel(gfx_r, gfx_g, gfx_b);
    );
    ix += osc_skipfactor;
    gfx_x += x_step;
  );
);

filter_type_slider1.init_slider_ui(-1, 0, 5, 0);
filter_gain_slider3.init_slider_ui(156, -24, 24, 0);
filter_keyfollow1.init_slider_ui(157, 0, 1, 0);

<?
  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.init_slider_ui(%d, -72, 0, 0);\n", i + 1, par);
    printf("osc_type_slider%d.init_slider_ui(-1, 0, 1, 0);\n", i + 1);
    printf("tune_slider%d.init_slider_ui(%d, 0.25, 8.0, 0);\n", i + 1, par + 1);
    printf("spacing_slider%d.init_slider_ui(%d, 0.25, 8.0, 0);\n", i + 1, par + 2);
    printf("brightness_slider%d.init_slider_ui(%d, 0.0, 0.95, 0);\n", i + 1, par + 3);
    printf("spacing_offset_slider%d.init_slider_ui(%d, 0, 5000.0, 0);\n", i + 1, par + 4);
    
    printf("(gain_slider%d.gain_mod_target == 0) ? gain_slider%d.gain_mod_target = 1;\n cx += 10;", i + 1, i + 1);
    i += 1;
  );
?>

output_slider1.init_slider_ui(254, -24, 24.0, 0);
chorus_slider1.init_slider_ui(255, 0.0, 1.0, 0);
noise_slider1.init_slider_ui(256, 0.0001, 0.4, 1);

<?
  loop(i=0;N_ENVELOPES,
    par = i * 5 + 49;
    printf("env_attack_slider%d.init_slider_ui(%d, 3.0, 3000.0, 1);\n", i + 1, par);
    printf("env_decay_slider%d.init_slider_ui(%d, 30.0, 3000.0, 1);\n", i + 1, par + 1);
    printf("env_sustain_slider%d.init_slider_ui(%d, 0, 1.0, 0);\n", i + 1, par + 2);
    printf("env_release_slider%d.init_slider_ui(%d, 30, 3000.0, 1);\n", i + 1, par + 3);
    
    printf("env_attack_slider%d.color=env_color;\n", i + 1);
    printf("env_decay_slider%d.color=env_color;\n", i + 1);
    printf("env_sustain_slider%d.color=env_color;\n", i + 1, par + 2);
    printf("env_release_slider%d.color=env_color;\n", i + 1, par + 3);
    
    i += 1;
  );
?>

<?
  loop(i=0;N_MODULATORS,
    par = i * 5 + 90;
    printf("mod_type_slider%d.init_slider_ui(%d, 0, 18, 0);\n", i + 1, par);
    printf("mod_freq_slider%d.init_slider_ui(%d, 0.0, 20.0, 0);\n", i + 1, par + 1);
    printf("mod_phase_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 2);
    printf("mod_lr_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 3);
    printf("mod_amount_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 4);
    
    printf("mod_type_slider%d.color=mod_color;\n", i + 1);
    printf("mod_freq_slider%d.color=mod_color;\n", i + 1);
    printf("mod_phase_slider%d.color=mod_color;\n", i + 1, par + 2);
    printf("mod_lr_slider%d.color=mod_color;\n", i + 1, par + 3);
    printf("mod_amount_slider%d.color=mod_color;\n", i + 1, par + 4);
    
    printf("mod%d_restart.color=mod_color;\n", i + 1);
    
    i += 1;
  );
?>

<?
  loop(i=0;4,
    par = i * 3 + 146;
    printf("f_cutoff_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par);
    printf("f_reso_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 1);
    printf("f_morph_slider%d.init_slider_ui(%d, 0.0, 1.0, 0);\n", i + 1, par + 2);
    i += 1;
  );
?>

function init_voice(freemem)
local()
global()
instance(
  osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, modulator_mem
)
(
  freemem = (modulator_mem = freemem) + 32;
  memset(modulator_mem, 0, 32);
  
  <?loop(i=1;8,
    printf("osc%d.init_dsf_osc();\n", i);
    printf("osc%d.init_ssaw();\n", i);
    i += 1;
  )?>
  
  freemem
);

function init_voice_mixers(freemem, shared_fft_buffer, window_buffer)
local()
global()
instance(mix1, mix2, mix3, mix4, mix21, mix22, mix31)
(
  freemem = mix1.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix2.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix3.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix4.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix21.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix22.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix31.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  
  freemem
);

twopi = 2 * $pi;

function lfo_modulator(shape, dt)
instance(state, lt, ct, y, t)
global(twopi)
local()
(
  shape = floor(shape);
  t += dt;
  y = ( shape == 0 ) ? .5 + .5 * sin(twopi*t)
  : ( shape==1 )  ? ( abs(cos($pi*t)) )
  : ( shape==2 )  ? ( abs(sin($pi*t)) )
  : ( shape==3 )  ? ( t-floor(t) )
  : ( shape==4 )  ? ( 1-t+floor(t) )
  : ( shape==5 )  ? ( exp(-4*(t-floor(t))) )
  : ( shape==6 )  ? ( min((15*(t-floor(t))),1)*exp(-4*(t-floor(t))) )
  : ( shape==7 )  ? ( 1-exp(-4*(t-floor(t))) )
  : ( shape==8 ) ? ( exp(-t) )    
  : ( shape==9 ) ? ( min((15*t),1)*exp(-t) )
  : ( shape==10 ) ? ( 1-2*abs(t-floor(t)-0.5) )
  : ( shape==11 ) ? ( sin(twopi*t)*.3+.5 + sin(2*twopi*t)*.2 )
  : ( shape==12 ) ? ( sin(twopi*t)*.2+.5 + sin(2*twopi*t)*.2 + sin(4*twopi*t)*.1 )
  : ( shape==13 ) ? ( (t-floor(t)) < .0625 )
  : ( shape==14 ) ? ( (t-floor(t)) < .125 )
  : ( shape==15 ) ? ( (t-floor(t)) < .25 )
  : ( shape==16 ) ? ( (t-floor(t)) < .5 )
  : ( shape==17 ) ? ( (t-floor(t)) < (lt-floor(lt)) ? ct = rand(); lt = t; ct )
  : ( shape==18 ) ? ( rand() );
  
  t == 0 ? state = y;
  state = .98 * state + .02 * y
);


function lfo_type(type)
(
  type = floor(type);
  (type == 0) ? "sine"
  : (type == 1) ? "abscos"
  : (type == 2) ? "abssin"
  : (type == 3) ? "rampup"
  : (type == 4) ? "rampdn"
  : (type == 5) ? "expdwn"
  : (type == 6) ? "exp"
  : (type == 7) ? "expup"
  : (type == 8) ? "1expdn"
  : (type == 9) ? "1exp"  // Exp up and down
  : (type == 10) ? "tri"
  : (type == 11) ? "harm2"
  : (type == 12) ? "harm3"
  : (type == 13) ? "16th"
  : (type == 14) ? "8th"
  : (type == 15) ? "4th"
  : (type == 16) ? "2th"
  : (type == 17) ? "S&H"
  : (type == 18) ? "noise"
);

function osc_type(type)
(
  type = floor(type);
  (type == 0) ? "Harm"
  : (type == 1) ? "ssaw"
);

function filt_type(type)
(
  type = floor(type);
  (type == 0) ? "Lin"
  : (type == 1) ? "MS"
  : (type == 2) ? "L2"
  : (type == 3) ? "L4"
  : (type == 4) ? "Shrk"
  : (type == 5) ? "PL"
);

// Modulator handling
<?
  function get_modulated_value1_preproc(target, slider_name, idx)
  (
    printf("
      %s = %s%d.mod_target1 ? (
          max(min(slider(%s%d.sl) + %s%d.mod_amount1_clamped * modulator_mem[%s%d.mod_target1], %s%d.sl_max), %s%d.sl_min)
        ) : slider(%s%d.sl);
      ",
      target,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx
    )
  );
  
  function get_modulated_value1_preproc_ranged(target, slider_name, idx)
  (
    printf("
      %s = %s%d.mod_target1 ? (
          max(min(slider(%s%d.sl) + %s%d.mod_amount1_clamped * (%s%d.sl_max - %s%d.sl_min) * modulator_mem[%s%d.mod_target1], %s%d.sl_max), %s%d.sl_min)
        ) : slider(%s%d.sl);
      ",
      target,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx
    )
  );
  
  function get_modulated_value2_preproc(target, slider_name, idx)
  (
    printf("
      %s = (%s%d.mod_target1 || %s%d.mod_target2) ? (
          m1 = %s%d.mod_target1 ? %s%d.mod_amount1_clamped * modulator_mem[%s%d.mod_target1] : 0;
          m2 = %s%d.mod_target2 ? %s%d.mod_amount2_clamped * modulator_mem[%s%d.mod_target2] : 0;
          max(min(slider(%s%d.sl) + m1 + m2, %s%d.sl_max), %s%d.sl_min)
        ) : slider(%s%d.sl);
      ",
      target,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx
    )
  );
  
  function get_modulated_value2_preproc_noclamp(target, slider_name, idx)
  (
    printf("
      %s = (%s%d.mod_target1 || %s%d.mod_target2) ? (
          m1 = %s%d.mod_target1 ? %s%d.mod_amount1_clamped * modulator_mem[%s%d.mod_target1] : 0;
          m2 = %s%d.mod_target2 ? %s%d.mod_amount2_clamped * modulator_mem[%s%d.mod_target2] : 0;
          (slider(%s%d.sl) + m1 + m2)
        ) : slider(%s%d.sl);
      ",
      target,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx,
      slider_name, idx
    )
  );
?>

function update_voice()
local(cur_freq, cur_spacing, cur_brightness, cfreq, noise_factor, atk, gain, f_cutoff, f_reso, f_morph, m1, m2, c_mod_freq, z_noise)
global(
  INV_SLOW_UPDATE_FACTOR,
  slow_update_srate,
  midi.active_note_mem, midi.active_note_vel,
  rel_spacing, freq_atten, n_update,
  midi.modwheel,
  keyfollow,
  pitchbend_modifier,
  <?loop(i=1;8, printf("osc%d_enabled,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_gain,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_tune,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_brightness,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_spacing,", i); i += 1);?>,
  <?loop(i=1;8, printf("osc%d_spacing_offset,", i); i += 1);?>,
  noise,
  
  <?loop(i=1;8, printf("gain_slider%d.gain_mod_target,", i); i += 1);?>
  <?loop(i=1;8, printf("gain_slider%d.mod_target1,", i); i += 1);?>
  <?loop(i=1;8, printf("gain_slider%d.mod_amount1_clamped,", i); i += 1);?>
  
  <?loop(i=1;8, printf("tune_slider%d.mod_target1, tune_slider%d.mod_amount1_clamped, tune_slider%d.get_modulated_value1, tune_slider%d.sl, tune_slider%d.sl_max, tune_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;8, printf("spacing_slider%d.mod_target1, spacing_slider%d.mod_amount1_clamped, spacing_slider%d.get_modulated_value1, spacing_slider%d.sl, spacing_slider%d.sl_max, spacing_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;8, printf("brightness_slider%d.mod_target1, brightness_slider%d.mod_amount1_clamped, brightness_slider%d.get_modulated_value1, brightness_slider%d.sl, brightness_slider%d.sl_max, brightness_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  
  filter1_enabled, filter2_enabled, filter3_enabled,
  <?loop(i=1;N_FILTERS, printf("f_cutoff_slider%d.mod_target1, f_cutoff_slider%d.mod_amount1_clamped, f_cutoff_slider%d.mod_target2, f_cutoff_slider%d.mod_amount2_clamped, f_cutoff_slider%d.get_modulated_value1, f_cutoff_slider%d.sl, f_cutoff_slider%d.sl_max, f_cutoff_slider%d.sl_min,", i, i, i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;N_FILTERS, printf("f_reso_slider%d.mod_target1, f_reso_slider%d.mod_amount1_clamped, f_reso_slider%d.mod_target2, f_reso_slider%d.mod_amount2_clamped, f_reso_slider%d.get_modulated_value1, f_reso_slider%d.sl, f_reso_slider%d.sl_max, f_reso_slider%d.sl_min,", i, i, i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;N_FILTERS, printf("f_morph_slider%d.mod_target1, f_morph_slider%d.mod_amount1_clamped, f_morph_slider%d.mod_target2, f_morph_slider%d.mod_amount2_clamped, f_morph_slider%d.get_modulated_value1, f_morph_slider%d.sl, f_morph_slider%d.sl_max, f_morph_slider%d.sl_min,", i, i, i, i, i, i, i, i); i += 1);?>
  f3_type,
  
  <?loop(i=1;N_MODULATORS, printf("mod_freq_slider%d.mod_target1, mod_freq_slider%d.mod_amount1_clamped, mod_freq_slider%d.sl, mod_freq_slider%d.sl_max, mod_freq_slider%d.sl_min,", i, i, i, i, i); i += 1);?>
  
  <?loop(i=1;N_MODULATORS, printf("mod%d_type, mod%d_freq, mod%d_phase, mod%d_lr, mod%d_amount,", i, i, i, i, i); i += 1; );?>
  <?loop(i=1;N_OSCS, printf("osc%d_type, ", i); i += 1; );?>
)
instance(
  midi_idx,
  freq, osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, rand_src,
  g1, g2, g3, g4, g5, g6, g7, g8,
  dg1, dg2, dg3, dg4, dg5, dg6, dg7, dg8,
  has_output,
  on,
  current_sample, pressed, has_played,
  modulator_mem,
  velocity,
  current_f3_type,
  keyfollow_mod,
  <?loop(i=1;N_MODULATORS, printf("mod%d_lfo,", i); i += 1; );?>
  <?loop(i=1;N_OSCS, printf("mod%d_lfo,", i); i += 1; );?>
  <?loop(i=1;N_OSCS, printf("osc%d_wave, ", i); i += 1; );?>
  
  <?loop(i=1;N_ENVELOPES,
    printf("env%d_atk_samples, env%d_k_atk, env%d_k_decay, env%d_k_release, env%d_current_sustain,", i, i, i, i, i);
    i += 1
  );?>
)
(
  // Update envelopes and modulators
  <?loop(i=1;N_ENVELOPES, printf("atk = current_sample < env%d_atk_samples; modulator_mem[%d] += (atk ? env%d_k_atk : pressed ? env%d_k_decay : env%d_k_release) * (max(atk, env%d_current_sustain * pressed) - modulator_mem[%d]);\n", i, i, i, i, i, i, i); i += 1);?>
  
  has_output ? (
    <?loop(i=1;N_VISIBLE_MODULATORS, 
      get_modulated_value1_preproc_ranged("c_mod_freq", "mod_freq_slider", i);
      printf("modulator_mem[%d] = mod%d_lfo.lfo_modulator(mod%d_type, slow_update_srate * c_mod_freq);\n", i + N_ENVELOPES, i, i);
      i += 1);
    ?>
  );
  <?
    printf("modulator_mem[%d] = velocity;", N_ENVELOPES + N_MODULATORS - 1);
    printf("modulator_mem[%d] = midi.modwheel;", N_ENVELOPES + N_MODULATORS);
  ?>
  
  has_output = max(max(max(max(max(max(max(max(g1, g2), g3), g4), g5), g6), g7), g8), pressed) > 0.0001;
  (!has_output) ? (
    on = 0;
    // Flag as available for new midi notes
    has_played ? (
      midi.active_note_mem[midi_idx] = 0;
      midi.active_note_vel[midi_idx] = 0;
      has_played = 0;
    );
  );
  
  rand_src = 0.9 * rand_src + 0.1 * rand();
  z_noise = max(0, noise - 0.0001);
  noise_factor = (1 - z_noise) + (z_noise + z_noise) * rand_src;
  cfreq = freq * noise_factor * pitchbend_modifier;
  
  // Update oscillators
  <?
    loop(i=1;N_OSCS,
      printf("osc%d_enabled ? (", i);
        printf("gain = min(0, osc%d_gain + (gain_slider%d.mod_target1 ? 72 * gain_slider%d.mod_amount1_clamped * modulator_mem[gain_slider%d.mod_target1] : 0));", i, i, i, i);
        printf("dg%d = INV_SLOW_UPDATE_FACTOR * (10^(0.05 * gain) * modulator_mem[gain_slider%d.gain_mod_target] - g%d);", i, i, i);
      
        get_modulated_value1_preproc_ranged("cur_freq", "tune_slider", i);
        printf("cur_freq *= cfreq;");
        get_modulated_value1_preproc_ranged("cur_spacing", "spacing_slider", i);
        get_modulated_value1_preproc("cur_brightness", "brightness_slider", i);
      
        printf("osc%d_wave = floor(osc%d_type);", i, i);
        
        printf("(osc%d_wave == 0) ? (\n", i);
          printf("osc%d.update_dsf_osc(cur_freq, cur_spacing * cur_freq + osc%d_spacing_offset, cur_brightness, 0);\n", i, i);
        printf(") : (\n");
          printf("osc%d.update_ssaw_osc(cur_freq, cur_spacing, cur_brightness, 0);\n", i);
        printf(");\n");
      printf(") : (");
        printf("g%d = 0; dg%d = 0;", i, i);
      printf(");");

      i += 1
    );
  ?>
  
  // Only run the filter coefficient computation when there's a voice playing
  has_output ? (
    <?
    loop(i=1;2,
      printf("filter%d_enabled ? (\n", i);
      get_modulated_value2_preproc("f_cutoff", "f_cutoff_slider", i);
      get_modulated_value2_preproc("f_reso", "f_reso_slider", i);
      get_modulated_value2_preproc("f_morph", "f_morph_slider", i);
      
      // Basic SVF
      printf("this.filter%d.L.init_linearSVF_all(f_cutoff, f_reso, f_morph);", i);
      //printf("this.filter%d.R.init_linearSVF_all(f_cutoff, f_reso, f_morph);", i);
      printf(");\n");
      
      //printf("this.filter%d.init_filter(0, f_cutoff, f_cutoff, f_morph, f_morph, f_reso);", i+1);
      i += 1;
    );
    ?>
    
    filter3_enabled ? (
      <?
        get_modulated_value2_preproc_noclamp("f_cutoff", "f_cutoff_slider", 3);
        get_modulated_value2_preproc("f_reso", "f_reso_slider", 3);
        get_modulated_value2_preproc("f_morph", "f_morph_slider", 3);
      ?>
      
      f_cutoff = min(1, max(0, f_cutoff - keyfollow * keyfollow_mod));
      
      current_f3_type = floor(f3_type);
      (current_f3_type == 0) ? (
        this.filter3.lin.init_linear(f_cutoff, f_reso, f_morph);
      ) : (current_f3_type == 1) ? (
        this.filter3.ms20.init_ms20(f_cutoff, f_reso, f_morph);
      ) : (current_f3_type == 2) ? (
        this.filter3.la2.init_lad2(f_cutoff, f_reso, f_morph);
      ) : (current_f3_type == 3) ? (
        this.filter3.la4.init_lad4(f_cutoff, f_reso, f_morph);
      ) : (current_f3_type == 4) ? (
        this.filter3.shriek.init_shriek(f_cutoff, f_reso, f_morph);
      ) : (current_f3_type == 5) ? (
        this.filter3.pl4.init_pl4(f_cutoff, f_reso, f_morph);
      );
    );
  );
  
  current_sample += 1;
);

function initialize_envelopes()
local(to_samples, sample_rate, log001, log001tds, current_value)
global(
  srate,
  SLOW_UPDATE_FACTOR,
  <?
    loop(i=1;N_ENVELOPES,
      printf("env_attack_slider%d.mod_target1, env_attack_slider%d.mod_amount1_clamped, env_attack_slider%d.sl, env_attack_slider%d.sl_max, env_attack_slider%d.sl_min,", i, i, i, i, i);
      printf("env_decay_slider%d.mod_target1, env_decay_slider%d.mod_amount1_clamped, env_decay_slider%d.sl, env_decay_slider%d.sl_max, env_decay_slider%d.sl_min,", i, i, i, i, i);
      printf("env_sustain_slider%d.mod_target1, env_sustain_slider%d.mod_amount1_clamped, env_sustain_slider%d.sl, env_sustain_slider%d.sl_max, env_sustain_slider%d.sl_min,", i, i, i, i, i);
      printf("env_release_slider%d.mod_target1, env_release_slider%d.mod_amount1_clamped, env_release_slider%d.sl, env_release_slider%d.sl_max, env_release_slider%d.sl_min,", i, i, i, i, i);
      i += 1
    );
  ?>
)
instance(
  current_sample, has_played, modulator_mem,
  <?
    loop(i=1;N_ENVELOPES,
      printf("env%d_atk_samples,", i);
      printf("env%d_k_atk,", i);
      printf("env%d_k_decay,", i);
      printf("env%d_k_release,", i);
      printf("env%d_current_sustain,", i);
      i += 1;
    );
  ?>
)
(
  sample_rate = srate / SLOW_UPDATE_FACTOR;
  to_samples = 0.001 * sample_rate;  // Since times were specified in ms
  log001 = log(0.01);
  log001tds = log001 / to_samples;
  current_sample = 0;
  has_played = 1;
  
  <?
    loop(i=1;N_ENVELOPES,
      get_modulated_value1_preproc_ranged("current_value", "env_attack_slider", i);
      printf("env%d_atk_samples = current_value * to_samples;\n", i);
      printf("env%d_k_atk = - log001 / env%d_atk_samples;\n", i, i);
      
      get_modulated_value1_preproc_ranged("current_value", "env_decay_slider", i);
      printf("env%d_k_decay = - log001tds / current_value;\n", i, i);
      
      get_modulated_value1_preproc_ranged("current_value", "env_sustain_slider", i);
      printf("env%d_current_sustain = current_value;\n", i, i);
      
      get_modulated_value1_preproc_ranged("current_value", "env_release_slider", i);
      printf("env%d_k_release = - log001tds / current_value;\n", i, i);
      i += 1;
    );
  ?>
);

function play_voice()
local(
  o1, o2, o3, o4, o5, o6, o7, o8, t1, t2,
)
global(
  mix_mode1, mix_mode2, mix_mode3, mix_mode4,
  mix_mode21, mix_mode22,
  mix_mode31,
  filter1_enabled, filter2_enabled, filter3_enabled,
  current_f3_gain,
  <?loop(i=1;N_OSCS, printf("osc%d_enabled, ", i); i += 1; );?>
)
instance(
  current_f3_type,
  mix1, mix2, mix3, mix4, mix21, mix22, mix31,
  osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, l, r
  g1, g2, g3, g4, g5, g6, g7, g8,
  dg1, dg2, dg3, dg4, dg5, dg6, dg7, dg8,
  <?loop(i=1;N_OSCS, printf("osc%d_wave, ", i); i += 1; );?>
)
(
  <?
    function gen_mixer(mix_out, mix_id, o1, o2)
    (
      printf(
        "o%d = (mix_mode%d == 0) ? (o%d + o%d) 
        : (mix_mode%d == 1) ? (o%d * (1.0 + o%d)) 
        : (mix_mode%d == 2) ? (o%d * o%d) 
        : (mix_mode%d == 3) ? (min(max(o%d, o%d), min(o%d, o%d))) 
        : (mix_mode%d == 4) ? (t1 = o%d + o%d; t2 = o%d - o%d; min(max(t1, t2), -min(t1, t2))) 
        : (mix_mode%d == 5) ? (mix%d.process_stft_mixer(o%d, o%d); mix%d.out_left)
        : (mix_mode%d == 6) ? (this.ofs%d.freq_shift_audio_rate(o%d, 16 * this.freq * o%d));",
        mix_out, 
        mix_id, o1, o2, 
        mix_id, o1, o2, 
        mix_id, o1, o2, 
        mix_id, o1, o2, o1, o2, 
        mix_id, o1, o2, o1, o2,
        mix_id, mix_id, o1, o2, mix_id,
        mix_id, mix_id, o1, o2
      );
    );
  ?>
  
  <?
    function gen_osc(i)
    (
      printf("o%d = g%d ? (osc%d_wave ? osc%d.ssaw_step() : osc%d.dsf_step()) * g%d;", i, i, i, i, i, i);
    );
  ?>
  
  (osc1_enabled || osc2_enabled) ? (
    <?gen_osc(1)?>
    <?gen_osc(2)?>
    <?gen_mixer(1, 1, 1, 2);?>
  ) : (
    o1 = o2 = 0;
  );
  
  (osc3_enabled || osc4_enabled) ? (
    <?gen_osc(3)?>
    <?gen_osc(4)?>
    <?gen_mixer(2, 2, 3, 4);?>
  ) : (
    o3 = o4 = 0;
  );

  (osc5_enabled || osc6_enabled) ? (
    <?gen_osc(5)?>
    <?gen_osc(6)?>
    <?gen_mixer(3, 3, 5, 6);?>
  ) : (
    o5 = o6 = 0;
  );
  
  (osc7_enabled || osc8_enabled) ? (
    <?gen_osc(7)?>
    <?gen_osc(8)?>
    <?gen_mixer(4, 4, 7, 8);?>
  ) : (
    o7 = o8 = 0;
  );
  
  <?gen_mixer(1, 21, 1, 2);?>
  o1 = filter1_enabled ? this.filter1.L.eval_linearSVF_all(o1) : o1;
  
  <?gen_mixer(2, 22, 3, 4);?>
  o2 = filter2_enabled ? this.filter2.L.eval_linearSVF_all(o2) : o2;
  
  <?gen_mixer(1, 31, 1, 2);?>
  l = r = filter3_enabled ? (
    (current_f3_type == 0) ? (
      this.filter3.lin.eval_linear_2p(o1)
    ) : (current_f3_type == 1) ? (
      this.filter3.ms20.run_ms20(o1 * current_f3_gain) / current_f3_gain
    ) : (current_f3_type == 2) ? (
      this.filter3.la2.run_lad2(o1 * current_f3_gain) / current_f3_gain;
    ) : (current_f3_type == 3) ? (
      this.filter3.la4.run_lad4(o1 * current_f3_gain) / current_f3_gain;
    ) : (current_f3_type == 4) ? (
      this.filter3.shriek.run_shriek(o1 * current_f3_gain) / current_f3_gain;
    ) : (current_f3_type == 5) ? (
      this.filter3.pl4.run_pl4(o1 * current_f3_gain) / current_f3_gain;
    )
  ) : o1;
 
  <?loop(i=1;8, printf("g%d += dg%d;\n", i, i); i += 1);?>
);
  
function stop_voice()
local()
instance(on)
global()
(
  on = 0;
);

function pitch_to_freq(pitch)
local(scaling, frac, temp)
global(microtuned, tuning_memory, sample_time, ln)
instance()
(
  microtuned ? (
    temp = min(127, max(0, pitch + 69));
    frac = temp - floor(temp);
    ln = temp;
    (pow(tuning_memory[temp], (1.0 - frac)) * pow(tuning_memory[temp + 1], frac))
  ) : (
    440 * 2 ^ (pitch / 12)
  );
);

function process_midi(note_idx, active, vel, state, ref_pitch)
local()
global(
  initialize_envelopes, modulator_mem
  <?loop(i=1;N_MODULATORS, printf("mod%d_restart, mod%d_phase, ", i, i); i += 1; );?>
)
instance(
  on, freq, pressed, current_sample, midi_idx, velocity, keyfollow_mod,
  <?loop(i=1;N_MODULATORS, printf("mod%d_lfo, ", i); i += 1; );?>
)
(
  midi_idx = note_idx;
  (state == 1) ? (
    // Note on
    on = 1;
    <?loop(i=1;N_MODULATORS, printf("mod%d_restart ? mod%d_lfo.t = mod%d_phase;", i, i, i); i += 1; );?>
    
    freq = pitch_to_freq(active + ref_pitch);
    //keyfollow_mod = (log(freq) - log(440)) / log(20/22050);
    keyfollow_mod = - 0.14274833584774144 * (log(freq) - 6.0867747269123065);
    pressed = 1;
    velocity = vel;
    
    this.update_voice();
    <?loop(i=1;8,
      printf("this.osc%d.init_ssaw();\n", i); i += 1;
    )?>
    
    this.initialize_envelopes();
    this.update_voice();
  ) : (state == -1) ? (
    // Release
    pressed = 0;
    current_sample = 100000000000000000; // Make sure we are beyond the attack
  );
);

function update_notes()
instance(
  notes_on, active_note_mem, active_note_vel, active_note_state, note_history,
  last_count
)
global(
  midi.pitchbend, midi.last_vel,
  latest_note,
  pitchbend_range,
  pitch_shift,
  glide,
  
  <?
    loop(i=0;MAX_VOICES,
      printf("v%d.on, v%d.process_midi, ", i, i);
      i += 1;
    );
  ?>
)
local(
  ref_pitch, remainder,
)
(
  ref_pitch = pitch_shift - 69;
  
  latest_note = note_history[notes_on - 1];
  glide ? (
    v1.on = v2.on = v3.on = v4.on = v5.on = v6.on = v7.on = v8.on = v9.on = v10.on = v11.on = 0;
    
    (notes_on > 0) ? (
      v0.process_midi(latest_note, active_note_mem[latest_note], active_note_vel[latest_note], active_note_state[latest_note], ref_pitch);
    ) : (
      v0.process_midi(latest_note, active_note_mem[latest_note], active_note_vel[latest_note], -1, ref_pitch);
    );
  ) : (
    <?
      loop(i=0;MAX_VOICES,
        printf("v%d.process_midi(%d, active_note_mem[%d], active_note_vel[%d], active_note_state[%d], ref_pitch);", i, i, i, i, i);
        i += 1;
      );
    ?>
    
    // Update note parameters
    /*note_on0 ? ( string1.set_pars(pitch_to_freq(note_on0 + ref_pitch), note_vel0, 0); string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0; );
    note_on1 ? ( string2.set_pars(pitch_to_freq(note_on1 + ref_pitch), note_vel1, 0); string2.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel1; );
    note_on2 ? ( string3.set_pars(pitch_to_freq(note_on2 + ref_pitch), note_vel2, 0); string3.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel2; );
    note_on3 ? ( string4.set_pars(pitch_to_freq(note_on3 + ref_pitch), note_vel3, 0); string4.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel3; );
    note_on4 ? ( string5.set_pars(pitch_to_freq(note_on4 + ref_pitch), note_vel4, 0); string5.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel4; );
    
    (note_state0 == -1) ? (string1.damp_string(); string1.update_freq(); );
    (note_state1 == -1) ? (string2.damp_string(); string2.update_freq(); );
    (note_state2 == -1) ? (string3.damp_string(); string3.update_freq(); );
    (note_state3 == -1) ? (string4.damp_string(); string4.update_freq(); );
    (note_state4 == -1) ? (string5.damp_string(); string5.update_freq(); );*/
  );
  
  memset(active_note_state, 0, 12);
  last_count = notes_on;
);

freemem = 0;
freemem = midi.init_midi(freemem);

MAX_FFT_SIZE = 32768;
freemem = (shared_window_buffer = freemem) + MAX_FFT_SIZE;
freemem = (shared_fft_buffer = freemem) + MAX_FFT_SIZE;

<?
/*  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.serialize(version);\n", i + 1);
    printf("tune_slider%d.serialize(version);\n", i + 1);
    printf("spacing_slider%d.serialize(version);\n", i + 1);
    printf("brightness_slider%d.serialize(version);\n", i + 1);
    printf("spacing_offset_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
*/
?>

<?
  loop(i=0;MAX_VOICES, printf("freemem = v%d.init_voice(freemem);\n", i); i += 1;);
  loop(i=0;MAX_VOICES, printf("freemem = v%d.init_voice_mixers(freemem, shared_fft_buffer, shared_window_buffer);\n", i); i += 1;);
?>

freemem = chorus.init_chorus(freemem, 340);
freemem = (audio_buffer = freemem) + 2 * osc_buffer;

midi.reset_midi();
<?loop(i=0;MAX_VOICES, printf("v%d.process_midi(0, 0, 0, -1, 0);", i); i += 1);?>

CURRENT_VERSION = 6;
version = CURRENT_VERSION;

@serialize
update_ticker = 0;
file_var(0, version);

<?
  loop(i=0;8,
    printf("gain_slider%d.serialize(version);\n", i + 1);
    printf("tune_slider%d.serialize(version);\n", i + 1);
    printf("spacing_slider%d.serialize(version);\n", i + 1);
    printf("brightness_slider%d.serialize(version);\n", i + 1);
    printf("spacing_offset_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
?>

version <= 3 ? (
  stored_envelopes = 8;
) : (
  stored_envelopes = 6;
);
<?
  loop(i=0;8,
    printf("(%d < stored_envelopes) ? (", i);
    printf("env_attack_slider%d.serialize(version);\n", i + 1);
    printf("env_decay_slider%d.serialize(version);\n", i + 1);
    printf("env_sustain_slider%d.serialize(version);\n", i + 1);
    printf("env_release_slider%d.serialize(version);\n", i + 1);
    printf(");", i);
    i += 1;
  );
?>

<?
  loop(i=1;3,
    printf("f_cutoff_slider%d.serialize(version);\n", i);
    printf("f_reso_slider%d.serialize(version);\n", i);
    printf("f_morph_slider%d.serialize(version);\n", i);
    i += 1;
  );
?>

(version > 2) ? (
  file_var(0, filter1_enabled);
  file_var(0, filter2_enabled);
  file_var(0, filter3_enabled);
) : (
  filter1_enabled = filter2_enabled = filter3_enabled = 0;
);

(version > 3) ? (
  <?
    loop(i=0;N_MODULATORS,
      printf("mod_type_slider%d.serialize(version);\n", i + 1);
      printf("mod_freq_slider%d.serialize(version);\n", i + 1);
      printf("mod_phase_slider%d.serialize(version);\n", i + 1);
      printf("mod_lr_slider%d.serialize(version);\n", i + 1);
      printf("mod_amount_slider%d.serialize(version);\n", i + 1);
      i += 1;
    );
  ?>
) : (
  <?
    loop(i=0;N_MODULATORS,
      printf("mod_type_slider%d.defaults();\n", i + 1);
      printf("mod_freq_slider%d.defaults();\n", i + 1);
      printf("mod_phase_slider%d.defaults();\n", i + 1);
      printf("mod_lr_slider%d.defaults();\n", i + 1);
      printf("mod_amount_slider%d.defaults();\n", i + 1);
      i += 1;
    );
  ?>
);

(version > 4) ? (
  <?
    loop(i=1;N_OSCS,
      printf("file_var(0, osc%d_enabled);", i);
      printf("file_var(0, osc%d_type);", i);
      i += 1;
    );
  ?>
) : (
  <?
    loop(i=1;N_OSCS,
      printf("osc%d_enabled = 1;", i);
      printf("osc%d_type = 0;", i);
      i += 1;
    );
    //printf("osc1_enabled = 1;");
  ?>
);

(version > 5) ? (
  output_slider1.serialize(version);
  chorus_slider1.serialize(version);
  noise_slider1.serialize(version);
) : (
  output_slider1.defaults();
  chorus_slider1.defaults();
  noise_slider1.defaults();
);

version = CURRENT_VERSION;

@slider

@block
slow_update_srate = SLOW_UPDATE_FACTOR / srate;

inv_samplesblock = 1 / samplesblock;
df3_gain = (pow(10, 0.05 * f3_drive) - current_f3_gain) * inv_samplesblock;
d_gain = (pow(10, 0.05 * output_gain) - current_gain) * inv_samplesblock;

(last_srate != srate) ? (
  init_freq_shift_modulator();
  oversampling = 1;
  last_srate = srate;
  israte = 1.0 / srate;
  tpiT = 2.0 * $pi / srate;
  sampling_ratio = legacy_mode ? 1 : 44100 / srate;
  sampling_factor = oversampling / sampling_ratio;
  isampling_factor = 1 / sampling_factor;
);
//israte_radian = 2.0*$pi*israte;

<?
  loop(i=0;N_OSCS,
    printf("gain_slider%d.text_slider_block();", i + 1);
    printf("tune_slider%d.text_slider_block();", i + 1);
    printf("spacing_slider%d.text_slider_block();", i + 1);
    printf("brightness_slider%d.text_slider_block();", i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;N_ENVELOPES,
    printf("env_attack_slider%d.text_slider_block();", i + 1);
    printf("env_decay_slider%d.text_slider_block();", i + 1);
    printf("env_sustain_slider%d.text_slider_block();", i + 1);
    printf("env_release_slider%d.text_slider_block();", i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;N_MODULATORS,
    printf("mod_freq_slider%d.text_slider_block();", i + 1);
    printf("mod_freq_slider%d.text_slider_block();", i + 1);
    printf("mod_freq_slider%d.text_slider_block();", i + 1);
    
    printf("mod_phase_slider%d.text_slider_block();", i + 1);
    printf("mod_phase_slider%d.text_slider_block();", i + 1);
    printf("mod_phase_slider%d.text_slider_block();", i + 1);
    
    /*
    printf("mod_lr_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", 100 * mod%d_lr), \"Spread\", \"Spread\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_lr_slider%d.check_text_input_defaults();", i + 1);
    
    printf("mod_amount_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", 100 * mod%d_amount), \"Amount\", \"Amount\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_amount_slider%d.check_text_input_defaults();", i + 1);
    */
    
    i += 1;
  );
?>

<?
  loop(i=0;N_FILTERS,
    printf("f_cutoff_slider%d.text_slider_block();", i + 1);
    printf("f_reso_slider%d.text_slider_block();", i + 1);
    printf("f_morph_slider%d.text_slider_block();", i + 1);
    i += 1;
  );
?>



// Fixes stuck notes
midi.notes_remain ? (
  midi.curSample += 1;
  // Reset if MIDI stuff updated
  midi_input = 1;
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

pass_through = 1;
midi.midi_block(pass_through);

@sample
freq_shift_modulator_sample();

midi.curSample += 1;
midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi_input = 1;
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

big_tick = update_ticker == 0;
update_ticker += 1;
(update_ticker > 128) ? (
  update_ticker = 0;
);

big_tick ? (
  midi.update_notes();
);

((n_update % SLOW_UPDATE_FACTOR) == 0) ? (
  pitchbend_modifier = 2 ^ (pitchbend_range * midi.pitchbend / 12);
  v0.update_voice();
  v1.update_voice();
  v2.update_voice();
  v3.update_voice();
  v4.update_voice();
  v5.update_voice();
  v6.update_voice();
  v7.update_voice();
  v8.update_voice();
  v9.update_voice();
  v10.update_voice();
  v11.update_voice();
);

v0.has_output ? v0.play_voice() : (v0.l = v0.r = 0);
v1.has_output ? v1.play_voice() : (v1.l = v1.r = 0);
v2.has_output ? v2.play_voice() : (v2.l = v2.r = 0);
v3.has_output ? v3.play_voice() : (v3.l = v3.r = 0);
v4.has_output ? v4.play_voice() : (v4.l = v4.r = 0);
v5.has_output ? v5.play_voice() : (v5.l = v5.r = 0);
v6.has_output ? v6.play_voice() : (v6.l = v6.r = 0);
v7.has_output ? v7.play_voice() : (v7.l = v7.r = 0);
v8.has_output ? v8.play_voice() : (v8.l = v8.r = 0);
v9.has_output ? v9.play_voice() : (v9.l = v9.r = 0);
v10.has_output ? v10.play_voice() : (v10.l = v10.r = 0);
v11.has_output ? v11.play_voice() : (v11.l = v11.r = 0);

spl0 += v0.l + v1.l + v2.l + v3.l + v4.l + v5.l + v6.l + v7.l + v8.l + v9.l + v10.l + v11.l;
spl1 += v0.r + v1.r + v2.r + v3.r + v4.r + v5.r + v6.r + v7.r + v8.r + v9.r + v10.r + v11.r;

chorus.apply_chorus(chorus_amount);

last_gain += d_gain;

n_update += 1;

function cheapo_block(x)
local(y)
global()
instance(xm1, ym1)
(
  y = x - xm1 + 0.995 * ym1;
  xm1 = x;
  ym1 = y;
  
  y
);

spl0 = ldc.cheapo_block(spl0);
spl1 = rdc.cheapo_block(spl1);

spl0 *= current_gain;
spl1 *= current_gain;

audio_buffer[audio_buffer_idx] = 0.5 * (spl0 + spl1);
audio_buffer_idx += 1;
audio_buffer_idx > osc_buffer ? audio_buffer_idx = 0;

current_f3_gain += df3_gain;
current_gain += d_gain;

@gfx
loaded = 0;
!loaded ? (
  loaded = gfx_loadimg(12, "./protosynth_dependencies/font.png");
  gfx_setimgdim(13, img_w, img_h);
);

function reset_color()
(
  gfx_r = gfx_g = gfx_b = 0.0; gfx_a = 1.0;
  gfx_mode = 1;
);

/* Background color */
gfx_dest = 13;
gfx_clear = 0;
gfx_set(0, 0, 0, 1);
gfx_rect(0, 0, img_w, img_h);
reset_color();

gfx_a = 0.1;
pad_width = 70;
pad_height = 70;
pad_spacing = 31;

side_pad = 8;
toggle_size = 6;

gfx_set(0.7, 0.5, 0.2, 0.3);
cx = side_pad;
cy = 0;
//osc1_enabled.choice_toggle(cx, cy, toggle_size, 0, 10, "Enable Oscillator 1", "Enable OSC1"); cx += toggle_size + 2;

MODULATOR_STRING=34;
sprintf(MODULATOR_STRING, "Modulator to apply\n\nRight click to select modulator source.\nLeft click and drag to change modulation depth.");

<?
  function uuid()
  (
    next_uuid += 1
  );
  
  function text_uuid()
  (
    next_uuid += 1
  );
  
  loop(i=0;8,
    printf("cx = side_pad;\n");
    
    printf("_osc%d_alpha = 0.7 * _osc%d_alpha + 0.2 * 0.3 * (over_osc == %d);", i + 1, i + 1, i + 1);
    printf("gfx_set(1.0, 1.0, 1.0, _osc%d_alpha);", i + 1);
    printf("gfx_rect(cx - 1, cy, 252, 8, 1);");
    
    printf("osc%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, osc%d_enabled, \"Enable Oscillator %d\", \"Enable OSC%d\") ? (osc%d_enabled = 1 - osc%d_enabled;);\ncx += toggle_size + 2;", i + 1, i + 1, i + 1, i + 1, i + 1, i + 1);
    printf("txt_blit(\"OSC%d\", cx, cy + 2); cx += 25;", i + 1);
    
    printf("osc_type_slider%d.current_value = osc%d_type;", i + 1, i + 1);
    printf("osc_type_slider%d.text_slider_ui(%d, cx, cy, 4 * toggle_size + 4, 8, sprintf(9, \"%%s\", osc_type(osc%d_type)), \"Type\", \"Type\"); cx += 4 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("osc%d_type = osc_type_slider%d.current_value;", i + 1, i + 1);
    
    printf("gain_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Gain envelope to apply\", \"OSC Envelope\", 1, 6, 0);\n cx += 10;", i + 1, uuid());
    printf("gain_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", osc%d_gain), \"Gain\", \"Gain\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("gain_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"OSC Envelope\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("gain_slider%d.check_text_input_defaults();", i + 1);
    
    printf("tune_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_tune), \"Tuning\", \"Tuning\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("tune_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Tune Mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("tune_slider%d.check_text_input_defaults();", i + 1);
    
    printf("spacing_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_spacing), \"Partial spacing\", \"Freq spacing\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("spacing_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Spacing Mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("spacing_slider%d.check_text_input_defaults();", i + 1);
    
    printf("brightness_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_brightness), \"Brightness\", \"Brightness\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("brightness_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Bright mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("brightness_slider%d.check_text_input_defaults();", i + 1);
    
    printf("cy += 8;");
    i += 1;
  );
?>
cy += 5;
cy_ref = cy;

<?
  loop(i=0;N_ENVELOPES,
    printf("cx = side_pad;\n");
    printf("env%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, 1, \"Enable Envelope %d\", \"Enable ENV%d\");\ncx += toggle_size + 2;", i + 1, i + 1, i + 1);
    printf("env%d_enabled.color=env_color;\n", i + 1);
    printf("txt_blit(\"ENV%d\", cx, cy + 2); cx += 25;", i + 1);
    printf("env_attack_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_attack), \"Attack\", \"Attack\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_attack_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Attack mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("env_attack_slider%d.check_text_input_defaults();", i + 1);
    
    printf("env_decay_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_decay), \"Decay\", \"Decay\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_decay_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Decay mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("env_decay_slider%d.check_text_input_defaults();", i + 1);
    
    printf("env_sustain_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%d\", 100 * env%d_sustain), \"Sustain\", \"Sustain\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_sustain_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Sustain mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("env_sustain_slider%d.check_text_input(%d) ? ( slider(env_sustain_slider%d.sl) = max(env_sustain_slider%d.sl_min, min(env_sustain_slider%d.sl_max, text_box.result / 100)); );", i + 1, uuid(), i + 1, i + 1, i + 1);
    //printf("env_sustain_slider%d.check_text_input_defaults();", i + 1);
    
    printf("env_release_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_release), \"Release\", \"Release\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_release_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Release mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("env_release_slider%d.check_text_input_defaults();", i + 1);
    
    printf("cy += 8;");
    i += 1;
  );
?>

cy += 5;
<?
  loop(i=0;N_VISIBLE_MODULATORS,
    printf("cx = side_pad;\n");
    printf("mod%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, 1, \"Enable Modulator %d\", \"Enable MOD%d\");\ncx += toggle_size + 2;", i + 1, i + 1, i + 1);
    printf("mod%d_enabled.color=mod_color;\n", i + 1);
    printf("txt_blit(\"MOD%d\", cx, cy + 2); cx += 25;", i + 1);
    
    printf("mod_type_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%s\", lfo_type(mod%d_type)), \"Type\", \"Type\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    
    printf("mod_freq_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\dHz\", mod%d_freq), \"Frequency\", \"Frequency\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_freq_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Freq mod\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("mod_freq_slider%d.check_text_input_defaults();", i + 1);
    
    printf("mod%d_restart.simple_serialize_toggle_big(cx, cy, 8, mod%d_restart, \"Reset phase %d on note on\", \"Phase init%d\") ? (mod%d_restart = 1 - mod%d_restart;);\ncx += toggle_size + 4;", i + 1, i + 1, i + 1, i + 1, i + 1, i + 1);
    printf("mod_phase_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%d\", 100 * mod%d_phase), \"Phase\", \"Phase\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_phase_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"Envelope\", 0, N_SELECTABLE_MODULATORS, 1);\n cx += 10;", i + 1, uuid());
    printf("mod_phase_slider%d.check_text_input(%d) ? ( slider(mod_phase_slider%d.sl) = max(mod_phase_slider%d.sl_min, min(mod_phase_slider%d.sl_max, text_box.result / 100)); );", i + 1, uuid(), i + 1, i + 1, i + 1);
    
    /*
    printf("mod_lr_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", 100 * mod%d_lr), \"Spread\", \"Spread\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_lr_slider%d.check_text_input_defaults();", i + 1);
    
    printf("mod_amount_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", 100 * mod%d_amount), \"Amount\", \"Amount\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("mod_amount_slider%d.check_text_input_defaults();", i + 1);
    */
    
    printf("cy += 8;");
    i += 1;
  );
?>

tune_slider1.active = 1;

//(x, y, w, select, slider_idx, hint, info)
cx = side_pad;
cy += 4;

function node(x, y, w, h, text, text_offset)
instance(_x, _y, _w, _h, x_from, x_to, y_from, y_to, over)
local(mouse_nx, mouse_ny)
global(x_offset, y_offset, blit_scale, mouse_cap, gfx_x, gfx_y, mouse_x, mouse_y, cap_mode)
(
  gfx_set(0.2, 0.2, 0.3, 1.0);
  _x = x; _y = y; _w = w; _h = h;
  gfx_rect(x, y, w, h, 0);
  x_from = x + w;
  y_from = y + 0.5 * h;
  x_to = x;
  y_to = y + 0.5 * h;
  
  mouse_nx = (mouse_x - x_offset) / blit_scale;
  mouse_ny = (mouse_y - y_offset) / blit_scale;
  over = ((mouse_nx > x) && (mouse_nx < (x + w)) && (mouse_ny > y) && (mouse_ny < (y + w)) && (cap_mode == 0));
  
  text ? (
    txt_blit(text, x + text_offset, y + 2);
  );
);

function mix_node(x, y, w, h, slider_idx)
instance()
local(value, text, mouse_nx, mouse_ny, over, ix)
global(gfx_a, gfx_x, gfx_y, mouse_x, mouse_y, x_offset, y_offset, blit_scale, cap_mode, last_cap, mouse_cap)
(
  value = slider(slider_idx);
  text = (value == 0) ? "ADD"
  : (value == 1) ? "AMP"
  : (value == 2) ? "MUL"
  : (value == 3) ? "XOR"
  : (value == 4) ? "XOD"
  : (value == 5) ? "CON"
  : (value == 6) ? "FrS";
  this.node(x, y, w, h, text, 2);

  mouse_nx = (mouse_x - x_offset) / blit_scale;
  mouse_ny = (mouse_y - y_offset) / blit_scale;
  over = ((mouse_nx > x) && (mouse_nx < (x + w)) && (mouse_ny > y) && (mouse_ny < (y + w)) && (cap_mode == 0));

  ((last_cap == 0) && over) ? (
    (mouse_cap == 2) ? (
      gfx_x = mouse_x;
      gfx_y = mouse_y;
      ix = gfx_showmenu("Additive mixing|Amplitude modulation|Ring modulation (multiply signals)|XOR|XOR on diff|Convolve|Freq Shift");
      (ix > 0) ? (
        slider(slider_idx) = ix - 1;
      );
    );
  );
);

function cline(x1, y1, x2, y2)
(
  gfx_line(floor(x1), floor(y1) - 0.5, floor(x2), floor(y2) - 0.5, 1);
  gfx_line(floor(x1), floor(y1), floor(x2), floor(y2), 0);
  gfx_line(floor(x1), floor(y1) + 0.5, floor(x2), floor(y2) + 0.5, 1);
);

block_size = 8;
spacing = 10;
left_side = 10;
start = cy;
cx = left_side;
cy = start;

over_filter = 0;
over_osc = 0;

//input_size = 
<?
  loop(i=0;8,
    printf("n1%d.node(cx, cy, block_size, block_size, 0, 0);", i);
    printf("n1%d.over ? (over_osc = %d; (last_cap == 0 && mouse_cap == 1) ? osc%d_enabled = 1 - osc%d_enabled; );", i, i + 1, i + 1, i + 1);
    
    printf("osc%d_enabled ? gfx_rect(cx, cy, block_size, block_size);", i + 1);
    printf("cy += block_size + 2;");
    i += 1;
  );
?>

cx = left_side + block_size + spacing;
cy = start + 0.5 * (block_size + 2);
// LAST
<?
  current_slider = 128; /* First mix slider */
  loop(i=0;4,
    printf("n2%d.mix_node(cx, cy, 2 * block_size + 2, block_size, %d);", i, current_slider);
    printf("cy += 2 * (block_size + 2);");
    i += 1;
    current_slider += 1;
  );
?>

cx = left_side + 3 * block_size + 2 * spacing;
cy = start + 0.5 * 3 * (block_size + 2);

<?
  loop(i=0;2,
    printf("n3%d.mix_node(cx, cy, 2 * block_size + 2, block_size, %d);", i, current_slider);
    printf("cy += 4 * (block_size + 2);");
    i += 1;
    current_slider += 1;
  );
?>

cx = left_side + 5 * block_size + 3 * spacing;
cy = start + 0.5 * 3 * (block_size + 2);

<?
  loop(i=0;2,
    printf("n4%d.node(cx, cy, 2 * block_size - 1, block_size, \"F%d\", 3);", i, i + 1);
    printf("n4%d.over ? (over_filter = %d; (last_cap == 0 && mouse_cap == 1) ? filter%d_enabled = 1 - filter%d_enabled; );", i, i + 1, i + 1, i + 1);
    printf("!filter%d_enabled ? ( gfx_set(0, 0, 0, 0.7); gfx_rect(cx, cy, 2 * block_size - 1, block_size, 1); );", i + 1);
    printf("cy += 4 * (block_size + 2);");
    i += 1;
  );
?>

cx = left_side + 7 * block_size + 4 * spacing;
cy = start + 3.5 * (block_size + 2);
n5.mix_node(cx, cy, 2 * block_size + 2, block_size, 134);

cy += 4 * (block_size + 2);
cx += 2 * block_size + spacing;
cy = start + 3.5 * (block_size + 2);
n6.node(cx, cy, 2 * block_size - 1, block_size, "F3", 3);
n6.over ? (
  over_filter = 3;
  (last_cap == 0 && mouse_cap == 1) ? filter3_enabled = 1 - filter3_enabled;
);
!filter3_enabled ? ( gfx_set(0, 0, 0, 0.7); gfx_rect(cx, cy, 2 * block_size - 1, block_size, 1); );


//cx += 2 * block_size + spacing;
cy = start + 5.0 * (block_size + 2);
n7.node(cx, cy, 2 * block_size - 1, block_size, "F4", 3);
n7.over ? (
  over_filter = 4;
  (last_cap == 0 && mouse_cap == 1) ? filter4_enabled = 1 - filter4_enabled;
);
!filter4_enabled ? ( gfx_set(0, 0, 0, 0.7); gfx_rect(cx, cy, 2 * block_size - 1, block_size, 1); );


gfx_set(0.2, 0.2, 0.3, 1.0);
gfx_a = 0.2;
gfx_rect(right_side, 163, 180, 30);
gfx_a = 1.0;
gfx_r = 0.5 * gfx_r;
gfx_g = 0.5 * gfx_g;
gfx_b = 0.5 * gfx_b;
gfx_rect(right_side - 1, 163 - 1, 182, 32, 0);
draw_oscilloscope(right_side, 162, 180, 30);

gfx_a = 1.0;

gfx_set(0.2, 0.2, 0.3, 1.0);
cline(n10.x_from, n10.y_from, n20.x_to, n20.y_to);
cline(n11.x_from, n11.y_from, n20.x_to, n20.y_to);
cline(n12.x_from, n12.y_from, n21.x_to, n21.y_to);
cline(n13.x_from, n13.y_from, n21.x_to, n21.y_to);
cline(n14.x_from, n14.y_from, n22.x_to, n22.y_to);
cline(n15.x_from, n15.y_from, n22.x_to, n22.y_to);
cline(n16.x_from, n16.y_from, n23.x_to, n23.y_to);
cline(n17.x_from, n17.y_from, n23.x_to, n23.y_to);

cline(n20.x_from, n20.y_from, n30.x_to, n30.y_to);
cline(n21.x_from, n21.y_from, n30.x_to, n30.y_to);
cline(n22.x_from, n22.y_from, n31.x_to, n31.y_to);
cline(n23.x_from, n23.y_from, n31.x_to, n31.y_to);

cline(n30.x_from, n30.y_from, n40.x_to, n40.y_to);
cline(n31.x_from, n31.y_from, n41.x_to, n41.y_to);

cline(n40.x_from, n40.y_from, n5.x_to, n5.y_to);
cline(n41.x_from, n41.y_from, n5.x_to, n5.y_to);

cline(n5.x_from, n5.y_from, n6.x_to, n6.y_to);
//gfx_line(n50.x_from, n50.y_from, n60.x_to, n60.y_to);

// sprintf(9, \"%%\.1f\", f%d_morph)
function morph_level(morph)
(
  (morph < 0.2) ? (
    "LP"
  ) : ( morph < 0.4 ) ? (
    "BP"
  ) : ( morph < 0.6 ) ? (
    "HP"
  ) : ( morph < 0.8 ) ? (
    "BR"
  ) : (
    "LP"
  )
);

right_side = 155;
cy = 208-5-7;
<?
  loop(i=0;N_FILTERS,
    printf("cx = right_side;\n");
    printf("_filt%d_alpha = 0.7 * _filt%d_alpha + 0.2 * 0.3 * (over_filter == %d);", i + 1, i + 1, i + 1);
    printf("gfx_set(1.0, 1.0, 1.0, _filt%d_alpha);", i + 1);
    printf("gfx_rect(right_side - 1, cy, 181, 8 %s, 1);", i == 2 ? "+ 8" : "");
    printf("filt%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, filter%d_enabled, \"Enable Filter %d\", \"Enable F%d\") ? (filter%d_enabled = 1 - filter%d_enabled);\ncx += toggle_size + 2;", i + 1, i + 1, i + 1, i+1, i + 1, i + 1, i + 1);
    printf("txt_blit(\"F%d\", cx, cy + 2); cx += 15;", i + 1);
    
    printf("center = 0.5 * sampling_ratio * srate * exp((1.0 - min(f_cutoff_slider%d.display_value, 0.99999)) * log(20/22050));\n", i + 1);
    printf("f_cutoff_slider%d.active = filter%d_enabled;\n", i + 1, i + 1);
    printf("f_cutoff_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, center < 1000 ? sprintf(1, \"%%dHz\", center) : sprintf(1, \"%%.1fk\", center/1000), \"Filter %d cutoff\", \"F%d Cutoff\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1, i + 1, i + 1, i + 1);
    printf("f_cutoff_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"F%d Cutoff Env\", 0, %d, 1);\n cx += 8;", i + 1, uuid(), i + 1, N_SELECTABLE_MODULATORS);
    printf("f_cutoff_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"F%d Cutoff Env\", 0, %d, 2);\n cx += 10;", i + 1, uuid(), i + 1, N_SELECTABLE_MODULATORS);


    printf("f_cutoff_slider%d.check_text_input(%d) ? ( slider(f_cutoff_slider%d.sl) = max(f_cutoff_slider%d.sl_min, min(f_cutoff_slider%d.sl_max, 1.0 - log(2.0 * text_box.result / sampling_ratio / srate) / log(20/22050) )); );", i + 1, uuid(), i + 1, i + 1, i + 1);

    printf("f_reso_slider%d.active = filter%d_enabled;\n", i + 1, i + 1);
    printf("f_reso_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\d\", 100 * f%d_reso), \"Filter %d resonance\", \"F%d Resonance\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1, i + 1, i + 1, i + 1);
    printf("f_reso_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"F%d Reso Env\", 0, %d, 1);\n cx += 8;", i + 1, uuid(), i + 1, N_SELECTABLE_MODULATORS);
    printf("f_reso_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"F%d Reso Env\", 0, %d, 2);\n cx += 10;", i + 1, uuid(), i + 1, N_SELECTABLE_MODULATORS);
    
    printf("f_reso_slider%d.check_text_input(%d) ? ( slider(f_reso_slider%d.sl) = max(f_reso_slider%d.sl_min, min(f_reso_slider%d.sl_max, text_box.result / 100)); );", i + 1, uuid(), i + 1, i + 1, i + 1);
    
    printf("f_morph_slider%d.active = filter%d_enabled;\n", i + 1, i + 1);
    printf("f_morph_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, morph_level(f%d_morph), \"Filter %d morph\\n\\nMorphs between LP, \\nBP, HP, BR and LP\\n\", \"F%d Morph\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1, i + 1, i + 1, i + 1);
    printf("f_morph_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"F%d Morph Env\", %d, 8, 1);\n cx += 8;", i + 1, uuid(), i + 1, N_SELECTABLE_MODULATORS);
    printf("f_morph_slider%d.modulator_field(%d, cx, cy, 8, 1, MODULATOR_STRING, \"F%d Morph Env\", %d, 8, 2);\n cx += 10;", i + 1, uuid(), i + 1, N_SELECTABLE_MODULATORS);
    printf("f_morph_slider%d.check_text_input_defaults();", i + 1);
    
    printf("cy += 8;");
    i += 1;
  );
?>

cx = right_side + 23;
filter_type_slider1.active = filter3_enabled;
filter_type_slider1.current_value = f3_type;
filter_type_slider1.text_slider_ui(<?printf("%d", uuid());?>, cx, cy, 5 * toggle_size + 4, 8, filt_type(f3_type), "Filter Type", "F3 Type");

cx += 8 * toggle_size + 5;
f3_type = filter_type_slider1.current_value;

filter_gain_slider3.active = filter3_enabled && f3_type > 0;
filter_gain_slider3.text_slider_ui(<?printf("%d", uuid(););?>, cx, cy, 5 * toggle_size + 4, 8, sprintf(1, "%0.1f", f3_drive), "F3 Drive", "F3 Drive");
cx += 8 * toggle_size + 5;

filter_keyfollow1.active = filter3_enabled;
filter_keyfollow1.text_slider_ui(<?printf("%d", uuid(););?>, cx, cy, 5 * toggle_size + 4, 8, sprintf(1, "%d", 100 * keyfollow), "Key follow", "Key follow");


cy += 8;


//  output_slider.serialize(version);
//  chorus_slider.serialize(version);
//  noise_slider.serialize(version);

//slider254:output_gain=0<-72,0,0,0.0001>Output Gain
//slider255:chorus_amount=0<0,1,0.0001>Chorus amount
//slider256:noise=0<0,1,0.0001:log>Noise

txt_blit("FX", right_side + 8, cy + 3);
cx = right_side + 23;
cy += 1;
chorus_slider1.text_slider_ui(<?printf("%d", uuid(););?>, cx, cy, 5 * toggle_size + 4, 8, sprintf(1, "%d", 100 * chorus_amount), "Widener", "Widener");
chorus_slider1.check_text_input(<?printf("%d", uuid(););?>) ? ( slider(chorus_slider1.sl) = max(chorus_slider1.sl_min, min(chorus_slider1.sl_max, text_box.result / 100)); );
cx += 8 * toggle_size + 5;

//txt_blit("A", cx - 8 , cy + 2);
noise_slider1.text_slider_ui(<?printf("%d", uuid(););?>, cx, cy, 5 * toggle_size + 4, 8, sprintf(1, "%0.1f", 100 * noise), "Pitch noise", "Pitch noise");
noise_slider1.check_text_input(<?printf("%d", uuid(););?>) ? ( slider(noise_slider1.sl) = max(noise_slider1.sl_min, min(noise_slider1.sl_max, text_box.result / 100)); );

cx += 8 * toggle_size + 5;
//txt_blit("G", cx - 8 , cy + 2);
output_slider1.text_slider_ui(<?printf("%d", uuid(););?>, cx, cy, 5 * toggle_size + 4, 8, sprintf(1, "%0.1f", output_gain), "Output Gain", "Output Gain");
output_slider1.check_text_input_defaults();

hinter.draw_hints();

i = 0;
str = sprintf(1, "");
loop(MAX_VOICES,
  str = strcat(str, (midi.active_note_mem[i] > 0) ? ("P") : (midi.active_note_mem[i] == 0) ? ("0") : ("R"));
  i += 1;
);

gfx_set(1, 1, 1, 0.3);
txt_blit(sprintf(2, "proto-synth %s", str), side_pad, img_h - 6);
(info_active > 0.001) ? (
  gfx_a = min(0.3, info_active);
  txt_blit(14, img_w - 66, img_h - 6);
  info_active *= 0.7;
) : (
  txt_blit("ALPHA VERSION", img_w - 66, img_h - 6);
);

text_box.render_text_input();

gfx_dest = -1;
gfx_set(1, 1, 1, 1);

raw_blit_scale = min(gfx_h / img_h, gfx_w / img_w);
blit_scale = raw_blit_scale >= 1 ? floor(raw_blit_scale) : raw_blit_scale;
x_offset = (gfx_w - blit_scale * img_w) * 0.5;
y_offset = (gfx_h - blit_scale * img_h) * 0.5;
shake = equ + 2 * (equ > 1);
gfx_x = x_offset; gfx_y = y_offset;
gfx_x += 0.25 * rand() * shake * blit_scale;
gfx_y += 0.25 * rand() * shake * blit_scale;
shake > 0 ? shake -= 1;

/*!show_ui ? (
  gfx_set(10/255, 31/255, 49/255, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);
);*/

gfx_set(1, 1, 1, 1);
gfx_mode = 4;
gfx_blit(13, blit_scale, 0);

last_cap = mouse_cap;
last_mouse_x = mouse_x;
last_mouse_y = mouse_y;
mouse_nx = (mouse_x - x_offset) / blit_scale;
mouse_ny = (mouse_y - y_offset) / blit_scale;

/*
1 ? (
  gfx_x = 0;
  gfx_y = 30;
  gfx_set(1, 1, 1, 1);
  fff = midi.active_note_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
  
  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  fff = midi.note_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
);
*/

/*
  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  fff = v0.modulator_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
*/

