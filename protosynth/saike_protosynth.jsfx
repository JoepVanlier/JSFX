desc:Protosynth
options:maxmem=20000000
tags: instrument
version: 0.01
author: Joep Vanlier
changelog: WIP
license: MIT
provides:
  protosynth_dependencies/*

<?
  tuning_basic = 0.5;
  loop(i=0;8,
    par = i * 6 + 1;
    printf("slider%d:osc%d_gain=-9<-72,0,0.0001>-osc%d gain\n", par, i + 1, i + 1);
    printf("slider%d:osc%d_tune=%f<0.25,8,0.0001>-osc%d tune\n", par + 1, i + 1, tuning_basic, i + 1);
    printf("slider%d:osc%d_spacing=1<0.25,8,0.0001>-osc%d spacing\n", par + 2, i + 1, i + 1);
    printf("slider%d:osc%d_brightness=0.2<0.0,0.95,.0001>-osc%d brightness\n", par + 3, i + 1, i + 1);
    printf("slider%d:osc%d_spacing_offset=0<0,5000.0001>-osc%d spacing offset\n", par + 4, i + 1, i + 1);
    tuning_basic *= 1.5;
    
    i += 1
  );
?>

<?
  loop(i=0;8,
    par = i * 5 + 49;
    printf("slider%d:env%d_attack=3.0<3.0,300.0,0.0001:log>-env%d attack\n", par, i + 1, i + 1);
    printf("slider%d:env%d_decay=30.0<30.0,3000.0.0001:log>-env%d decay\n", par + 1, i + 1, i + 1);
    printf("slider%d:env%d_sustain=0.7<0.0,1.0,0.0001>-env%d sustain\n", par + 2, i + 1, i + 1);
    printf("slider%d:env%d_release=300.0<30.0,3000.0,0.0001:log>-env%d release\n", par + 3, i + 1, i + 1);
    printf("slider%d:env%d_amount=1<0.0,1.0,0.0001>-env%d amount\n", par + 4, i + 1, i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;4,
    par = i * 5 + 90;
    printf("slider%d:mod%d_type=0<0,1,16>-mod%d_type\n", par, i + 1, i + 1);
    printf("slider%d:mod%d_freq=0.0<0.0,20.0.0001:log>-mod%d freq\n", par + 1, i + 1, i + 1);
    printf("slider%d:mod%d_phase=0<0.0,1.0,0.0001>-mod%d phase\n", par + 2, i + 1, i + 1);
    printf("slider%d:mod%d_lr=0.0<0.0,1.0,0.0001>-mod%d lr\n", par + 3, i + 1, i + 1);
    printf("slider%d:mod%d_amount=0.0<0.0,1.0,0.0001>-mod%d amount\n", par + 3, i + 1, i + 1);
    
    i += 1;
  );
?>

slider128:mix_mode1=0<0,2,1>-Mix mode 1
slider129:mix_mode2=0<0,2,1>-Mix mode 2
slider130:mix_mode3=0<0,2,1>-Mix mode 3
slider131:mix_mode4=0<0,2,1>-Mix mode 4
slider132:mix_mode21=0<0,2,1>-Mix mode 21
slider133:mix_mode22=0<0,2,1>-Mix mode 22
slider134:mix_mode31=0<0,2,1>-Mix mode 31

slider135:cutoff21=0<0,1,0.001>-Cutoff Mix 21
slider136:resonance21=0<0,1,0.001>-Resonance Mix 21
slider137:morph21=0<0,1,0.001>-Morph Mix 21

slider138:cutoff22=0<0,1,0.001>-Cutoff Mix 22
slider139:resonance22=0<0,1,0.001>-Resonance Mix 22
slider140:morph22=0<0,1,0.001>-Morph Mix 22

slider141:type31=0<0,16,1>-Filter Type
slider142:drive31=0<0,1,0.001>-Drive Mix
slider143:cutoff31=0<0,1,0.001>-Cutoff Mix
slider144:resonance31=0<0,1,0.001>-Resonance Mix
slider145:morph31=0<0,1,0.001>-Morph Mix

slider256:noise=0<0,1,0.0001:log>Noise

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

import saike_proto_synth_oscillators.jsfx-inc
import saike_proto_synth_kp_midi.jsfx-inc
import saike_proto_synth_pixel_gfx.jsfx-inc
import saike_proto_stft_fx.jsfx-inc

@init
SLOW_UPDATE_FACTOR = 16;
MAX_VOICES = 12;
<?MAX_VOICES = 12;?>
INV_SLOW_UPDATE_FACTOR = 1.0 / SLOW_UPDATE_FACTOR;

model = 5;

<?
  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.init_slider_ui(%d, -72, 0, 0);\n", i + 1, par);
    printf("tune_slider%d.init_slider_ui(%d, 0.25, 8.0, 0);\n", i + 1, par + 1);
    printf("spacing_slider%d.init_slider_ui(%d, 0.25, 8.0, 0);\n", i + 1, par + 2);
    printf("brightness_slider%d.init_slider_ui(%d, 0.0, 0.95, 0);\n", i + 1, par + 3);
    printf("spacing_offset_slider%d.init_slider_ui(%d, 0, 5000.0, 0);\n", i + 1, par + 4);
    i += 1;
  );
?>

<?
  loop(i=0;8,
    par = i * 5 + 49;
    printf("env_attack_slider%d.init_slider_ui(%d, 3.0, 300.0, 1);\n", i + 1, par);
    printf("env_decay_slider%d.init_slider_ui(%d, 30.0, 3000.0, 1);\n", i + 1, par + 1);
    printf("env_sustain_slider%d.init_slider_ui(%d, 0, 1.0, 0);\n", i + 1, par + 2);
    printf("env_release_slider%d.init_slider_ui(%d, 30, 3000.0, 1);\n", i + 1, par + 3);
    
    printf("env_attack_slider%d.color=0.5;\n", i + 1);
    printf("env_decay_slider%d.color=0.5;\n", i + 1);
    printf("env_sustain_slider%d.color=0.5;\n", i + 1, par + 2);
    printf("env_release_slider%d.color=0.5;\n", i + 1, par + 3);
    
    printf("(gain_slider%d.gain_mod_target == 0) ? gain_slider%d.gain_mod_target = 1;\n cx += 10;", i + 1, i + 1);
    i += 1;
  );
?>

function init_voice(freemem)
local()
global()
instance(
  osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, modulator_mem
)
(
  freemem = (modulator_mem = freemem) + 32;
  memset(modulator_mem, 0, 32);
  osc1.init_dsf_osc();
  osc2.init_dsf_osc();
  osc3.init_dsf_osc();
  osc4.init_dsf_osc();
  osc5.init_dsf_osc();
  osc6.init_dsf_osc();
  osc7.init_dsf_osc();
  osc8.init_dsf_osc();
  
  freemem
);

function init_voice_mixers(freemem, shared_fft_buffer, window_buffer)
local()
global()
instance(mix1, mix2, mix3, mix4, mix21, mix22, mix31)
(
  freemem = mix1.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix2.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix3.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix4.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix21.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix22.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  freemem = mix31.init_stft_mix_mem(freemem, shared_fft_buffer, window_buffer);
  
  freemem
);

function update_voice()
local(cur_freq, cur_spacing, cur_brightness, cfreq, noise_factor, atk, gain)
global(
  INV_SLOW_UPDATE_FACTOR,
  midi.active_note_mem, midi.active_note_vel,
  rel_spacing, freq_atten, n_update,
  <?loop(i=1;8, printf("osc%d_gain,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_tune,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_brightness,", i); i += 1);?>
  <?loop(i=1;8, printf("osc%d_spacing,", i); i += 1);?>,
  <?loop(i=1;8, printf("osc%d_spacing_offset,", i); i += 1);?>,
  noise,
  <?loop(i=1;8, printf("env%d_atk_samples,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_k_atk,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_k_decay,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_k_release,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_sustain,", i); i += 1);?>
  
  <?loop(i=1;8, printf("gain_slider%d.gain_mod_target,", i); i += 1);?>
  
  <?loop(i=1;8, printf("gain_slider%d.mod_target1,", i); i += 1);?>
  <?loop(i=1;8, printf("gain_slider%d.mod_amount1,", i); i += 1);?>
  
  <?loop(i=1;8, printf("tune_slider%d.mod_target1, tune_slider%d.mod_amount1, tune_slider%d.get_modulated_value1, tune_slider%d.sl, tune_slider%d.sl_max, tune_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;8, printf("spacing_slider%d.mod_target1, spacing_slider%d.mod_amount1, spacing_slider%d.get_modulated_value1, spacing_slider%d.sl, spacing_slider%d.sl_max, spacing_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
  <?loop(i=1;8, printf("brightness_slider%d.mod_target1, brightness_slider%d.mod_amount1, brightness_slider%d.get_modulated_value1, brightness_slider%d.sl, brightness_slider%d.sl_max, brightness_slider%d.sl_min,", i, i, i, i, i, i); i += 1);?>
)
instance(
  midi_idx,
  freq, osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, rand_src,
  g1, g2, g3, g4, g5, g6, g7, g8,
  dg1, dg2, dg3, dg4, dg5, dg6, dg7, dg8,
  has_output,
  on,
  current_sample, pressed, has_played,
  modulator_mem,
)
(
  // Update envelopes and modulators
  <?loop(i=1;8, printf("atk = current_sample < env%d_atk_samples; modulator_mem[%d] += (atk ? env%d_k_atk : pressed ? env%d_k_decay : env%d_k_release) * (max(atk, env%d_sustain * pressed) - modulator_mem[%d]);\n", i, i, i, i, i, i, i); i += 1);?>
  
  has_output = max(max(max(max(max(max(max(max(g1, g2), g3), g4), g5), g6), g7), g8), pressed) > 0.0001;
  (!has_output) ? (
    on = 0;
    // Flag as available for new midi notes
    has_played ? (
      midi.active_note_mem[midi_idx] = 0;
      midi.active_note_vel[midi_idx] = 0;
      has_played = 0;
    );
  );
  
  rand_src = 0.9 * rand_src + 0.1 * rand();
  noise_factor = (1 - noise) + (noise + noise) * rand_src;
  cfreq = freq * noise_factor;
  
  // Update oscillators
  <?
    function get_modulated_value1_preproc(target, slider_name, idx)
    (
      printf("
        %s = %s%d.mod_target1 ? (
            max(min(slider(%s%d.sl) + %s%d.mod_amount1 * modulator_mem[%s%d.mod_target1], %s%d.sl_max), %s%d.sl_min)
          ) : slider(%s%d.sl);
        ",
        target,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx,
        slider_name, idx
      )
    );
  
    loop(i=1;8,
      printf("gain = min(0, osc%d_gain + (gain_slider%d.mod_target1 ? gain_slider%d.mod_amount1 * modulator_mem[gain_slider%d.mod_target1] : 0));", i, i, i, i);
      printf("dg%d = INV_SLOW_UPDATE_FACTOR * (10^(0.05 * gain) * modulator_mem[gain_slider%d.gain_mod_target] - g%d);", i, i, i);
      
      get_modulated_value1_preproc("cur_freq", "tune_slider", i);
      printf("cur_freq *= cfreq;");
      get_modulated_value1_preproc("cur_spacing", "spacing_slider", i);
      get_modulated_value1_preproc("cur_brightness", "brightness_slider", i);
      
      printf("osc%d.update_dsf_osc(cur_freq, cur_spacing * cur_freq + osc%d_spacing_offset, cur_brightness, 0);\n", i, i);
      i += 1
    );
  ?>
  
  current_sample += 1;
);

function initialize_envelopes()
local(to_samples, sample_rate, log001, log001tds)
global(
  srate,
  SLOW_UPDATE_FACTOR,
  <?loop(i=1;8, printf("env%d_attack,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_decay,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_sustain,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_release,", i); i += 1);?>
  
  <?loop(i=1;8, printf("env%d_atk_samples,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_k_atk,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_k_decay,", i); i += 1);?>
  <?loop(i=1;8, printf("env%d_k_release,", i); i += 1);?>
)
instance(current_sample, has_played)
(
  sample_rate = srate / SLOW_UPDATE_FACTOR;
  to_samples = 0.001 * sample_rate;  // Since times were specified in ms
  log001 = log(0.01);
  log001tds = log001 / to_samples;
  current_sample = 0;
  has_played = 1;
  
  <?
    loop(i=1;8,
      printf("env%d_atk_samples = env%d_attack * to_samples;\n", i, i);
      printf("env%d_k_atk = - log001 / env%d_atk_samples;\n", i, i);
      printf("env%d_k_decay = - log001tds / env%d_decay;\n", i, i);
      printf("env%d_k_release = - log001tds / env%d_release;\n", i, i);
      i += 1;
    );
  ?>
);

function play_voice()
local(
  o1, o2, o3, o4, o5, o6, o7, o8, t1, t2,
)
global(
  mix_mode1, mix_mode2, mix_mode3, mix_mode4,
  mix_mode21, mix_mode22,
  mix_mode31,
)
instance(
  mix1, mix2, mix3, mix4, mix21, mix22, mix31,
  osc1, osc2, osc3, osc4, osc5, osc6, osc7, osc8, l, r
  g1, g2, g3, g4, g5, g6, g7, g8,
  dg1, dg2, dg3, dg4, dg5, dg6, dg7, dg8,
)
(
  <?
    function gen_mixer(mix_out, mix_id, o1, o2)
    (
      printf(
        "o%d = (mix_mode%d == 0) ? (o%d + o%d) 
        : (mix_mode%d == 1) ? (o%d * (1.0 + o%d)) 
        : (mix_mode%d == 2) ? (o%d * o%d) 
        : (mix_mode%d == 3) ? (min(max(o%d, o%d), min(o%d, o%d))) 
        : (mix_mode%d == 4) ? (t1 = o%d + o%d; t2 = o%d - o%d; min(max(t1, t2), -min(t1, t2))) 
        : (mix_mode%d == 5) ? (mix%d.process_stft_mixer(o%d, o%d); mix%d.out_left);",
        mix_out, 
        mix_id, o1, o2, 
        mix_id, o1, o2, 
        mix_id, o1, o2, 
        mix_id, o1, o2, o1, o2, 
        mix_id, o1, o2, o1, o2,
        mix_id, mix_id, o1, o2, mix_id, mix_id
      );
    );
  ?>
  
  o1 = osc1.dsf_step() * g1;
  o2 = osc2.dsf_step() * g2;
  <?gen_mixer(1, 1, 1, 2);?>
  
  o3 = osc3.dsf_step() * g3;
  o4 = osc4.dsf_step() * g4;
  <?gen_mixer(2, 2, 3, 4);?>

  o5 = osc5.dsf_step() * g5;
  o6 = osc6.dsf_step() * g6;
  <?gen_mixer(3, 3, 5, 6);?>
  
  o7 = osc7.dsf_step() * g7;
  o8 = osc8.dsf_step() * g8;
  <?gen_mixer(4, 4, 7, 8);?>
  
  <?gen_mixer(1, 21, 1, 2);?>
  <?gen_mixer(2, 22, 3, 4);?>
  
  <?gen_mixer(1, 31, 1, 2);?>
 
  l = r = o1;
 
  /*mix1 = (mix_mode1 == 0) ? (o1 + o2) : (mix_mode1 == 1) ? (o1 * (1.0 + o2)) : (mix_mode1 == 2) ? (o1 - o2);
  
  o3 = osc3.dsf_step();
  o4 = osc4.dsf_step();

  mix2 = (mix_mode2 == 0) ? (o3 + o4) : (mix_mode2 == 1) ? (o3 * (1.0 + o4)) : (mix_mode2 == 2) ? (o3 - o4);

  o5 = osc5.dsf_step();
  o6 = osc6.dsf_step();

  mix3 = (mix_mode3 == 0) ? (o5 + o6) : (mix_mode3 == 1) ? (o5 * (1.0 + o6)) : (mix_mode2 == 2) ? (o3 - o4);
  */

  //l = r = 0.2 * osc1.dsf_step() + 0.2 * osc2.dsf_step() + 0.13 * osc3.dsf_step() + 0.15 * osc4.dsf_step() + 0.14 * osc5.dsf_step() + 0.15 * osc6.dsf_step() + 0.05 * osc7.dsf_step() + 0.05 * osc8.dsf_step();
  //l = r = 0.2 * osc1.dsf_step() * (1 + osc2.dsf_step())
  <?loop(i=1;8, printf("g%d += dg%d;\n", i, i); i += 1);?>
);
  
function stop_voice()
local()
instance(on)
global()
(
  on = 0;
);


function pitch_to_freq(pitch)
local(scaling, frac, temp)
global(microtuned, tuning_memory, sample_time, ln)
instance()
(
  microtuned ? (
    temp = min(127, max(0, pitch + 69));
    frac = temp - floor(temp);
    ln = temp;
    (pow(tuning_memory[temp], (1.0 - frac)) * pow(tuning_memory[temp + 1], frac))
  ) : (
    440 * 2 ^ (pitch / 12)
  );
);

function process_midi(note_idx, active, vel, state, ref_pitch)
local()
global(initialize_envelopes, modulator_mem)
instance(on, freq, pressed, current_sample, midi_idx)
(
  midi_idx = note_idx;
  (state == 1) ? (
    // Note on
    on = 1;
    freq = pitch_to_freq(active + ref_pitch);
    pressed = 1;
    this.initialize_envelopes();
    this.update_voice();
  ) : (state == -1) ? (
    // Release
    pressed = 0;
    current_sample = 100000000000000000; // Make sure we are beyond the attack
  );
);


function update_notes()
instance(
  notes_on, active_note_mem, active_note_vel, active_note_state, note_history,
  last_count
)
global(
  midi.pitchbend, midi.last_vel,
  latest_note,
  pitchbend_range,
  pitch_shift,
  glide,
  v0.on, v1.on, v2.on, v3.on, 
  v4.on, v5.on, v6.on, v7.on, 
  v8.on, v9.on, v10.on, v11.on,
  v0.process_midi, v1.process_midi, v2.process_midi, v3.process_midi,
  v4.process_midi, v5.process_midi, v6.process_midi, v7.process_midi,
  v8.process_midi, v9.process_midi, v10.process_midi, v11.process_midi,
)
local(
  ref_pitch, remainder,
)
(
  ref_pitch = pitchbend_range * midi.pitchbend + pitch_shift - 69;
  
  latest_note = note_history[notes_on - 1];
  glide ? (
    v1.on = v2.on = v3.on = v4.on = v5.on = v6.on = v7.on = v8.on = v9.on = v10.on = v11.on = 0;
    
    (notes_on > 0) ? (
      v0.process_midi(latest_note, active_note_mem[latest_note], active_note_vel[latest_note], active_note_state[latest_note], ref_pitch);
    ) : (
      v0.process_midi(latest_note, active_note_mem[latest_note], active_note_vel[latest_note], -1, ref_pitch);
    );
  ) : (
    v0.process_midi(0, active_note_mem[0], active_note_vel[0], active_note_state[0], ref_pitch);
    v1.process_midi(1, active_note_mem[1], active_note_vel[1], active_note_state[1], ref_pitch);
    v2.process_midi(2, active_note_mem[2], active_note_vel[2], active_note_state[2], ref_pitch);
    v3.process_midi(3, active_note_mem[3], active_note_vel[3], active_note_state[3], ref_pitch);
    v4.process_midi(4, active_note_mem[4], active_note_vel[4], active_note_state[4], ref_pitch);
    v5.process_midi(5, active_note_mem[5], active_note_vel[5], active_note_state[5], ref_pitch);
    v6.process_midi(6, active_note_mem[6], active_note_vel[6], active_note_state[6], ref_pitch);
    v7.process_midi(7, active_note_mem[7], active_note_vel[7], active_note_state[7], ref_pitch);
    v8.process_midi(8, active_note_mem[8], active_note_vel[8], active_note_state[8], ref_pitch);
    v9.process_midi(9, active_note_mem[9], active_note_vel[9], active_note_state[9], ref_pitch);
    v10.process_midi(10, active_note_mem[10], active_note_vel[10], active_note_state[10], ref_pitch);
    v11.process_midi(11, active_note_mem[11], active_note_vel[11], active_note_state[11], ref_pitch);
    

    // Update note parameters
    /*note_on0 ? ( string1.set_pars(pitch_to_freq(note_on0 + ref_pitch), note_vel0, 0); string1.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel0; );
    note_on1 ? ( string2.set_pars(pitch_to_freq(note_on1 + ref_pitch), note_vel1, 0); string2.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel1; );
    note_on2 ? ( string3.set_pars(pitch_to_freq(note_on2 + ref_pitch), note_vel2, 0); string3.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel2; );
    note_on3 ? ( string4.set_pars(pitch_to_freq(note_on3 + ref_pitch), note_vel3, 0); string4.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel3; );
    note_on4 ? ( string5.set_pars(pitch_to_freq(note_on4 + ref_pitch), note_vel4, 0); string5.ref_cutoff = filter_cutoff + filter_cutoff_vel * note_vel4; );
    
    (note_state0 == -1) ? (string1.damp_string(); string1.update_freq(); );
    (note_state1 == -1) ? (string2.damp_string(); string2.update_freq(); );
    (note_state2 == -1) ? (string3.damp_string(); string3.update_freq(); );
    (note_state3 == -1) ? (string4.damp_string(); string4.update_freq(); );
    (note_state4 == -1) ? (string5.damp_string(); string5.update_freq(); );*/
  );
  
  memset(active_note_state, 0, 12);
  last_count = notes_on;
);

freemem = 0;
freemem = midi.init_midi(freemem);

MAX_FFT_SIZE = 32768;
freemem = (shared_window_buffer = freemem) + MAX_FFT_SIZE;
freemem = (shared_fft_buffer = freemem) + MAX_FFT_SIZE;

<?
  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.serialize(version);\n", i + 1);
    printf("tune_slider%d.serialize(version);\n", i + 1);
    printf("spacing_slider%d.serialize(version);\n", i + 1);
    printf("brightness_slider%d.serialize(version);\n", i + 1);
    printf("spacing_offset_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;MAX_VOICES, printf("freemem = v%d.init_voice(freemem);\n", i); i += 1;);
  loop(i=0;MAX_VOICES, printf("freemem = v%d.init_voice_mixers(freemem, shared_fft_buffer, shared_window_buffer);\n", i); i += 1;);
?>

midi.reset_midi();

CURRENT_VERSION = 2;
version = CURRENT_VERSION;

@serialize
file_var(0, version);

<?
  loop(i=0;8,
    par = i * 6 + 1;
    printf("gain_slider%d.serialize(version);\n", i + 1);
    printf("tune_slider%d.serialize(version);\n", i + 1);
    printf("spacing_slider%d.serialize(version);\n", i + 1);
    printf("brightness_slider%d.serialize(version);\n", i + 1);
    printf("spacing_offset_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
?>

<?
  loop(i=0;8,
    par = i * 5 + 49;
    printf("env_attack_slider%d.serialize(version);\n", i + 1);
    printf("env_decay_slider%d.serialize(version);\n", i + 1);
    printf("env_sustain_slider%d.serialize(version);\n", i + 1);
    printf("env_release_slider%d.serialize(version);\n", i + 1);
    i += 1;
  );
?>

version = CURRENT_VERSION;

@slider

@block
pass_through = 1;
midi.midi_block(pass_through);

@sample
midi.curSample += 1;
midi.notes_remain ? (
  // Reset if MIDI stuff updated
  midi_input = 1;
  midi.midi_sample(midi_input) ? (
    settings_changed = 1;
  );
);

big_tick = update_ticker == 0;
update_ticker += 1;
(update_ticker > 128) ? (
  update_ticker = 0;
);

big_tick ? (
  midi.update_notes();
);

((n_update % SLOW_UPDATE_FACTOR) == 0) ? (
  v0.update_voice();
  v1.update_voice();
  v2.update_voice();
  v3.update_voice();
  v4.update_voice();
  v5.update_voice();
  v6.update_voice();
  v7.update_voice();
  v8.update_voice();
  v9.update_voice();
  v10.update_voice();
  v11.update_voice();
);

v0.has_output ? v0.play_voice() : (v0.l = v0.r = 0);
v1.has_output ? v1.play_voice() : (v1.l = v1.r = 0);
v2.has_output ? v2.play_voice() : (v2.l = v2.r = 0);
v3.has_output ? v3.play_voice() : (v3.l = v3.r = 0);
v4.has_output ? v4.play_voice() : (v4.l = v4.r = 0);
v5.has_output ? v5.play_voice() : (v5.l = v5.r = 0);
v6.has_output ? v6.play_voice() : (v6.l = v6.r = 0);
v7.has_output ? v7.play_voice() : (v7.l = v7.r = 0);
v8.has_output ? v8.play_voice() : (v8.l = v8.r = 0);
v9.has_output ? v9.play_voice() : (v9.l = v9.r = 0);
v10.has_output ? v10.play_voice() : (v10.l = v10.r = 0);
v11.has_output ? v11.play_voice() : (v11.l = v11.r = 0);

spl0 += v0.l + v1.l + v2.l + v3.l + v4.l + v5.l + v6.l + v7.l + v8.l + v9.l + v10.l + v11.l;
spl1 += v0.r + v1.r + v2.r + v3.r + v4.r + v5.r + v6.r + v7.r + v8.r + v9.r + v10.r + v11.r;

last_gain += d_gain;

n_update += 1;

@gfx
loaded = 0;
!loaded ? (
  loaded = gfx_loadimg(12, "./protosynth_dependencies/font.png");
  gfx_setimgdim(13, img_w, img_h);
);

function reset_color()
(
  gfx_r = gfx_g = gfx_b = 0.0; gfx_a = 1.0;
  gfx_mode = 1;
);

img_w = 320;
img_h = 240;

/* Background color */
gfx_dest = 13;
gfx_clear = 0;
gfx_set(0, 0, 0, 1);
gfx_rect(0, 0, img_w, img_h);
reset_color();

gfx_a = 0.1;
pad_width = 70;
pad_height = 70;
pad_spacing = 31;

side_pad = 8;
toggle_size = 6;

gfx_set(0.7, 0.5, 0.2, 0.3);
cx = side_pad;
cy = 0;
//osc1_enabled.choice_toggle(cx, cy, toggle_size, 0, 10, "Enable Oscillator 1", "Enable OSC1"); cx += toggle_size + 2;

<?
  function uuid()
  (
    next_uuid += 1
  );
  
  loop(i=0;8,
    printf("cx = side_pad;\n");
    printf("osc%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, 1, \"Enable Oscillator %d\", \"Enable OSC%d\");\ncx += toggle_size + 2;", i + 1, i + 1);
    printf("txt_blit(\"OSC%d\", cx, cy + 2); cx += 25;", i + 1);
    
    printf("gain_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Gain envelope to apply\", \"OSC Envelope\", 1, 8, 0);\n cx += 10;", i + 1, uuid());
    printf("gain_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", osc%d_gain), \"Gain\", \"Gain\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("gain_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Gain envelope to apply\", \"OSC Envelope\", 0, 8, 1);\n cx += 10;", i + 1, uuid());
    
    printf("tune_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_tune), \"Tuning\", \"Tuning\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("tune_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Tuning modulator to apply\", \"Tune Modulation\", 0, 14, 1);\n cx += 10;", i + 1, uuid());
    
    printf("spacing_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_spacing), \"Partial spacing\", \"Freq spacing\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("spacing_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Spacing modulator to apply\", \"Spacing Modulation\", 0, 14, 1);\n cx += 10;", i + 1, uuid());
    
    printf("brightness_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.3f\", osc%d_brightness), \"Brightness\", \"Brightness\"); cx += 5 * toggle_size + 4 + 1;", i + 1, uuid(), i + 1);
    printf("brightness_slider%d.modulator_field(%d, cx, cy, 8, 1, \"Brightness modulator to apply\", \"Brightness Modulation\", 0, 14, 1);\n cx += 10;", i + 1, uuid());
    
    printf("cy += 8;");
    i += 1;
  );
?>
cy += 5;
<?
  loop(i=0;8,
    printf("cx = side_pad;\n");
    printf("env%d_enabled.simple_serialize_toggle(cx, cy + 1, toggle_size, 1, \"Enable Envelope %d\", \"Enable ENV%d\");\ncx += toggle_size + 2;", i + 1, i + 1);
    printf("env%d_enabled.color=0.5;\n", i + 1);
    printf("txt_blit(\"ENV%d\", cx, cy + 2); cx += 25;", i + 1);
    printf("env_attack_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_attack), \"Attack\", \"Attack\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_decay_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_decay), \"Decay\", \"Decay\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_sustain_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%d\", 100 * env%d_sustain), \"Sustain\", \"Sustain\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("env_release_slider%d.text_slider_ui(%d, cx, cy, 5 * toggle_size + 4, 8, sprintf(9, \"%%\.1f\", env%d_release), \"Release\", \"Release\"); cx += 5 * toggle_size + 4 + 2;", i + 1, uuid(), i + 1);
    printf("cy += 8;");
    i += 1;
  );
?>

tune_slider1.active = 1;

//(x, y, w, select, slider_idx, hint, info)
cx = side_pad;
cy += 4;

function node(x, y, w, h)
instance(_x, _y, _w, _h, x_from, x_to, y_from, y_to)
(
  gfx_set(0.2, 0.2, 0.3, 1.0); gfx_a = 1;
  _x = x; _y = y; _w = w; _h = h;
  gfx_a = 1.0;
  gfx_rect(x, y, w, h, 0);
  x_from = x + w;
  y_from = y + 0.5 * h;
  x_to = x;
  y_to = y + 0.5 * h;
);

function mix_node(x, y, w, h, slider_idx)
instance()
local(value, text, mouse_nx, mouse_ny, over, ix)
global(gfx_a, gfx_x, gfx_y, mouse_x, mouse_y, x_offset, y_offset, blit_scale, cap_mode, last_cap, mouse_cap)
(
  this.node(x, y, w, h);
  value = slider(slider_idx);
  text = (value == 0) ? "ADD"
  : (value == 1) ? "AMP"
  : (value == 2) ? "MUL"
  : (value == 3) ? "XOR"
  : (value == 4) ? "XOD"
  : (value == 5) ? "CON";

  mouse_nx = (mouse_x - x_offset) / blit_scale;
  mouse_ny = (mouse_y - y_offset) / blit_scale;
  over = ((mouse_nx > x) && (mouse_nx < (x + w)) && (mouse_ny > y) && (mouse_ny < (y + w)) && (cap_mode == 0));

  ((last_cap == 0) && over) ? (
    (mouse_cap == 2) ? (
      gfx_x = mouse_x;
      gfx_y = mouse_y;
      ix = gfx_showmenu("Additive mixing|Amplitude modulation|Ring modulation (multiply signals)|XOR|XOR on diff|Convolve");
      (ix > 0) ? (
        slider(slider_idx) = ix - 1;
      );
    );
  );

  gfx_set(1, 1, 1, 1);
  gfx_a = 0.5;
  txt_blit(text, x + 2, y + 2);
);

function cline(x1, y1, x2, y2)
(
  gfx_line(floor(x1), floor(y1) - 0.5, floor(x2), floor(y2) - 0.5, 1);
  gfx_line(floor(x1), floor(y1), floor(x2), floor(y2), 0);
  gfx_line(floor(x1), floor(y1) + 0.5, floor(x2), floor(y2) + 0.5, 1);
);

block_size = 8;
spacing = 10;
left_side = 10;
start = cy;
cx = left_side;
cy = start;

//input_size = 
<?
  loop(i=0;8,
    printf("n1%d.node(cx, cy, block_size, block_size);", i);
    printf("cy += block_size + 2;");
    i += 1;
  );
?>

cx = left_side + block_size + spacing;
cy = start + 0.5 * (block_size + 2);

<?
  current_slider = 128; /* First mix slider */
  loop(i=0;4,
    printf("n2%d.mix_node(cx, cy, 2 * block_size + 2, block_size, %d);", i, current_slider);
    printf("cy += 2 * (block_size + 2);");
    i += 1;
    current_slider += 1;
  );
?>

cx = left_side + 3 * block_size + 2 * spacing;
cy = start + 0.5 * 3 * (block_size + 2);

<?
  loop(i=0;2,
    printf("n3%d.mix_node(cx, cy, 2 * block_size + 2, block_size, %d);", i, current_slider);
    printf("cy += 4 * (block_size + 2);");
    i += 1;
    current_slider += 1;
  );
?>

cx = left_side + 5 * block_size + 3 * spacing;
cy = start + 0.5 * 3 * (block_size + 2);

<?
  loop(i=0;2,
    printf("n4%d.node(cx, cy, 2 * block_size, block_size);", i);
    printf("cy += 4 * (block_size + 2);");
    i += 1;
  );
?>

cx = left_side + 7 * block_size + 4 * spacing;
cy = start + 3.5 * (block_size + 2);
n5.mix_node(cx, cy, 2 * block_size + 2, block_size, 134);

cy += 4 * (block_size + 2);
cx += 2 * block_size + spacing;
cy = start + 3.5 * (block_size + 2);
n6.node(cx, cy, 2 * block_size, block_size);

cline(n10.x_from, n10.y_from, n20.x_to, n20.y_to);
cline(n11.x_from, n11.y_from, n20.x_to, n20.y_to);
cline(n12.x_from, n12.y_from, n21.x_to, n21.y_to);
cline(n13.x_from, n13.y_from, n21.x_to, n21.y_to);
cline(n14.x_from, n14.y_from, n22.x_to, n22.y_to);
cline(n15.x_from, n15.y_from, n22.x_to, n22.y_to);
cline(n16.x_from, n16.y_from, n23.x_to, n23.y_to);
cline(n17.x_from, n17.y_from, n23.x_to, n23.y_to);

cline(n20.x_from, n20.y_from, n30.x_to, n30.y_to);
cline(n21.x_from, n21.y_from, n30.x_to, n30.y_to);
cline(n22.x_from, n22.y_from, n31.x_to, n31.y_to);
cline(n23.x_from, n23.y_from, n31.x_to, n31.y_to);

cline(n30.x_from, n30.y_from, n40.x_to, n40.y_to);
cline(n31.x_from, n31.y_from, n41.x_to, n41.y_to);

cline(n40.x_from, n40.y_from, n5.x_to, n5.y_to);
cline(n41.x_from, n41.y_from, n5.x_to, n5.y_to);

cline(n5.x_from, n5.y_from, n6.x_to, n6.y_to);
//gfx_line(n50.x_from, n50.y_from, n60.x_to, n60.y_to);

hinter.draw_hints();

i = 0;
str = sprintf(1, "");
loop(MAX_VOICES,
  str = strcat(str, (midi.active_note_mem[i] > 0) ? ("P") : (midi.active_note_mem[i] == 0) ? ("0") : ("R"));
  i += 1;
);

gfx_set(1, 1, 1, 0.3);
txt_blit(sprintf(2, "proto-synth %s", str), side_pad, img_h - 6);
(info_active > 0.001) ? (
  gfx_a = min(0.3, info_active);
  txt_blit(14, img_w - 66, img_h - 6);
  info_active *= 0.7;
) : (
  txt_blit("ALPHA VERSION", img_w - 66, img_h - 6);
);

gfx_dest = -1;
gfx_set(1, 1, 1, 1);

raw_blit_scale = min(gfx_h / img_h, gfx_w / img_w);
blit_scale = raw_blit_scale >= 1 ? floor(raw_blit_scale) : raw_blit_scale;
x_offset = (gfx_w - blit_scale * img_w) * 0.5;
y_offset = (gfx_h - blit_scale * img_h) * 0.5;
shake = equ + 2 * (equ > 1);
gfx_x = x_offset; gfx_y = y_offset;
gfx_x += 0.25 * rand() * shake * blit_scale;
gfx_y += 0.25 * rand() * shake * blit_scale;
shake > 0 ? shake -= 1;

/*!show_ui ? (
  gfx_set(10/255, 31/255, 49/255, 1);
  gfx_rect(0, 0, gfx_w, gfx_h);
);*/

gfx_set(1, 1, 1, 1);
gfx_mode = 4;
gfx_blit(13, blit_scale, 0);

last_cap = mouse_cap;
last_mouse_x = mouse_x;
last_mouse_y = mouse_y;
mouse_nx = (mouse_x - x_offset) / blit_scale;
mouse_ny = (mouse_y - y_offset) / blit_scale;

/*
1 ? (
  gfx_x = 0;
  gfx_y = 30;
  gfx_set(1, 1, 1, 1);
  fff = midi.active_note_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
  
  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  fff = midi.note_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );
);
*/

  gfx_x = 0;
  gfx_y = 0;
  gfx_set(1, 1, 1, 1);
  fff = v0.modulator_mem;
  loop(30,
    gfx_printf("%f  ", fff[]);
    fff += 1;
  );

