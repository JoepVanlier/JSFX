@init
dial_animation = 1;

function init_strip(strip_index)
global()
local()
instance(me)
(
  me = strip_index;
);

function serialize_non_sliders()
global()
local()
instance(env, time_offset, retrigger,
         lpf, hpf, pitch)
(
  file_var(0, env);
  file_var(0, lpf.mod1);
  file_var(0, hpf.mod1);
  file_var(0, pitch.mod1);
  file_var(0, time_offset);
  file_var(0, retrigger);
  
  /* Memory to expand into when features are added */
  memset(0, 0, 76);
  file_mem(0, 0, 76); /* Reduce this by one when you want to add features */
);

function set_knob_properties(slider_id, minimum, sc, def, _active)
instance(scale, min_value, default, slider_idx, active)
local()
global()
(
  slider_idx = slider_id;
  scale = sc;
  min_value = minimum;
  default = def;
  active = _active;
);

function draw_and_process(cX, cY, knobSize, label, description, current, modifier)
instance(mod1, default, scale, value, min_value, slider_idx, newValue)
global(mouse_x, mouse_y, mouse_cap,
       dial_animation, bipolar, activeModifier,
       dial_position_color_r, dial_position_color_g, dial_position_color_b
       mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a,
       current_mod1, dragging)
local(norm_current, current)
(
  (current == -1337) ? current = slider(slider_idx);
  value = (slider(slider_idx) - min_value) / scale;

  this.drawKnob(cX + knobSize, cY + knobSize, knobSize, label, description, 1.0);
  
  dial_animation ? (
    norm_current = (current - min_value) / scale;
    this.knob_draw_modifier(norm_current - value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, -0.1);
    this.knob_draw_modifier(norm_current - value, bipolar, dial_position_color_r, dial_position_color_g, dial_position_color_b, 1.0, 0.1);
  );
  
  modifier ? this.knob_draw_modifier(mod1, bipolar, mod1_color_r, mod1_color_g, mod1_color_b, mod1_color_a, 1);

  ( activeModifier == 1 ) ? ( 
    this.knob_modifier_processMouse(0, mod1) ? ( mod1 = newValue; dragging = 1; );
  ) : (
    this.knob_processMouse(mouse_x, mouse_y, mouse_cap, (default - min_value) / scale ) ? (
      slider_idx > 0 ? (
        slider(slider_idx) = scale * value + min_value;
        slider_automate(slider_idx);
      );
      dragging = 1;
    );
  );
);

function draw_and_process_simple_par(cX, cY, knobSize, label, description, raw_value, default, min_value, scale)
instance(active, value)
global(mouse_x, mouse_y, mouse_cap, dragging)
local()
(
  active = 1;
  value = (raw_value - min_value) / scale;
  this.drawKnob(cX + knobSize, cY + knobSize, knobSize, label, description, 1.0);
  this.knob_processMouse(mouse_x, mouse_y, mouse_cap, (default - min_value) / scale ) ? (
    dragging = 1;
  );
  
  value * scale + min_value;
);

function draw_mode_selectors(xs, ys)
local(ww, hh, hspit)
global(scaling)
instance(env)
(
  ww = 80 * (1 + scaling);
  hh = 13 * (1 + scaling);
  hspit = 3 * (1 + scaling);
  
  drawSelectionButton("Follower", xs, ys, ww, hh, 0, -env, "Dynamics handled as envelope follower.\n\nAn envelope follower will follow the incoming signal.\nThis follower is then used to modulate the sample gain.\nThis type of follower does not exceed the signal level.") ? env = 0;
  drawSelectionButton("Threshold", xs, ys + hh + hspit, ww, hh, 1, -env, "Dynamics based on thresholded signal.\n\nWhen the signal is over the threshold, the\nsignal will increase until at full strength.") ? env = 1;
  drawSelectionButton("Triggered", xs, ys + 2 * hh + 2 * hspit, ww, hh, 2, -env, "Trigger-based envelope.\n\nWhen the signal exceeds the threshold, it will\nplay a fixed attack/hold/decay envelope.") ? env = 2;
  
  xs += ww * 1.2;
);

activeModifier = 0;
function draw_buttons(xs, ys, h)
local()
global(SLIDERS_PER_SAMPLE)
instance(env, atk, decay, hold_percent, hold_time, gain, pitch, hpf, lpf, me, time_offset, time_offset_knob)
(
  xs = this.draw_mode_selectors(xs, ys);

  time_offset = time_offset_knob.draw_and_process_simple_par(xs, ys - 5, 0.5 * h, "Offset", "Set time offset\n\nNote: Negative offset induces plugin latency", time_offset, 0, -100, 200);
  xs += 1.25 * h;

  atk.set_knob_properties(SLIDERS_PER_SAMPLE * me + 1, 0, 1, 0, 1);
  atk.draw_and_process(xs, ys - 5, 0.5 * h, "Attack", "Envelope attack", -1337, 0);
  xs += 1.25 * h;
  
  decay.set_knob_properties(SLIDERS_PER_SAMPLE * me + 2, 0, 1, 0.3, 1);
  decay.draw_and_process(xs, ys - 5, 0.5 * h, "Decay", "Envelope decay", -1337, 0);
  xs += 1.25 * h;
  
  hold_percent.set_knob_properties(SLIDERS_PER_SAMPLE * me + 3, 0, 100, 30, env==2);
  hold_percent.draw_and_process(xs, ys - 5, 0.5 * h, "Hold Level", "Hold percentage", -1337, 0);
  xs += 1.25 * h;
  
  hold_time.set_knob_properties(SLIDERS_PER_SAMPLE * me + 4, 0, 1, 0, env==2);
  hold_time.draw_and_process(xs, ys - 5, 0.5 * h, "Hold Time", "Hold time", -1337, 0);
  xs += 1.25 * h;

  gain.set_knob_properties(SLIDERS_PER_SAMPLE * me + 7, -48, 51, 0.00000001, 1);
  gain.draw_and_process(xs, ys - 5, 0.5 * h, "Gain", "Gain", -1337, 0);
  xs += 1.25 * h;

  pitch.set_knob_properties(SLIDERS_PER_SAMPLE * me + 8, -24, 48, 0.00000001, 1);
  pitch.draw_and_process(xs, ys - 5, 0.5 * h, "Pitch", "Pitch", -1337, 1);
  xs += 1.25 * h;
  
  hpf.set_knob_properties(SLIDERS_PER_SAMPLE * me + 9, 0, 1, 0, 1);
  hpf.draw_and_process(xs, ys - 5, 0.5 * h, "Highpass", "High pass filter cutoff frequency", -1337, 1);
  xs += 1.25 * h;
  
  lpf.set_knob_properties(SLIDERS_PER_SAMPLE * me + 10, 0, 1, 1, 1);
  lpf.draw_and_process(xs, ys - 5, 0.5 * h, "Lowpass", "Low pass filter cutoff frequency", -1337, 1);
  xs += 1.25 * h;
  
  handleModifier("Env Mod", xs, ys + .15 * h, h, 0.5 * h, 1);
  //handleModifier("Mod", xs, ys + .75 * h, h, 0.5 * h, 2);
);

