desc:Saike FM Filter
tags: audio-rate filters
version: 0.09
author: Joep Vanlier
changelog: Added autokill switch. Add bug workaround to get correct last touched parameters (sadly this introduces a lot of dummy parameters).
license: MIT
provides:
  FMFilter_Dependencies/*
  FM Filter.jsfx.rpl

Attribution: Moog filter implementation was based on the paper:
S. D'Angelo and V. Vaelimaeki, "Generalized Moog Ladder Filter: Part II - Explicit Non linear Model through a Novel Delay-Free
Loop Implementation Method". IEEE Trans. Audio,Speech, and Lang. Process., vol. 22, no. 12, pp. 1873-1883, December 2014.
303 emulation is Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)

import Saike_FMF_midilib.jsfx-inc
import Saike_FMF_widgets.jsfx-inc

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

slider1:0<-6,48,1>-Drive (dB)
slider2:0<-6,48,1>-Post Boost (dB)
slider3:autokill=0<0,1,1>-Autokill
slider4:dummy=0<0,1,1>-Dummy
slider5:dummy=0<0,1,1>-Dummy
slider6:inertia=60<0,200,.001>-Inertia [ms]
slider7:dummy=0<0,1,1>-Dummy
slider8:dummy=0<0,1,1>-Dummy
slider9:dummy=0<0,1,1>-Dummy
slider10:dummy=0<0,1,1>-Dummy
slider11:dummy=0<0,1,1>-Dummy
slider12:filter_type=1<0,5,1{Linear,MS-20,Linear x2,Moog,Ladder,303}>-Filter type
slider13:.6<0,1,.0001>-Cutoff
slider14:0.7<0,1,.0001>-Resonance
slider15:morph=0<0,1,.0001>-Morph
slider16:bleed=0<0,1,1>-Bleed

slider17:m_lfo_amnt=0<0,1,.00001>-Morph LFO amount
slider18:m_lfo_speed=0<0,20,.001>-Morph LFO speed [Hz]
slider19:m_lfo_phase=0<0,30,.001>-Morph LFO phase [radian]
slider20:c_lfo_amnt=0<0,1,.00001>-Cutoff LFO amount
slider21:c_lfo_speed=0<0,20,.001>-Cutoff LFO speed [Hz]
slider22:c_lfo_phase=0<0,36,.001>-Cutoff LFO phase [radian]

slider23:fm_mode=0<0,5,1{MIDI sin,MIDI square,Self,Self Abs,Audio Stereo 3/4,Audio Mono 3/4}>-FM mode
slider24:fm_amnt=0<0,1,.0001>-FM level
slider25:fm_factor=<-8,8,1>-FM rate factor
slider26:fm_spread=<0,1,.001>-FM spread
slider27:key_follow=0<0,1,.0001>-Key Follow
slider28:fm_cutoff=1<0,1,.0001>-FM Cutoff

slider29:env_amnt=0<-1,1,.0001>-Envelope Amount
slider30:env_decay=0<0,1,.0001>-Decay [ms]

slider60:oversampling=1<1,8,1>-Oversampling

@init
  function calc_times()
  global(k_rise, k_decay, env_decay, srate, time_factor)
  local(rise_time)
  (
    // time in [ms] to get to .1
    rise_time = 3.0;
    time_factor = - (1000.0 / srate) * log(0.1);
    k_rise = time_factor / rise_time;
    
    // Decay time between 3 and 300 ms
    // Strange way to write 1 / (3 * 10^(2*env_decay))
    k_decay = time_factor * (0.33 * exp(-4.605170185988092*env_decay));
  );
  calc_times();
  
  function envelopeTempo(cTime)
    instance(cRate, tempoLabel)
    local()
    global(tempo)
    (
    ( cTime < 0.0416667 ) ?
    (
      tempoLabel = "1/16";
      cRate = 0.0625;
    ) : ( cTime < 0.0833333 ) ?
    (
      tempoLabel = "1/12";
      cRate = 0.0833333;
    ) : ( cTime < 0.125 ) ?
    (
      tempoLabel = "1/8";
      cRate = 0.125;
    ) : ( cTime < 0.166667 ) ?
    (
      tempoLabel = "1/6";
      cRate = 0.166667;
    ) : ( cTime < 0.208333 ) ?
    (
      tempoLabel = "1/5";
      cRate = 0.2;
    ) : ( cTime < 0.25 ) ?
    (
      tempoLabel = "1/4";
      cRate = 0.25;
    ) : ( cTime < 0.291667 ) ?
    (
      tempoLabel = "1/3";
      cRate = 0.333333;
    ) : ( cTime < 0.333333 ) ?
    (
      tempoLabel = "1/2";
      cRate = 0.5;
    ) : ( cTime < 0.375 ) ?
    (
      tempoLabel = "1";
      cRate = 1;
    ) : ( cTime < 0.416667 ) ?
    (
      tempoLabel = "2";
      cRate = 2;
    ) : ( cTime < 0.458333 ) ?
    (
      tempoLabel = "3";
      cRate = 3;
    ) : ( cTime < 0.5 ) ?
    (
      tempoLabel = "4";
      cRate = 4;
    ) : ( cTime < 0.541667 ) ?
    (
      tempoLabel = "6";
      cRate = 6;
    ) : ( cTime < 0.583333 ) ?
    (
      tempoLabel = "7";
      cRate = 7;
    ) : ( cTime < 0.625 ) ?
    (
      tempoLabel = "8";
      cRate = 8;
    ) : ( cTime < 0.666667 ) ?
    (
      tempoLabel = "12";
      cRate = 12;
    ) : ( cTime < 0.708333 ) ?
    (
      tempoLabel = "16";
      cRate = 16;
    ) : ( cTime < 0.75 ) ?
    (
      tempoLabel = "24";
      cRate = 24;
    ) : ( cTime < 0.791667 ) ?
    (
      tempoLabel = "32";
      cRate = 32;
    ) : ( cTime < 0.833333 ) ?
    (
      tempoLabel = "64";
      cRate = 64;
    ) : ( cTime < 0.875 ) ?
    (
      tempoLabel = "128";
      cRate = 128;
    ) : ( cTime < 0.916667 ) ?
    (
      tempoLabel = "256";
      cRate = 256;
    ) : ( cTime < 0.958333 ) ?
    (
      tempoLabel = "512";
      cRate = 512;
    ) : ( 
      tempoLabel = "1024";
      cRate = 1024;
    );
    
    cRate = 60 / tempo / cRate;
  );

  midimem = 0;
  midi.initializeMIDI(midimem, 0, 1);
  midi.notesOn = 0;

  // MS-20 Simulation settings
  epsilon = 0.00000000001;
  epsilon = 0.00000001;
  maxiter = 6;
  safety_limit_ms20 = 0.935;
  safety_limit_moog = 0.25; // Above this level the model suffers from numerical difficulties. Ensures fc < fs/8.

  m_lfo_time = 0;
  c_lfo_time = 0;

  // Approximate, but good enough for most things
  function tanh(s)
  local(s2, a, b, c)
  global()
  (
    s2 = s * s;
    a = s * (135135.0 + s2 * (17325.0 + s2 * (378.0 + s2)));
    b = 135135.0 + s2 * (62370.0 + s2 * (3150.0 + s2 * 28.0));
    c = a / b;
    (c < -1) ? c = -1 : (c > 1) ? c = 1 : c;
  );

function init_303(cutoff, q)
  local(dwc, dwc2, dwc3, qwc2, qwc3)
  global(oversampling)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    // This specific filter came from
    // Copyright (c) 2012 Dominique Wurtz (www.blaukraut.info)
    wc = exp( (1-cutoff) * log(20/22050) ) / oversampling;
    wc = tan(.39 * $pi * wc);
    
    wc2 = wc*wc;
    wc3 = wc2*wc;
    wc4 = wc3*wc;
    b   = 1.0 / ( 1.0 + 8.0*wc + 20.0*wc2 + 16.0*wc3 + 2.0*wc4);
    g   = 2.0 * wc4 * b;
    
    k   = 20.0*q;
    A   = 1 + 0.5 * k;
    
    dwc = 2*wc;
    dwc2 = 2*wc2;
    qwc2 = 4*wc2;
    dwc3 = 2*wc3;
    qwc3 = 4*wc3;
    
    b0 = dwc+12*wc2+20*wc3+8*wc4;
    a0 = 1+6*wc+10*wc2+qwc3;
    a1 = dwc+8*wc2+6*wc3;
    a2 = dwc2+wc3;
    a3 = dwc3;
    
    b10 = dwc2+8*wc3+6*wc4;
    a10 = wc+4*wc2+3*wc3;
    a11 = 1+6*wc+11*wc2+6*wc3;
    a12 = wc+qwc2+qwc3;
    a13 = wc2+dwc3;
    
    b20 = dwc3+4*wc4;
    a20 = a13;
    a21 = wc+qwc2+4*wc3;
    a22 = 1+6*wc+10*wc2+qwc3;
    a23 = wc+qwc2+dwc3;
    
    c2  = a21 - a3;
    c3  = 1+6*wc+9*wc2+dwc3;
  ); 
  
function reset_303()
  local(Kbig)
  global(slider54)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4,
  b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  (
    z1 = z2 = z3 = 0;
    y1 = y2 = y3 = y4 = 0;
  );
  
function eval_303(input, choice, frac)
  local(y0, s0, s, f1, f2)
  instance(wc, wc2, wc3, wc4, A, k, b, g, z0, z1, z2, z3, y1, y2, y3, y4
            b0, a0, a1, a2, a3, b10, a10, a11, a12, a13, b20, a20, a21, a22, a23, c2, c3 )
  global()
  (
    s = (z0*wc3 + z1*a20 + z2*c2 + z3*c3) * b;
    y4 = (g*input + s) / (1.0 + g*k);
    
    y0 = max(-1,min(1,(input - k*y4)));
 
    y1 = b * (y0*b0 + z0*a0 + z1*a1 + z2*a2 + z3*a3);     // #OK
    y2 = b * (y0*b10 + z0*a10 + z1*a11 + z2*a12 + z3*a13);  // #OK
    y3 = b * (y0*b20 + z0*a20 + z1*a21 + z2*a22 + z3*a23);  //
    y4 = ((g*y0 + s));
    
    z0 += 4*wc*(y0 - y1   + y2);
    z1 += 2*wc*(y1 - 2*y2 + y3);
    z2 += 2*wc*(y2 - 2*y3 + y4);
    z3 += 2*wc*(y3 - 2*y4);
    
    (choice == 0 ) ? (
      f1 = A*y4; // LP
      f2 = y4 + y2 - y1; // BP
    ) : (choice == 1) ? (
      f1 = y4 + y2 - y1; // BP
      f2 = -(y0 - y4)*.5; // HP
    ) : (choice == 2) ? (
      frac = frac * frac;
      frac = frac * frac;
      f1 = -(y0 - y4)*.5; // HP
      f2 = -(y0*2 + (y4 + y2 - y1))*.5; // BR
    ) : (choice == 3) ? (
      f1 = (y0*2 + (y4 + y2 - y1))*.5; // BR
      f2 = A*y4; // LP  
    );
    
    f2 * frac + f1 * (1.0-frac)
);

function init_linearSVF(freq, res)
  global(oversampling)
  local(g)
  instance(f0, ic1eq, ic2eq, k, a1, a2, a3)
  (
    f0 = exp( (1-freq) * log(20/22050) ) / oversampling;
    g = tan(.5 * $pi * f0);
    k = 2 - 2*res;
        
    a1 = 1/(1+g*(g+k));
    a2 = g*a1;
    a3 = g*a2;
  ); 

function reset_linearSVF()
  global()
  local()
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    ic1eq = ic2eq = 0;  
  );
  
function eval_linearSVF_LP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v2
  );  
  
function eval_linearSVF_BP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v1
  );  
  
function eval_linearSVF_HP(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - k*v1 - v2
  );  
  
function eval_linearSVF_BR(v0)
  global()
  local(v1, v2, v3)
  instance(ic1eq, ic2eq, k, a1, a2, a3)
  (
    v3 = v0 - ic2eq;
    v1 = a1 * ic1eq + a2 * v3;
    v2 = ic2eq + a2 * ic1eq + a3*v3;
    ic1eq = 2*v1 - ic1eq;
    ic2eq = 2*v2 - ic2eq;    
    
    v0 - v1
  );

  function expensive_tanh(x)
  local(em2x) 
  global()
  (
    x = x;
    em2x = exp(-2*x);
    (2/(1+em2x))-1
  );
  
  function init_moog2(cutoff, resonance)
  local(fs, fc, g, p0s, nmp, gN, kgN, p0g, tmp, acc)
  global(srate, oversampling)
  instance(VT2, rg1, rg2, qg1, qg2, si1, sf1, sg1, si2, sf2, sg2, k0g, k0s, VT2i, q0s, r1s, k)
  (
    k    = resonance*120;

    fs   = srate * oversampling;
    fc   = .5 * srate * exp( (1-cutoff) * log(20/22050) );    
    g    = tan($pi / fs * fc) / sqrt(1 + k);
    
    VT2  = 0.052;
    VT2i = 19.23076923076923;
  
    // Ladder stages
    p0s = 1.0 / (1.0 + g);
    q0s = 1.0 - g;
    r1s = -g;
    k0s = VT2 * g * p0s;
  
    // Global filter
    nmp = (1.0 - p0s);
    gN  = nmp ^ 2;
    kgN = k * gN;
    p0g = 1.0 / (1.0 + kgN);
    k0g = -VT2i * p0g;
  
    rg1 = -2.0*kgN;
    rg2 = -1.0*kgN;
    acc = tmp = p0s*(g - 1.0);
    qg1 = -2.0*(kgN + acc);
    acc = acc*tmp;
    qg2 = -1.0*(kgN + acc);
  );
  
  function eval_moog2(x)
  local(yi, yd, yf)
  global()
  instance(yo, y, A, B, rg1, rg2, qg1, qg2, si1, sf1, sg1, si2, sf2, sg2, k0g, k0s, VT2i, q0s, r1s, k)
  (
    yo = tanh(k0g * (x + sg1));
    A    = yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf1);
    y    = yd + si1;
    yo   = tanh(VT2i * y);
    B    = yo;
  
    si1 = yd + y;
    sf1 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf2);
    y    = yd + si2;
    yo   = tanh(VT2i * y);
  
    si2 = yd + y;
    sf2 = r1s * yi - q0s * yo;
  
    yf = k * y;
  
    sg1 = rg1 * x + qg1 * yf + sg2;
    sg2 = rg2 * x + qg2 * yf;
  );  
  
  function mix_moog2(x, choice, frac)
  local()
  global()
  instance(VT, VT2, VT2i, A, B, y, yo, k, f1, f2)
  (
    this.eval_moog2(x*VT2);
    
    (choice == 0) ? (
      f1 = y * (1 + k); // LP
      f2 = VT2 * (2*B - 2*yo)*8; // BP
    ) : (choice == 1) ? (
      f1 = VT2 * (2*B - 2*yo)*8; // BP
      f2 = VT2 * (A - B); // HP
    ) : (choice == 2) ? (
      frac = frac * frac;
      frac = frac * frac;
      f1 = VT2 * (A - B); // HP
      f2 = -VT2 * (2*B-2*yo-A); // BR
    ) : (choice == 3) ? (
      f1 = -VT2 * (2*B-2*yo-A); // BR
      f2 = y * (1 + k); // LP
    );
    
    (f2 * frac + f1 * (1.0-frac))*VT2i;
  );
  
  function init_moog(cutoff, resonance)
  local(fs, fc, g, p0s, nmp, gN, kgN, p0g, tmp, acc)
  global(srate, oversampling)
  instance(VT2, rg1, rg2, rg3, rg4, qg1, qg2, qg3, qg4, si1, sf1, sg1, si2, sf2, sg2, si3, sf3, sg3, si4, sf4, sg4, k0g, k0s, VT2i, q0s, r1s, k)
  (
    k    = resonance* 3.9999999999999987;
    fc   = .5 * srate * exp( (1-cutoff) * log(20/22050) );
    fs   = srate * oversampling;
    g    = tan($pi * fc / fs) / sqrt(1.0 + sqrt(k) - 2 * pow(k, 0.25) * 0.7071067811865476);
    VT2  = 0.052;
    VT2i = 19.23076923076923;
  
    // Ladder stages
    p0s = 1.0 / (1.0 + g);
    q0s = 1.0 - g;
    r1s = -g;
    k0s = VT2 * g * p0s;
  
    // Global filter
    nmp = (1.0 - p0s);
    gN  = nmp * nmp * nmp * nmp;
    kgN = k * gN;
    p0g = 1.0 / (1.0 + kgN);
    k0g = -VT2i * p0g;
    
    rg1 = -4.0*kgN;
    rg2 = -6.0*kgN;
    rg3 = -4.0*kgN;
    rg4 = -1.0*kgN;
    acc = tmp = p0s*(g - 1.0);
    qg1 = -4.0*(kgN + acc);
    acc = acc*tmp;
    qg2 = -6.0*(kgN + acc);
    acc = acc*tmp;
    qg3 = -4.0*(kgN + acc);
    acc = acc*tmp;
    qg4 = -1.0*(kgN + acc);
  );
  
  function eval_moog(x)
  local(yi, yd, yf)
  global()
  instance(rg1, rg2, rg3, rg4, qg1, qg2, qg3, qg4, si1, sf1, sg1, si2, sf2, sg2, si3, sf3, sg3, si4, sf4, sg4, k0g, k0s, VT2i, q0s, r1s, k,
           A, B, C, D, y, yo)
  (
    yo = tanh(k0g * (x + sg1));
    A = yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf1);
    y    = yd + si1;
    yo   = tanh(VT2i * y);
    B = yo;
  
    si1 = yd + y;
    sf1 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf2);
    y    = yd + si2;
    yo   = tanh(VT2i * y);
    C = yo;
  
    si2 = yd + y;
    sf2 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf3);
    y    = yd + si3;
    yo   = tanh(VT2i * y);
    D = yo;
  
    si3 = yd + y;
    sf3 = r1s * yi - q0s * yo;
  
    yi   = yo;
    yd   = k0s * (yi + sf4);
    y    = yd + si4;
    yo   = tanh(VT2i * y);
  
    si4 = yd + y;
    sf4 = r1s * yi - q0s * yo;
    yf = k * y;
  
    sg1 = rg1 * x + qg1 * yf + sg2;
    sg2 = rg2 * x + qg2 * yf + sg3;
    sg3 = rg3 * x + qg3 * yf + sg4;
    sg4 = rg4 * x + qg4 * yf;
  );
  
  function mix_moog(x, choice, frac)
  local()
  global()
  instance(VT, VT2, VT2i, A, B, C, D, y, yo, k, f1, f2)
  (
    this.eval_moog(x*VT2);
    
    (choice == 0) ? (
      f1 = y * (1 + k); // LP
      f2 = VT2 * (2*C - 2*B); // BP
    ) : (choice == 1) ? (
      f1 = VT2 * (2*C - 2*B); // BP
      //f1 = VT2 * (4*C - 8*B + 4*yo)/6; // BP
      f2 = VT2 * (A - 4 * B + 6 * C - 4 * D + yo); // HP
    ) : (choice == 2) ? (
      frac = frac * frac; /* Make sure the HP gets some space */
      frac = frac * frac;
      f1 = VT2 * (A - 4 * B + 6 * C - 4 * D + yo); // HP
      f2 = VT2 * (A - 4 * B + 6 * C - 4 * D); // Notch
    ) : (choice == 3) ? (
      f1 = VT2 * (A - 4 * B + 6 * C - 4 * D); // Notch
      f2 = y * (1 + k); // LP
    );
    
    (f2 * frac + f1 * (1.0-frac))*VT2i
  );  
  
  function f_g(s)
  local()
  global()
  instance()
  (
    max(-1,min(1,s))
  );
  
  function f_dg(s)
  local()
  global()
  instance()
  (
    1 - 1 * (abs(s)>1)
  );
  
 function smooth_parameter(target)
  instance(s, coeff)
  global()
  local(y, v)
  (
    v = coeff*(target - s);
    y = v + s;
    s = y + v;
    y
  );
  
  function initialize_smoother(cutoff)
  instance(coeff)
  global(srate)
  local(g)
  ( 
    g = tan($pi*cutoff/srate);
    coeff = g/(1+g);  
  );

  function interpolator_init(slider_idx)
  instance(next_val, idx)
  local()
  global()
  (
    next_val = slider(slider_idx);
    idx = slider_idx;
  );

  function interpolator_block()
  instance(delta, next_changepoint_t, next_val, idx)
  local(next_changepoint_y)
  global(samplesblock)
  (
    next_changepoint_t = slider_next_chg(idx, next_changepoint_y);
    next_changepoint_t > 0 ? 
    (
      next_val = slider(idx);
    ) : (
      next_changepoint_y = slider(idx);
      next_val = slider(idx);
      next_changepoint_t = samplesblock;
    );
    
    delta = (next_changepoint_y - next_val) / next_changepoint_t;
  );
  
  function interpolate()
  instance(delta, next_changepoint_t, next_val, idx, coeff)
  local(current_value, next_changepoint_y)
  global(current_sample)
  (
    current_value = next_val;
    current_sample == next_changepoint_t ? 
    (
      next_changepoint_t = slider_next_chg(idx, next_changepoint_y);
      delta = next_changepoint_t > current_sample ? (next_changepoint_y - current_value) / (next_changepoint_t-current_sample) : 0;
    );
    
    next_val = current_value + delta;
    
    coeff > 0 ? this.smooth_parameter(current_value) : current_value
  );
  
  function initialize_interpolators()
  (
    cutoff_interpolator.interpolator_init(13);
    reso_interpolator.interpolator_init(14);
    morph_interpolator.interpolator_init(15);
    drive_interpolator.interpolator_init(1);
    gain_interpolator.interpolator_init(2);
    morph_phase_interpolator.interpolator_init(19);
    cutoff_phase_interpolator.interpolator_init(22);
    
    (last_inertia != inertia) ? (
      last_inertia = inertia;
      inertia_cutoff = 1000.0/inertia;
      cutoff_interpolator.initialize_smoother(inertia_cutoff);
      reso_interpolator.initialize_smoother(inertia_cutoff);
      morph_interpolator.initialize_smoother(inertia_cutoff);
      drive_interpolator.initialize_smoother(inertia_cutoff);
      gain_interpolator.initialize_smoother(inertia_cutoff);
      morph_phase_interpolator.initialize_smoother(inertia_cutoff);
      cutoff_phase_interpolator.initialize_smoother(inertia_cutoff);
      cutoff_interpolator.s = slider(13);
      reso_interpolator.s = slider(14);
      morph_interpolator.s = slider(15);
      morph_phase_interpolator.s = slider(19);
      cutoff_phase_interpolator.s = slider(22);
      change += 1;
    );
  );
  
  initialize_interpolators();

  function init_MS20(freq, reso)
    global(oversampling, srate)
    local(f0)
    instance(y1, y2, d1, d2, h, hh, k)
    (
      f0 = exp( (1-freq) * log(20/22050) ) * $pi / oversampling;
      h = tan(f0 / (2.1 * oversampling)) * 2.1 * oversampling;
      hh = 0.5 * h;
      k  = 2*reso;
    );

  function eval_MS20_nonlin_tanh(x)
    global(epsilon, maxiter)
    local(iter, res, gd2k, ky2, gky2, dgky2,
          f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
    instance(i, y1, y2, d1, d2, h, hh, k, obs)
    (
      gd2k = f_g(d2*k);
      tanhterm1 = tanh(-d1 + x - gd2k);
      tanhterm2 = tanh(d1 - d2 + gd2k);
      
      iter = 0;
      while(
        iter += 1;
        ky2 = k*y2;
        gky2 = f_g(ky2);
        dgky2 = f_dg(ky2);
      
        sig1 = x - y1 - gky2;
        thsig1 = tanh(sig1);
        thsig1sq = thsig1 * thsig1;
      
        sig2 = y1 - y2 + gky2;
        thsig2 = tanh(sig2);
        thsig2sq = thsig2 * thsig2;
        hhthsig1sqm1 = hh*(thsig1sq - 1);
        hhthsig2sqm1 = hh*(thsig2sq - 1);
      
        f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
        f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
        res = abs(f1) + abs(f2);
        
        a = -hhthsig1sqm1 + 1;
        b = -k*hhthsig1sqm1*dgky2;
        c = hhthsig2sqm1;
        d = (k*dgky2 - 1)*hhthsig2sqm1 + 1;
        
        norm = 1 / ( a*d - b*c );
        y1 = y1 - ( d*f1 - b*f2 ) * norm;
        y2 = y2 - ( a*f2 - c*f1 ) * norm;
      (res > epsilon) && (iter < maxiter);
      );
      
      d1 = y1;
      d2 = y2;
    ); 


  function eval_MS20_nonlinBP_tanh(x)
    global(epsilon, maxiter)
    local(iter, res, gd2k, ky2, gky2, dgky2,
          f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
    instance(i, y1, y2, d1, d2, h, hh, k, obs)
    (
      gd2k = f_g(d2*k);
      tanhterm1 = tanh(-d1 - x - gd2k);
      tanhterm2 = tanh(d1 - d2 + x + gd2k);
      
      iter = 0;
      while(
        iter += 1;
        ky2 = k*y2;
        gky2 = f_g(ky2);
        dgky2 = f_dg(ky2);
      
        sig1 = -x - y1 - gky2;
        thsig1 = tanh(sig1);
        thsig1sq = thsig1 * thsig1;
      
        sig2 = x + y1 - y2 + gky2;
        thsig2 = tanh(sig2);
        thsig2sq = thsig2 * thsig2;
      
        hhthsig1sqm1 = hh*(thsig1sq - 1);
        hhthsig2sqm1 = hh*(thsig2sq - 1);
      
        f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
        f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
        res = abs(f1) + abs(f2);
        
        a = 1 - hhthsig1sqm1;
        b = -k*hhthsig1sqm1*dgky2;
        c = hhthsig2sqm1;
        d = (k*dgky2 - 1)*hhthsig2sqm1 + 1;
      
        norm = 1 / ( a*d - b*c );
        y1 = y1 - ( d*f1 - b*f2 ) * norm;
        y2 = y2 - ( a*f2 - c*f1 ) * norm;
      (res > epsilon) && (iter < maxiter);
      );
      
      d1 = y1;
      d2 = y2;
    );
    
  function eval_MS20_nonlinBR_tanh(x)
    global(epsilon, maxiter)
    local(iter, res, gd2k, ky2, gky2, dgky2,
          f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
    instance(i, y1, y2, d1, d2, h, hh, k, obs)
    (
      gd2k = f_g(d2*k);
      tanhterm1 = tanh(-d1 - x - gd2k);
      tanhterm2 = tanh(d1 - d2 + x + gd2k);
      
      iter = 0;
      while(
        iter += 1;
        ky2 = k*y2;
        gky2 = f_g(ky2);
        dgky2 = f_dg(ky2);
      
        sig1 = -x - y1 - gky2;
        thsig1 = tanh(sig1);
        thsig1sq = thsig1 * thsig1;
      
        sig2 = x + y1 - y2 + gky2;
        thsig2 = tanh(sig2);
        thsig2sq = thsig2 * thsig2;
      
        hhthsig1sqm1 = hh*(thsig1sq - 1);
        hhthsig2sqm1 = hh*(thsig2sq - 1);
      
        f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
        f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
        res = abs(f1) + abs(f2);
        
        a = 1 - hhthsig1sqm1;
        b = -k*hhthsig1sqm1*dgky2;
        c = hhthsig2sqm1;
        d = (k*dgky2 - 1)*hhthsig2sqm1 + 1;
      
        norm = 1 / ( a*d - b*c );
        y1 = y1 - ( d*f1 - b*f2 ) * norm;
        y2 = y2 - ( a*f2 - c*f1 ) * norm;
      (res > epsilon) && (iter < maxiter);
      );
      
      d1 = y1;
      d2 = y2;
      x - y2;
    );     
    
    function eval_MS20_nonlinHP_tanh(x)
      global(epsilon, maxiter)
      local(iter, res, gkd2px, kxpy2, gkxpy2, dgky2px,
            f1, f2, a, b, c, d, norm, sig1, thsig1, thsig1sq, sig2, thsig2, thsig2sq, tanhterm1, tanhterm2, hhthsig1sqm1, hhthsig2sqm1 )
      instance(i, y1, y2, d1, d2, h, hh, k, obs)
      (
        gkd2px = f_g(k*(d2 + x));
        tanhterm1 = tanh(-d1 - gkd2px);
        tanhterm2 = tanh(d1 - d2 - x + gkd2px);
        
        iter = 0;
        while(
          iter += 1;
          kxpy2 = k*(x + y2);
          gkxpy2 = f_g(kxpy2);
          dgky2px = f_dg(kxpy2);
        
          sig1 = -y1 - gkxpy2;
          thsig1 = tanh(sig1);
          thsig2sq = thsig2 * thsig2;
        
          sig2 = -x + y1 - y2 + gkxpy2;
          thsig2 = tanh(sig2);
          thsig2sq = thsig2 * thsig2;
        
          hhthsig1sqm1 = (thsig1sq - 1);
          hhthsig2sqm1 = (thsig2sq - 1);
        
          f1 = y1 - d1 - hh*(tanhterm1 + thsig1);
          f2 = y2 - d2 - hh*(tanhterm2 + thsig2);
          res = abs(f1) + abs(f2);
          
          a = -hhthsig1sqm1 + 1;
          b = -k*hhthsig1sqm1*dgky2px;
          c = hhthsig2sqm1;
          d = (k*dgky2px - 1)*hhthsig2sqm1 + 1;
          
          norm = 1 / ( a*d - b*c );
          y1 = y1 - ( d*f1 - b*f2 ) * norm;
          y2 = y2 - ( a*f2 - c*f1 ) * norm;
        (res > epsilon) && (iter < maxiter);
        );
          
        d1 = y1;
        d2 = y2;
        
        y2 + x
      ); 

  // UP / DOWNSAMPLING
  // Generate windowed sinc filter at memory location FIR
  // Inputs are:
  //    fir   - Memory location to store windowed sinc
  //    nt    - Number of taps
  //    bw    - Fractional bandwidth
  //     g    - Gain
  function sinc(fir, nt, bw, g)
    local(a, ys, yg, yw, i, pibw2, pifc2, pidnt2, hnt)
    global()
    (
      pibw2   = 2.0*$pi*bw;
      pidnt2  = 2.0*$pi/nt;
      hnt     = 0.5*nt;
      i       = 1;
          
      loop(nt-1,
        // Sinc width
        a  = (i - hnt) * pibw2;
          
        // Sinc
        ys = (a != 0) ? sin(a)/a : 1.0;
   
        // Window gain
        yg = g * (4.0 * bw);
          
        // Hamming window (could be replaced with Kaiser in the future)
        yw = 0.54 - 0.46 * cos(i * pidnt2);
           
        // Calc FIR coeffs
        fir[i-1] = yw * yg * ys;
        
        i += 1;
      );
    );
  
  // Generate sinc filters for a specific upsampling ratio
  //
  // Upsampling leads to a sample followed by N-1 zeroes. Hence 
  // to compute each subsample, we only need 1/Nth of the taps.
  // This is why we set up a specific filter for each subsample.
  // i.e. for N=4, you get something like f1*Zn + f5*Zn-1 + ...
  //
  // Inputs:
  //    N_in            - oversampling factor
  //    tapsPerFilter   - Taps per subfilter (should be 8 in this implementation)
  //    targetmem       - Location to store the coefficients
  //    tmp             - Working memory
  function updateSincFilter(N_in, tapsPerFilter, targetmem, tmp)
    local(nHist, iFilt, nTaps)
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N, delta)
    global()
    (
      N       = N_in;
      nHist   = tapsPerFilter;
      loc     = 0;
      coeffs  = targetmem;
      nTaps   = N*nHist;
      
      // Memory being set is conservatively large.
      memset(coeffs,0,10000);
      memset(tmp,0,10000);
      
      sinc(tmp, nTaps, .5/N, .5*N);
      
      // Divide sinc over the different filters
      iFilt = 0; // Filter idx for which subsample this filter is
      delta = 0; // Sample idx
      loop(nTaps,
        coeffs[delta + iFilt*100] = tmp[];
        iFilt += 1;
        iFilt == N ? ( iFilt = 0; delta += 1 );
        tmp += 1;
      );
    );
  
  // Generate downsample filter
  // Here, the full N*nHist tap filter has to be evaluated for every sample, 
  // but only every Nth sample has to be evaluated.
  function updateSincDownsampleFilter(N_in, nTaps_in, histmem, coeffmem)
    global()
    instance(hist, hend, hptr, coeffs, loc, N, delta, nTaps)
    local()
    (
      N       = N_in;
      hist    = histmem;
      coeffs  = coeffmem;
      nTaps   = nTaps_in;
      hptr    = hist;
      hend    = hist + nTaps;
      
      memset(coeffs,0,10000);
      sinc(coeffs, nTaps, .5/N, .5);
    );
    
  function advanceHist(sample)
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, nTaps)
    (
      hptr += 1;
      ( hptr == hend ) ? hptr = hist;
      hptr[] = sample;
    );
  
  function sincDownSample()
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, hm1, hptr2, out, cfptr)
    (
      hm1   = hist-1;
      hptr2 = hptr;
      cfptr = coeffs;
      out   = 0;
      
      loop(nTaps,
        out = out + hptr2[] * cfptr[];
        
        cfptr += 1;
        hptr2 -= 1;
        ( hptr2 == hm1 ) ? hptr2 = hend-1;
      );
      
      out
    );
  
  function resetSincDown()
    global()
    instance(hist, hptr, hend, coeffs, loc, N, delta, nTaps)
    local(nHist, hm1, hptr2)
    (
      hm1   = hist-1;
      hptr2 = hptr;
      
      loop(nTaps,
        hptr2[] = 0;
        
        hptr2 -= 1;
        ( hptr2 == hm1 ) ? hptr2 = hend-1;
      );
    );
  
  // Maintain input sample history. Hardcoded for speed.
  // Note h7 is omitted because for integer upsampling it is always zero!
  function advanceSinc(sample)
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt)
    (
      h6 = h5;
      h5 = h4;
      h4 = h3;
      h3 = h2;
      h2 = h1;
      h1 = h0;
      h0 = sample;
      loc = 0;
    );
  
  function resetSincUp()
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt)
    (
      h0 = h1 = h2 = h3 = h4 = h5 = h6 = 0;
    );
  
  // Note h7 is omitted because for integer upsampling it is always zero!
  function getSubSample()
    instance(h0, h1, h2, h3, h4, h5, h6, coeffs, loc, N)
    global()
    local(filt, out)
    (
      filt = coeffs + loc;
      out =  filt[] * h0 + filt[1] * h1 + filt[2] * h2 + filt[3] * h3 + filt[4] * h4 + filt[5] * h5 + filt[6] * h6;
  
      loc += 100;
      out
    );

  function inputFilter(sample)
    instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
    local (out)
    global ()
    (
      out  = sample*b0 + d1*b1 + d2*b2 - d3*a1 - d4*a2;
      d2   = d1;
      d1   = sample;
      d4   = d3;
      d3   = out;
    );
  
  function outputFilter(sample)
    instance(len, d1, d2, d3, d4, o1, o2, o3, o4, a1, a2, b0, b1, b2)
    local (out)
    global ()
    (
      out = sample*b0 + o1*b1 + o2*b2 - o3*a1 - o4*a2;
      o2  = o1;
      o1  = sample;
      o4  = o3;
      o3  = out;
    );

bpos=0;

cutoff_mem  = 0;
reso_mem    = 10000;
sinc_hist1  = 20000;
sinc_hist2  = 30000;
sinc_flt    = 40000;
sinc_flt2   = 50000;
sinc_flt3   = 60000;
sinc_flt4   = 70000;
sinc_tmp    = 80000;

current_safety_moog = (1.0 - log(safety_limit_moog * oversampling) / log(20/22050));

function check_safety()
(
  (filter_type == 1) && (oversampling == 1) ? (
    slider13 > safety_limit_ms20 ? (
      slider_automate(slider13 = safety_limit_ms20);
      warning = 75;
    );
  );
  
  (filter_type == 3) || (filter_type == 4) ?
  (
    slider13 > current_safety_moog ? (
      slider_automate(slider13 = current_safety_moog);
      warning = 75;
    );
  );
);

function updateFMFilter()
local()
global(FM_left.init_linearSVF, FM_right.init_linearSVF, fm_cutoff, last_fm_cutoff)
instance()
(
  (fm_cutoff != last_fm_cutoff) ? (
    FM_left.init_linearSVF(fm_cutoff, 0);
    FM_right.init_linearSVF(fm_cutoff, 0);
    last_fm_cutoff = fm_cutoff;
  );
);

function updateSlider()
(
  current_safety_moog = (1.0 - log(safety_limit_moog * oversampling) / log(20/22050));
  initialize_interpolators();
  check_safety();
);

cutoff_LFO.tempoLabel = 8;
morph_LFO.tempoLabel = 9;
function updateTempo()
(
  cutoff_LFO.envelopeTempo(c_lfo_speed/20);
  morph_LFO.envelopeTempo(m_lfo_speed/20);
);

last_fm_cutoff = -1;
UpdateFMFilter();

@slider
updateSlider();
updateTempo();
israte = 2.0*$pi/srate;

@serialize
file_var(0, m_lfo_sync);
file_var(0, c_lfo_sync);

@block
    updateTempo();
    midi.processMIDIBlock();
    israte = 2.0*$pi/srate;
    
    cutoff_interpolator.interpolator_block();
    reso_interpolator.interpolator_block();
    morph_interpolator.interpolator_block();
    drive_interpolator.interpolator_block();
    gain_interpolator.interpolator_block();
    morph_phase_interpolator.interpolator_block();
    cutoff_phase_interpolator.interpolator_block();
    
   // Update the oversampling filters when needed.
   ( oversampling != lastOversample ) ? 
   (
     lastOversample = oversampling;   
  
     // Memory for the sincs is located at sinc_tmp, sinc_flt, sinc_flt2, sinc_flt3 and sinc_flt4
     sincFilterL.updateSincFilter(oversampling, 8, sinc_flt,  sinc_tmp);
     sincFilterR.updateSincFilter(oversampling, 8, sinc_flt2, sinc_tmp);
     nTapSinc = oversampling < 5 ? 16 : oversampling*4;
     sincDownL.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist1, sinc_flt3);
     sincDownR.updateSincDownsampleFilter(oversampling, nTapSinc, sinc_hist2, sinc_flt4);  
  );
  
  env_attack_samples = oversampling * srate * 5 / 1000;
  

@sample
  midi.processMIDISample() ? (
    pitchMod = 2^((midi.lastNote - 69)/12);
    sliderMod = log(pitchMod) / log(20/22050);
    t = 0;
    midi.notesOn == 1  ? tEnvelope = 0;
    midiChange = 1;
    
    calc_times();
  );
  
  updateFMFilter();
  
  k = .0005;
  tEnvelope < env_attack_samples ? (
    env += k_rise * (1.0 - env);
  ) : (
    env -= k_decay * env;
  );
  tEnvelope += 1;
  
  t += (2^floor(fm_factor))*440*israte*pitchMod;

 function processSample_ms20(s, choice)
 local()
 instance(BP, HP, BR, LP)
 global()
  (
    (choice == 1) ? (
      s = BP.eval_MS20_nonlinBP_tanh(s)  
    ) : (choice == 2) ? (
      s = HP.eval_MS20_nonlinHP_tanh(s)
    ) : (choice == 3) ? (
      s = BR.eval_MS20_nonlinBR_tanh(s)
    ) : (
      // LP is last and first
      s = LP.eval_MS20_nonlin_tanh(s)
    );
  );
  
  function clamp(v, lb, ub)
  (
    min(ub, max(v, lb))
  );
  
 function processSample_lin(s, choice)
 local()
 instance(BP, HP, BR, LP)
 global()
  (
    (choice == 1) ? (
      s = BP.eval_linearSVF_BP(s)  
    ) : (choice == 2) ? (
      s = HP.eval_linearSVF_HP(s)
    ) : (choice == 3) ? (
      s = BR.eval_linearSVF_BR(s)
    ) : (
      // LP is last and first
      s = LP.eval_linearSVF_LP(s)
    );
  );  

  log10d20_conversion  = .11512925464970228420089957273422;
   
  bleed ? (
    modul       = modul * .99 + .01 * (1.0+.15*sin(.5*t));
    preamp      = exp(log10d20_conversion*(modul*drive_interpolator.interpolate()));
    inv_preamp  = exp(-log10d20_conversion*(modul*drive_interpolator.interpolate()) + log10d20_conversion*gain_interpolator.interpolate());
  ) : (
    preamp      = exp(log10d20_conversion*(drive_interpolator.interpolate()));
    inv_preamp  = exp(-log10d20_conversion*(drive_interpolator.interpolate()) + log10d20_conversion*gain_interpolator.interpolate());
  );

  autokill > 0 ? (
    cmax = abs(spl0) + abs(spl1);
    on += cmax > .00000000000001 ? 1 : -1;
    on = min(on, 40);
    on <= 0 ? (
      on = 0;
      term = .99 * term;
    ) : (
      term = 1;
    );
  );

  spl0 *= preamp;
  spl1 *= preamp;
  
  sliderCutoffL = sliderCutoffR = cutoff_interpolator.interpolate();
  sliderReso = reso_interpolator.interpolate();
  sliderMorphL = sliderMorphR = morph_interpolator.interpolate();
  morph_phase = morph_phase_interpolator.interpolate();
  cutoff_phase = cutoff_phase_interpolator.interpolate();
 
  sliderCutoffL += env * env_amnt;
  sliderCutoffR += env * env_amnt;
  
  sliderCutoffL -= key_follow * sliderMod;
  sliderCutoffR -= key_follow * sliderMod;
  
  c_lfo_amnt > 0 ? (
    c_lfo_sync ? (
      c_lfo_time += israte * cutoff_LFO.cRate;
    ) : (
      c_lfo_time += israte * c_lfo_speed;    
    );
    sliderCutoffL = sliderCutoffL + c_lfo_amnt * sin(c_lfo_time + cutoff_phase);
    sliderCutoffR = sliderCutoffR + c_lfo_amnt * sin(c_lfo_time);
  );
  
  m_lfo_amnt > 0 ? (
    m_lfo_sync ? (
      m_lfo_time += israte * morph_LFO.cRate;
    ) : (
      m_lfo_time += israte * m_lfo_speed;    
    );
    sliderMorphL = clamp(sliderMorphL + m_lfo_amnt * sin(m_lfo_time + morph_phase), 0, 1);
    sliderMorphR = clamp(sliderMorphR + m_lfo_amnt * sin(m_lfo_time), 0, 1);
  );
  
  fm_mode == 0 ? (
    fmst = sin(t);
    fmst2 = sin(t+$pi*fm_spread);
  ) : ( fm_mode == 1 ) ? (
    fmst = abs(sin(t)) * 2 - 1;
    fmst2 = abs(sin(t+$pi*fm_spread)) * 2 - 1;
  ) : ( fm_mode == 2 ) ? (
    fmst = FM_left.eval_linearSVF_LP(spl0);
    fmst2 = FM_right.eval_linearSVF_LP(spl1);
  ) : ( fm_mode == 3 ) ? (
    fmst = FM_left.eval_linearSVF_LP(abs(spl0));
    fmst2 = FM_right.eval_linearSVF_LP(abs(spl1));
  ) : ( fm_mode == 4 ) ? (
    fmst = FM_left.eval_linearSVF_LP(spl2);
    fmst2 = FM_right.eval_linearSVF_LP(spl3);
  ) : ( fm_mode == 5 ) ? (
    fmst2 = fmst = FM_left.eval_linearSVF_LP(.5 * (spl2 + spl3));
  );
  
  sliderCutoffL = clamp(sliderCutoffL + fm_amnt * fmst, 0, .99);
  sliderCutoffR = clamp(sliderCutoffR + fm_amnt * fmst2, 0, .99);
  
  
  filter_type == 0 ? (
    L.LP.init_linearSVF(sliderCutoffL, sliderReso);
    L.HP.a1 = L.BR.a1 = L.BP.a1 = L.LP.a1;
    L.HP.a2 = L.BR.a2 = L.BP.a2 = L.LP.a2;
    L.HP.a3 = L.BR.a3 = L.BP.a3 = L.LP.a3;
    L.HP.k  = L.BR.k  = L.BP.k  = L.LP.k;
    
    R.LP.init_linearSVF(sliderCutoffR, sliderReso);
    R.HP.a1 = R.BR.a1 = R.BP.a1 = R.LP.a1;
    R.HP.a2 = R.BR.a2 = R.BP.a2 = R.LP.a2;
    R.HP.a3 = R.BR.a3 = R.BP.a3 = R.LP.a3;
    R.HP.k  = R.BR.k  = R.BP.k  = R.LP.k;
  ) : ( filter_type == 1 ) ? (
    (oversampling == 1) ? (
      sliderCutoffL = sliderCutoffL > safety_limit_ms20 ? safety_limit_ms20 : sliderCutoffL;
      sliderCutoffR = sliderCutoffR > safety_limit_ms20 ? safety_limit_ms20 : sliderCutoffR;
    );
  
    L.LP.init_MS20(sliderCutoffL, sliderReso);
    L.HP.hh = L.BR.hh = L.BP.hh = L.LP.hh;
    L.HP.h = L.BR.h = L.BP.h = L.LP.h;
    L.HP.k = L.BR.k = L.BP.k = L.LP.k;
    
    R.LP.init_MS20(sliderCutoffR, sliderReso);
    R.HP.hh = R.BR.hh = R.BP.hh = R.LP.hh;
    R.HP.h = R.BR.h = R.BP.h = R.LP.h;
    R.HP.k = R.BR.k = R.BP.k = R.LP.k;
  ) : ( filter_type == 2 ) ? (
    L.LP.init_linearSVF(sliderCutoffL, sliderReso);
    L2.HP.a1 = L2.BR.a1 = L2.BP.a1 = L2.LP.a1 = L.HP.a1 = L.BR.a1 = L.BP.a1 = L.LP.a1;
    L2.HP.a2 = L2.BR.a2 = L2.BP.a2 = L2.LP.a2 = L.HP.a2 = L.BR.a2 = L.BP.a2 = L.LP.a2;
    L2.HP.a3 = L2.BR.a3 = L2.BP.a3 = L2.LP.a3 = L.HP.a3 = L.BR.a3 = L.BP.a3 = L.LP.a3;
    L2.HP.k  = L2.BR.k  = L2.BP.k  = L2.LP.k  = L.HP.k  = L.BR.k  = L.BP.k  = L.LP.k;
    
    R.LP.init_linearSVF(sliderCutoffR, sliderReso);
    R2.HP.a1 = R2.BR.a1 = R2.BP.a1 = R2.LP.a1 = R.HP.a1 = R.BR.a1 = R.BP.a1 = R.LP.a1;
    R2.HP.a2 = R2.BR.a2 = R2.BP.a2 = R2.LP.a2 = R.HP.a2 = R.BR.a2 = R.BP.a2 = R.LP.a2;
    R2.HP.a3 = R2.BR.a3 = R2.BP.a3 = R2.LP.a3 = R.HP.a3 = R.BR.a3 = R.BP.a3 = R.LP.a3;
    R2.HP.k  = R2.BR.k  = R2.BP.k  = R2.LP.k  = R.HP.k  = R.BR.k  = R.BP.k  = R.LP.k;
  ) : ( filter_type == 3 ) ? (
    sliderCutoffL = sliderCutoffL > current_safety_moog ? current_safety_moog : sliderCutoffL;
    sliderCutoffR = sliderCutoffR > current_safety_moog ? current_safety_moog : sliderCutoffR;
  
    L.moog.init_moog(sliderCutoffL, sliderReso);
    R.moog.init_moog(sliderCutoffR, sliderReso);
  ) : ( filter_type == 4 ) ? (
    sliderCutoffL = sliderCutoffL > current_safety_moog ? current_safety_moog : sliderCutoffL;
    sliderCutoffR = sliderCutoffR > current_safety_moog ? current_safety_moog : sliderCutoffR;
    
    L.moog2.init_moog2(sliderCutoffL, sliderReso);
    R.moog2.init_moog2(sliderCutoffR, sliderReso);
  ) : ( filter_type == 5 ) ? (
    L.b303.init_303(sliderCutoffL, sliderReso);
    R.b303.init_303(sliderCutoffR, sliderReso);    
  );
  
  filter_choiceL = floor(sliderMorphL*4);
  frac_morphL = sliderMorphL*4 - filter_choiceL;
  i_morphL = 1.0 - frac_morphL;

  filter_choiceR = floor(sliderMorphR*4);
  frac_morphR = sliderMorphR*4 - filter_choiceR;
  i_morphR = 1.0 - frac_morphR;
  
  ( oversampling > 1 ) ? (
    sincFilterL.advanceSinc(spl0);
    sincFilterR.advanceSinc(spl1);
    
    loop( oversampling,
      ssl = sincFilterL.getSubSample();
      ssr = sincFilterR.getSubSample();
      
      filter_type == 0 ? (
        ssl = L.processSample_lin(ssl, filter_choiceL) * i_morphL + L.processSample_lin(ssl, filter_choiceL + 1) * frac_morphL;
        ssr = R.processSample_lin(ssr, filter_choiceR) * i_morphR + R.processSample_lin(ssr, filter_choiceR + 1) * frac_morphR;
      ) : ( filter_type == 1 ) ? (
        ssl = L.processSample_ms20(ssl, filter_choiceL) * i_morphL + L.processSample_ms20(ssl, filter_choiceL + 1) * frac_morphL;
        ssr = R.processSample_ms20(ssr, filter_choiceR) * i_morphR + R.processSample_ms20(ssr, filter_choiceR + 1) * frac_morphR;
      ) : ( filter_type == 2 ) ? (
        ssl = L.processSample_lin(ssl, filter_choiceL) * i_morphL + L.processSample_lin(ssl, filter_choiceL + 1) * frac_morphL;
        ssr = R.processSample_lin(ssr, filter_choiceR) * i_morphR + R.processSample_lin(ssr, filter_choiceR + 1) * frac_morphR;
        ssl = L2.processSample_lin(ssl, filter_choiceL) * i_morphL + L2.processSample_lin(ssl, filter_choiceL + 1) * frac_morphL;
        ssr = R2.processSample_lin(ssr, filter_choiceR) * i_morphR + R2.processSample_lin(ssr, filter_choiceR + 1) * frac_morphR;
      ) : ( filter_type == 3 ) ? (
        ssl = L.moog.mix_moog(ssl, filter_choiceL, frac_morphL);
        ssr = R.moog.mix_moog(ssr, filter_choiceR, frac_morphR);
      ) : ( filter_type == 4 ) ? (
        ssl = L.moog2.mix_moog2(ssl, filter_choiceL, frac_morphL);
        ssr = R.moog2.mix_moog2(ssr, filter_choiceR, frac_morphR);
      ) : ( filter_type == 5 ) ? (
        ssl = L.b303.eval_303(ssl, filter_choiceL, frac_morphL);
        ssr = R.b303.eval_303(ssr, filter_choiceR, frac_morphR);
      );
      
      sincDownL.advanceHist(ssl);
      sincDownR.advanceHist(ssr);
    );
    
    spl0 = sincDownL.sincDownSample();
    spl1 = sincDownR.sincDownSample();
  ) : (
    filter_type == 0 ? (
      spl0 = L.processSample_lin(spl0, filter_choiceL) * i_morphL + L.processSample_lin(spl0, filter_choiceL + 1) * frac_morphL;
      spl1 = R.processSample_lin(spl1, filter_choiceR) * i_morphR + R.processSample_lin(spl1, filter_choiceR + 1) * frac_morphR;
    ) : ( filter_type == 1 ) ? (
      spl0 = L.processSample_ms20(spl0, filter_choiceL) * i_morphL + L.processSample_ms20(spl0, filter_choiceL + 1) * frac_morphL;
      spl1 = R.processSample_ms20(spl1, filter_choiceR) * i_morphR + R.processSample_ms20(spl1, filter_choiceR + 1) * frac_morphR;
    ) : ( filter_type == 2 ) ? (
      spl0 = L.processSample_lin(spl0, filter_choiceL) * i_morphL + L.processSample_lin(spl0, filter_choiceL + 1) * frac_morphL;
      spl1 = R.processSample_lin(spl1, filter_choiceR) * i_morphR + R.processSample_lin(spl1, filter_choiceR + 1) * frac_morphR;
      spl0 = L2.processSample_lin(spl0, filter_choiceL) * i_morphL + L2.processSample_lin(spl0, filter_choiceL + 1) * frac_morphL;
      spl1 = R2.processSample_lin(spl1, filter_choiceR) * i_morphR + R2.processSample_lin(spl1, filter_choiceR + 1) * frac_morphR;
    ) : ( filter_type == 3 ) ? (
      spl0 = L.moog.mix_moog(spl0, filter_choiceL, frac_morphL);
      spl1 = R.moog.mix_moog(spl1, filter_choiceR, frac_morphR);
    ) : ( filter_type == 4 ) ? (
      spl0 = L.moog2.mix_moog2(spl0, filter_choiceL, frac_morphL);
      spl1 = R.moog2.mix_moog2(spl1, filter_choiceR, frac_morphR);
    ) : ( filter_type == 5 ) ? (
      spl0 = L.b303.eval_303(spl0, filter_choiceL, frac_morphL);
      spl1 = R.b303.eval_303(spl1, filter_choiceR, frac_morphR);
    );
  );
  
  spl0 *= inv_preamp;
  spl1 *= inv_preamp;
  
  autokill ? (
    spl0 *= term;
    spl1 *= term;
  );

@gfx 1048 280
render_time += .025;
gfx_set(21/255, 20/255, 21/255, 1.0);
gfx_rect(0, 0, gfx_w, gfx_h);

xs = 10;
ys = 10;

knobSize = 35*(1+scaling);
knobSpacing = .7 * knobSize;

buttonSize = floor(.3 * knobSpacing);
widget_r = 35/255;
widget_g = 155/255;
widget_b = 30/255;
widget_a = 1.0;
toggle_r = .5;
toggle_g = 1.6;
toggle_b = .5;
toggle_a = 1.0;

cY = w1y + w1h + .4*(gfx_h-w1h);
panelY = cY - 32 * (1+scaling);
panelPad = 6;
panelHeight = 3.2 * knobSize;

xOrigin = 75*(1+scaling);
yOrigin = 65*(1+scaling);

font_color_r = .7;
font_color_g = .6;
font_color_b = .8;
font_color_a = 1;
knob_font_color_r = 0.9;
knob_font_color_g = 0.9;
knob_font_color_b = 0.8;
knob_font_color_a = 1;
edge_r = 39/255;
edge_g = 39/255;
edge_b = 41/255;
edge_a = 1.0;

edge_font_r = 0.9;
edge_font_g = 0.9;
edge_font_b = 0.8;


FONT_GRID = 4;
gfx_setfont(FONT_GRID, "Arial", 16 * (1+scaling));

BAND_FONT = 5;
gfx_setfont(BAND_FONT, "Arial", 16 * (1+scaling));

KNOB_FONT = 6;
gfx_setfont(KNOB_FONT, "Arial", 14 * (1+scaling));

KNOB_FONT2 = 7;
gfx_setfont(KNOB_FONT2, "Arial", 13 * (1+scaling));

HINT_FONT = 8;
gfx_setfont(HINT_FONT, "Arial", 13 * (1+scaling));

TOGGLE_FONT = 9;
gfx_setfont(TOGGLE_FONT, "Arial", 16 * (1+scaling));


cX = xOrigin;
cY = yOrigin;
drawPanel("DRIVE", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 10.25*knobSpacing, panelHeight);

cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
drawSelectionButton("Lin 2p", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, 12);
drawSelectionButton("Lin 4p", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 2, 12);
drawSelectionButton("MS-20", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 1, 12);
drawSelectionButton("Moog", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 3, 12);
drawSelectionButton("Ladder", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 4, 12);
drawSelectionButton("303", cX - 2*knobSize, cY-1.1*knobSize + 5*y_move, ww, hh, 5, 12);

cX += .65*knobSize;

driveKnob.active = 1;
driveKnob.value = (slider1 + 6)/54;
driveKnob.label = sprintf(1, "%.1f dB", slider1);
driveKnob.drawKnob(cX, cY, knobSize, "Drive", "Input Gain\n\nPushing this saturates the filter nicely.", 1.0);
driveKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? (
  slider1 = driveKnob.value * 54 - 6;
  slider_automate(slider1);
);

bleedToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, bleed, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.\nGives a more analog feel.");
bleed = bleedToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

autokillToggle.drawToggle(cX+knobSize-2, cy-knobSize, .15*knobSize, .15*knobSize, autokill, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Kill audio after no more input comes in.\nPrevents resonance from singing.");
autokill = autokillToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cX += 2.5 * knobSize;
postBoost.active = 1;
postBoost.value = (slider2 + 6)/54;
postBoost.label = sprintf(1, "%.1f dB", slider2);
postBoost.drawKnob(cX, cY, knobSize, "Output Gain", "Output Gain", 1.0);
postBoost.knob_processMouse(mouse_x, mouse_y, mouse_cap, 6/54+.000001) ? (
  slider2 = postBoost.value * 54 - 6;
  slider_automate(slider2);
);
cX += 2.5 * knobSize;

cX += 1.5 * knobSize;

drawPanel("FILTER", cX - 2.25*knobSpacing, cY - .53*panelHeight + .2*knobSize, 15*knobSpacing, panelHeight);


morphKnob.active = 1;
morphKnob.value = morph;
morphKnob.drawKnob(cX, cY, knobSize, "Morph", "Filter Morph", 1.0);
morphKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  morph = morphKnob.value;
  slider_automate(morph);
);
gfx_set(1,1,1,1);
drawKnobLabels(knobSize*1.25, 0, "LP");
drawKnobLabels(knobSize*1.25, 1/4, "BP");
drawKnobLabels(knobSize*1.25, 2/4, "HP");
drawKnobLabels(knobSize*1.25, 3/4, "BR");
drawKnobLabels(knobSize*1.25, 4/4, "LP");

cX += knobSize*2.5;

cutoffKnob.active = 1;
cutoffKnob.value = slider13;
center = .5 * srate * exp( (1-slider13) * log(20/22050) );
center < 1000 ? (
  cutoffKnob.label = sprintf(1, "%d Hz", center);
) : (
  cutoffKnob.label = sprintf(1, "%.1f kHz", center/1000);
);
cutoffKnob.drawKnob(cX, cY, knobSize, "Cutoff", "Filter Cutoff", 1.0);
cutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  slider13 = cutoffKnob.value;
  slider_automate(slider13);
  check_safety();
);

cX += knobSize*2.5;
resonanceKnob.active = 1;
resonanceKnob.value = slider14;
resonanceKnob.label = sprintf(1, "%.1f", slider14);
resonanceKnob.drawKnob(cX, cY, knobSize, "Resonance", "Filter Resonance", 1.0);
resonanceKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  slider14 = resonanceKnob.value;
  slider_automate(slider14);
);

cX += knobSize*2.5;

keyFollowKnob.active = 1;
keyFollowKnob.value = key_follow;
keyFollowKnob.drawKnob(cX, cY, knobSize, "Follow", "Follow MIDI pitch", 1.0);
keyFollowKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  key_follow = keyFollowKnob.value;
  slider_automate(key_follow);
);
cX += 3.675 * knobSize;

drawPanel("FM", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 13.5*knobSpacing, panelHeight);

cX += knobSize;
gfx_setfont(KNOB_FONT);
y_move = .4 * knobSize;
ww = 1.3*knobSize;
hh = .35 * knobSize;
drawSelectionButton("MIDI Sin", cX - 2*knobSize, cY-1.1*knobSize, ww, hh, 0, 23);
drawSelectionButton("MIDI Sqr", cX - 2*knobSize, cY-1.1*knobSize + y_move, ww, hh, 1, 23);
drawSelectionButton("Self", cX - 2*knobSize, cY-1.1*knobSize + 2*y_move, ww, hh, 2, 23);
drawSelectionButton("Self Abs", cX - 2*knobSize, cY-1.1*knobSize + 3*y_move, ww, hh, 3, 23);
drawSelectionButton("3/4", cX - 2*knobSize, cY-1.1*knobSize + 4*y_move, ww, hh, 4, 23);
drawSelectionButton("3+4", cX - 2*knobSize, cY-1.1*knobSize + 5*y_move, ww, hh, 5, 23);
cX += .65*knobSize;

fmLevelKnob.active = 1;
fmLevelKnob.value = fm_amnt;
fmLevelKnob.drawKnob(cX, cY, knobSize, "FM Level", "FM Level\nLevel of FM modulation", 1.0);
fmLevelKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  fm_amnt = fmLevelKnob.value;
  slider_automate(fm_amnt);
);

cX += 2.5 * knobSize;

fm_mode < 2 ? (
  fmRateKnob.active = 1;
  fmRateKnob.value = (fm_factor+8)/16;
  fmRateKnob.label = sprintf(1, "%.1f x", 2^floor(fm_factor));
  fmRateKnob.drawKnob(cX, cY, knobSize, "FM factor", "FM factor.\n\nFilter cutoff will oscillate with\nthis factor times the MIDI pitch's\nfrequency.", .5);
  fmRateKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
    fm_factor = fmRateKnob.value * 16 - 8;
    slider_automate(fm_factor);
  );
) : (
  fmCutoffKnob.active = 1;
  fmCutoffKnob.value = fm_cutoff;
  center = .5 * srate * exp( (1-fm_cutoff) * log(20/22050) );
  center < 1000 ? (
    fmCutoffKnob.label = sprintf(1, "%d Hz", center);
  ) : (
    fmCutoffKnob.label = sprintf(1, "%.1f kHz", center/1000);
  );
  fmCutoffKnob.drawKnob(cX, cY, knobSize, "FM cutoff", "FM Cutoff\n\nCutoff used to filter signal that\ncontrols the cutoff.", .5);
  fmCutoffKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 1) ? (
    fm_cutoff = fmCutoffKnob.value;
    slider_automate(fm_cutoff);
  );
);
cX += 2.5 * knobSize;

fmPhaseKnob.active = 1;
fmPhaseKnob.value = fm_spread;
fmPhaseKnob.drawKnob(cX, cY, knobSize, "FM Spread", "FM Phase difference", 1.0);
fmPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  fm_spread = fmPhaseKnob.value;
  slider_automate(fm_spread);
);

cX += 2.5 * knobSize;

cX += 1.5 * knobSize;


cX = xOrigin;
cY = cY + 4 * knobSize;

drawPanel("ENVELOPE", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 7.675*knobSpacing, panelHeight);

gfx_set(midiChange*.4+.1, .1, .1, midiChange); midiChange *= .9;
gfx_rect(cX - 2.5*knobSpacing, cY - .4*panelHeight, 9, 9);

envAmountKnob.active = 1;
envAmountKnob.value = env_amnt * .5 + .5;
envAmountKnob.drawKnob(cX, cY, knobSize, "- Amount +", "Envelope Amount", 1.0);
envAmountKnob.label = sprintf(4, "   %d %%%%", 100*env_amnt);
envAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.5) ? (
  env_amnt = envAmountKnob.value * 2 - 1;
  slider_automate(env_amnt);
);

cX += knobSize*2.5;
envDecayKnob.active = 1;
envDecayKnob.value = env_decay;
env_decay > .5 ? (
  envDecayKnob.label = sprintf(1, "%d ms", (3 * 10^(2*env_decay)));
) : (
  envDecayKnob.label = sprintf(1, "%.1f ms", (3 * 10^(2*env_decay)));
);
envDecayKnob.drawKnob(cX, cY, knobSize, "Decay", "Decay Time", 1.0);
envDecayKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  env_decay = envDecayKnob.value;
  slider_automate(env_decay);
);


cX += 3.675 * knobSize;
drawPanel("CUTOFF LFO", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 11.125*knobSpacing, panelHeight);

cutoffLFOAmountKnob.active = 1;
cutoffLFOAmountKnob.value = c_lfo_amnt;
cutoffLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount", 1.0);
cutoffLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  c_lfo_amnt = cutoffLFOAmountKnob.value;
  slider_automate(c_lfo_amnt);
);

cX += 2.5 * knobSize;
cutoffSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, c_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.");
c_lfo_sync = cutoffSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

cutoffLFOSpeedKnob.active = 1;
cutoffLFOSpeedKnob.value = c_lfo_speed / 20;
cutoffLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
c_lfo_sync ? (
  cutoffLFOSpeedKnob.label = cutoff_LFO.tempoLabel;
) : (
  cutoffLFOSpeedKnob.label = sprintf(3, "%d Hz", c_lfo_speed);
);
cutoffLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  c_lfo_speed = cutoffLFOSpeedKnob.value * 20;
  updateTempo();
  slider_automate(c_lfo_speed);
);

cX += 2.5 * knobSize;
cutoffLFOPhaseKnob.active = 1;
cutoffLFOPhaseKnob.value = c_lfo_phase / 36;
cutoffLFOPhaseKnob.drawKnob(cX, cY, knobSize, "LR Phase", "Cutoff LFO Phase", 1.0);
cutoffLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  c_lfo_phase = cutoffLFOPhaseKnob.value * 36;
  slider_automate(c_lfo_phase);
);

cX += 3.675 * knobSize;
drawPanel("MORPH LFO", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 11.125*knobSpacing, panelHeight);
morphLFOAmountKnob.active = 1;
morphLFOAmountKnob.value = m_lfo_amnt;
morphLFOAmountKnob.drawKnob(cX, cY, knobSize, "Amount", "Cutoff LFO Amount", 1.0);
morphLFOAmountKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  m_lfo_amnt = morphLFOAmountKnob.value;
  slider_automate(m_lfo_amnt);
);

cX += 2.5 * knobSize;
morphSyncToggle.drawToggle(cX-knobSize, cy-knobSize, .15*knobSize, .15*knobSize, m_lfo_sync, widget_r, widget_g, widget_b, widget_a, toggle_r, toggle_g, toggle_b, toggle_a, "Modulate gain by pitch.");
m_lfo_sync = morphSyncToggle.processMouseToggle(mouse_x, mouse_y, mouse_cap);

morphLFOSpeedKnob.active = 1;
morphLFOSpeedKnob.value = m_lfo_speed / 20;
morphLFOSpeedKnob.drawKnob(cX, cY, knobSize, "Rate", "Cutoff LFO frequency", 1.0);
m_lfo_sync ? (
  morphLFOSpeedKnob.label = morph_LFO.tempoLabel;
) : (
  morphLFOSpeedKnob.label = sprintf(5, "%d Hz", m_lfo_speed);
);
morphLFOSpeedKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  m_lfo_speed = morphLFOSpeedKnob.value * 20;
  updateTempo();
  slider_automate(m_lfo_speed);
);

cX += 2.5 * knobSize;
morphLFOPhaseKnob.active = 1;
morphLFOPhaseKnob.value = m_lfo_phase / 36;
morphLFOPhaseKnob.drawKnob(cX, cY, knobSize, "LR Phase", "Cutoff LFO Phase", 1.0);
morphLFOPhaseKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0.25) ? (
  m_lfo_phase = morphLFOPhaseKnob.value * 36;
  slider_automate(m_lfo_phase);
);

cX += 3.5 * knobSize;
drawPanel("OPTIONS", cX - 2*knobSpacing, cY - .53*panelHeight + .2*knobSize, 7.75*knobSpacing, panelHeight);
oversamplingKnob.active = 1;
oversampling != floor(oversamplingKnob.value * 7 + 1) ? (
  oversamplingKnob.value = (oversampling - 1) / 7;
);
oversamplingKnob.drawKnob(cX, cY, knobSize, "Oversampling", "", 1.0);
oversamplingKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 0) ? (
  newOversampling = floor(oversamplingKnob.value * 7 + 1);
  floor(newOversampling) != overSampling ? (
    oversampling = newOversampling;
    slider_automate(oversampling);
    updateSlider();
  );
);

cX += 2.5 * knobSize;

inertiaKnob.active = 1;
inertiaKnob.value = inertia / 200;
inertiaKnob.drawKnob(cX, cY, knobSize, "Inertia", "", 1.0);
inertiaKnob.knob_processMouse(mouse_x, mouse_y, mouse_cap, 60/200) ? (
  inertia = inertiaKnob.value * 200;
  slider_automate(inertia);
);






gfx_set(0, 0, 0, 0);
gfx_rect(0, 0, gfx_w, gfx_h);
gfx_set(1, 1, 1, 1);

/*
gfx_x = xs;
gfx_y = ys;
current_setting = slider13;
center = .5 * srate * exp( (1-current_setting) * log(20/22050) );
c_lfo_amnt > 0 ? (
  bottom = .5 * srate * exp( (1-max(0, current_setting - c_lfo_amnt) ) * log(20/22050) );
  top = .5 * srate * exp( (1-min(1,current_setting + c_lfo_amnt)) * log(20/22050) );
  gfx_printf("Cutoff: %d Hz [LFO: %d Hz - %d Hz]", center, bottom, top );
) : (
  gfx_printf("Cutoff: %d Hz", center );
);
dx = 40;

gfx_x = xs;
gfx_y = ys + 25;
gfx_printf("LP");

gfx_x = xs+dx;
gfx_y = ys + 25;
gfx_printf("BP");

gfx_x = xs+2*dx;
gfx_y = ys + 25;
gfx_printf("HP");

gfx_x = xs+3*dx;
gfx_y = ys + 25;
gfx_printf("BR");

gfx_x = xs+4*dx;
gfx_y = ys + 25;
gfx_printf("LP");

gfx_y = ys + 40;
gfx_line(xs, gfx_y, xs+4*dx, gfx_y);

xc = xs + 4*morph*dx;
gfx_line(xc, gfx_y - 5, xc, gfx_y + 5);

gfx_a = .4;
gfx_rect(xc - 4*m_lfo_amnt*dx, gfx_y - 5, ceil(8*m_lfo_amnt*dx), 10);

gfx_x = 0;
gfx_y = ys + 50;
*/

warning > 0 ? (
  gfx_set(1,1,1,1);
  gfx_x = 0;
  gfx_y = 0;
  gfx_a = warning / 75;
  gfx_printf("Warning, cutoff clamped! Without oversampling, this non-linear filter cannot safely go to higher cutoff frequencies.");
  warning -= 1;
);

lcap = mouse_cap;

hinter.drawHint_draw();
